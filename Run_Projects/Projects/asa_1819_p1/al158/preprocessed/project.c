/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct 
{
  int x;
  int y;
} Par;
typedef struct node *link;
struct node
{
  int w;
  link next;
};
typedef struct graph
{
  int V;
  int A;
  link *adj;
} *Graph;
static link NEWnode(int w, link next)
{
  link a = malloc(sizeof(struct node));
  a->w = w;
  a->next = next;
  return a;
}

Graph GRAPHinit(int V)
{
  int v;
  Graph G = malloc(sizeof(G));
  G->V = V;
  G->A = 0;
  G->adj = malloc((V + 1) * (sizeof(link)));
  for (v = 1; v <= V; v++)
  {
    G->adj[v] = 0;
  }

  return G;
}

void GRAPHinsertArc(Graph G, int v, int w)
{
  link a;
  for (a = G->adj[v]; a != 0; a = a->next)
  {
    if (a->w == w)
    {
      return;
    }
    else
    {
      
    }

  }

  G->adj[v] = NEWnode(w, G->adj[v]);
  G->A++;
}

void GRAPHListshow(Graph G)
{
  int v;
  for (v = 1; v <= G->V; ++v)
  {
    printf("%2d:", v);
    link a;
    for (a = G->adj[v]; a != 0; a = a->next)
    {
      printf(" %2d", a->w);
    }

    printf("\n");
  }

}

static void dfsRcc(Graph G, int *cc, int v, int id)
{
  cc[v] = id;
  link a;
  for (a = G->adj[v]; a != 0; a = a->next)
  {
    if ((cc[a->w] == (-1)) && (a->w != (-1)))
    {
      dfsRcc(G, &cc[0], a->w, id);
    }
    else
    {
      
    }

  }

}

int GRAPHcc(Graph G, int *cc)
{
  int n = 0;
  int v;
  for (v = 0; v <= G->V; ++v)
  {
    cc[v] = -1;
  }

  for (v = 0; v <= G->V; ++v)
  {
    if (cc[v] == (-1))
    {
      dfsRcc(G, &cc[0], v, n++);
    }
    else
    {
      
    }

  }

  return n - 1;
}

int *newList(int n)
{
  int *v;
  v = (int *) malloc(n * (sizeof(int)));
  return v;
}

void idSubRedes(Graph G, int *cc, int nsr, int *mR)
{
  int x = 0;
  int i;
  int k = 1;
  int j = 0;
  while (k <= nsr)
  {
    for (i = 0; i <= G->V; i++)
    {
      if (cc[i] == k)
      {
        x = i;
      }
      else
      {
        
      }

    }

    mR[j] = x;
    j++;
    k++;
  }

}

void orderVector(int *v, int n)
{
  int i;
  int j;
  for (i = 0; i < (n - 1); i++)
  {
    for (j = i + 1; j < n; j++)
    {
      if (v[i] > v[j])
      {
        int aux = v[i];
        v[i] = v[j];
        v[j] = aux;
      }
      else
      {
        
      }

    }

  }

}

static void reachR(Graph G, int i, int *visit, int v)
{
  visit[i] = 1;
  link a;
  for (a = G->adj[i]; a != 0; a = a->next)
    if ((visit[a->w] == 0) && (a->w != v))
  {
    reachR(G, a->w, &visit[0], v);
  }
  else
  {
    
  }


}

int GRAPHreach(Graph G, int s, int t, int v)
{
  int i;
  int *visit = newList(G->V + 1);
  for (i = 0; i <= G->V; i++)
  {
    visit[i] = 0;
  }

  reachR(G, s, &visit[0], v);
  if (visit[t] == 0)
  {
    return 0;
  }
  else
  {
    return 1;
  }

}

int nBreaks(Graph G, int *cc, int n_subRedes, int *breaks)
{
  int v;
  int n = 0;
  int i;
  int cond = 0;
  for (v = 1; v <= G->V; v++)
  {
    link a = G->adj[v];
    while ((a != 0) && (cond == 0))
    {
      i = 1;
      if (v == i)
      {
        i++;
      }
      else
      {
        
      }

      while (((cc[i] != cc[v]) && (i <= G->V)) && (cond == 0))
      {
        if (i < G->V)
        {
          i++;
          if ((v == i) || (a->w == i))
          {
            i++;
          }
          else
          {
            
          }

        }
        else
        {
          cond++;
        }

      }

      if (GRAPHreach(G, i, a->w, v) == 0)
      {
        cond++;
        breaks[n] = v;
        n++;
      }
      else
      {
        a = a->next;
      }

    }

    cond = 0;
  }

  return n;
}

int moreRouters(Graph G, int *breaks, int n_breaks)
{
  int i;
  int j;
  int big = 0;
  for (i = 0; i < n_breaks; i++)
  {
    G->adj[breaks[i]] = 0;
  }

  link a;
  for (i = 1; i <= G->V; i++)
  {
    a = G->adj[i];
    while (a != 0)
    {
      for (j = 0; j < n_breaks; j++)
      {
        if (a->w == breaks[j])
        {
          a->w = -1;
        }
        else
        {
          
        }

      }

      a = a->next;
    }

  }

  int *cc = newList(G->V + 1);
  int n_subRedes = GRAPHcc(G, cc);
  int cont = 0;
  for (i = 1; i <= n_subRedes; i++)
  {
    for (j = 1; j <= G->V; j++)
    {
      if (cc[j] == i)
      {
        cont++;
      }
      else
      {
        
      }

    }

    if (cont > big)
    {
      big = cont;
    }
    else
    {
      
    }

    cont = 0;
  }

  return big;
}

int main(int argc, char *argv[])
{
  int n_routers;
  int n_connects;
  Par *list;
  int i;
  int x;
  int y;
  n_routers = new_sym_var(sizeof(int) * 8);
  n_connects = new_sym_var(sizeof(int) * 8);
  list = (Par *) malloc((n_connects + 1) * (sizeof(Par)));
  for (i = 0; i < n_connects; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    if (x > y)
    {
      int aux = x;
      x = y;
      y = aux;
    }
    else
    {
      
    }

    (list + i)->x = x;
    (list + i)->y = y;
  }

  Graph g = GRAPHinit(n_routers);
  for (i = 0; i < n_connects; i++)
  {
    GRAPHinsertArc(g, list[i].x, list[i].y);
  }

  int *cc = newList(g->V + 1);
  int n_subRedes = GRAPHcc(g, cc);
  int *id_subRedes = newList(n_subRedes);
  idSubRedes(g, cc, n_subRedes, id_subRedes);
  orderVector(id_subRedes, n_subRedes);
  int *breaks = newList(n_routers);
  ;
  int n_breaks = nBreaks(g, cc, n_subRedes, breaks);
  int big = moreRouters(g, breaks, n_breaks);
  printf("%d\n", n_subRedes);
  for (i = 0; i < (n_subRedes - 1); i++)
  {
    printf("%d ", id_subRedes[i]);
  }

  printf("%d\n", id_subRedes[i]);
  printf("%d\n", n_breaks);
  printf("%d", big);
  return 0;
}

