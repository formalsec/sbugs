/*File generated by PreProcessor.py*/


#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include <limits.h>


int numvertices;
struct edge
{
  int x;
  int y;
};
int compare_function(const void *a, const void *b)
{
  int *x = (int *) a;
  int *y = (int *) b;
  return (*x) - (*y);
}

int compare_function_edge(const void *a, const void *b)
{
  const struct edge *a1 = a;
  const struct edge *b1 = b;
  if ((a1->x - b1->x) != 0)
  {
    return a1->x - b1->x;
  }
  else
  {
    return a1->y - b1->y;
  }

}

void push(int **capacities, int **flows, int *excess, int u, int v)
{
  int sentflow = (excess[u] < (capacities[u][v] - flows[u][v])) ? (excess[u]) : (capacities[u][v] - flows[u][v]);
  flows[v][u] -= sentflow;
  flows[u][v] += sentflow;
  excess[u] -= sentflow;
  excess[v] += sentflow;
}

void relabel(int **capacities, int **flows, int *height, int u)
{
  int v;
  int min_height = 32767;
  for (v = 0; v < numvertices; v++)
  {
    if ((capacities[u][v] - flows[u][v]) > 0)
    {
      min_height = (min_height < height[v]) ? (min_height) : (height[v]);
      height[u] = min_height + 1;
    }
    else
    {
      
    }

  }

}

void discharge(int **capacities, int **flows, int *excess, int *height, int *seen, int u)
{
  while (excess[u] > 0)
  {
    if (seen[u] < numvertices)
    {
      int v = seen[u];
      if (((capacities[u][v] - flows[u][v]) > 0) && (height[u] > height[v]))
      {
        push(capacities, flows, excess, u, v);
      }
      else
      {
        seen[u] += 1;
      }

    }
    else
    {
      relabel(capacities, flows, height, u);
      seen[u] = 0;
    }

  }

}

void updateList(int i, int *list)
{
  int p = list[i];
  int n;
  for (n = i; n > 0; n--)
  {
    list[n] = list[n - 1];
  }

  list[0] = p;
}

int relabelToFront(int **capacities, int **flows, int source, int market)
{
  int *excess;
  int *height;
  int *list;
  int *seen;
  int i;
  int p = 0;
  excess = (int *) calloc(numvertices, sizeof(int));
  height = (int *) calloc(numvertices, sizeof(int));
  seen = (int *) calloc(numvertices, sizeof(int));
  list = (int *) calloc(numvertices - 2, sizeof(int));
  for (i = 0; i < numvertices; i++)
  {
    if ((i != source) && (i != market))
    {
      list[p] = i;
      p++;
    }
    else
    {
      
    }

  }

  height[source] = numvertices;
  excess[source] = 32767;
  for (i = 0; i < numvertices; i++)
    push(capacities, flows, excess, source, i);

  p = 0;
  while (p < (numvertices - 2))
  {
    int u = list[p];
    int old_height = height[u];
    discharge(capacities, flows, excess, height, seen, u);
    if (height[u] > old_height)
    {
      updateList(p, list);
      p = 0;
    }
    else
    {
      p += 1;
    }

  }

  int maximumflow = 0;
  for (i = 0; i < numvertices; i++)
    maximumflow += flows[source][i];

  free(list);
  free(seen);
  free(height);
  free(excess);
  return maximumflow;
}

void DFS(int **G, int *visited, int size, int i)
{
  int j;
  visited[i] = 1;
  for (j = 0; j < size; j++)
    if ((!visited[j]) && G[i][j])
  {
    DFS(G, visited, size, j);
  }
  else
  {
    
  }


}

int main(void)
{
  int **flows;
  int **capacities;
  int **transposed;
  int i;
  int j;
  int k;
  int l;
  int o;
  int d;
  int c;
  int a;
  int f;
  int e;
  int connections;
  int stcounter = 1;
  a = 1;
  f = new_sym_var(sizeof(int) * 8);
  a = 1;
  e = new_sym_var(sizeof(int) * 8);
  numvertices = (f + (e * 2)) + 2;
  a = 1;
  connections = new_sym_var(sizeof(int) * 8);
  flows = (int **) calloc(numvertices, sizeof(int *));
  capacities = (int **) calloc(numvertices, sizeof(int *));
  transposed = (int **) calloc(numvertices, sizeof(int *));
  for (i = 0; i < numvertices; i++)
  {
    flows[i] = (int *) calloc(numvertices, sizeof(int));
    capacities[i] = (int *) calloc(numvertices, sizeof(int));
    transposed[i] = (int *) calloc(numvertices, sizeof(int));
  }

  for (j = 2; j <= (f + 1); j++)
  {
    a = 1;
    k = new_sym_var(sizeof(int) * 8);
    capacities[0][j] = k;
  }

  for (j = f + 2; j < ((f + e) + 2); j++)
  {
    a = 1;
    l = new_sym_var(sizeof(int) * 8);
    capacities[j][((numvertices - 1) - e) + stcounter] = l;
    stcounter++;
  }

  for (j = 0; j < connections; j++)
  {
    a = 1;
    o = new_sym_var(sizeof(int) * 8);
    a = 1;
    d = new_sym_var(sizeof(int) * 8);
    a = 1;
    c = new_sym_var(sizeof(int) * 8);
    if ((d == 1) && (o >= (f + 2)))
    {
      capacities[o + e][d] = c;
    }
    else
    {
      if ((((o >= (f + 2)) && (o <= ((f + e) + 1))) && (d >= (f + 2))) && (d <= ((f + e) + 1)))
      {
        capacities[o + e][d] = c;
      }
      else
      {
        capacities[o][d] = c;
      }

    }

  }

  printf("%d\n", relabelToFront(capacities, flows, 0, 1));
  for (i = 0; i < numvertices; i++)
    for (j = 0; j < numvertices; j++)
  {
    flows[i][j] = capacities[i][j] - flows[i][j];
  }


  for (i = 0; i < numvertices; i++)
    for (j = 0; j < numvertices; j++)
    transposed[j][i] = flows[i][j];


  int *visited;
  visited = (int *) calloc(numvertices, sizeof(int));
  DFS(transposed, visited, numvertices, 1);
  int *cutstations;
  int *storedstations;
  int st_c = 0;
  int lig_c = 0;
  struct edge *cutedges;
  storedstations = (int *) calloc(e, sizeof(int));
  cutstations = (int *) calloc(e, sizeof(int));
  cutedges = (struct edge *) malloc(connections * (sizeof(struct edge)));
  for (i = 0; i < connections; i++)
  {
    cutedges[i].x = 0;
    cutedges[i].y = 0;
  }

  for (i = 0; i < numvertices; i++)
    for (j = 0; j < numvertices; j++)
    if ((visited[i] != visited[j]) && (capacities[i][j] != 0))
  {
    if (((j == (i + e)) && (i >= (f + 2))) && (i <= ((f + e) + 1)))
    {
      cutstations[st_c] = i;
      storedstations[(i - f) - 2] = 1;
      st_c++;
    }
    else
    {
      if ((((i >= ((f + e) + 2)) && (j >= (f + 2))) && (j <= ((f + e) + 1))) && (storedstations[((i - e) - f) - 2] == 0))
      {
        cutedges[lig_c].x = i - e;
        cutedges[lig_c].y = j;
        lig_c++;
      }
      else
      {
        if ((i >= ((f + e) + 2)) && (j == 1))
        {
          cutedges[lig_c].x = i - e;
          cutedges[lig_c].y = j;
          lig_c++;
        }
        else
        {
          if ((i >= 2) && (i <= (f + 1)))
          {
            cutedges[lig_c].x = i;
            cutedges[lig_c].y = j;
            lig_c++;
          }
          else
          {
            
          }

        }

      }

    }

  }
  else
  {
    
  }



  qsort(cutstations, e, sizeof(int), compare_function);
  qsort(cutedges, connections, sizeof(struct edge), compare_function_edge);
  int augmentstations = 0;
  for (i = 0; i < (e - 1); i++)
    if (cutstations[i] != 0)
  {
    printf("%d ", cutstations[i]);
    augmentstations++;
  }
  else
  {
    
  }


  if (cutstations[e - 1] != 0)
  {
    printf("%d\n", cutstations[e - 1]);
    augmentstations++;
  }
  else
  {
    
  }

  if (augmentstations == 0)
  {
    printf("\n");
  }
  else
  {
    
  }

  for (i = 0; i < connections; i++)
    if (cutedges[i].x != 0)
  {
    printf("%d %d\n", cutedges[i].x, cutedges[i].y);
  }
  else
  {
    
  }


  free(visited);
  free(cutstations);
  free(cutedges);
  free(storedstations);
  for (i = 0; i < numvertices; i++)
  {
    free(capacities[i]);
    free(flows[i]);
    free(transposed[i]);
  }

  a = 0;
  return a;
}

