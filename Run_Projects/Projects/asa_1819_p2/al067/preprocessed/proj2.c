/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>


typedef struct connection
{
  int id;
  int capacity;
  int flow;
  struct connection *next;
} Connection;
typedef struct vertex
{
  int id;
  int excess;
  int height;
  Connection *head;
  Connection *tail;
  Connection *current;
  struct vertex *next;
  struct vertex *prev;
} Vertex;
typedef struct vertex_list
{
  Vertex *head;
  Vertex *tail;
} Vertex_List;
typedef struct cut
{
  int source;
  int dest;
} Cut;
typedef struct network
{
  int n_suppliers;
  int n_stations;
  int n_connections;
  Vertex *vertices;
} Network;
char *readInput()
{
  int c;
  int n = 0;
  char *input = malloc((sizeof(char)) * 8000);
  while (((c = getchar()) != ' ') && (c != '\n'))
  {
    input[n] = c;
    n++;
  }

  return input;
}

void create_vertex(int id, Network *nw)
{
  Vertex v;
  v.id = id;
  v.excess = 0;
  v.height = 0;
  v.head = 0;
  v.tail = 0;
  nw->vertices[id] = v;
}

Connection *create_connection()
{
  Connection *c = (Connection *) malloc(sizeof(struct connection));
  return c;
}

void vertex_add_conn(int u, int v, int cap, Network *Nw)
{
  if (Nw->vertices[u].head == 0)
  {
    Nw->vertices[u].head = (Nw->vertices[u].tail = create_connection());
    Nw->vertices[u].head->id = v;
    Nw->vertices[u].head->flow = 0;
    Nw->vertices[u].head->capacity = cap;
    Nw->vertices[u].head->next = 0;
  }
  else
  {
    if (Nw->vertices[u].head == Nw->vertices[u].tail)
    {
      Nw->vertices[u].tail = create_connection();
      Nw->vertices[u].head->next = Nw->vertices[u].tail;
      Nw->vertices[u].tail->id = v;
      Nw->vertices[u].tail->flow = 0;
      Nw->vertices[u].tail->capacity = cap;
      Nw->vertices[u].tail->next = 0;
    }
    else
    {
      Connection *c = create_connection();
      Nw->vertices[u].tail->next = c;
      Nw->vertices[u].tail = c;
      Nw->vertices[u].tail->flow = 0;
      Nw->vertices[u].tail->capacity = cap;
      c->id = v;
      c->next = 0;
    }

  }

}

Vertex_List *create_vertex_list(Network *Nw)
{
  int i;
  Vertex_List *L = (Vertex_List *) malloc(((Nw->n_suppliers + (2 * Nw->n_stations)) + 2) * (sizeof(struct vertex_list)));
  L->head = 0;
  L->tail = 0;
  for (i = 2; i <= ((Nw->n_suppliers + (2 * Nw->n_stations)) + 1); i++)
  {
    if (L->head == 0)
    {
      L->head = &Nw->vertices[i];
      L->tail = L->head;
      L->head->next = 0;
      L->head->prev = 0;
    }
    else
    {
      if (L->head == L->tail)
      {
        L->tail = &Nw->vertices[i];
        L->head->next = L->tail;
        L->tail->next = 0;
        L->tail->prev = L->head;
      }
      else
      {
        L->tail->next = &Nw->vertices[i];
        Nw->vertices[i].prev = L->tail;
        L->tail = &Nw->vertices[i];
        L->tail->next = 0;
      }

    }

  }

  return L;
}

void initialize_preflow(Network *Nw)
{
  Nw->vertices[0].height = (Nw->n_suppliers + (2 * Nw->n_stations)) + 2;
  Connection *c = Nw->vertices[0].head;
  while (c != 0)
  {
    c->flow = c->capacity;
    Nw->vertices[c->id].excess = c->capacity;
    Nw->vertices[0].excess -= c->capacity;
    Connection *d = Nw->vertices[c->id].head;
    while (d != 0)
    {
      if (d->id == 0)
      {
        d->flow -= c->capacity;
        break;
      }
      else
      {
        
      }

      d = d->next;
    }

    c = c->next;
  }

}

void relabel(Vertex *u, Network *Nw)
{
  Connection *c = Nw->vertices[u->id].head;
  int min = 32767;
  while (c != 0)
  {
    if ((Nw->vertices[c->id].height < min) && (c->capacity != c->flow))
    {
      min = Nw->vertices[c->id].height;
    }
    else
    {
      
    }

    c = c->next;
  }

  u->height = min + 1;
}

void push(Vertex *u, Connection *v, Network *Nw)
{
  int increase;
  increase = (u->excess < (v->capacity - v->flow)) ? (u->excess) : (v->capacity - v->flow);
  if ((v->capacity - v->flow) > 0)
  {
    v->flow += increase;
    Connection *c = Nw->vertices[v->id].head;
    while (c != 0)
    {
      if (c->id == u->id)
      {
        c->flow -= increase;
        break;
      }
      else
      {
        
      }

      c = c->next;
    }

  }
  else
  {
    Connection *c = Nw->vertices[v->id].head;
    while (c != 0)
    {
      if (c->id == u->id)
      {
        c->flow -= increase;
        break;
      }
      else
      {
        
      }

      c = c->next;
    }

    v->flow += increase;
  }

  u->excess -= increase;
  Nw->vertices[v->id].excess += increase;
}

void discharge(Vertex *u, Network *Nw)
{
  while (u->excess > 0)
  {
    Connection *v = u->current;
    if (v == 0)
    {
      relabel(u, Nw);
      u->current = u->head;
    }
    else
    {
      if (((v->capacity - v->flow) > 0) && (u->height == (Nw->vertices[v->id].height + 1)))
      {
        push(u, v, Nw);
      }
      else
      {
        u->current = v->next;
      }

    }

  }

}

void relabel_to_front(Network *Nw)
{
  int i;
  int old_height;
  initialize_preflow(Nw);
  Vertex_List *L = create_vertex_list(Nw);
  for (i = 2; i <= ((Nw->n_suppliers + (2 * Nw->n_stations)) + 1); i++)
    Nw->vertices[i].current = Nw->vertices[i].head;

  Vertex *u = L->head;
  while (u != 0)
  {
    old_height = u->height;
    discharge(u, Nw);
    if (u->height > old_height)
    {
      if (u == L->head)
      {
        ;
      }
      else
      {
        if (L->tail == u)
        {
          L->head->prev = u;
          u->prev->next = 0;
          L->tail = u->prev;
          u->prev = 0;
          u->next = L->head;
          L->head = u;
        }
        else
        {
          L->head->prev = u;
          u->prev->next = u->next;
          u->next->prev = u->prev;
          u->prev = 0;
          u->next = L->head;
          L->head = u;
        }

      }

    }
    else
    {
      
    }

    u = u->next;
  }

}

void DFS(int v, int visited[], Network *Nw)
{
  visited[v] = 1;
  Connection *c = Nw->vertices[v].head;
  for (; c != 0; c = c->next)
  {
    if ((!visited[c->id]) && ((c->flow + c->capacity) != 0))
    {
      DFS(c->id, visited, Nw);
    }
    else
    {
      
    }

  }

}

void merge(Cut arr[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  Cut L[n1];
  Cut R[n2];
  for (i = 0; i < n1; i++)
    L[i] = arr[l + i];

  for (j = 0; j < n2; j++)
    R[j] = arr[(m + 1) + j];

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (L[i].source < R[j].source)
    {
      arr[k] = L[i];
      i++;
    }
    else
    {
      if (L[i].source == R[j].source)
      {
        if (L[i].dest < R[j].dest)
        {
          arr[k] = L[i];
          i++;
        }
        else
        {
          arr[k] = R[j];
          j++;
        }

      }
      else
      {
        arr[k] = R[j];
        j++;
      }

    }

    k++;
  }

  while (i < n1)
  {
    arr[k] = L[i];
    i++;
    k++;
  }

  while (j < n2)
  {
    arr[k] = R[j];
    j++;
    k++;
  }

}

void mergeSort(Cut arr[], int p, int r)
{
  if (p < r)
  {
    int q = p + ((r - p) / 2);
    mergeSort(arr, p, q);
    mergeSort(arr, q + 1, r);
    merge(arr, p, q, r);
  }
  else
  {
    
  }

}

void get_minimum_cut(Network *Nw)
{
  int i;
  int n_conn = Nw->n_connections;
  int n_sup = Nw->n_suppliers;
  int n_sta = Nw->n_stations;
  int *visited = (int *) malloc(((n_sup + (2 * n_sta)) + 1) * (sizeof(int)));
  memset(visited, 0, ((n_sup + (2 * n_sta)) + 1) * (sizeof(int)));
  Cut *cut_list = (Cut *) malloc(n_conn * (sizeof(struct cut)));
  memset(cut_list, -1, n_conn * (sizeof(struct cut)));
  Connection *c = Nw->vertices[1].head;
  visited[1] = 1;
  int j = 0;
  for (; c != 0; c = c->next)
  {
    if ((!visited[c->id]) && ((c->flow + c->capacity) != 0))
    {
      DFS(c->id, visited, Nw);
      visited[c->id] = 1;
    }
    else
    {
      
    }

  }

  for (i = 0; i <= ((n_sup + (2 * n_sta)) + 1); i++)
  {
    Connection *c = Nw->vertices[i].head;
    while (c != 0)
    {
      if ((visited[i] && (!visited[c->id])) && (c->flow != 0))
      {
        cut_list[j].source = c->id;
        cut_list[j].dest = i;
        j++;
      }
      else
      {
        
      }

      c = c->next;
    }

  }

  mergeSort(cut_list, 0, n_conn - 1);
  for (i = 0; i < n_conn; i++)
    if (((cut_list[i].source + n_sta) == cut_list[i].dest) && (cut_list[i].source > (n_sup + 1)))
  {
    printf("%d", cut_list[i].source);
    cut_list[i].source = -1;
    break;
  }
  else
  {
    
  }


  for (i = 0; i < n_conn; i++)
    if (((cut_list[i].source + n_sta) == cut_list[i].dest) && (cut_list[i].source > (n_sup + 1)))
  {
    printf(" %d", cut_list[i].source);
    cut_list[i].source = -1;
  }
  else
  {
    
  }


  printf("\n");
  for (i = 0; i < n_conn; i++)
  {
    if (((cut_list[i].source != 0) && (cut_list[i].source >= ((n_sup + n_sta) + 2))) && (cut_list[i].source != (-1)))
    {
      printf("%d %d\n", cut_list[i].source - n_sta, cut_list[i].dest);
    }
    else
    {
      if (((cut_list[i].source != 0) && (cut_list[i].source <= (n_sup + n_sta))) && (cut_list[i].source != (-1)))
      {
        printf("%d %d\n", cut_list[i].source, cut_list[i].dest);
      }
      else
      {
        
      }

    }

  }

}

int main()
{
  int i;
  int n_sup;
  int n_conn;
  int n_sta;
  int input;
  int source;
  int dest;
  int cap;
  char *input_str;
  if (3 < 0)
  {
    exit(-1);
  }
  else
  {
    n_sup = new_sym_var(sizeof(int) * 8);
    n_sta = new_sym_var(sizeof(int) * 8);
    n_conn = new_sym_var(sizeof(int) * 8);
    
  }

  Network *Nw = (Network *) malloc(sizeof(struct network));
  Nw->n_suppliers = n_sup;
  Nw->n_stations = n_sta;
  Nw->n_connections = n_conn;
  Vertex *V = (Vertex *) malloc(((n_sup + (n_sta * 2)) + 2) * (sizeof(struct vertex)));
  Nw->vertices = V;
  create_vertex(0, Nw);
  create_vertex(1, Nw);
  getchar();
  for (i = 2; i <= (n_sup + 1); i++)
  {
    input_str = readInput();
    input = atoi(input_str);
    free(input_str);
    create_vertex(i, Nw);
    vertex_add_conn(0, i, input, Nw);
    vertex_add_conn(i, 0, input, Nw);
  }

  for (i = n_sup + 2; i <= ((n_sup + n_sta) + 1); i++)
  {
    input_str = readInput();
    input = atoi(input_str);
    free(input_str);
    create_vertex(i, Nw);
    create_vertex(i + n_sta, Nw);
    vertex_add_conn(i, i + n_sta, input, Nw);
    vertex_add_conn(i + n_sta, i, input, Nw);
  }

  for (i = 0; i < n_conn; i++)
  {
    if (3 < 0)
    {
      exit(-1);
    }
    else
    {
      source = new_sym_var(sizeof(int) * 8);
      dest = new_sym_var(sizeof(int) * 8);
      cap = new_sym_var(sizeof(int) * 8);
      
    }

    if ((source >= (n_sup + 2)) && (source <= ((n_sup + n_sta) + 2)))
    {
      vertex_add_conn(source + n_sta, dest, cap, Nw);
      vertex_add_conn(dest, source + n_sta, cap, Nw);
    }
    else
    {
      vertex_add_conn(source, dest, cap, Nw);
      vertex_add_conn(dest, source, cap, Nw);
    }

  }

  relabel_to_front(Nw);
  printf("%d\n", Nw->vertices[1].excess);
  get_minimum_cut(Nw);
  return 0;
}

