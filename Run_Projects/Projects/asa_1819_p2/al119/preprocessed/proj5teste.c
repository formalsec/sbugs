/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct vertex
{
  int height;
  int flow;
  int flag;
  int visited;
} Vertex;
typedef struct aresta
{
  int flow;
  int max_flow;
} Aresta;
static Aresta **matriz;
static Vertex *lista;
static int vertices;
static int *op_list;
static int counter;
int *stack;
int top = -1;
static int *lista_vizinhos;
static int *lista_resultado;
static int *lista_armazens;
static int *lista_ligacoes;
int capacidade_maxima()
{
  return lista[1].flow;
}

int stack_isempty()
{
  if (top == (-1))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int stack_pop()
{
  int data;
  data = stack[top];
  top = top - 1;
  return data;
}

void stack_push(int data)
{
  top = top + 1;
  stack[top] = data;
}

void swap(int index)
{
  int i;
  int data;
  data = op_list[index];
  for (i = index; i > 0; i--)
  {
    op_list[i] = op_list[i - 1];
  }

  op_list[0] = data;
}

int min(int a, int b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

void push(int u, int v)
{
  int d = min(lista[u].flow, matriz[u][v].max_flow - matriz[u][v].flow);
  matriz[u][v].flow += d;
  matriz[v][u].flow -= d;
  lista[u].flow -= d;
  lista[v].flow += d;
}

void relabel(int a)
{
  int j;
  int m = 100000000;
  for (j = 1; j <= vertices; j++)
  {
    if ((matriz[a][j].max_flow - matriz[a][j].flow) != 0)
    {
      m = min(m, lista[j].height);
    }
    else
    {
      
    }

  }

  lista[a].height = m + 1;
}

void discharge(int u)
{
  int v;
  int seen = 0;
  while (lista[u].flow > 0)
  {
    if (seen <= vertices)
    {
      v = seen;
      if (((matriz[u][v].max_flow - matriz[u][v].flow) > 0) && (lista[u].height > lista[v].height))
      {
        push(u, v);
      }
      else
      {
        seen += 1;
      }

    }
    else
    {
      relabel(u);
      seen = 0;
    }

  }

}

void free_matrix()
{
  int i;
  for (i = 0; i <= vertices; i++)
    free(matriz[i]);

  free(matriz);
}

void descobre_vizinhos(int s)
{
  int i;
  int j;
  for (i = 0; i <= vertices; i++)
  {
    lista_vizinhos[i] = -1;
  }

  for (i = 1, j = 0; i <= vertices; i++)
  {
    if ((matriz[i][s].max_flow - matriz[i][s].flow) != 0)
    {
      lista_vizinhos[j] = i;
      j++;
    }
    else
    {
      
    }

  }

}

void DFS()
{
  int i;
  int s;
  for (i = 2; i <= vertices; i++)
    lista[i].visited = 0;

  lista[1].visited = 1;
  stack_push(1);
  for (i = 0; i <= vertices; i++)
    lista_resultado[i] = 0;

  lista_resultado[1] = 1;
  while (!stack_isempty())
  {
    s = stack_pop();
    lista_resultado[s] = 1;
    descobre_vizinhos(s);
    for (i = 0; lista_vizinhos[i] != (-1); i++)
    {
      if (lista[lista_vizinhos[i]].visited == 0)
      {
        lista[lista_vizinhos[i]].visited = 1;
        stack_push(lista_vizinhos[i]);
      }
      else
      {
        
      }

    }

  }

}

void corte_minimo(int armazens)
{
  int i;
  int j;
  int h = 0;
  int k;
  int min;
  int aux1;
  int aux2;
  DFS();
  for (i = 0; i <= vertices; i++)
    lista_armazens[i] = 0;

  for (i = 0; i <= vertices; i++)
    lista_ligacoes[i] = -1;

  for (i = 0; i <= vertices; i++)
  {
    if (lista_resultado[i] == 1)
    {
      if ((lista[i].flag == 1) || (lista[i].flag == 3))
      {
        for (j = 1; j <= vertices; j++)
        {
          if ((((matriz[j][i].max_flow - matriz[j][i].flow) == 0) && (matriz[j][i].max_flow != 0)) && (lista_resultado[j] == 0))
          {
            if (j > (vertices - armazens))
            {
              lista_ligacoes[h] = j - armazens;
            }
            else
            {
              lista_ligacoes[h] = j;
            }

            lista_ligacoes[h + 1] = i;
            h += 2;
          }
          else
          {
            
          }

        }

      }
      else
      {
        
      }

      if ((lista[i].flag == 2) && (lista_resultado[i - armazens] == 0))
      {
        lista_armazens[i] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  for (i = 0, k = 0; i <= vertices; i++)
    if ((k == 0) && (lista_armazens[i] != 0))
  {
    printf("%d", i - armazens);
    k = 1;
  }
  else
  {
    if (lista_armazens[i] != 0)
    {
      printf(" %d", i - armazens);
    }
    else
    {
      
    }

  }


  printf("\n");
  for (k = 0; k < (h / 2); k++)
  {
    min = 100000000;
    aux2 = 100000000;
    aux1 = 0;
    for (i = 0; i < h; i += 2)
    {
      if (min == lista_ligacoes[i])
      {
        if (aux2 > lista_ligacoes[1 + i])
        {
          min = lista_ligacoes[i];
          aux2 = lista_ligacoes[i + 1];
          aux1 = i;
        }
        else
        {
          
        }

      }
      else
      {
        if (min > lista_ligacoes[i])
        {
          min = lista_ligacoes[i];
          aux2 = lista_ligacoes[i + 1];
          aux1 = i;
        }
        else
        {
          
        }

      }

    }

    printf("%d %d\n", min, aux2);
    lista_ligacoes[aux1] = 100000000;
    lista_ligacoes[aux1 + 1] = 100000000;
  }

}

int main()
{
  int fornecedores;
  int armazens;
  int Ligacoes;
  int i;
  int j;
  int flow;
  int V_Inicial;
  int V_Final;
  int Valor;
  fornecedores = new_sym_var(sizeof(int) * 8);
  armazens = new_sym_var(sizeof(int) * 8);
  Ligacoes = new_sym_var(sizeof(int) * 8);
  vertices = (fornecedores + (2 * armazens)) + 1;
  lista = (Vertex *) malloc((vertices + 1) * (sizeof(Vertex)));
  op_list = (int *) malloc(((2 * armazens) + 1) * (sizeof(int)));
  matriz = (Aresta **) malloc((vertices + 1) * (sizeof(Aresta *)));
  for (i = 0; i <= vertices; i++)
  {
    matriz[i] = (Aresta *) malloc((vertices + 1) * (sizeof(Aresta)));
    for (j = 0; j <= vertices; j++)
    {
      matriz[i][j].flow = 0;
      matriz[i][j].max_flow = 0;
    }

  }

  lista[1].flow = 0;
  lista[1].height = 0;
  lista[1].flag = 3;
  for (i = 2; i <= (fornecedores + 1); i++)
  {
    flow = new_sym_var(sizeof(int) * 8);
    lista[i].flow = flow;
    lista[i].height = vertices;
    lista[i].flag = 0;
  }

  counter = 0;
  for (i = fornecedores + 2; i <= ((fornecedores + armazens) + 1); i++)
  {
    flow = new_sym_var(sizeof(int) * 8);
    lista[i].flow = 0;
    lista[i].height = 0;
    lista[i].flag = 1;
    op_list[counter] = i;
    counter++;
    matriz[i][i + armazens].flow = 0;
    matriz[i][i + armazens].max_flow = flow;
    lista[i + armazens].flow = 0;
    lista[i + armazens].height = 0;
    lista[i + armazens].flag = 2;
    op_list[counter] = i + armazens;
    counter++;
  }

  for (i = 0; i < Ligacoes; i++)
  {
    V_Inicial = new_sym_var(sizeof(int) * 8);
    V_Final = new_sym_var(sizeof(int) * 8);
    Valor = new_sym_var(sizeof(int) * 8);
    if (lista[V_Inicial].flag == 1)
    {
      matriz[V_Inicial + armazens][V_Final].flow = 0;
      matriz[V_Inicial + armazens][V_Final].max_flow = Valor;
    }
    else
    {
      matriz[V_Inicial][V_Final].flow = 0;
      matriz[V_Inicial][V_Final].max_flow = Valor;
    }

  }

  for (i = 2; i < (fornecedores + 2); i++)
  {
    for (j = 1; j <= vertices; j++)
    {
      if (matriz[i][j].max_flow > 0)
      {
        push(i, j);
      }
      else
      {
        
      }

    }

  }

  i = 0;
  while (i < counter)
  {
    int u = op_list[i];
    int old_height = lista[u].height;
    discharge(u);
    if (lista[u].height > old_height)
    {
      swap(i);
      i = 0;
    }
    else
    {
      i += 1;
    }

  }

  free(op_list);
  lista_armazens = (int *) malloc((vertices + 1) * (sizeof(int)));
  lista_ligacoes = (int *) malloc(((2 * (Ligacoes + armazens)) + 1) * (sizeof(int)));
  lista_resultado = (int *) malloc((vertices + 1) * (sizeof(int)));
  lista_vizinhos = (int *) malloc((vertices + 1) * (sizeof(int)));
  stack = malloc(vertices * (sizeof(int)));
  printf("%d\n", capacidade_maxima());
  corte_minimo(armazens);
  free(lista);
  free_matrix();
  free(stack);
  free(lista_resultado);
  free(lista_vizinhos);
  free(lista_ligacoes);
  free(lista_armazens);
  return 0;
}

