/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <signal.h>
#include <unistd.h>


int min(int a, int b)
{
  return (a > b) ? (b) : (a);
}

int compare(const void *a, const void *b)
{
  (void) a;
  (void) b;
  return 0;
}

int getMax(int arr[], int n)
{
  int mx = arr[0];
  int i;
  for (i = 1; i < n; i++)
    if (arr[i] > mx)
  {
    mx = arr[i];
  }
  else
  {
    
  }


  return mx;
}

void countSort(int arr[], int n, int exp)
{
  int output[n];
  int i;
  int count[10] = {0};
  for (i = 0; i < n; i++)
    count[(arr[i] / exp) % 10]++;

  for (i = 1; i < 10; i++)
    count[i] += count[i - 1];

  for (i = n - 1; i >= 0; i--)
  {
    output[count[(arr[i] / exp) % 10] - 1] = arr[i];
    count[(arr[i] / exp) % 10]--;
  }

  for (i = 0; i < n; i++)
    arr[i] = output[i];

}

void radixsort(int arr[], int n)
{
  int m = getMax(arr, n);
  int exp;
  for (exp = 1; (m / exp) > 0; exp *= 10)
    countSort(arr, n, exp);

}

typedef struct list_node
{
  void *data;
  struct list_node *next;
} *list_node_t;
typedef struct list
{
  list_node_t head;
  list_node_t tail;
  long size;
  int data_size;
} *list_t;
static list_node_t list_node_create(void *data, int data_size)
{
  list_node_t node = malloc(sizeof(struct list_node));
  if (!node)
  {
    fprintf(stderr, "%s\n", "Could not allocate memory for node.");
    exit(1);
  }
  else
  {
    
  }

  ;
  node->data = malloc(data_size);
  memcpy(node->data, data, data_size);
  node->next = 0;
  return node;
}

list_t list_create(int data_size)
{
  list_t list = malloc(sizeof(struct list));
  if (!list)
  {
    {
      fprintf(stderr, "%s\n", "Could not allocate memory for linked list.");
      exit(1);
    }
    ;
  }
  else
  {
    
  }

  list->data_size = data_size;
  list->head = 0;
  list->tail = 0;
  list->size = 0;
  return list;
}

long list_getSize(list_t list)
{
  return list->size;
}

void list_iter_reset(list_t list, list_node_t *node)
{
  *node = list->head;
}

int list_iter_hasNext(list_node_t *node)
{
  return ((*node) != 0) ? (1) : (0);
}

void list_iter_next(list_node_t *node)
{
  if (node != 0)
  {
    *node = (*node)->next;
  }
  else
  {
    
  }

}

void list_insert_start(list_t list, void *data)
{
  list_node_t temp;
  list_node_t node = list_node_create(data, list->data_size);
  if (list->size == 0)
  {
    list->head = node;
    list->tail = node;
  }
  else
  {
    temp = list->head;
    node->next = temp;
    list->head = node;
  }

  list->size++;
}

void list_push(list_t list, void *data)
{
  list_insert_start(list, data);
}

void list_insert(list_t list, void *data)
{
  list_node_t node = list_node_create(data, list->data_size);
  if (list->size == 0)
  {
    list->head = node;
    list->tail = node;
  }
  else
  {
    list->tail->next = node;
    list->tail = node;
  }

  list->size++;
}

void list_insert_end(list_t list, void *data)
{
  list_insert(list, data);
}

void list_insert_at(list_t list, void *data, long index)
{
  long i = 1;
  long size = list_getSize(list);
  if (index > size)
  {
    printf("Index exceeds list size.\n");
    return;
  }
  else
  {
    
  }

  if (index == 0)
  {
    list_insert_start(list, data);
  }
  else
  {
    if (index == size)
    {
      list_insert_end(list, data);
    }
    else
    {
      list_node_t new = list_node_create(data, list->data_size);
      list_node_t temp = list->head->next;
      list_node_t prev = list->head;
      while (i != index)
      {
        list_iter_next(&temp);
        list_iter_next(&prev);
        i++;
      }

      prev->next = new;
      new->next = temp;
      list->size++;
    }

  }

}

void *list_at(list_t list, long index)
{
  long i = 0;
  long size = list_getSize(list);
  if (index > (size - 1))
  {
    printf("Index exceeds list size.\n");
    return 0;
  }
  else
  {
    
  }

  list_node_t temp = 0;
  list_iter_reset(list, &temp);
  while (i != index)
  {
    list_iter_next(&temp);
    i++;
  }

  void *egg = temp->data;
  (void) egg;
  return temp->data;
}

void list_remove_start(list_t list)
{
  list_node_t head = list->head;
  list->head = head->next;
  free(head);
  list->size--;
}

void list_remove_end(list_t list)
{
  list_node_t temp;
  list_node_t prev = 0;
  temp = list->head;
  while (list_iter_hasNext(&temp->next))
  {
    prev = temp;
    temp = temp->next;
  }

  free(temp);
  if (prev)
  {
    prev->next = 0;
    list->tail = prev;
  }
  else
  {
    list->head = 0;
    list->tail = 0;
  }

  if (list->size == 1)
  {
    list->head = list->tail;
  }
  else
  {
    
  }

  list->size--;
}

void list_pop(list_t list)
{
  list_remove_end(list);
}

void list_remove(list_t list, void *data)
{
  list_node_t head = list->head;
  list_node_t tail = list->tail;
  int found = 0;
  if (list->size == 0)
  {
    printf("Could not remove: list is empty.\n");
    return;
  }
  else
  {
    
  }

  if (head->data == data)
  {
    found = 1;
    list_remove_start(list);
  }
  else
  {
    if (tail->data == data)
    {
      found = 1;
      list_remove_end(list);
    }
    else
    {
      list_node_t temp = list->head->next;
      list_node_t prev = list->head;
      while (list_iter_hasNext(&temp))
      {
        if (temp->data == data)
        {
          prev->next = temp->next;
          free(temp);
          found = 1;
          list->size--;
          break;
        }
        else
        {
          
        }

        temp = temp->next;
        prev = prev->next;
      }

    }

  }

  if (!found)
  {
    printf("Could not remove: data was not found in list.\n");
  }
  else
  {
    
  }

}

void list_remove_at(list_t list, long index)
{
  long i = 0;
  long size = list_getSize(list);
  if (index > (size - 1))
  {
    printf("Index exceeds list size.\n");
    return;
  }
  else
  {
    
  }

  if (index == 0)
  {
    list_remove_start(list);
  }
  else
  {
    if (index == (size - 1))
    {
      list_remove_end(list);
    }
    else
    {
      list_node_t temp = list->head->next;
      list_node_t prev = list->head;
      i++;
      while (i != index)
      {
        list_iter_next(&temp);
        list_iter_next(&prev);
        i++;
      }

      prev->next = temp->next;
      free(temp);
      list->size--;
    }

  }

}

int list_isEmpty(list_t list)
{
  return !list->size;
}

void list_free(list_t list)
{
  list_node_t current;
  while (list->head != 0)
  {
    current = list->head;
    list->head = current->next;
    free(current->data);
    free(current);
  }

  free(list);
}

typedef unsigned long ulong_t;
enum 
{
  FALSE = 0,
  TRUE = 1
};
typedef long bool_t;
typedef struct queue queue_t;
struct queue
{
  long pop;
  long push;
  long capacity;
  void **elements;
};
enum config
{
  QUEUE_GROWTH_FACTOR = 2
};
queue_t *queue_alloc(long initCapacity)
{
  queue_t *queuePtr = (queue_t *) malloc(sizeof(queue_t));
  if (queuePtr)
  {
    long capacity = (initCapacity < 2) ? (2) : (initCapacity);
    queuePtr->elements = (void **) malloc(capacity * (sizeof(void *)));
    if (queuePtr->elements == 0)
    {
      free(queuePtr);
      return 0;
    }
    else
    {
      
    }

    queuePtr->pop = capacity - 1;
    queuePtr->push = 0;
    queuePtr->capacity = capacity;
  }
  else
  {
    
  }

  return queuePtr;
}

void queue_free(queue_t *queuePtr)
{
  free(queuePtr->elements);
  free(queuePtr);
}

bool_t queue_isEmpty(queue_t *queuePtr)
{
  long pop = queuePtr->pop;
  long push = queuePtr->push;
  long capacity = queuePtr->capacity;
  return (((pop + 1) % capacity) == push) ? (TRUE) : (FALSE);
}

void queue_clear(queue_t *queuePtr)
{
  queuePtr->pop = queuePtr->capacity - 1;
  queuePtr->push = 0;
}

bool_t queue_push(queue_t *queuePtr, void *dataPtr)
{
  long pop = queuePtr->pop;
  long push = queuePtr->push;
  long capacity = queuePtr->capacity;
  assert(pop != push);
  long newPush = (push + 1) % capacity;
  if (newPush == pop)
  {
    long newCapacity = capacity * QUEUE_GROWTH_FACTOR;
    void **newElements = (void **) malloc(newCapacity * (sizeof(void *)));
    if (newElements == 0)
    {
      return FALSE;
    }
    else
    {
      
    }

    long dst = 0;
    void **elements = queuePtr->elements;
    if (pop < push)
    {
      long src;
      for (src = pop + 1; src < push; src++, dst++)
      {
        newElements[dst] = elements[src];
      }

    }
    else
    {
      long src;
      for (src = pop + 1; src < capacity; src++, dst++)
      {
        newElements[dst] = elements[src];
      }

      for (src = 0; src < push; src++, dst++)
      {
        newElements[dst] = elements[src];
      }

    }

    free(elements);
    queuePtr->elements = newElements;
    queuePtr->pop = newCapacity - 1;
    queuePtr->capacity = newCapacity;
    push = dst;
    newPush = push + 1;
  }
  else
  {
    
  }

  queuePtr->elements[push] = dataPtr;
  queuePtr->push = newPush;
  return TRUE;
}

void *queue_pop(queue_t *queuePtr)
{
  long pop = queuePtr->pop;
  long push = queuePtr->push;
  long capacity = queuePtr->capacity;
  long newPop = (pop + 1) % capacity;
  if (newPop == push)
  {
    return 0;
  }
  else
  {
    
  }

  void *dataPtr = queuePtr->elements[newPop];
  queuePtr->pop = newPop;
  return dataPtr;
}

typedef struct edge
{
  int target_id;
  int capacity;
  int flow;
} edge_t;
typedef struct node
{
  int excess;
  int height;
  int current;
  int id;
  edge_t *adj;
} node_t;
typedef struct queueItem
{
  int id;
  int type;
} queueItem_t;
node_t *stations_in;
node_t *stations_out;
node_t *producers;
int num_suppliers = 0;
int num_stations = 0;
int num_edges = 0;
int total_production;
int *amount_edges;
list_t queue;
typedef struct connection
{
  int origin_id;
  int target_id;
} connection_t;
void add_edge(int source_id, int target_id, int capacity)
{
  node_t source;
  int num_edges;
  if (source_id == target_id)
  {
    source = stations_in[(source_id - num_suppliers) - 2];
    if (!source.adj)
    {
      source.adj = calloc(1, sizeof(edge_t));
    }
    else
    {
      
    }

    source.adj[0].target_id = target_id;
    source.adj[0].capacity += capacity;
    stations_in[(source_id - num_suppliers) - 2] = source;
    return;
  }
  else
  {
    
  }

  if (source_id > (num_suppliers + 1))
  {
    source = stations_out[(source_id - num_suppliers) - 2];
  }
  else
  {
    source = producers[source_id];
  }

  num_edges = amount_edges[source_id];
  if (num_edges != 0)
  {
    source.adj = realloc(source.adj, (num_edges + 1) * (sizeof(edge_t)));
  }
  else
  {
    edge_t *mcnubbwe = calloc(1, sizeof(edge_t));
    source.adj = mcnubbwe;
    source.id = source_id;
  }

  source.adj[num_edges].target_id = target_id;
  source.adj[num_edges].capacity += capacity;
  amount_edges[source_id]++;
  if (source_id > (num_suppliers + 1))
  {
    stations_out[(source_id - num_suppliers) - 2] = source;
  }
  else
  {
    producers[source_id] = source;
  }

  if (source_id == 0)
  {
    producers[0].excess += capacity;
  }
  else
  {
    
  }

}

void get_input()
{
  int i = 0;
  char buffer[10000];
  char *token;
  const char *delim = " \n";
  queue = list_create(sizeof(node_t));
  if (3 == 3)
  {
    num_suppliers = new_sym_var(sizeof(int) * 8);
    num_stations = new_sym_var(sizeof(int) * 8);
    num_edges = new_sym_var(sizeof(int) * 8);
    ;
  }
  else
  {
    
  }

  amount_edges = calloc((num_suppliers + num_stations) + 20, sizeof(int));
  stations_in = calloc(num_stations, sizeof(node_t));
  stations_out = calloc(num_stations, sizeof(node_t));
  producers = calloc(num_suppliers + 2, sizeof(node_t));
  if (fgets(buffer, 9999, stdin) != 0)
  {
    ;
  }
  else
  {
    
  }

  token = strtok(buffer, delim);
  i = 2;
  while (token != 0)
  {
    add_edge(0, i, atoi(token));
    i++;
    token = strtok(0, delim);
  }

  i = num_suppliers + 2;
  if (fgets(buffer, 9999, stdin) != 0)
  {
    ;
  }
  else
  {
    
  }

  token = strtok(buffer, delim);
  while (token != 0)
  {
    add_edge(i, i, atoi(token));
    i++;
    token = strtok(0, delim);
  }

  for (i = 0; i < num_edges; i++)
  {
    int origin_id;
    int target_id;
    int capacity;
    if (3 == 3)
    {
      origin_id = new_sym_var(sizeof(int) * 8);
      target_id = new_sym_var(sizeof(int) * 8);
      capacity = new_sym_var(sizeof(int) * 8);
      ;
    }
    else
    {
      
    }

    add_edge(origin_id, target_id, capacity);
    add_edge(target_id, origin_id, capacity);
  }

  producers[0].height = num_suppliers + num_stations;
  list_insert(queue, &producers[0]);
}

void push(node_t *u, node_t *v, int u_edge_id, int v_edge_id)
{
  int current_flow = u->adj[u_edge_id].capacity - u->adj[u_edge_id].flow;
  int residual_flow = min(u->excess, current_flow);
  if (residual_flow)
  {
    u->adj[u_edge_id].flow += residual_flow;
  }
  else
  {
    v->adj[v_edge_id].flow += residual_flow;
  }

  u->excess -= residual_flow;
  v->excess += residual_flow;
  if (v->id < (num_suppliers + 2))
  {
    list_insert_end(queue, &producers[v->id]);
  }
  else
  {
    if (u->id == v->id)
    {
      list_insert_end(queue, &stations_out[(v->id - num_suppliers) - 2]);
    }
    else
    {
      list_insert_end(queue, &stations_in[(v->id - num_suppliers) - 2]);
    }

  }

}

void relabel(node_t *u)
{
  u->height += 1;
}

void discharge(node_t *u)
{
  int counter = 0;
  while (u->excess != 0)
  {
    int v = u->current;
    node_t *vertex = malloc(sizeof(struct node));
    if (v)
    {
      if (v < (num_suppliers + 2))
      {
        vertex = &producers[v];
      }
      else
      {
        if (u->id == v)
        {
          vertex = &stations_out[(v - num_suppliers) - 2];
        }
        else
        {
          vertex = &stations_in[(v - num_suppliers) - 2];
        }

      }

    }
    else
    {
      
    }

    int current_flow = 0;
    int j = 0;
    int size = amount_edges[u->id];
    int i = 0;
    for (; i < size; i++)
    {
      if (u->adj[i].target_id == vertex->id)
      {
        current_flow = u->adj[i].capacity - u->adj[i].flow;
        if (current_flow > 0)
        {
          break;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (!v)
    {
      relabel(u);
      u->current = u->adj[counter++].target_id;
    }
    else
    {
      if ((u->height > vertex->height) && (current_flow > 0))
      {
        for (; j < size; j++)
          if (vertex->adj[j].target_id == u->id)
        {
          break;
        }
        else
        {
          
        }


        push(u, vertex, i, j);
      }
      else
      {
        u->current = u->adj[counter++].target_id;
      }

    }

  }

}

void relabel_to_front()
{
  int counter = 0;
  int old_h;
  while ((!list_isEmpty(queue)) && (counter < list_getSize(queue)))
  {
    fflush(stdout);
    node_t *vertex = list_at(queue, counter);
    old_h = vertex->height;
    discharge(vertex);
    if (old_h > vertex->height)
    {
      counter = 1;
      list_remove(queue, vertex);
      list_insert_start(queue, vertex);
    }
    else
    {
      list_remove(queue, vertex);
      counter++;
    }

  }

}

int main()
{
  int i;
  get_input();
  relabel_to_front();
  free(amount_edges);
  for (i = 0; i < num_stations; i++)
  {
    free(stations_in[i].adj);
  }

  free(stations_in);
  for (i = 0; i < num_stations; i++)
  {
    free(stations_out[i].adj);
  }

  free(stations_out);
  for (i = 0; i < (num_suppliers + 2); i++)
  {
    free(producers[i].adj);
  }

  free(producers);
  exit(0);
}

