/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct vertex
{
  int grade;
  int number;
  int color;
  struct vertex *next;
} vertex;
int main()
{
  int N;
  int M;
  int i;
  N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  if ((N < 2) || (M < 1))
  {
    perror("Invalid number of vertexes or edges\n");
    exit(1);
  }
  else
  {
    
  }

  int FIFO[N];
  vertex *adjList = (vertex *) malloc((sizeof(vertex)) * N);
  if (!adjList)
  {
    perror("Fail to allocate adjacent list\n");
    exit(1);
  }
  else
  {
    
  }

  for (i = 0; i < N; i++)
  {
    adjList[i].next = 0;
    adjList[i].grade = new_sym_var(sizeof(int) * 8);
    adjList[i].color = 0;
    FIFO[i] = -1;
  }

  vertex *u;
  int v;
  for (i = 0; i < M; i++)
  {
    u = (vertex *) malloc(sizeof(vertex));
    if (!u)
    {
      perror("Fail to allocate vertex\n");
      exit(1);
    }
    else
    {
      
    }

    u->number = new_sym_var(sizeof(int) * 8);
    v = new_sym_var(sizeof(int) * 8);
    u->number--;
    v--;
    u->next = adjList[v].next;
    adjList[v].next = u;
  }

  int node;
  int fifoIndex = 0;
  int fifoNext = 0;
  int fifoValue;
  vertex *p;
  for (node = 0; node < N; node++)
  {
    if (adjList[node].color == 0)
    {
      adjList[node].color = 1;
      fifoValue = 0;
      FIFO[fifoIndex] = node;
      fifoNext = (fifoIndex + 1) % N;
      while (FIFO[fifoIndex] != (-1))
      {
        fifoValue = FIFO[fifoIndex];
        FIFO[fifoIndex] = -1;
        p = adjList[fifoValue].next;
        while (p != 0)
        {
          if (adjList[p->number].grade < adjList[fifoValue].grade)
          {
            FIFO[fifoNext] = p->number;
            fifoNext = (fifoNext + 1) % N;
            adjList[p->number].grade = adjList[fifoValue].grade;
            adjList[p->number].color = 1;
          }
          else
          {
            
          }

          p = p->next;
        }

        fifoIndex = (fifoIndex + 1) % N;
      }

    }
    else
    {
      
    }

  }

  for (i = 0; i < N; i++)
  {
    printf("%d\n", adjList[i].grade);
    p = adjList[i].next;
    while (p != 0)
    {
      u = p;
      p = p->next;
      free(u);
    }

  }

  free(adjList);
  return 0;
}

