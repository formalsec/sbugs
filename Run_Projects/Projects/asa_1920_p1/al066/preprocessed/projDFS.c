/*File generated by PreProcessor.py*/


#include<stdio.h>
#include<stdlib.h>
#include<string.h>


typedef struct Vertices
{
  int StudentId;
  int previousStudentGrade;
  int actualStudentGrade;
  struct Vertices *nextStudent;
} vertex;
typedef struct Graph
{
  int *visited;
  int verticesNumber;
  vertex **adjlist;
} graph;
graph *CreateGraph(int verticesNumber);
void createStudentVertex(int StudentGrade, graph *G, int index);
void InsertFriendshipEdge(int student, int friend, graph *G);
void calculateNewGrades(graph *G, int *PreviousGrades);
void caculate(vertex *u);
void DFS_VISIT_STUDENT(graph *g, int studentId, int student);
int maxgrade(int x, int y);
graph *G;
int current_grade = 0;
graph *CreateGraph(int verticesNumber)
{
  int counter;
  graph *G = (graph *) malloc(sizeof(graph));
  if (G != 0)
  {
    G->verticesNumber = verticesNumber;
    G->adjlist = (vertex **) malloc((sizeof(vertex *)) * (verticesNumber + 1));
    G->visited = (int *) malloc((sizeof(int)) * (verticesNumber + 1));
    for (counter = 1; counter < verticesNumber; counter++)
    {
      G->visited[counter] = 0;
      G->adjlist[counter] = 0;
    }

  }
  else
  {
    
  }

  return G;
}

void createStudentVertex(int StudentGrade, graph *G, int index)
{
  vertex *aux = (vertex *) malloc(sizeof(vertex));
  aux->previousStudentGrade = StudentGrade;
  aux->StudentId = index;
  aux->nextStudent = 0;
  G->adjlist[index] = aux;
}

void InsertFriendshipEdge(int student, int friend, graph *G)
{
  vertex *aux = (vertex *) malloc(sizeof(vertex));
  vertex *temp_next = (vertex *) malloc(sizeof(vertex));
  temp_next = G->adjlist[student]->nextStudent;
  aux->previousStudentGrade = G->adjlist[friend]->previousStudentGrade;
  aux->StudentId = friend;
  aux->nextStudent = temp_next;
  G->adjlist[student]->nextStudent = aux;
}

void UpdateAllGrades(graph *G)
{
  int counter;
  int i;
  for (counter = 1; counter <= G->verticesNumber; counter++)
  {
    int studentId = G->adjlist[counter]->StudentId;
    current_grade = G->adjlist[counter]->previousStudentGrade;
    DFS_VISIT_STUDENT(G, studentId, studentId);
    G->adjlist[counter]->actualStudentGrade = current_grade;
    for (i = 1; i <= G->verticesNumber; i++)
    {
      G->visited[i] = 0;
    }

  }

}

void DFS_VISIT_STUDENT(graph *g, int studentId, int student)
{
  vertex *adjList = g->adjlist[studentId];
  vertex *temp = adjList;
  g->visited[studentId] = 1;
  if (current_grade < temp->previousStudentGrade)
  {
    current_grade = temp->previousStudentGrade;
  }
  else
  {
    
  }

  while (temp != 0)
  {
    int connectedVertex = temp->StudentId;
    if (g->visited[connectedVertex] == 0)
    {
      DFS_VISIT_STUDENT(g, connectedVertex, student);
    }
    else
    {
      
    }

    temp = temp->nextStudent;
  }

}

int main(int argc, char *argv[])
{
  int studentsNumber;
  int friendshipNumber;
  int counter = 1;
  int grade;
  int *PreviousGrades;
  int student;
  int friend;
  int i;
  studentsNumber = new_sym_var(sizeof(int) * 8);
  friendshipNumber = new_sym_var(sizeof(int) * 8);
  G = CreateGraph(studentsNumber);
  PreviousGrades = (int *) malloc((sizeof(int)) * (studentsNumber + 1));
  while (counter <= studentsNumber)
  {
    grade = new_sym_var(sizeof(int) * 8);
    PreviousGrades[counter] = grade;
    createStudentVertex(grade, G, counter);
    counter++;
  }

  counter = 1;
  while (counter <= friendshipNumber)
  {
    student = new_sym_var(sizeof(int) * 8);
    friend = new_sym_var(sizeof(int) * 8);
    InsertFriendshipEdge(student, friend, G);
    counter++;
  }

  UpdateAllGrades(G);
  for (i = 1; i <= studentsNumber; i++)
  {
    printf("%d\n", G->adjlist[i]->actualStudentGrade);
  }

  return 0;
}

