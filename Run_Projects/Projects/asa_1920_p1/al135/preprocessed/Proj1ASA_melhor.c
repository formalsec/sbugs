/*File generated by PreProcessor.py*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct node
{
  int value;
  struct node *next;
} *link;
typedef struct queue
{
  link head;
  link tail;
  int size;
} *queue_t;
typedef struct graph
{
  link *adjList;
  int numNodes;
} *graph_t;
link newNode(int value, link head)
{
  link x = (link) malloc(sizeof(struct node));
  x->value = value;
  x->next = head;
  return x;
}

void initQueue(queue_t queue)
{
  queue->head = 0;
  queue->tail = 0;
  queue->size = 0;
}

int emptyQueue(queue_t queue)
{
  return queue->head == 0;
}

void push(queue_t queue, int value)
{
  if (queue->head == 0)
  {
    queue->head = (queue->tail = newNode(value, queue->head));
    return;
  }
  else
  {
    
  }

  queue->tail->next = newNode(value, queue->tail->next);
  queue->tail = queue->tail->next;
  queue->size++;
}

int pop(queue_t queue)
{
  link x;
  int value;
  value = queue->head->value;
  x = queue->head->next;
  free(queue->head);
  queue->head = x;
  queue->size--;
  return value;
}

link insertBegin(link head, int v)
{
  link x = (link) malloc(sizeof(struct node));
  x->value = v;
  x->next = head;
  return x;
}

graph_t initGraph(int n)
{
  int v;
  graph_t graph = (graph_t) malloc(sizeof(struct graph));
  graph->numNodes = n;
  graph->adjList = (link *) malloc(n * (sizeof(link)));
  for (v = 0; v < n; v++)
    graph->adjList[v] = 0;

  return graph;
}

void insertEdge(graph_t graph, int node1, int node2)
{
  graph->adjList[node1] = insertBegin(graph->adjList[node1], node2);
}

void bfs(graph_t G, int *gradeList, int numNodes)
{
  int i;
  int node;
  int friend_index;
  int max;
  link friend;
  bool *visited = (bool *) malloc(numNodes * (sizeof(bool)));
  queue_t queue = (queue_t) malloc(sizeof(struct queue));
  initQueue(queue);
  numNodes = G->numNodes;
  link *adjList = G->adjList;
  for (i = 0; i < numNodes; i++)
  {
    memset(visited, 0, numNodes);
    visited[i] = true;
    push(queue, i);
    max = gradeList[i];
    while (!emptyQueue(queue))
    {
      node = pop(queue);
      for (friend = adjList[node]; friend != 0; friend = friend->next)
      {
        friend_index = friend->value;
        if (!visited[friend_index])
        {
          if (gradeList[friend_index] > max)
          {
            max = gradeList[friend_index];
          }
          else
          {
            
          }

          visited[friend_index] = true;
          push(queue, friend_index);
        }
        else
        {
          
        }

      }

    }

    gradeList[i] = max;
  }

  while (!emptyQueue(queue))
  {
    perror("qq not empty");
    pop(queue);
  }

  free(queue);
  free(visited);
}

int main(int argc, char **argv)
{
  int numNodes;
  int numEdges;
  int node1;
  int node2;
  graph_t graph;
  if (2 != 2)
  {
    perror("error reading file");
    return 1;
  }
  else
  {
    numNodes = new_sym_var(sizeof(int) * 8);
    numEdges = new_sym_var(sizeof(int) * 8);
    
  }

  graph = initGraph(numNodes);
  int gradeList[numNodes];
  int i;
  for (i = 0; i < numNodes; i++)
  {
    if (1 != 1)
    {
      perror("error reading file");
      return 1;
    }
    else
    {
      gradeList[i] = new_sym_var(sizeof(int) * 8);
      
    }

  }

  for (i = 0; i < numEdges; i++)
  {
    if (2 != 2)
    {
      perror("error reading file");
      return 1;
    }
    else
    {
      node1 = new_sym_var(sizeof(int) * 8);
      node2 = new_sym_var(sizeof(int) * 8);
      
    }

    insertEdge(graph, node1 - 1, node2 - 1);
  }

  bfs(graph, gradeList, numNodes);
  link x;
  link next;
  for (i = 0; i < numNodes; i++)
  {
    printf("%d\n", gradeList[i]);
    for (x = graph->adjList[i]; x != 0; x = next)
    {
      next = x->next;
      free(x);
    }

  }

  free(graph->adjList);
  free(graph);
  return 0;
}

