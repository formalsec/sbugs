/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef enum color
{
  WHITE,
  BLACK
} Color;
typedef struct amigo
{
  int amigo;
  struct amigo *next;
} Amigo;
typedef struct scc
{
  int low;
  int nota;
} SCComponents;
typedef struct aluno
{
  Color color;
  int _nota;
  int d;
  int low;
  Amigo *lista;
  SCComponents *scc;
} Aluno;
typedef struct stack
{
  int i;
  struct stack *next;
} Stack;
typedef struct node
{
  SCComponents *scc;
  struct node *next;
} Node;
void amigo(Aluno *alunos, int a, int b)
{
  Amigo *plista = alunos[a - 1].lista;
  Amigo *new = 0;
  if (plista->amigo == 0)
  {
    plista->amigo = b;
    return;
  }
  else
  {
    
  }

  new = (Amigo *) malloc(sizeof(Amigo));
  new->amigo = b;
  new->next = plista;
  alunos[a - 1].lista = new;
}

void dfs_visit(Aluno *alunos, int i)
{
  Amigo *plista = alunos[i].lista;
  alunos[i].color = BLACK;
  while ((plista != 0) && (plista->amigo != 0))
  {
    if (alunos[plista->amigo - 1].color == WHITE)
    {
      dfs_visit(alunos, plista->amigo - 1);
    }
    else
    {
      
    }

    if (alunos[plista->amigo - 1]._nota > alunos[i]._nota)
    {
      alunos[i]._nota = alunos[plista->amigo - 1]._nota;
    }
    else
    {
      
    }

    plista = plista->next;
  }

  return;
}

void dfs(Aluno *alunos, int n)
{
  int i;
  for (i = 0; i < n; i++)
  {
    alunos[i].color = WHITE;
  }

  for (i = 0; i < n; i++)
  {
    if (alunos[i].color == WHITE)
    {
      dfs_visit(alunos, i);
    }
    else
    {
      
    }

  }

}

int top(Stack *stack)
{
  return stack->i;
}

Stack *pop(Stack *stack)
{
  Stack *top = stack->next;
  free(stack);
  return top;
}

Stack *push(Stack *stack, int i)
{
  Stack *top = (Stack *) malloc(sizeof(Stack));
  top->i = i;
  top->next = stack;
  return top;
}

void addSCC(Node *sccs, SCComponents *newSCC)
{
  Node *new = 0;
  if (sccs->scc == 0)
  {
    sccs->scc = newSCC;
    return;
  }
  else
  {
    
  }

  new = (Node *) malloc(sizeof(Node));
  sccs->next = new;
  new->scc = newSCC;
  new->next = 0;
}

Stack *SCCUtil(int i, Aluno *alunos, Stack *stack, int *stackMember, Node *sccs)
{
  static int time = 0;
  int w;
  Amigo *plista = alunos[i].lista;
  alunos[i].d = ++time;
  alunos[i].low = time;
  stack = push(stack, i);
  stackMember[i] = 1;
  while ((plista != 0) && (plista->amigo != 0))
  {
    if (alunos[plista->amigo - 1].d == 0)
    {
      stack = SCCUtil(plista->amigo - 1, alunos, stack, stackMember, sccs);
      alunos[i].low = (alunos[i].low < alunos[plista->amigo - 1].low) ? (alunos[i].low) : (alunos[plista->amigo - 1].low);
    }
    else
    {
      if (stackMember[plista->amigo - 1] == 1)
      {
        alunos[i].low = (alunos[i].low < alunos[plista->amigo - 1].d) ? (alunos[i].low) : (alunos[plista->amigo - 1].d);
      }
      else
      {
        
      }

    }

    plista = plista->next;
  }

  w = 0;
  if (alunos[i].low == alunos[i].d)
  {
    SCComponents *newSCC = (SCComponents *) malloc(sizeof(SCComponents));
    newSCC->low = alunos[i].low;
    newSCC->nota = 0;
    addSCC(sccs, newSCC);
    while (top(stack) != i)
    {
      w = top(stack);
      alunos[w].scc = newSCC;
      stackMember[w] = 0;
      stack = pop(stack);
    }

    w = top(stack);
    alunos[w].scc = newSCC;
    stackMember[w] = 0;
    stack = pop(stack);
  }
  else
  {
    
  }

  return stack;
}

void SCC(Aluno *alunos, int N, Node *sccs)
{
  int i;
  int *stackMember = (int *) malloc((sizeof(int)) * N);
  Stack *stack = (Stack *) malloc(sizeof(Stack));
  stack->next = 0;
  stack->i = -1;
  for (i = 0; i < N; i++)
  {
    alunos[i].d = 0;
    alunos[i].low = 0;
    stackMember[i] = 0;
  }

  for (i = 0; i < N; i++)
  {
    if (alunos[i].d == 0)
    {
      stack = SCCUtil(i, alunos, stack, stackMember, sccs);
    }
    else
    {
      
    }

  }

  free(stack);
  free(stackMember);
}

void delete(Aluno *alunos, int n, Node *sccs)
{
  int i;
  Node *aux = 0;
  for (i = 0; i < n; i++)
  {
    Amigo *plista = alunos[i].lista;
    while (plista != 0)
    {
      alunos[i].lista = plista->next;
      free(plista);
      plista = alunos[i].lista;
    }

  }

  while (sccs != 0)
  {
    aux = sccs->next;
    free(sccs->scc);
    free(sccs);
    sccs = aux;
  }

  free(alunos);
}

int main()
{
  int N;
  int M;
  int nota;
  int i = 0;
  int a;
  int b;
  Aluno *alunos;
  Node *sccs = (Node *) malloc(sizeof(Node));
  sccs->scc = 0;
  sccs->next = 0;
  N = new_sym_var(sizeof(int) * 8);
  getchar();
  M = new_sym_var(sizeof(int) * 8);
  alunos = (Aluno *) malloc((sizeof(Aluno)) * N);
  while (i < N)
  {
    nota = new_sym_var(sizeof(int) * 8);
    alunos[i]._nota = nota;
    alunos[i].lista = (Amigo *) malloc(sizeof(Amigo));
    alunos[i].lista->amigo = 0;
    alunos[i].lista->next = 0;
    i++;
  }

  for (i = 0; i < M; i++)
  {
    a = new_sym_var(sizeof(int) * 8);
    b = new_sym_var(sizeof(int) * 8);
    amigo(alunos, a, b);
  }

  SCC(alunos, N, sccs);
  dfs(alunos, N);
  for (i = 0; i < N; i++)
  {
    if (alunos[i].scc->nota < alunos[i]._nota)
    {
      alunos[i].scc->nota = alunos[i]._nota;
    }
    else
    {
      
    }

  }

  for (i = 0; i < N; i++)
  {
    if (alunos[i]._nota < alunos[i].scc->nota)
    {
      alunos[i]._nota = alunos[i].scc->nota;
    }
    else
    {
      
    }

  }

  for (i = 0; i < N; i++)
  {
    printf("%d\n", alunos[i]._nota);
  }

  delete(alunos, N, sccs);
  return 0;
}

