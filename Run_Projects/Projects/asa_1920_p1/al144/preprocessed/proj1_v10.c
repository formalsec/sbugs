/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct Edge
{
  int to;
  struct Edge *next;
} edge;
typedef edge *elink;
typedef struct Node
{
  int number;
  struct Node *next;
} node;
typedef node *link;
struct Vertex;
typedef struct SCComp
{
  short colour;
  int max_grade;
  struct Vertex *v;
  struct SCComp *next;
} sccomp;
typedef struct Vertex
{
  int number;
  int grade;
  sccomp *scc;
  int d;
  int low;
  struct Vertex *next;
} vertex;
void initialize_edges(elink *edges, int vertices)
{
  int i;
  for (i = 0; i < vertices; i++)
  {
    *(edges + i) = 0;
  }

  return;
}

void add_edge(elink *edges, elink new_edge, int from)
{
  new_edge->next = *(edges + from);
  *(edges + from) = new_edge;
  return;
}

link new_node(int n)
{
  link new = (link) malloc(sizeof(node));
  new->number = n;
  new->next = 0;
  return new;
}

int is_empty(link root)
{
  if (root == 0)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void push(link *root, int n)
{
  link new;
  new = new_node(n);
  new->next = *root;
  *root = new;
}

int pop(link *root)
{
  link l;
  int pop;
  if (is_empty(*root))
  {
    return -1;
  }
  else
  {
    
  }

  l = *root;
  *root = (*root)->next;
  pop = l->number;
  free(l);
  return pop;
}

int is_element(link root, int n)
{
  link l;
  l = root;
  while (l != 0)
  {
    if (l->number == n)
    {
      return 1;
    }
    else
    {
      
    }

    l = l->next;
  }

  return 0;
}

void free_list(link *L)
{
  link l;
  link temp;
  l = *L;
  if (l == 0)
  {
    free(L);
    return;
  }
  else
  {
    
  }

  while (l != 0)
  {
    temp = l->next;
    free(l);
    l = temp;
  }

  free(L);
  return;
}

int readP1()
{
  int i = 0;
  char c;
  char number[100];
  for (c = getchar(); c != ' '; c = getchar())
  {
    number[i++] = c;
  }

  number[i] = '\0';
  return atoi(number);
}

int readNumber()
{
  int i = 0;
  char c;
  char number[100];
  for (c = getchar(); c != '\n'; c = getchar())
  {
    number[i++] = c;
  }

  number[i] = '\0';
  return atoi(number);
}

void processInput(int *N, int *M)
{
  char c;
  char number[100];
  int i = 0;
  for (c = getchar(); c != ','; c = getchar())
  {
    number[i++] = c;
  }

  number[i] = '\0';
  *N = atoi(number);
  *M = readNumber();
  if (((*N) <= 1) || ((*M) <= 0))
  {
    free(N);
    free(M);
    exit(0);
  }
  else
  {
    
  }

  return;
}

void processGrades(vertex *graph, int *N)
{
  int i;
  for (i = 0; i < (*N); i++)
  {
    (graph + i)->number = i;
    (graph + i)->scc = 0;
    (graph + i)->grade = readNumber();
    (graph + i)->d = -1;
    (graph + i)->next = 0;
  }

  return;
}

void processFriendships(elink *edges, int M)
{
  int p1;
  int p2;
  int i;
  elink e;
  for (i = 0; i < M; i++)
  {
    p1 = readP1() - 1;
    p2 = readNumber() - 1;
    e = (elink) malloc(sizeof(edge));
    e->to = p2;
    e->next = 0;
    add_edge(edges, e, p1);
  }

  return;
}

int min(int a, int b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

int max(int a, int b)
{
  if (a > b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

void tarjan_visit(vertex *u, int *visited, link *L, elink *edges, int N, vertex *graph, sccomp **sccs)
{
  int i;
  vertex *v;
  sccomp *n_scc;
  elink e;
  u->d = *visited;
  u->low = *visited;
  *visited = (*visited) + 1;
  push(L, u->number);
  e = *(edges + u->number);
  while (e != 0)
  {
    v = graph + e->to;
    if (v->d == (-1))
    {
      tarjan_visit(v, visited, L, edges, N, graph, sccs);
      u->low = min(v->low, u->low);
    }
    else
    {
      if (is_element(*L, v->number))
      {
        u->low = min(u->low, v->d);
      }
      else
      {
        
      }

    }

    e = e->next;
  }

  if (u->low == u->d)
  {
    n_scc = (sccomp *) malloc(sizeof(sccomp));
    n_scc->next = *sccs;
    n_scc->v = 0;
    i = (graph + (*L)->number)->grade;
    while ((*L)->number != u->number)
    {
      (graph + (*L)->number)->next = n_scc->v;
      n_scc->v = graph + (*L)->number;
      (graph + (*L)->number)->scc = n_scc;
      i = max(i, (graph + (*L)->number)->grade);
      pop(L);
    }

    (graph + (*L)->number)->next = n_scc->v;
    n_scc->v = graph + (*L)->number;
    (graph + (*L)->number)->scc = n_scc;
    i = max(i, (graph + (*L)->number)->grade);
    pop(L);
    n_scc->max_grade = i;
    n_scc->colour = -1;
    *sccs = n_scc;
  }
  else
  {
    
  }

  return;
}

void scc_tarjan(vertex *graph, int N, elink *edges, sccomp **sccs)
{
  link *L;
  int i;
  int *visited;
  visited = (int *) malloc(sizeof(int));
  *visited = 0;
  L = (link *) malloc(sizeof(link));
  for (i = 0; i < N; i++)
  {
    if ((graph + i)->d == (-1))
    {
      tarjan_visit(graph + i, visited, L, edges, N, graph, sccs);
    }
    else
    {
      
    }

  }

  free_list(L);
  free(visited);
  return;
}

void maxout_visit(elink *edges, sccomp **sccs, sccomp *to_visit, vertex *graph)
{
  elink e;
  vertex *w;
  to_visit->colour = 0;
  w = to_visit->v;
  while (w != 0)
  {
    e = *(edges + w->number);
    while (e != 0)
    {
      if (w->scc != (graph + e->to)->scc)
      {
        if ((graph + e->to)->scc->colour == (-1))
        {
          maxout_visit(edges, sccs, (graph + e->to)->scc, graph);
        }
        else
        {
          
        }

        w->scc->max_grade = max(w->scc->max_grade, (graph + e->to)->scc->max_grade);
      }
      else
      {
        
      }

      e = e->next;
    }

    w = w->next;
  }

  to_visit->colour = 1;
}

void scc_maxout(elink *edges, sccomp **sccs, vertex *graph)
{
  sccomp *scc_tovisit;
  scc_tovisit = *sccs;
  while (scc_tovisit != 0)
  {
    if (scc_tovisit->colour == (-1))
    {
      maxout_visit(edges, sccs, scc_tovisit, graph);
    }
    else
    {
      
    }

    scc_tovisit = scc_tovisit->next;
  }

}

void free_all(vertex *graph, elink *edges, sccomp **sccs, int *M, int *N)
{
  int i;
  elink e;
  elink temp;
  sccomp *scc_temp;
  sccomp *scc_free;
  scc_free = *sccs;
  while (scc_free != 0)
  {
    scc_temp = scc_free->next;
    free(scc_free);
    scc_free = scc_temp;
  }

  free(sccs);
  for (i = 0; i < (*N); i++)
  {
    e = *(edges + i);
    while (e != 0)
    {
      temp = e->next;
      free(e);
      e = temp;
    }

    continue;
  }

  free(edges);
  free(graph);
  free(M);
  free(N);
  return;
}

int main()
{
  int i;
  int *N;
  int *M;
  vertex *v;
  vertex *graph;
  elink *edges;
  sccomp **sccs;
  sccs = 0;
  N = (int *) malloc(sizeof(int));
  M = (int *) malloc(sizeof(int));
  processInput(N, M);
  graph = (vertex *) malloc((sizeof(vertex)) * (*N));
  processGrades(graph, N);
  edges = (elink *) malloc((sizeof(elink)) * (*N));
  initialize_edges(edges, *N);
  processFriendships(edges, *M);
  sccs = (sccomp **) malloc(sizeof(sccomp *));
  *sccs = 0;
  scc_tarjan(graph, *N, edges, sccs);
  scc_maxout(edges, sccs, graph);
  for (i = 0; i < (*N); i++)
  {
    v = graph + i;
    printf("%d\n", v->scc->max_grade);
  }

  free_all(graph, edges, sccs, M, N);
  return 0;
}

