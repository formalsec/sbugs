/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <limits.h>


typedef struct edge
{
  int v;
  int w;
  struct edge *next;
} Edge;
Edge EDGE(int v, int w)
{
  Edge e;
  e.v = v;
  e.w = w;
  return e;
}

typedef struct graph *Graph;
typedef struct node *link;
struct node
{
  int v;
  link next;
};
struct graph
{
  int V;
  int E;
  link *adj;
};
link InsertBegin(int v, link head)
{
  link x = (link) malloc(sizeof(struct node));
  x->v = v;
  x->next = head;
  return x;
}

link new;
link aux2;
link InsertEnd(link head, link tail, int v)
{
  new->v = v;
  new->next = 0;
  aux2 = new;
  if (head == 0)
  {
    return new;
  }
  else
  {
    
  }

  tail->next = new;
  return head;
}

Edge *aux;
Edge *InsertEndEdge(Edge *head, Edge *tail, Edge e)
{
  Edge *new = (Edge *) malloc(sizeof(Edge));
  new->v = e.v;
  new->w = e.w;
  new->next = 0;
  aux = new;
  if (head == 0)
  {
    return new;
  }
  else
  {
    
  }

  tail->next = new;
  return head;
}

Graph G;
Graph GRAPHinit(int V)
{
  int v;
  G = (Graph) malloc(sizeof(struct graph));
  G->V = V;
  G->E = 0;
  G->adj = (link *) malloc(V * (sizeof(link)));
  for (v = 0; v < V; v++)
    G->adj[v] = 0;

  return G;
}

void GRAPHinsertE(Graph G, Edge e)
{
  int v = e.v;
  int w = e.w;
  G->adj[v - 1] = InsertBegin(w, G->adj[v - 1]);
  G->E++;
}

struct stack_node
{
  int value;
  struct stack_node *next;
};
static struct stack_node *top;
void STACKinit()
{
  top = 0;
}

void STACKpush(int value)
{
  struct stack_node *new;
  new = (struct stack_node *) malloc(sizeof(struct stack_node));
  new->value = value;
  new->next = top;
  top = new;
}

int STACKis_empty()
{
  return top == 0;
}

int STACKpop()
{
  int value;
  struct stack_node *old;
  if (!STACKis_empty())
  {
    value = top->value;
    old = top;
    top = top->next;
    free(old);
    return value;
  }
  else
  {
    return -1;
  }

}

struct stack_node *STACKfind_index(int tar)
{
  struct stack_node *t = top;
  int f = 0;
  while (t != 0)
  {
    if (t->value == tar)
    {
      f = 1;
      break;
    }
    else
    {
      
    }

    t = t->next;
  }

  if (f != 0)
  {
    return t;
  }
  else
  {
    return 0;
  }

}

int visited = 0;
int *d;
int *low;
int *est;
int highest_est = INT_MIN;
int scc_counter = 0;
link *scc;
link scc_highest_est;
Edge *bridges;
void Tarjan_Visit(int u)
{
  d[u] = visited;
  low[u] = visited;
  visited += 1;
  STACKpush(u + 1);
  link i;
  for (i = G->adj[u]; i != 0; i = i->next)
  {
    if ((d[i->v - 1] == 32767) || (STACKfind_index(i->v) != 0))
    {
      if (d[i->v - 1] == 32767)
      {
        Tarjan_Visit(i->v - 1);
      }
      else
      {
        
      }

      low[u] = (low[u] < low[i->v - 1]) ? (low[u]) : (low[i->v - 1]);
      if (d[u] < low[i->v - 1])
      {
        bridges = InsertEndEdge(bridges, aux, EDGE(u + 1, i->v));
      }
      else
      {
        
      }

    }
    else
    {
      bridges = InsertEndEdge(bridges, aux, EDGE(u + 1, i->v));
    }

  }

  if (d[u] == low[u])
  {
    int v = STACKpop();
    new = (link) malloc(sizeof(struct node));
    scc[v - 1] = new;
    highest_est = (est[v - 1] > highest_est) ? (est[v - 1]) : (highest_est);
    while ((u + 1) != v)
    {
      v = STACKpop();
      scc[v - 1] = new;
      highest_est = (est[v - 1] > highest_est) ? (est[v - 1]) : (highest_est);
    }

    scc_highest_est = InsertEnd(scc_highest_est, aux2, highest_est);
    scc_counter++;
    highest_est = INT_MIN;
  }
  else
  {
    
  }

}

void SCC_Tarjan(Graph G)
{
  STACKinit();
  int u;
  for (u = 0; u < G->V; u++)
    d[u] = 32767;

  for (u = 0; u < G->V; u++)
    if (d[u] == 32767)
  {
    Tarjan_Visit(u);
  }
  else
  {
    
  }


}

int main()
{
  int N;
  int M;
  do
  {
    N = new_sym_var(sizeof(int) * 8);
    M = new_sym_var(sizeof(int) * 8);
  }
  while ((N < 2) || (M < 1));
  Graph G = GRAPHinit(N);
  est = (int *) malloc(N * (sizeof(int)));
  scc = (link *) malloc(N * (sizeof(link)));
  int i;
  for (i = 0; i < N; i++)
  {
    est[i] = new_sym_var(sizeof(int) * 8);
  }

  int v;
  int w;
  for (i = 0; i < M; i++)
  {
    v = new_sym_var(sizeof(int) * 8);
    w = new_sym_var(sizeof(int) * 8);
    GRAPHinsertE(G, EDGE(v, w));
  }

  d = (int *) malloc(G->V * (sizeof(int)));
  low = (int *) malloc(G->V * (sizeof(int)));
  SCC_Tarjan(G);
  Edge *e;
  for (e = bridges; e != 0; e = e->next)
  {
    scc[e->v - 1]->v = (scc[e->v - 1]->v > scc[e->w - 1]->v) ? (scc[e->v - 1]->v) : (scc[e->w - 1]->v);
  }

  for (i = 0; i < N; i++)
  {
    printf("%d\n", scc[i]->v);
  }

  return 0;
}

