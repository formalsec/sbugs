/*File generated by PreProcessor.py*/


#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct adjListNode_t
{
  struct crossroads_t *from;
  struct crossroads_t *dest;
  struct adjListNode_t *next;
  struct adjListNode_t *originalEdge;
  struct adjListNode_t *reverseEdge;
  bool isItMain;
  int capacity;
  int flow;
} AdjListNode_t;
typedef struct crossroads_t
{
  int index;
  int type;
  bool done;
  AdjListNode_t *head;
  bool revEdge;
  int color;
} Crossroads_t;
typedef struct graph_t
{
  Crossroads_t **vertex;
  int size;
} Graph_t;
typedef struct node_t
{
  Crossroads_t *crossroad;
  struct node_t *next;
} Node_t;
typedef struct list_t
{
  Node_t *head;
  Node_t *last;
} List_t;
void processInput();
int calculateIndex(int avenue, int street);
Crossroads_t *createNewCrossroads(int index, int type);
Graph_t *createGraph(int m, int n);
void addEdge(Graph_t *g, int from, int dest);
void displayMaxFlow(int flow);
void placeInCrossroad(int index, int type);
int edmondsKarpAlgorithm(Graph_t *graph, Crossroads_t *source, Crossroads_t *sink);
void augmentFlowEdge(AdjListNode_t *edge, int flow);
Node_t *newNode();
void printAdjList(Crossroads_t *u);
int numberAvenues;
int numberStreets;
int numberCitizens = 0;
int numberSupermarkets = 0;
int maxFlow = 0;
Graph_t *manhattan;
void processInput()
{
  int i = 0;
  int j = 0;
  int avenue = 0;
  int street = 0;
  int retvalue = 0;
  int index = 0;
  retvalue = 2;
  numberAvenues = new_sym_var(sizeof(int) * 8);
  numberStreets = new_sym_var(sizeof(int) * 8);
  retvalue = 2;
  numberSupermarkets = new_sym_var(sizeof(int) * 8);
  numberCitizens = new_sym_var(sizeof(int) * 8);
  manhattan = createGraph(numberAvenues, numberStreets);
  for (i = 0; i < numberSupermarkets; i++)
  {
    retvalue = 2;
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    index = calculateIndex(avenue, street);
    placeInCrossroad(index, -2);
    addEdge(manhattan, index, manhattan->size - 1);
  }

  for (j = 0; j < numberCitizens; j++)
  {
    retvalue = 2;
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    index = calculateIndex(avenue, street);
    placeInCrossroad(index, -3);
    addEdge(manhattan, 0, index);
  }

  retvalue++;
}

int calculateIndex(int avenue, int street)
{
  avenue--;
  return street + (numberStreets * avenue);
}

Crossroads_t *createNewCrossroads(int index, int type)
{
  Crossroads_t *newCrossroad = (Crossroads_t *) malloc(sizeof(Crossroads_t));
  newCrossroad->index = index;
  newCrossroad->type = type;
  newCrossroad->head = 0;
  newCrossroad->revEdge = false;
  newCrossroad->color = 1;
  newCrossroad->done = false;
  return newCrossroad;
}

void placeInCrossroad(int index, int type)
{
  if (manhattan->vertex[index] != 0)
  {
    manhattan->vertex[index]->type = type;
  }
  else
  {
    
  }

}

void printAdjList(Crossroads_t *u)
{
  AdjListNode_t *aux = 0;
  for (aux = u->head; aux != 0; aux = aux->next)
  {
    printf("dest: %d\n ", aux->dest->index);
    printf("->\n");
  }

}

Graph_t *createGraph(int m, int n)
{
  int i = 1;
  int size = (m * n) + 2;
  Graph_t *manhattan = (Graph_t *) malloc(sizeof(Graph_t));
  manhattan->size = size;
  manhattan->vertex = (Crossroads_t **) malloc((size * (sizeof(Crossroads_t))) + 1);
  Crossroads_t *source = createNewCrossroads(0, -4);
  Crossroads_t *sink = createNewCrossroads(size - 1, -5);
  manhattan->vertex[0] = source;
  manhattan->vertex[size - 1] = sink;
  for (i = 0; i < (size - 1); i++)
  {
    manhattan->vertex[i] = createNewCrossroads(i, -1);
  }

  for (i = 2; i < (size - 1); i++)
  {
    if (((i - 1) % n) == 0)
    {
      i++;
    }
    else
    {
      
    }

    addEdge(manhattan, i, i - 1);
    addEdge(manhattan, i - 1, i);
  }

  for (i = 1; (i + n) < (size - 1); i++)
  {
    addEdge(manhattan, i, i + n);
    addEdge(manhattan, i + n, i);
  }

  return manhattan;
}

void addEdge(Graph_t *g, int from, int dest)
{
  AdjListNode_t *newEdge = (AdjListNode_t *) malloc(sizeof(AdjListNode_t));
  newEdge->from = g->vertex[from];
  newEdge->dest = g->vertex[dest];
  newEdge->next = 0;
  newEdge->capacity = 1;
  newEdge->flow = 0;
  newEdge->isItMain = true;
  newEdge->originalEdge = newEdge;
  newEdge->reverseEdge = 0;
  if (g->vertex[from]->head == 0)
  {
    g->vertex[from]->head = newEdge;
    return;
  }
  else
  {
    
  }

  AdjListNode_t *aux = g->vertex[from]->head;
  while (aux->next != 0)
    aux = aux->next;

  aux->next = newEdge;
}

void addReverseEdge(Graph_t *g, AdjListNode_t *original, int capacity)
{
  AdjListNode_t *newEdge = (AdjListNode_t *) malloc(sizeof(AdjListNode_t));
  newEdge->from = original->dest;
  newEdge->dest = original->from;
  newEdge->next = 0;
  newEdge->capacity = capacity;
  newEdge->flow = 0;
  newEdge->isItMain = false;
  newEdge->originalEdge = original;
  newEdge->reverseEdge = 0;
  original->reverseEdge = newEdge;
  int index = original->dest->index;
  if (!g->vertex[index]->revEdge)
  {
    g->vertex[index]->revEdge = true;
    return;
  }
  else
  {
    
  }

}

List_t *newList()
{
  List_t *l = (List_t *) malloc(sizeof(List_t));
  l->head = 0;
  l->last = 0;
  return l;
}

Node_t *newNode()
{
  Node_t *l = (Node_t *) malloc(sizeof(Node_t));
  l->next = 0;
  l->crossroad = 0;
  return l;
}

void printlist(Node_t *u)
{
  Node_t *aux = 0;
  for (aux = u; aux != 0; aux = aux->next)
  {
    printf("dest: %d\n", aux->crossroad->index);
  }

}

List_t *pushFirst(List_t *l, Crossroads_t *c)
{
  Node_t *node = newNode();
  Node_t *aux = l->last;
  node->crossroad = c;
  node->next = 0;
  if ((l->head == 0) && (l->last == 0))
  {
    l->head = node;
    l->last = 0;
    l->head->next = l->last;
    return l;
  }
  else
  {
    if ((l->head != 0) && (l->last == 0))
    {
      l->last = node;
      l->head->next = l->last;
      return l;
    }
    else
    {
      if ((aux != 0) && (aux->next == 0))
      {
        aux->next = node;
        l->last = aux->next;
        return l;
      }
      else
      {
        
      }

    }

  }

  return 0;
}

Crossroads_t *popLast(List_t *l)
{
  Node_t *aux = l->head;
  if (aux != 0)
  {
    l->head = l->head->next;
    aux->next = 0;
    Crossroads_t *c = aux->crossroad;
    aux->crossroad = 0;
    return c;
  }
  else
  {
    
  }

  return 0;
}

int min(int a, int b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

void augmentFlowEdge(AdjListNode_t *edge, int flow)
{
  if (edge->isItMain)
  {
    edge->flow += flow;
  }
  else
  {
    edge->originalEdge->flow -= flow;
  }

}

int residualCap(AdjListNode_t *edge)
{
  int residualCap = 0;
  residualCap = edge->capacity - edge->flow;
  return residualCap;
}

int bfs(Crossroads_t *start, AdjListNode_t **parents)
{
  int i = 0;
  int flow = 1;
  int vIx = 0;
  int startIx = 0;
  List_t *queue = newList();
  List_t *nonWhites = newList();
  Node_t *aux = 0;
  AdjListNode_t *v = 0;
  Crossroads_t *u = 0;
  parents[startIx] = 0;
  for (i = 0; i < manhattan->size; i++)
  {
    parents[i] = 0;
  }

  start->color = 2;
  start->done = false;
  manhattan->vertex[manhattan->size - 1]->done = false;
  nonWhites = pushFirst(nonWhites, start);
  queue = pushFirst(queue, start);
  while (queue->head != 0)
  {
    u = popLast(queue);
    for (v = u->head; v != 0; v = v->next)
    {
      if ((((v->dest->color == 1) && (residualCap(v) > 0)) && (v->from->type != (-5))) && (!v->dest->done))
      {
        vIx = v->dest->index;
        v->dest->color = 2;
        parents[vIx] = v;
        flow = residualCap(v);
        queue = pushFirst(queue, v->dest);
        nonWhites = pushFirst(nonWhites, v->dest);
      }
      else
      {
        
      }

      if (((v->reverseEdge != 0) && (v->reverseEdge->dest->color == 1)) && (!v->dest->done))
      {
        vIx = v->reverseEdge->from->index;
        v->reverseEdge->from->color = 2;
        parents[vIx] = v->reverseEdge;
        flow = residualCap(v->reverseEdge);
        queue = pushFirst(queue, v->reverseEdge->from);
        nonWhites = pushFirst(nonWhites, v->reverseEdge->from);
      }
      else
      {
        
      }

      if (v->dest->type == (-5))
      {
        parents[manhattan->size - 1] = v;
        for (aux = nonWhites->head; aux->next != 0; aux = aux->next)
        {
          aux->crossroad->color = 1;
        }

        return flow;
      }
      else
      {
        
      }

      u->color = 3;
    }

  }

  return 0;
}

int edmondsKarpAlgorithm(Graph_t *graph, Crossroads_t *source, Crossroads_t *sink)
{
  int moreFlow = -1;
  int current = 0;
  int i = 0;
  AdjListNode_t **parents = (AdjListNode_t **) malloc(manhattan->size * (sizeof(AdjListNode_t *)));
  AdjListNode_t *previous = 0;
  for (i = 0; i < manhattan->size; i++)
  {
    parents[i] = 0;
  }

  while (moreFlow != 0)
  {
    moreFlow = bfs(source, parents);
    if (!moreFlow)
    {
      break;
    }
    else
    {
      
    }

    maxFlow += moreFlow;
    current = manhattan->size - 1;
    while (current > 0)
    {
      previous = parents[current];
      if (previous != 0)
      {
        if (previous->isItMain && (previous->reverseEdge == 0))
        {
          addReverseEdge(manhattan, previous, moreFlow);
        }
        else
        {
          
        }

        augmentFlowEdge(previous, moreFlow);
        if (previous->dest->type == (-3))
        {
          previous->dest->done = true;
        }
        else
        {
          
        }

        current = previous->from->index;
      }
      else
      {
        
      }

    }

  }

  return maxFlow;
}

void displayMaxFlow(int flow)
{
  printf("%d\n", flow);
}

int main()
{
  processInput();
  displayMaxFlow(edmondsKarpAlgorithm(manhattan, manhattan->vertex[0], manhattan->vertex[manhattan->size - 1]));
  return 0;
}

