/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void initializegraph(int vertices, int M);
void addtarget(int x, int y, int M, int vertices);
void addsource(int x, int y, int M, int vertices);
int EdmondsKarp(int start, int end, int vertices);
void addReverseEdge(int current, int previous);
void deleteEdge(int previous, int current);
typedef struct V
{
  int index;
  struct V *next;
} V;
typedef struct 
{
  V *head;
  int parents;
  int visited;
} Graph;
Graph *graph;
struct Node
{
  int data;
  struct Node *next;
};
typedef struct Queue
{
  struct Node *front;
  struct Node *last;
  unsigned int size;
} Queue;
void initQueue(Queue *q);
int pop(Queue *q);
void push(Queue *q, int data);
int BFS(int start, int end, int vertices);
int not_in_list(int index, int v);
int main()
{
  int M;
  int N;
  int S;
  int C;
  int x;
  int y;
  int i;
  int z;
  z = 2;
  M = new_sym_var(sizeof(int) * 8);
  N = new_sym_var(sizeof(int) * 8);
  z = 2;
  S = new_sym_var(sizeof(int) * 8);
  C = new_sym_var(sizeof(int) * 8);
  int nvertices = M * N;
  graph = malloc((sizeof(Graph)) * ((nvertices * 2) + 2));
  int total = (nvertices * 2) + 2;
  initializegraph(nvertices * 2, M);
  for (i = 0; i < S; i++)
  {
    z = 2;
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    addtarget(x, y, M, nvertices * 2);
  }

  for (i = 0; i < C; i++)
  {
    z = 2;
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    addsource(x, y, M, nvertices * 2);
  }

  int maxflow = EdmondsKarp(nvertices * 2, (nvertices * 2) + 1, total);
  printf("%d\n", maxflow);
  for (i = 0; i < ((nvertices * 2) + 2); i++)
  {
    V *iter;
    while (graph[i].head != 0)
    {
      iter = graph[i].head;
      graph[i].head = graph[i].head->next;
      free(iter);
    }

  }

  free(graph);
  if (z == (-1))
  {
    return -1;
  }
  else
  {
    
  }

  return 0;
}

void initializegraph(int vertices, int M)
{
  int i = 0;
  int j;
  for (i = 0; i < (vertices + 2); i++)
  {
    graph[i].head = 0;
    graph[i].parents = -1;
    graph[i].visited = 0;
  }

  j = 0;
  while (j < vertices)
  {
    for (i = 0; i < ((M * 2) - 1); i++)
    {
      V *adj = malloc(sizeof(V));
      adj->index = (j + i) + 1;
      adj->next = graph[j + i].head;
      graph[j + i].head = adj;
    }

    j = j + (M * 2);
  }

  j = (2 * M) - 1;
  while (j < vertices)
  {
    for (i = 0; i < ((M - 1) * 2); i = i + 2)
    {
      V *adj = malloc(sizeof(V));
      adj->index = (j - i) - 3;
      adj->next = graph[j - i].head;
      graph[j - i].head = adj;
    }

    j = j + (M * 2);
  }

  j = M * 2;
  while (j < vertices)
  {
    for (i = 1; i < (M * 2); i = i + 2)
    {
      V *adj = malloc(sizeof(V));
      adj->index = ((j + i) - (M * 2)) - 1;
      adj->next = graph[j + i].head;
      graph[j + i].head = adj;
    }

    j = j + (M * 2);
  }

  j = 0;
  while (j < (vertices - (M * 2)))
  {
    for (i = 1; i < (M * 2); i = i + 2)
    {
      V *adj = malloc(sizeof(V));
      adj->index = ((j + i) + (M * 2)) - 1;
      adj->next = graph[j + i].head;
      graph[j + i].head = adj;
    }

    j = j + (M * 2);
  }

}

void addtarget(int x, int y, int M, int vertices)
{
  int index = ((y - 1) * M) + (x - 1);
  index = (index * 2) + 1;
  if (not_in_list(index, vertices + 1))
  {
    V *target = malloc(sizeof(V));
    target->index = vertices + 1;
    target->next = graph[index].head;
    graph[index].head = target;
  }
  else
  {
    
  }

}

int not_in_list(int index, int v)
{
  V *iter;
  iter = graph[index].head;
  while ((iter != 0) && (iter->index != v))
  {
    iter = iter->next;
  }

  if (iter == 0)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void addsource(int x, int y, int M, int vertices)
{
  int index = ((y - 1) * M) + (x - 1);
  if (not_in_list(vertices, index * 2))
  {
    V *adj = malloc(sizeof(V));
    adj->index = index * 2;
    adj->next = graph[vertices].head;
    graph[vertices].head = adj;
  }
  else
  {
    
  }

}

void initQueue(Queue *q)
{
  q->front = 0;
  q->last = 0;
  q->size = 0;
}

int pop(Queue *q)
{
  int value = -1;
  if (q->size > 0)
  {
    q->size--;
    struct Node *tmp = q->front;
    q->front = q->front->next;
    value = tmp->data;
    free(tmp);
  }
  else
  {
    
  }

  return value;
}

void push(Queue *q, int data)
{
  q->size++;
  if (q->front == 0)
  {
    q->front = (struct Node *) malloc(sizeof(struct Node));
    q->front->data = data;
    q->front->next = 0;
    q->last = q->front;
  }
  else
  {
    q->last->next = (struct Node *) malloc(sizeof(struct Node));
    q->last->next->data = data;
    q->last->next->next = 0;
    q->last = q->last->next;
  }

}

int BFS(int start, int end, int vertices)
{
  int i;
  for (i = 0; i < vertices; i++)
  {
    graph[i].visited = 0;
  }

  Queue *q = malloc(sizeof(Queue));
  initQueue(q);
  push(q, start);
  graph[start].parents = -1;
  graph[start].visited = 1;
  while (q->size > 0)
  {
    int currentNode = pop(q);
    V *node = graph[currentNode].head;
    while (node != 0)
    {
      int to = node->index;
      if (graph[to].visited != 1)
      {
        graph[to].parents = currentNode;
        graph[to].visited = 1;
        if (to == end)
        {
          graph[to].visited = 1;
          while (q->size > 0)
            pop(q);

          free(q);
          return 1;
        }
        else
        {
          
        }

        push(q, to);
      }
      else
      {
        
      }

      node = node->next;
    }

  }

  free(q);
  return 0;
}

int EdmondsKarp(int start, int end, int vertices)
{
  int maxflow = 0;
  int i;
  for (i = 0; i < vertices; i++)
  {
    graph[i].parents = -1;
  }

  while (BFS(start, end, vertices))
  {
    int flow = 999;
    int previousNode;
    int currentNode = end;
    while (currentNode != start)
    {
      previousNode = graph[currentNode].parents;
      flow = (flow < 1) ? (flow) : (1);
      currentNode = previousNode;
    }

    currentNode = end;
    while (currentNode != start)
    {
      previousNode = graph[currentNode].parents;
      addReverseEdge(currentNode, previousNode);
      deleteEdge(previousNode, currentNode);
      currentNode = previousNode;
    }

    maxflow += flow;
  }

  return maxflow;
}

void addReverseEdge(int current, int previous)
{
  V *new = malloc(sizeof(V));
  new->index = previous;
  new->next = graph[current].head;
  graph[current].head = new;
}

void deleteEdge(int previous, int current)
{
  V *iter;
  V *prev;
  iter = graph[previous].head;
  prev = graph[previous].head;
  if ((iter != 0) && (iter->index == current))
  {
    graph[previous].head = graph[previous].head->next;
    free(iter);
    return;
  }
  else
  {
    
  }

  while ((iter != 0) && (iter->index != current))
  {
    prev = iter;
    iter = iter->next;
  }

  if (iter == 0)
  {
    return;
  }
  else
  {
    
  }

  prev->next = iter->next;
  free(iter);
}

