/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct 
{
  int x;
  int y;
  int prev;
} Node;
Node *previous;
int M = 1;
int N = 1;
int S = 1;
int C = 1;
int move_count = 0;
int front = -1;
int rear = -1;
int nodes_left_in_layer = 1;
int nodes_in_next_layer = 0;
int p_aux = 0;
int reached_end = 0;
static int dr[4] = {-1, 1, 0, 0};
static int dc[4] = {0, 0, 1, -1};
void pg(int grid[M + 1][N + 1]);
void inicialize_sc(int grid[M + 1][N + 1], int supers[S][3], int cidadaos[C][2], int cid_sup[C][3]);
void inicialize_bfs(int state[M + 1][N + 1], int rq[M * N], int cq[M * N]);
void enqueue(int rq[M * N], int cq[M * N], int r, int c);
int dequeue(int queue[M * N]);
int queue_empty();
void explore_neighbours(int r_aux, int c_aux, int grid[M + 1][N + 1], int rq[M * N], int cq[M * N], int state[M + 1][N + 1]);
int bfs(int sr, int sc, int fr, int fc, int grid[M + 1][N + 1], int rq[M * N], int cq[M * N], int state[M + 1][N + 1]);
void solve(int supers[S + 1][3], int cidadaos[C + 1][2], int cid_sup[C + 1][3], int grid[M + 1][N + 1], int rq[M * N], int cq[M * N], int state[M + 1][N + 1]);
void distances(int supers[S + 1][3], int cidadaos[C + 1][2], int cid_sup[C + 1][3]);
void distances_aux(int i, int supers[S + 1][3], int cidadaos[C][2], int cid_sup[C + 1][3]);
void distances_clean(int i, int e, int cid_sup[C + 1][3]);
int main()
{
  int k = 0;
  int i = 0;
  char y;
  char input[100];
  char s_aux[100];
  while (((y = getchar()) != '\n') && (y != EOF))
  {
    input[k] = y;
    k++;
  }

  input[k] = '\0';
  k = 0;
  while (input[i] != ' ')
  {
    s_aux[i] = input[i];
    i++;
  }

  s_aux[i] = '\0';
  M = atoi(s_aux);
  memset(s_aux, '\0', sizeof(s_aux));
  i++;
  while (input[i] != '\0')
  {
    s_aux[k] = input[i];
    i++;
    k++;
  }

  s_aux[k] = '\0';
  N = atoi(s_aux);
  memset(s_aux, '\0', sizeof(s_aux));
  if (2)
  {
    S = new_sym_var(sizeof(int) * 8);
    C = new_sym_var(sizeof(int) * 8);
    i++;
  }
  else
  {
    
  }

  int grid[M + 1][N + 1];
  int supers[S + 1][3];
  int cidadaos[C + 1][2];
  int cid_sup[C + 1][3];
  int rq[M * N];
  int cq[M * N];
  int state[M + 1][N + 1];
  inicialize_sc(grid, supers, cidadaos, cid_sup);
  for (i = 0; i < S; i++)
  {
    if (2)
    {
      supers[i][0] = new_sym_var(sizeof(int) * 8);
      supers[i][1] = new_sym_var(sizeof(int) * 8);
      supers[i][2] = 100;
      grid[supers[i][0]][supers[i][1]] = 6;
    }
    else
    {
      
    }

  }

  for (i = 0; i < C; i++)
  {
    if (2)
    {
      cidadaos[i][0] = new_sym_var(sizeof(int) * 8);
      cidadaos[i][1] = new_sym_var(sizeof(int) * 8);
      cid_sup[i][0] = -1;
      cid_sup[i][1] = -1;
      cid_sup[i][2] = 0;
      grid[cidadaos[i][0]][cidadaos[i][1]] = 6;
    }
    else
    {
      
    }

  }

  distances(supers, cidadaos, cid_sup);
  solve(supers, cidadaos, cid_sup, grid, rq, cq, state);
  return 0;
}

void inicialize_sc(int grid[M + 1][N + 1], int supers[S][3], int cidadaos[C][2], int cid_sup[C][3])
{
  int i;
  int e = 1;
  for (i = 0; i <= (M + 1); i++)
  {
    for (e = 0; e <= (N + 1); e++)
    {
      grid[i][e] = 0;
    }

  }

  for (i = 0; i < S; i++)
  {
    supers[i][0] = 0;
    supers[i][1] = 0;
    supers[i][2] = 100;
  }

  for (i = 0; i < C; i++)
  {
    cidadaos[i][0] = 0;
    cidadaos[i][1] = 0;
  }

}

void inicialize_bfs(int state[M + 1][N + 1], int rq[M * N], int cq[M * N])
{
  int i;
  int e = 1;
  for (i = 0; i <= (M + 1); i++)
  {
    for (e = 0; e <= (N + 1); e++)
    {
      state[i][e] = 1;
    }

  }

  for (i = 0; i < (M * N); i++)
  {
    rq[i] = 0;
    cq[i] = 0;
  }

}

void pg(int grid[M + 1][N + 1])
{
  int i;
  int e = 0;
  for (i = 1; i <= M; i++)
  {
    for (e = 1; e <= N; e++)
    {
      printf("%d ", grid[i][e]);
    }

    printf("\n");
  }

}

void enqueue(int rq[M * N], int cq[M * N], int r, int c)
{
  if (front == (-1))
  {
    front = 0;
  }
  else
  {
    
  }

  rear = rear + 1;
  rq[rear] = r;
  cq[rear] = c;
}

int dequeue(int queue[M * N])
{
  int aux = 1;
  if (front == (-1))
  {
    exit(1);
  }
  else
  {
    
  }

  p_aux = front;
  aux = queue[front];
  return aux;
}

int queue_empty()
{
  if ((front == (-1)) || (front > rear))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int bfs(int sr, int sc, int fr, int fc, int grid[M + 1][N + 1], int rq[M * N], int cq[M * N], int state[M + 1][N + 1])
{
  int r_aux;
  int c_aux = 0;
  nodes_left_in_layer = 1;
  nodes_in_next_layer = 0;
  grid[sr][sc] = 4;
  grid[fr][fc] = 5;
  previous = malloc(((sizeof(Node)) * M) * N);
  enqueue(rq, cq, sr, sc);
  state[sr][sc] = 2;
  previous[0].x = sr;
  previous[0].y = sc;
  previous[0].prev = 0;
  while (!queue_empty())
  {
    r_aux = dequeue(rq);
    c_aux = dequeue(cq);
    state[r_aux][c_aux] = 3;
    front = front + 1;
    if (grid[r_aux][c_aux] == 5)
    {
      reached_end = 1;
      break;
    }
    else
    {
      
    }

    explore_neighbours(r_aux, c_aux, grid, rq, cq, state);
    nodes_left_in_layer--;
    if (nodes_left_in_layer == 0)
    {
      nodes_left_in_layer = nodes_in_next_layer;
      nodes_in_next_layer = 0;
      move_count++;
    }
    else
    {
      
    }

  }

  while (p_aux != 0)
  {
    r_aux = previous[p_aux].prev;
    p_aux = r_aux;
    grid[previous[p_aux].x][previous[p_aux].y] = 6;
  }

  free(previous);
  if (reached_end == 1)
  {
    return move_count;
  }
  else
  {
    return -1;
  }

}

void explore_neighbours(int r_aux, int c_aux, int grid[M + 1][N + 1], int rq[M * N], int cq[M * N], int state[M + 1][N + 1])
{
  int i;
  int rr;
  int cc = 1;
  for (i = 0; i < 4; i++)
  {
    rr = r_aux + dr[i];
    cc = c_aux + dc[i];
    if ((((rr > 0) && (cc > 0)) && (rr <= M)) && (cc <= N))
    {
      if ((grid[rr][cc] != 6) && (state[rr][cc] == 1))
      {
        enqueue(rq, cq, rr, cc);
        state[rr][cc] = 2;
        nodes_in_next_layer++;
        previous[rear].x = rr;
        previous[rear].y = cc;
        previous[rear].prev = p_aux;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

}

void solve(int supers[S][3], int cidadaos[C][2], int cid_sup[C][3], int grid[M + 1][N + 1], int rq[M * N], int cq[M * N], int state[M + 1][N + 1])
{
  int output = 0;
  int track = 0;
  int sr = 1;
  int sc = 1;
  int fr = 2;
  int fc = 2;
  int i;
  int c_aux;
  int s_aux = 0;
  for (i = 0; i < C; i++)
  {
    c_aux = cid_sup[i][0];
    sr = cidadaos[c_aux][0];
    sc = cidadaos[c_aux][1];
    s_aux = cid_sup[i][1];
    fr = supers[s_aux][0];
    fc = supers[s_aux][1];
    inicialize_bfs(state, rq, cq);
    track = bfs(sr, sc, fr, fc, grid, rq, cq, state);
    if (track > (-1))
    {
      output++;
    }
    else
    {
      
    }

  }

  printf("%d\n", output);
}

void distances(int supers[S + 1][3], int cidadaos[C + 1][2], int cid_sup[C + 1][3])
{
  int i;
  int e;
  int c1;
  int c2;
  int s1;
  int s2;
  int d;
  int d_aux;
  int s_aux = 0;
  for (i = 0; i < C; i++)
  {
    d = 1000;
    c1 = cidadaos[i][0];
    c2 = cidadaos[i][1];
    for (e = 0; e < S; e++)
    {
      s1 = supers[e][0];
      s2 = supers[e][1];
      d_aux = abs(c1 - s1) + abs(c2 - s2);
      if (d_aux < d)
      {
        s_aux = supers[e][2];
        if ((d_aux < cid_sup[s_aux][2]) || (cid_sup[s_aux][2] == 0))
        {
          d = d_aux;
          cid_sup[i][0] = i;
          cid_sup[i][1] = e;
          cid_sup[i][2] = d;
          supers[e][2] = i;
          if ((s_aux != 100) && (s_aux != i))
          {
            distances_clean(i, e, cid_sup);
            distances_aux(s_aux, supers, cidadaos, cid_sup);
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

}

void distances_clean(int i, int e, int cid_sup[C + 1][3])
{
  int z = 0;
  for (z = 0; z < C; z++)
  {
    if ((cid_sup[z][1] == e) && (z != i))
    {
      cid_sup[z][1] = -1;
      cid_sup[z][2] = 0;
    }
    else
    {
      
    }

  }

}

void distances_aux(int i, int supers[S + 1][3], int cidadaos[C + 1][2], int cid_sup[C + 1][3])
{
  int e;
  int s1;
  int s2;
  int d_aux;
  int s_aux = 0;
  int d = 1000;
  int c1 = cidadaos[i][0];
  int c2 = cidadaos[i][1];
  for (e = 0; e < S; e++)
  {
    s1 = supers[e][0];
    s2 = supers[e][1];
    d_aux = abs(c1 - s1) + abs(c2 - s2);
    if (d_aux < d)
    {
      s_aux = supers[e][2];
      if ((d_aux < cid_sup[s_aux][2]) || (cid_sup[s_aux][2] == 0))
      {
        d = d_aux;
        cid_sup[i][0] = i;
        cid_sup[i][1] = e;
        cid_sup[i][2] = d;
        supers[e][2] = i;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

}

