/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include <stdbool.h>


struct node
{
  int w;
  struct node *next;
};
typedef struct node *link;
struct edge
{
  int from;
  int to;
  int capacity;
  bool hasReverse;
  struct edge *next;
};
typedef struct edge Edge;
struct adjList
{
  Edge *head;
};
typedef struct adjList AdjList;
struct graph
{
  int V;
  int E;
  AdjList *adj;
};
typedef struct graph *Graph;
struct queue
{
  link head;
  link tail;
};
typedef struct queue *Queue;
int vertices;
int source;
int sink;
int avenues;
int streets;
int markets;
int citizens;
int increment;
int maxFlow = 0;
int *currentC;
int *prev;
Graph G;
Queue queue;
int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

link newNode(int v)
{
  link a = malloc(sizeof(struct node));
  a->w = v;
  a->next = 0;
  return a;
}

void newEdge(Graph graph, int v, int w, int weight, bool hasReverse)
{
  Edge *new = malloc(sizeof(struct edge));
  new->from = v;
  new->to = w;
  new->capacity = weight;
  new->hasReverse = hasReverse;
  new->next = graph->adj[v].head;
  graph->adj[v].head = new;
  graph->E++;
}

int intFromCoordinates(int x, int y, bool inc)
{
  if (inc)
  {
    return (((y - 1) * avenues) + (x - 1)) + increment;
  }
  else
  {
    
  }

  return ((y - 1) * avenues) + (x - 1);
}

Graph initGraph()
{
  int i;
  int j;
  int k;
  int v_in;
  int v_out;
  int da[4] = {0, 0, 1, -1};
  int ds[4] = {-1, 1, 0, 0};
  Graph G = malloc(sizeof(struct graph));
  G->V = avenues * streets;
  G->E = 0;
  G->adj = malloc((((avenues * streets) * 2) + 2) * (sizeof(AdjList)));
  for (i = 0; i < (avenues * streets); i++)
    G->adj[i].head = 0;

  for (i = 1; i <= avenues; i++)
  {
    for (j = 1; j <= streets; j++)
    {
      v_in = intFromCoordinates(i, j, false);
      v_out = intFromCoordinates(i, j, true);
      G->adj[v_out].head = 0;
      newEdge(G, v_in, v_out, 1, false);
      for (k = 0; k < 4; k++)
      {
        int aa = i + da[k];
        int ss = j + ds[k];
        if ((((ss >= 1) && (aa >= 1)) && (ss <= streets)) && (aa <= avenues))
        {
          newEdge(G, v_out, intFromCoordinates(aa, ss, false), 1, false);
        }
        else
        {
          
        }

      }

    }

  }

  G->adj[source].head = 0;
  G->adj[sink].head = 0;
  return G;
}

Queue createQueue()
{
  Queue s = (Queue) malloc(sizeof(struct queue));
  s->head = (s->tail = 0);
  return s;
}

int emptyQueue()
{
  if (queue->head == 0)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void pop()
{
  if (queue->head == 0)
  {
    return;
  }
  else
  {
    
  }

  link temp = queue->head;
  queue->head = queue->head->next;
  if (queue->head == 0)
  {
    queue->tail = 0;
  }
  else
  {
    
  }

  free(temp);
}

void push(int v)
{
  link temp = newNode(v);
  if (queue->tail == 0)
  {
    queue->head = (queue->tail = temp);
    return;
  }
  else
  {
    
  }

  queue->tail->next = temp;
  queue->tail = temp;
}

int bfs(int start, int end)
{
  Edge *a;
  memset(prev, -1, vertices * (sizeof(int)));
  memset(currentC, 0, vertices * (sizeof(int)));
  push(start);
  prev[start] = -2;
  currentC[start] = 999;
  while (emptyQueue() == 0)
  {
    int u = queue->head->w;
    pop();
    for (a = G->adj[u].head; a != 0; a = a->next)
    {
      if (prev[a->to] == (-1))
      {
        if (a->capacity > 0)
        {
          prev[a->to] = u;
          currentC[a->to] = min(currentC[u], a->capacity);
          if (a->to == end)
          {
            while (emptyQueue() == 0)
            {
              pop();
            }

            return currentC[end];
          }
          else
          {
            
          }

          push(a->to);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  return 0;
}

void treatPath(int start, int end, int flow)
{
  Edge *a;
  int current = end;
  while (current != start)
  {
    int previous = prev[current];
    for (a = G->adj[previous].head; a != 0; a = a->next)
    {
      if (a->to == current)
      {
        a->capacity -= flow;
        break;
      }
      else
      {
        
      }

    }

    if (a->hasReverse)
    {
      for (a = G->adj[current].head; a != 0; a = a->next)
      {
        if (a->to == previous)
        {
          a->capacity += flow;
          break;
        }
        else
        {
          
        }

      }

    }
    else
    {
      a->hasReverse = true;
      newEdge(G, a->to, a->from, 1, true);
    }

    current = previous;
  }

}

void edmondsKarp()
{
  while (true)
  {
    int flow = 0;
    flow = bfs(source, sink);
    if (flow == 0)
    {
      break;
    }
    else
    {
      
    }

    maxFlow += flow;
    if (maxFlow == min(citizens, markets))
    {
      break;
    }
    else
    {
      
    }

    treatPath(source, sink, flow);
  }

}

int main()
{
  int i = 0;
  int x;
  int y;
  avenues = new_sym_var(sizeof(int) * 8);
  streets = new_sym_var(sizeof(int) * 8);
  markets = new_sym_var(sizeof(int) * 8);
  citizens = new_sym_var(sizeof(int) * 8);
  increment = avenues * streets;
  source = (2 * avenues) * streets;
  sink = ((2 * avenues) * streets) + 1;
  vertices = ((2 * avenues) * streets) + 2;
  G = initGraph();
  queue = createQueue();
  prev = (int *) malloc(vertices * (sizeof(int)));
  currentC = (int *) malloc(vertices * (sizeof(int)));
  for (i = 0; i < markets; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    newEdge(G, intFromCoordinates(x, y, true), sink, 1, false);
  }

  for (i = 0; i < citizens; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    newEdge(G, source, intFromCoordinates(x, y, false), 1, false);
  }

  edmondsKarp();
  printf("%d\n", maxFlow);
  free(G);
  free(queue);
  free(prev);
  free(currentC);
  return 0;
}

