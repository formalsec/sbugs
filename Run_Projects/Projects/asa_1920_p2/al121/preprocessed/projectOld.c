/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>


typedef struct 
{
  int neighbors[6];
  int visitedIteration;
} Node;
typedef struct 
{
  int *neighbors;
} Source;
typedef struct 
{
  Node *nodes;
  int size;
} AdjacenciesList;
enum Direction
{
  SINK = 0,
  BROTHER,
  UP,
  DOWN,
  LEFT,
  RIGHT
};
AdjacenciesList list;
Source source;
int amountCrossings;
int inverted;
int amountAvenues;
int amountStreets;
int amountMarkets;
int amountPeople;
int sinkID;
int getBrotherID(int id)
{
  return id + amountCrossings;
}

int getNodeID(int avenue, int street)
{
  return (avenue * amountStreets) + street;
}

void insertAdjacency(int nodeID, int adjacencyID, int direction)
{
  list.nodes[nodeID].neighbors[direction] = adjacencyID;
}

void printList()
{
  int i;
  int j;
  for (i = 0; i < list.size; i++)
  {
    printf("Node number %d's neighbors are: ", i);
    for (j = 0; j < 6; j++)
    {
      if (list.nodes[i].neighbors[j] != (-1))
      {
        printf("%d, ", list.nodes[i].neighbors[j]);
      }
      else
      {
        
      }

    }

    printf("\n");
  }

  printf("The source is connected to: ");
  for (i = 0; i < amountPeople; i++)
  {
    printf("%d, ", source.neighbors[i]);
  }

  printf("\n");
}

int main()
{
  int i;
  int j;
  int aux;
  int iteration = 0;
  int index;
  int brotherIndex;
  int avenue;
  int street;
  int flow = 0;
  int pathI;
  int reverseDirection;
  int flowUpperBound;
  int direction;
  int *currentPathIDs;
  int *neighborVisitDirection;
  int directions[] = {UP, DOWN, LEFT, RIGHT};
  amountAvenues = new_sym_var(sizeof(int) * 8);
  amountStreets = new_sym_var(sizeof(int) * 8);
  amountMarkets = new_sym_var(sizeof(int) * 8);
  amountPeople = new_sym_var(sizeof(int) * 8);
  amountCrossings = amountAvenues * amountStreets;
  if (amountPeople > amountMarkets)
  {
    inverted = 1;
  }
  else
  {
    inverted = 0;
  }

  flowUpperBound = (inverted) ? (amountPeople) : (amountMarkets);
  list.size = (amountCrossings * 2) + 1;
  sinkID = list.size - 1;
  list.nodes = (Node *) malloc((sizeof(Node)) * list.size);
  for (i = 0; i < list.size; i++)
  {
    for (j = 0; j < 6; j++)
    {
      insertAdjacency(i, -1, j);
    }

    list.nodes[i].visitedIteration = -1;
  }

  for (i = 0; i < amountAvenues; i++)
  {
    for (j = 0; j < amountStreets; j++)
    {
      index = getNodeID(i, j);
      brotherIndex = getBrotherID(index);
      insertAdjacency(index, brotherIndex, BROTHER);
      if (i != 0)
      {
        insertAdjacency(brotherIndex, index - amountStreets, UP);
      }
      else
      {
        
      }

      if (j != 0)
      {
        insertAdjacency(brotherIndex, index - 1, LEFT);
      }
      else
      {
        
      }

      if (i != (amountAvenues - 1))
      {
        insertAdjacency(brotherIndex, index + amountStreets, DOWN);
      }
      else
      {
        
      }

      if (j != (amountStreets - 1))
      {
        insertAdjacency(brotherIndex, index + 1, RIGHT);
      }
      else
      {
        
      }

    }

  }

  source.neighbors = (int *) malloc((sizeof(int)) * ((inverted) ? (amountMarkets) : (amountPeople)));
  for (i = 0; i < amountMarkets; i++)
  {
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    avenue--;
    street--;
    index = getNodeID(avenue, street);
    if (inverted)
    {
      source.neighbors[i] = index;
    }
    else
    {
      brotherIndex = getBrotherID(index);
      if (list.nodes[brotherIndex].neighbors[SINK] != (-1))
      {
        flowUpperBound--;
      }
      else
      {
        list.nodes[brotherIndex].neighbors[SINK] = sinkID;
      }

    }

  }

  for (i = 0; i < amountPeople; i++)
  {
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    avenue--;
    street--;
    index = getNodeID(avenue, street);
    if (!inverted)
    {
      source.neighbors[i] = index;
    }
    else
    {
      brotherIndex = getBrotherID(index);
      if (list.nodes[brotherIndex].neighbors[SINK] != (-1))
      {
        flowUpperBound--;
      }
      else
      {
        list.nodes[brotherIndex].neighbors[SINK] = sinkID;
      }

    }

  }

  currentPathIDs = (int *) malloc((sizeof(int)) * list.size);
  neighborVisitDirection = (int *) malloc((sizeof(int)) * list.size);
  for (i = 0; i < ((inverted) ? (amountMarkets) : (amountPeople)); i++)
  {
    index = source.neighbors[i];
    pathI = 0;
    if (flow >= flowUpperBound)
    {
      break;
    }
    else
    {
      
    }

    while (1)
    {
      currentPathIDs[pathI] = index;
      list.nodes[index].visitedIteration = iteration;
      aux = -1;
      for (j = 0; j < 6; j++)
      {
        aux = list.nodes[index].neighbors[j];
        if (j < 2)
        {
          direction = j;
        }
        else
        {
          direction = directions[j - 2];
        }

        aux = list.nodes[index].neighbors[direction];
        if ((aux != (-1)) && (list.nodes[aux].visitedIteration != iteration))
        {
          neighborVisitDirection[pathI] = direction;
          break;
        }
        else
        {
          aux = -1;
        }

      }

      if (aux == (-1))
      {
        pathI--;
        if (pathI < 0)
        {
          break;
        }
        else
        {
          index = currentPathIDs[pathI];
          continue;
        }

      }
      else
      {
        
      }

      if (aux == sinkID)
      {
        flow++;
        direction = directions[0];
        directions[0] = directions[1];
        directions[1] = directions[2];
        directions[2] = directions[3];
        directions[3] = direction;
        for (j = 0; j < pathI; j++)
        {
          switch (neighborVisitDirection[j])
          {
            case UP:
              reverseDirection = DOWN;
              break;

            case DOWN:
              reverseDirection = UP;
              break;

            case LEFT:
              reverseDirection = RIGHT;
              break;

            case RIGHT:
              reverseDirection = LEFT;
              break;

            case BROTHER:
              reverseDirection = BROTHER;
              break;

            case SINK:
              reverseDirection = SINK;
              break;

            default:
              reverseDirection = 0;
              break;

          }

          list.nodes[currentPathIDs[j]].neighbors[neighborVisitDirection[j]] = -1;
          list.nodes[currentPathIDs[j + 1]].neighbors[reverseDirection] = currentPathIDs[j];
        }

        list.nodes[currentPathIDs[pathI]].neighbors[SINK] = -1;
        break;
      }
      else
      {
        index = aux;
        pathI++;
      }

    }

    iteration++;
  }

  printf("%d\n", flow);
  free(list.nodes);
  free(source.neighbors);
  free(currentPathIDs);
  free(neighborVisitDirection);
  return 0;
}

