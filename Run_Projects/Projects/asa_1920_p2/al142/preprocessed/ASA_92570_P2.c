/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct vertix
{
  int numCidadaos;
  int numSupermercados;
  int numAvenida;
  int numRua;
} Vertix;
typedef struct lstNode
{
  int dest_vertix;
  int val;
  struct lstNode *nextNode;
} LstNode;
int head;
int tail;
int *q;
int *color;
int *pred;
int *seen;
LstNode **capacity;
Vertix *vertices;
LstNode *newNode(int vertix, int val)
{
  LstNode *p = malloc(sizeof(LstNode));
  if (0 != p)
  {
    p->dest_vertix = vertix;
    p->val = val;
    p->nextNode = 0;
  }
  else
  {
    
  }

  return p;
}

void printList(LstNode **list, int size)
{
  int i;
  LstNode *nodeAux = 0;
  for (i = 0; i < size; i++)
  {
    for (nodeAux = list[i]; nodeAux != 0; nodeAux = nodeAux->nextNode)
    {
      printf("vertix [%d] -> vertix [%d]\n", i, nodeAux->dest_vertix);
    }

  }

}

int inArray(int *array, int size, int val)
{
  int i = 0;
  for (i = 0; i < size; i++)
  {
    if (array[i] == val)
    {
      return 1;
    }
    else
    {
      
    }

  }

  return 0;
}

void insertNode(LstNode **lstAdjacencias, int vertix, LstNode *node)
{
  LstNode *auxNode = 0;
  if (lstAdjacencias[vertix] == 0)
  {
    lstAdjacencias[vertix] = node;
    return;
  }
  else
  {
    for (auxNode = lstAdjacencias[vertix]; auxNode->nextNode != 0; auxNode = auxNode->nextNode)
      ;

    auxNode->nextNode = node;
    return;
  }

}

void deleteNode(LstNode **head_ref, int key)
{
  LstNode *temp = *head_ref;
  LstNode *prev;
  if ((temp != 0) && (temp->dest_vertix == key))
  {
    *head_ref = temp->nextNode;
    free(temp);
    return;
  }
  else
  {
    
  }

  while ((temp != 0) && (temp->dest_vertix != key))
  {
    prev = temp;
    temp = temp->nextNode;
  }

  if (temp == 0)
  {
    return;
  }
  else
  {
    
  }

  prev->nextNode = temp->nextNode;
  free(temp);
}

void freeList(LstNode *head)
{
  LstNode *auxNode = 0;
  LstNode *nextNodeAux = 0;
  if (head == 0)
  {
    return;
  }
  else
  {
    
  }

  auxNode = head;
  nextNodeAux = auxNode->nextNode;
  while (nextNodeAux != 0)
  {
    free(auxNode);
    auxNode = nextNodeAux;
    nextNodeAux = nextNodeAux->nextNode;
  }

  free(auxNode);
}

void freeLstAdjacencias(LstNode **lstAdjacencias, int size)
{
  int i;
  for (i = 0; i < size; i++)
  {
    freeList(lstAdjacencias[i]);
  }

  free(lstAdjacencias);
}

void display(int **graph, int size)
{
  int i;
  int j;
  for (i = 0; i < size; i++)
  {
    for (j = 0; j < size; j++)
      printf("%4d", graph[i][j]);

    printf("\n");
  }

}

int procuraVal(LstNode **hashtableHeads, int origem, int dest)
{
  LstNode *nodeAux = 0;
  for (nodeAux = hashtableHeads[origem]; nodeAux != 0; nodeAux = nodeAux->nextNode)
  {
    if (dest == nodeAux->dest_vertix)
    {
      return nodeAux->val;
    }
    else
    {
      
    }

  }

  return 0;
}

void alteraVal(LstNode **hashtableHeads, int origem, int dest, int size)
{
  LstNode *nodeAux = 0;
  deleteNode(&hashtableHeads[origem], dest);
  nodeAux = newNode(origem, 1);
  if (nodeAux != 0)
  {
    insertNode(capacity, dest, nodeAux);
  }
  else
  {
    
  }

}

int min(int x, int y)
{
  return (x < y) ? (x) : (y);
}

void enqueue(int x)
{
  q[tail] = x;
  tail++;
  color[x] = 1;
}

int dequeue()
{
  int x = q[head];
  head++;
  color[x] = 2;
  return x;
}

int bfs(int start, int target, int size)
{
  int u;
  LstNode *node1;
  for (u = 0; u < size; u++)
  {
    color[u] = 0;
  }

  head = (tail = 0);
  enqueue(start);
  pred[start] = -1;
  while (head != tail)
  {
    u = dequeue();
    if (u == target)
    {
      return color[target] == 2;
    }
    else
    {
      
    }

    for (node1 = capacity[u]; node1 != 0; node1 = node1->nextNode)
    {
      if (color[node1->dest_vertix] == 0)
      {
        enqueue(node1->dest_vertix);
        pred[node1->dest_vertix] = u;
      }
      else
      {
        
      }

    }

  }

  return color[target] == 2;
}

int max_flow(int source, int sink, int size)
{
  int u;
  int max_flow = 0;
  int increment;
  while (bfs(source, sink, size))
  {
    increment = 1111;
    for (u = size - 1; pred[u] >= 0; u = pred[u])
    {
      increment = min(increment, procuraVal(capacity, pred[u], u));
    }

    for (u = size - 1; pred[u] >= 0; u = pred[u])
    {
      alteraVal(capacity, pred[u], u, size);
    }

    max_flow += increment;
  }

  return max_flow;
}

int main()
{
  int i = 0;
  int k;
  int j;
  int numAvenidas;
  int numRuas;
  int numCidadaos;
  int numSupermercados;
  int n1;
  int n2;
  int graphSize = 0;
  int aux = 1;
  int maxFlow;
  int counter = 0;
  char s1[100];
  char s2[100];
  for (int s1_index = 0; s1_index < 10; s1_index++)
  {
    s1[s1_index] = new_sym_var(sizeof(char) * 8);
  }

  s1[10 - 1] = '\0';
  for (int s2_index = 0; s2_index < 10; s2_index++)
  {
    s2[s2_index] = new_sym_var(sizeof(char) * 8);
  }

  s2[10 - 1] = '\0';
  numAvenidas = atoi(s1);
  numRuas = atoi(s2);
  memset(s1, '\0', 100);
  memset(s2, '\0', 100);
  for (int s1_index = 0; s1_index < 10; s1_index++)
  {
    s1[s1_index] = new_sym_var(sizeof(char) * 8);
  }

  s1[10 - 1] = '\0';
  for (int s2_index = 0; s2_index < 10; s2_index++)
  {
    s2[s2_index] = new_sym_var(sizeof(char) * 8);
  }

  s2[10 - 1] = '\0';
  numCidadaos = atoi(s2);
  numSupermercados = atoi(s1);
  graphSize = (numAvenidas * numRuas) + 2;
  vertices = (Vertix *) malloc((sizeof(Vertix)) * graphSize);
  memset(s1, '\0', 100);
  memset(s2, '\0', 100);
  seen = (int *) malloc((sizeof(int)) * ((numAvenidas * numRuas) + 1));
  memset(seen, 0, (sizeof(int)) * ((numAvenidas * numRuas) + 1));
  for (k = 1, i = 1; i < (graphSize - 1); i++)
  {
    if (aux > numAvenidas)
    {
      aux = 1;
      k++;
    }
    else
    {
      
    }

    vertices[i].numCidadaos = 0;
    vertices[i].numSupermercados = 0;
    vertices[i].numAvenida = aux++;
    vertices[i].numRua = k;
    seen[counter++] = i;
  }

  for (i = 0; i < numSupermercados; i++)
  {
    for (int s1_index = 0; s1_index < 10; s1_index++)
    {
      s1[s1_index] = new_sym_var(sizeof(char) * 8);
    }

    s1[10 - 1] = '\0';
    for (int s2_index = 0; s2_index < 10; s2_index++)
    {
      s2[s2_index] = new_sym_var(sizeof(char) * 8);
    }

    s2[10 - 1] = '\0';
    n1 = atoi(s1);
    n2 = atoi(s2);
    vertices[(n2 * numAvenidas) - (numAvenidas - n1)].numSupermercados++;
  }

  for (i = 0; i < numCidadaos; i++)
  {
    for (int s1_index = 0; s1_index < 10; s1_index++)
    {
      s1[s1_index] = new_sym_var(sizeof(char) * 8);
    }

    s1[10 - 1] = '\0';
    for (int s2_index = 0; s2_index < 10; s2_index++)
    {
      s2[s2_index] = new_sym_var(sizeof(char) * 8);
    }

    s2[10 - 1] = '\0';
    n1 = atoi(s1);
    n2 = atoi(s2);
    vertices[(n2 * numAvenidas) - (numAvenidas - n1)].numCidadaos++;
  }

  graphSize = (2 * (numAvenidas * numRuas)) + 2;
  capacity = (LstNode **) malloc((sizeof(LstNode *)) * graphSize);
  color = (int *) malloc((sizeof(int)) * graphSize);
  pred = (int *) malloc((sizeof(int)) * graphSize);
  q = (int *) malloc((sizeof(int)) * graphSize);
  memset(color, 0, graphSize);
  memset(pred, 0, graphSize);
  memset(q, 0, graphSize);
  for (i = 0; i < graphSize; i++)
  {
    capacity[i] = 0;
  }

  for (i = 1; i < ((numAvenidas * numRuas) + 1); i++)
  {
    LstNode *nodeAux;
    if (vertices[i].numSupermercados > 0)
    {
      for (j = 0; j < vertices[i].numSupermercados; j++)
      {
        LstNode *node1;
        node1 = newNode(graphSize - 1, 1);
        if (0 != node1)
        {
          insertNode(capacity, 2 * i, node1);
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

    if (vertices[i].numCidadaos > 0)
    {
      for (j = 0; j < vertices[i].numCidadaos; j++)
      {
        LstNode *node1;
        node1 = newNode((2 * i) - 1, 1);
        if (0 != node1)
        {
          insertNode(capacity, 0, node1);
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

    nodeAux = newNode(2 * i, 1);
    if (0 != nodeAux)
    {
      insertNode(capacity, (2 * i) - 1, nodeAux);
    }
    else
    {
      
    }

    for (k = i - 1; k < counter; k++)
    {
      if (i != seen[k])
      {
        if (((vertices[i].numRua == vertices[seen[k]].numRua) && (abs(i - seen[k]) == 1)) || ((vertices[i].numAvenida == vertices[seen[k]].numAvenida) && (abs(i - seen[k]) == numAvenidas)))
        {
          LstNode *node1;
          LstNode *node2;
          node1 = newNode((2 * seen[k]) - 1, 1);
          node2 = newNode((2 * i) - 1, 1);
          if (0 != node1)
          {
            insertNode(capacity, 2 * i, node1);
            insertNode(capacity, 2 * seen[k], node2);
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  maxFlow = max_flow(0, graphSize - 1, graphSize);
  printf("%d\n", maxFlow);
  freeLstAdjacencias(capacity, graphSize);
  free(vertices);
  free(color);
  free(q);
  free(pred);
  free(seen);
  return 0;
}

