/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>


typedef struct Grafo
{
  int numVertices;
  int **adjList;
  int *numArcs;
} grafo;
typedef struct Fila
{
  int *list;
  int head;
  int tail;
} fila;
grafo graph;
fila queue;
int qIsEmpty()
{
  return queue.head == queue.tail;
}

void qInit()
{
  queue.head = 0;
  queue.tail = 0;
}

void qPush(int n)
{
  queue.list[queue.tail++] = n;
}

int qPop()
{
  int n = -1;
  if (!qIsEmpty(queue))
  {
    n = queue.list[queue.head++];
  }
  else
  {
    
  }

  return n;
}

void insert(int src, int dest)
{
  graph.adjList[src] = realloc(graph.adjList[src], (++graph.numArcs[src]) * (sizeof(int)));
  graph.adjList[src][graph.numArcs[src] - 1] = dest;
}

void delete(int src, int pos)
{
  for (; pos < (graph.numArcs[src] - 1); pos++)
    graph.adjList[src][pos] = graph.adjList[src][pos + 1];

  graph.adjList[src] = realloc(graph.adjList[src], (--graph.numArcs[src]) * (sizeof(int)));
}

void processInput()
{
  int a;
  int b;
  int i;
  int e;
  int d;
  int c;
  d = new_sym_var(sizeof(int) * 8);
  c = new_sym_var(sizeof(int) * 8);
  graph.numVertices = d * c;
  graph.numArcs = malloc((sizeof(int)) * ((graph.numVertices * 2) + 2));
  graph.adjList = (int **) malloc(((graph.numVertices * 2) + 2) * (sizeof(int *)));
  for (i = 0; i < graph.numVertices; i++)
  {
    graph.adjList[i] = (int *) malloc(sizeof(int));
    graph.numArcs[i] = 0;
    graph.adjList[i + graph.numVertices] = (int *) malloc(sizeof(int));
    graph.numArcs[i + graph.numVertices] = 0;
    insert(i, i + graph.numVertices);
    if (((i - 1) >= 0) && (((i - 1) % d) != (d - 1)))
    {
      insert(i + graph.numVertices, i - 1);
    }
    else
    {
      
    }

    if (((i + 1) < graph.numVertices) && (((i + 1) % d) != 0))
    {
      insert(i + graph.numVertices, i + 1);
    }
    else
    {
      
    }

    if ((i + d) < graph.numVertices)
    {
      insert(i + graph.numVertices, i + d);
    }
    else
    {
      
    }

    if ((i - d) >= 0)
    {
      insert(i + graph.numVertices, i - d);
    }
    else
    {
      
    }

  }

  graph.numVertices *= 2;
  c = new_sym_var(sizeof(int) * 8);
  e = new_sym_var(sizeof(int) * 8);
  graph.adjList[graph.numVertices] = (int *) malloc(sizeof(int));
  graph.numArcs[graph.numVertices] = 0;
  for (i = 0; i < c; i++)
  {
    a = new_sym_var(sizeof(int) * 8);
    b = new_sym_var(sizeof(int) * 8);
    insert(((a - 1) + ((b - 1) * d)) + (graph.numVertices / 2), graph.numVertices);
  }

  graph.numVertices++;
  graph.adjList[graph.numVertices] = (int *) malloc(sizeof(int));
  graph.numArcs[graph.numVertices] = 0;
  for (i = 0; i < e; i++)
  {
    a = new_sym_var(sizeof(int) * 8);
    b = new_sym_var(sizeof(int) * 8);
    insert(graph.numVertices, (a - 1) + ((b - 1) * d));
  }

  graph.numVertices++;
}

int findFlux(int u, int v)
{
  int i;
  for (i = 0; i < graph.numArcs[u]; i++)
    if (graph.adjList[u][i] == v)
  {
    return i;
  }
  else
  {
    
  }


  return -1;
}

int bfs(int parent[], int s, int t)
{
  int u;
  int i;
  int visited[graph.numVertices];
  qInit();
  memset(visited, 0, sizeof(visited));
  qPush(s);
  visited[s] = 1;
  parent[s] = -1;
  while (!qIsEmpty(&queue))
  {
    u = qPop();
    for (i = 0; i < graph.numArcs[u]; i++)
    {
      if (!visited[graph.adjList[u][i]])
      {
        qPush(graph.adjList[u][i]);
        parent[graph.adjList[u][i]] = u;
        visited[graph.adjList[u][i]] = 1;
      }
      else
      {
        
      }

      if (visited[t])
      {
        return 1;
      }
      else
      {
        
      }

    }

  }

  return 0;
}

int fordFulkerson()
{
  int u;
  int v;
  int s;
  int t;
  int parent[graph.numVertices];
  int maxFlow = 0;
  s = graph.numVertices - 1;
  t = graph.numVertices - 2;
  queue.list = malloc((sizeof(int)) * graph.numVertices);
  while (bfs(parent, s, t))
  {
    for (v = t; v != s; v = parent[v])
    {
      u = parent[v];
      delete(u, findFlux(u, v));
      insert(v, u);
    }

    maxFlow++;
  }

  return maxFlow;
}

int main()
{
  processInput();
  printf("%d\n", fordFulkerson());
  return 0;
}

