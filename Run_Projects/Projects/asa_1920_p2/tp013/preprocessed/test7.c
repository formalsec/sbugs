/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct node
{
  int id;
  int num_connections;
  int *connections;
} node;
int ruas;
int avenidas;
int supermercados;
int pessoas;
int max_possible;
int queue_size = 0;
int size = -1;
int front = -1;
int rear = -1;
int *queue;
int *parent;
int *visited;
node **adjGraph;
int convertID(int x, int y, int side)
{
  return (((((y - 1) * avenidas) + x) - 1) * 2) + side;
}

node *createEmptyNode(int id)
{
  node *brotha;
  node *some = malloc(sizeof(node));
  some->id = id;
  some->num_connections = 0;
  brotha = some;
  return brotha;
}

void addEdge(int source, int sink)
{
  adjGraph[source]->connections[adjGraph[source]->num_connections++] = sink;
}

void createNode(int i)
{
  adjGraph[i]->connections = malloc(7 * (sizeof(int)));
  if (i == 0)
  {
    addEdge(0, 1);
    return;
  }
  else
  {
    if ((i % 2) != 0)
    {
      if (i == ((avenidas * 2) - 1))
      {
        addEdge(i, i - 3);
        addEdge(i, 2 * i);
        return;
      }
      else
      {
        
      }

      if ((i + 1) == ((avenidas * ruas) * 2))
      {
        addEdge(i, i - ((avenidas * 2) + 1));
        addEdge(i, i - 3);
        return;
      }
      else
      {
        
      }

      if (((i + 1) % (avenidas * 2)) == 0)
      {
        addEdge(i, i - ((avenidas * 2) + 1));
        addEdge(i, i - 3);
        addEdge(i, i + ((avenidas * 2) - 1));
        return;
      }
      else
      {
        
      }

      if (i == 1)
      {
        addEdge(i, i + 1);
        addEdge(i, i + ((avenidas * 2) - 1));
        return;
      }
      else
      {
        
      }

      if (i == (((avenidas * 2) * (ruas - 1)) + 1))
      {
        addEdge(i, i - ((avenidas * 2) + 1));
        addEdge(i, i + 1);
        return;
      }
      else
      {
        
      }

      if (((i - 1) % (avenidas * 2)) == 0)
      {
        addEdge(i, i - ((avenidas * 2) + 1));
        addEdge(i, i + 1);
        addEdge(i, i + ((avenidas * 2) - 1));
        return;
      }
      else
      {
        
      }

      if ((i > 0) && (i < ((avenidas * 2) - 1)))
      {
        addEdge(i, i + 1);
        addEdge(i, i - 3);
        addEdge(i, i + ((avenidas * 2) - 1));
        return;
      }
      else
      {
        
      }

      if ((i > (((avenidas * 2) * (ruas - 1)) + 1)) && (i < (((avenidas * ruas) * 2) - 1)))
      {
        addEdge(i, i - ((avenidas * 2) + 1));
        addEdge(i, i + 1);
        addEdge(i, i - 3);
        return;
      }
      else
      {
        
      }

      addEdge(i, i - ((avenidas * 2) + 1));
      addEdge(i, i + 1);
      addEdge(i, i - 3);
      addEdge(i, i + ((avenidas * 2) - 1));
      return;
    }
    else
    {
      addEdge(i, i + 1);
      return;
    }

  }

}

void createInitializeParent()
{
  parent[(ruas * avenidas) * 2] = -1;
  parent[((ruas * avenidas) * 2) + 1] = -1;
}

void addBigSuperToSupermarket(int id)
{
  addEdge(id, ((avenidas * ruas) * 2) + 1);
}

void addPersonToBigPerson(int id)
{
  addEdge((avenidas * ruas) * 2, id);
}

int min(int a, int b)
{
  return (a > b) ? (b) : (a);
}

node *createBigNode(int id, int type)
{
  node *some;
  node *brotha;
  some = malloc(sizeof(node));
  some->num_connections = 0;
  if (type == 0)
  {
    some->connections = malloc(pessoas * (sizeof(int)));
    brotha = some;
    return some;
  }
  else
  {
    
  }

  some->connections = malloc(supermercados * (sizeof(int)));
  brotha = some;
  return brotha;
}

void initializeAdjGraph()
{
  int i;
  adjGraph = malloc((((avenidas * ruas) * 2) + 2) * (sizeof(node *)));
  parent = malloc((((avenidas * ruas) * 2) + 2) * (sizeof(int)));
  for (i = 0; i < ((avenidas * ruas) * 2); i++)
  {
    adjGraph[i] = createEmptyNode(i);
    createNode(i);
    parent[i] = -1;
  }

  adjGraph[(avenidas * ruas) * 2] = createBigNode(i, 0);
  adjGraph[((avenidas * ruas) * 2) + 1] = createBigNode(i, 1);
}

int inArray(int id, int size, int *array)
{
  int i;
  for (i = 0; i < size; i++)
  {
    if (array[i] == id)
    {
      return 1;
    }
    else
    {
      
    }

  }

  return 0;
}

void parseArgs()
{
  int i;
  int x;
  int y;
  int id;
  int *array;
  int size = 0;
  avenidas = new_sym_var(sizeof(int) * 8);
  ruas = new_sym_var(sizeof(int) * 8);
  supermercados = new_sym_var(sizeof(int) * 8);
  pessoas = new_sym_var(sizeof(int) * 8);
  array = calloc(supermercados, sizeof(int));
  initializeAdjGraph();
  createInitializeParent();
  for (i = 0; i < supermercados; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    id = convertID(x, y, 1);
    if (inArray(id, size, array) == 0)
    {
      addBigSuperToSupermarket(id);
      array[size++] = id;
    }
    else
    {
      
    }

  }

  free(array);
  array = calloc(pessoas, sizeof(int));
  size = 0;
  for (i = 0; i < pessoas; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    id = convertID(x, y, 0);
    if (inArray(id, size, array) == 0)
    {
      addPersonToBigPerson(id);
      array[size++] = id;
    }
    else
    {
      
    }

  }

  max_possible = min(pessoas, supermercados);
  free(array);
}

void insertQueue(int id)
{
  if (size < (((ruas * avenidas) * 2) + 2))
  {
    if (size < 0)
    {
      queue[0] = id;
      front = (rear = 0);
      size = 1;
    }
    else
    {
      if (rear == (((ruas * avenidas) * 2) + 1))
      {
        queue[0] = id;
        rear = 0;
        size++;
      }
      else
      {
        queue[rear + 1] = id;
        rear++;
        size++;
      }

    }

  }
  else
  {
    
  }

}

int popQueue()
{
  int id = queue[front];
  size--;
  front++;
  return id;
}

int BFS()
{
  int vertex_id;
  int adjVertex_id;
  int num_con;
  int i;
  for (i = 0; i < (((ruas * avenidas) * 2) + 2); i++)
    visited[i] = 0;

  visited[(ruas * avenidas) * 2] = 1;
  insertQueue((ruas * avenidas) * 2);
  parent[(ruas * avenidas) * 2] = -1;
  while (size != 0)
  {
    vertex_id = popQueue();
    num_con = adjGraph[vertex_id]->num_connections;
    for (i = 0; i < num_con; i++)
    {
      adjVertex_id = adjGraph[vertex_id]->connections[i];
      if (visited[adjVertex_id] == 0)
      {
        parent[adjVertex_id] = vertex_id;
        visited[adjVertex_id] = 1;
        if (adjVertex_id == (((ruas * avenidas) * 2) + 1))
        {
          return 1;
        }
        else
        {
          
        }

        insertQueue(adjVertex_id);
      }
      else
      {
        
      }

    }

  }

  return 0;
}

void deleteAdjGraph(int u, int v)
{
  int i;
  int e;
  int num_con;
  num_con = adjGraph[u]->num_connections;
  for (i = 0; i < num_con; i++)
  {
    if (adjGraph[u]->connections[i] == v)
    {
      for (e = i; e < (num_con - 1); e++)
      {
        adjGraph[u]->connections[e] = adjGraph[u]->connections[e + 1];
      }

      adjGraph[u]->num_connections--;
      return;
    }
    else
    {
      
    }

  }

}

int edmondsKARPA()
{
  int flo;
  int max_flow = 0;
  int v;
  int u;
  while (1)
  {
    if (max_flow == max_possible)
    {
      return max_flow;
    }
    else
    {
      
    }

    flo = BFS();
    if (flo == 0)
    {
      return max_flow;
    }
    else
    {
      
    }

    for (v = ((ruas * avenidas) * 2) + 1; v != ((ruas * avenidas) * 2); v = parent[v])
    {
      u = parent[v];
      if ((v != (((ruas * avenidas) * 2) + 1)) && (u != ((ruas * avenidas) * 2)))
      {
        deleteAdjGraph(u, v);
      }
      else
      {
        
      }

      addEdge(v, u);
    }

    for (u = 0; u < (((ruas * avenidas) * 2) + 2); u++)
      queue[u] = 0;

    size = -1;
    rear = -1;
    front = -1;
    max_flow++;
  }

  return max_flow;
}

int main(int argc, const char *argv[])
{
  int flo = 0;
  parseArgs();
  queue = malloc((((ruas * avenidas) * 2) + 2) * (sizeof(int)));
  visited = calloc(((ruas * avenidas) * 2) + 2, sizeof(int));
  flo = edmondsKARPA();
  free(queue);
  free(parent);
  printf("%d\n", flo);
  return 0;
}

