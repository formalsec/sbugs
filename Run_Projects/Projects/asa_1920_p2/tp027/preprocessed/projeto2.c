/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct node
{
  struct node *next;
  int nextValue;
  int cap;
} node;
typedef struct stack
{
  int val;
  struct stack *next;
  struct stack *prev;
} stack;
node **manhattan;
int numVertices;
int numSuper;
int numCitizens;
int total;
int *supermarkets;
int *citizens;
int *visited;
stack *head;
stack *last;
void initManhattan(int m);
void scanInput(int m);
void insert(int u, int v);
int fordFulkerson(int s, int t);
int bfs(int s, int t, int parent[]);
void updatePathFlow(int u, int v, int x);
void push(int at);
int pop();
node *getNode(int u, int v);
void freeAll();
int main()
{
  int m;
  int n;
  m = new_sym_var(sizeof(int) * 8);
  n = new_sym_var(sizeof(int) * 8);
  numSuper = new_sym_var(sizeof(int) * 8);
  numCitizens = new_sym_var(sizeof(int) * 8);
  numVertices = 2 * (n * m);
  manhattan = malloc((sizeof(node)) * numVertices);
  supermarkets = malloc((sizeof(int)) * numSuper);
  citizens = malloc((sizeof(int)) * numCitizens);
  visited = malloc(((sizeof(int)) * numVertices) + 2);
  head = 0;
  last = 0;
  initManhattan(n);
  scanInput(n);
  total = fordFulkerson(numVertices, numVertices + 1);
  printf("%d\n", total);
  freeAll();
  return 0;
}

int fordFulkerson(int s, int t)
{
  int u;
  int v;
  int path_flow;
  int max_flow = 0;
  int *parent;
  if ((numCitizens == 0) || (numSuper == 0))
  {
    return 0;
  }
  else
  {
    
  }

  parent = malloc(((sizeof(int)) * numVertices) + 2);
  while ((bfs(s, t, parent) && (max_flow <= numCitizens)) && (max_flow <= numSuper))
  {
    path_flow = 1;
    for (v = t; v != s; v = parent[v])
    {
      u = parent[v];
      insert(v, u);
      updatePathFlow(u, v, path_flow);
    }

    max_flow += path_flow;
  }

  free(parent);
  return max_flow;
}

int bfs(int s, int t, int parent[])
{
  int i;
  int v;
  int u;
  node *no;
  for (i = 0; i < (numVertices + 2); i++)
    visited[i] = 0;

  push(s);
  visited[s] = 1;
  parent[s] = -1;
  u = pop();
  while (u >= 0)
  {
    no = manhattan[u];
    while (no != 0)
    {
      v = no->nextValue;
      if ((visited[v] == 0) && (no->cap > 0))
      {
        push(v);
        parent[v] = u;
        visited[v] = 1;
        if (v == t)
        {
          while (u != (-1))
            u = pop();

          return visited[t];
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      no = no->next;
    }

    u = pop();
  }

  return visited[t];
}

void updatePathFlow(int u, int v, int x)
{
  node *no = getNode(u, v);
  no->cap -= x;
}

node *getNode(int u, int v)
{
  node *no;
  no = manhattan[u];
  while (no != 0)
  {
    if (no->nextValue == v)
    {
      return no;
    }
    else
    {
      
    }

    no = no->next;
  }

  return 0;
}

void push(int valor)
{
  stack *aux = malloc(sizeof(stack));
  if (head == 0)
  {
    head = aux;
    head->next = 0;
    head->prev = 0;
    head->val = valor;
    last = head;
    return;
  }
  else
  {
    
  }

  head->prev = aux;
  aux->next = head;
  aux->prev = 0;
  aux->val = valor;
  head = aux;
}

int pop()
{
  int i = 0;
  if (head == 0)
  {
    return -1;
  }
  else
  {
    
  }

  if ((last->prev == 0) && (last->next == 0))
  {
    i = last->val;
    head = 0;
    free(last);
    last = 0;
    return i;
  }
  else
  {
    i = last->val;
    last = last->prev;
    free(last->next);
    last->next = 0;
    return i;
  }

}

void initManhattan(int n)
{
  int i;
  int c;
  c = 2 * n;
  for (i = 0; i < numVertices; i++)
  {
    if ((i % 2) == 0)
    {
      insert(i, i + 1);
    }
    else
    {
      if (i > c)
      {
        insert(i, i - (c + 1));
      }
      else
      {
        
      }

      if ((i + c) < numVertices)
      {
        insert(i, i + (c - 1));
      }
      else
      {
        
      }

      if ((i % c) == (c - 1))
      {
        insert(i, i - 3);
      }
      else
      {
        if ((i % c) == 1)
        {
          insert(i, i + 1);
        }
        else
        {
          insert(i, i + 1);
          insert(i, i - 3);
        }

      }

    }

  }

}

void insert(int u, int v)
{
  node *new;
  new = (node *) malloc(sizeof(node));
  if (manhattan[u] == 0)
  {
    manhattan[u] = new;
    new->next = 0;
  }
  else
  {
    new->next = manhattan[u];
    manhattan[u] = new;
  }

  new->nextValue = v;
  new->cap = 1;
}

void scanInput(int n)
{
  int intersection;
  int i;
  int x;
  int y;
  for (i = 0; i < numSuper; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    x--;
    y--;
    intersection = (x * n) + y;
    supermarkets[i] = (intersection * 2) + 1;
    insert((intersection * 2) + 1, numVertices + 1);
  }

  for (i = 0; i < numCitizens; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    x--;
    y--;
    intersection = (x * n) + y;
    citizens[i] = intersection * 2;
    insert(numVertices, intersection * 2);
  }

}

void freeAll()
{
  int i;
  node *aux;
  node *aux1;
  free(supermarkets);
  free(citizens);
  free(visited);
  for (i = 0; i < numVertices; i++)
  {
    aux = manhattan[i];
    while (aux)
    {
      aux1 = aux;
      aux = aux->next;
      free(aux1);
    }

  }

}

