/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct VERTEX
{
  int vertex;
  int visited;
  int count;
  int *adj;
  int max_path_size;
} VERTEX;
VERTEX *initGraph(int *dominos, int *dependencies)
{
  int i = 0;
  char buff[30];
  if (fgets(buff, 30, stdin) == 0)
  {
    return 0;
  }
  else
  {
    
  }

  *dominos = atoi(strtok(buff, " "));
  *dependencies = atoi(strtok(0, "\n"));
  VERTEX *graph = (VERTEX *) malloc((*dominos) * (sizeof(VERTEX)));
  for (i = 0; i < (*dominos); i++)
  {
    graph[i].vertex = i + 1;
    graph[i].visited = 0;
    graph[i].count = 0;
    graph[i].adj = (int *) malloc(1 * (sizeof(int)));
    graph[i].max_path_size = 0;
  }

  return graph;
}

void readDependencies(VERTEX *graph, int dependencies)
{
  int i = 0;
  int u = 0;
  int v = 0;
  char buff[30];
  for (i = 0; i < dependencies; i++)
  {
    if (fgets(buff, 30, stdin) == 0)
    {
      return;
    }
    else
    {
      
    }

    u = atoi(strtok(buff, " "));
    v = atoi(strtok(0, "\n"));
    graph[u - 1].adj[graph[u - 1].count] = v;
    graph[u - 1].count++;
    graph[u - 1].adj = (int *) realloc(graph[u - 1].adj, (graph[u - 1].count + 1) * (sizeof(int)));
  }

}

void DFS(VERTEX *graph, int u, int path_size, int vertex)
{
  int i = 0;
  int v = 0;
  graph[u - 1].visited = 1;
  path_size++;
  if (graph[u - 1].count == 0)
  {
    if (path_size > graph[vertex - 1].max_path_size)
    {
      graph[vertex - 1].max_path_size = path_size;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  for (i = 0; i < graph[u - 1].count; i++)
  {
    v = graph[u - 1].adj[i];
    if (graph[v - 1].visited == 0)
    {
      DFS(graph, v, path_size, vertex);
    }
    else
    {
      
    }

  }

  graph[u - 1].visited = 0;
}

void result(VERTEX *graph, int dominos)
{
  int i = 0;
  int j = 0;
  int n = 0;
  int biggest_path = 0;
  int vertices[dominos];
  for (i = 0; i < dominos; i++)
  {
    vertices[i] = i + 1;
  }

  for (i = 0; i < dominos; i++)
  {
    for (j = 0; j < graph[i].count; j++)
    {
      vertices[graph[i].adj[j] - 1] = 0;
    }

  }

  for (i = 0; i < dominos; i++)
  {
    if (vertices[i] != 0)
    {
      n++;
    }
    else
    {
      
    }

    if (graph[i].max_path_size > biggest_path)
    {
      biggest_path = graph[i].max_path_size;
    }
    else
    {
      
    }

  }

  printf("%d %d\n", n, biggest_path);
}

void run(VERTEX *graph, int dominos)
{
  int i = 0;
  int path_size = 0;
  for (i = 0; i < dominos; i++)
  {
    DFS(graph, graph[i].vertex, path_size, graph[i].vertex);
  }

  result(graph, dominos);
}

void freeMem(VERTEX *graph, int dominos)
{
  int i = 0;
  for (i = 0; i < dominos; i++)
  {
    free(graph[i].adj);
  }

  free(graph);
}

int main()
{
  int dominos = 0;
  int dependencies = 0;
  VERTEX *graph = initGraph(&dominos, &dependencies);
  readDependencies(graph, dependencies);
  run(graph, dominos);
  freeMem(graph, dominos);
  return 0;
}

