/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int numeroNodes;
int numeroDependencias;
int first = 0;
int last = 0;
int k;
int l = 0;
int V;
int E;
typedef struct node
{
  int id;
  int indegree;
  int outdegree;
  int d;
  int pi;
} node;
typedef struct grafo
{
  int numeroNodes;
  int numeroDependencias;
  int **matrizAdjacencias;
  node *vertices;
} grafo;
node *ordemTopologica;
node *queue;
int **constroiMatriz()
{
  int i;
  int j;
  int origem;
  int destino;
  int **matriz = 0;
  if (2 == 2)
  {
    V = new_sym_var(sizeof(int) * 8);
    E = new_sym_var(sizeof(int) * 8);
    matriz = malloc(V * (sizeof(int *)));
    numeroNodes = V;
    for (i = 0; i < V; i++)
    {
      matriz[i] = malloc(V * (sizeof(int)));
      for (j = 0; j < V; j++)
      {
        matriz[i][j] = 0;
      }

    }

  }
  else
  {
    
  }

  for (i = 0; i < E; i++)
  {
    if (2 == 2)
    {
      origem = new_sym_var(sizeof(int) * 8);
      destino = new_sym_var(sizeof(int) * 8);
      matriz[origem - 1][destino - 1] = 1;
    }
    else
    {
      
    }

  }

  return matriz;
}

grafo constroiGrafo(int **matrizAdjacencias)
{
  grafo g;
  int i;
  int j;
  g.numeroNodes = V;
  g.numeroDependencias = E;
  g.matrizAdjacencias = matrizAdjacencias;
  g.vertices = malloc(numeroNodes * (sizeof(node)));
  for (i = 0; i < numeroNodes; i++)
  {
    g.vertices[i].indegree = 0;
    g.vertices[i].outdegree = 0;
  }

  for (i = 0; i < numeroNodes; i++)
  {
    g.vertices[i].id = i + 1;
    for (j = 0; j < numeroNodes; j++)
    {
      if (matrizAdjacencias[i][j] == 1)
      {
        g.vertices[i].outdegree += 1;
        g.vertices[j].indegree += 1;
      }
      else
      {
        
      }

    }

  }

  return g;
}

void topologicalOrder(grafo g)
{
  int i;
  queue = malloc(numeroNodes * (sizeof(node)));
  ordemTopologica = malloc(numeroNodes * (sizeof(node)));
  for (i = 0; i < numeroNodes; i++)
  {
    if (g.vertices[i].indegree == 0)
    {
      queue[last] = g.vertices[i];
      last += 1;
    }
    else
    {
      
    }

  }

  k = last;
  while (first < last)
  {
    ordemTopologica[first] = queue[first];
    for (i = 0; i < numeroNodes; i++)
    {
      if (g.matrizAdjacencias[ordemTopologica[first].id - 1][i] == 1)
      {
        g.vertices[i].indegree -= 1;
        if (g.vertices[i].indegree == 0)
        {
          queue[last] = g.vertices[i];
          last += 1;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    first += 1;
  }

}

void caminhoMaisLongo(grafo g)
{
  int i;
  int j;
  for (i = 0; i < numeroNodes; i++)
  {
    ordemTopologica[i].d = 0;
  }

  for (i = 0; i < numeroNodes; i++)
  {
    for (j = 0; j < numeroNodes; j++)
    {
      if ((g.matrizAdjacencias[j][ordemTopologica[i].id - 1] == 1) && (g.vertices[j].d >= g.vertices[ordemTopologica[i].id - 1].d))
      {
        g.vertices[ordemTopologica[i].id - 1].d = g.vertices[j].d;
      }
      else
      {
        
      }

    }

    g.vertices[ordemTopologica[i].id - 1].d += 1;
  }

}

void liberta(int **matriz, grafo g)
{
  int i;
  free(g.vertices);
  for (i = 0; i < numeroNodes; i++)
  {
    free(matriz[i]);
  }

  free(matriz);
}

int main()
{
  int **matriz = constroiMatriz();
  grafo g = constroiGrafo(matriz);
  int i;
  topologicalOrder(g);
  caminhoMaisLongo(g);
  for (i = 0; i < numeroNodes; i++)
  {
    if ((g.vertices[i].outdegree == 0) && (g.vertices[i].d > l))
    {
      l = g.vertices[i].d;
    }
    else
    {
      
    }

  }

  printf("%d %d\n", k, l);
  liberta(matriz, g);
  free(ordemTopologica);
  free(queue);
  return 0;
}

