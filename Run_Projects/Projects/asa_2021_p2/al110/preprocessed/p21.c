/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct EDGE
{
  int dest;
  int weight;
} EDGE;
typedef struct NODE
{
  int color;
  int n_edges;
  struct EDGE *edges;
} NODE;
typedef struct GRAPH
{
  int size;
  struct NODE *nodes;
} GRAPH;
GRAPH *createGraph(int num_processes)
{
  int i = 0;
  GRAPH *graph = (GRAPH *) malloc(sizeof(GRAPH));
  graph->size = num_processes + 2;
  graph->nodes = (NODE *) malloc(graph->size * (sizeof(NODE)));
  for (i = 0; i < graph->size; i++)
  {
    graph->nodes[i].color = 0;
    graph->nodes[i].n_edges = 0;
    graph->nodes[i].edges = (EDGE *) malloc(sizeof(EDGE));
  }

  return graph;
}

void addEdge(GRAPH *graph, int source, int dest, int weight)
{
  int n_edges_f = 0;
  int n_edges_b = 0;
  n_edges_f = graph->nodes[source].n_edges;
  n_edges_b = graph->nodes[dest].n_edges;
  graph->nodes[source].edges[n_edges_f].dest = dest;
  graph->nodes[source].edges[n_edges_f].weight = weight;
  graph->nodes[source].n_edges += 1;
  graph->nodes[source].edges = (EDGE *) realloc(graph->nodes[source].edges, (sizeof(EDGE)) * (n_edges_f + 2));
  graph->nodes[dest].edges[n_edges_b].dest = source;
  graph->nodes[dest].edges[n_edges_b].weight = weight;
  graph->nodes[dest].n_edges += 1;
  graph->nodes[dest].edges = (EDGE *) realloc(graph->nodes[dest].edges, (sizeof(EDGE)) * (n_edges_b + 2));
}

void initGraph(GRAPH *graph, int num_processes, int num_communications)
{
  int i = 0;
  int weight_X = -1;
  int weight_Y = -1;
  int source = 0;
  int dest = 0;
  for (i = 1; i <= num_processes; i++)
  {
    weight_X = new_sym_var(sizeof(int) * 8);
    weight_Y = new_sym_var(sizeof(int) * 8);
    addEdge(graph, 0, i, weight_X);
    addEdge(graph, i, graph->size - 1, weight_Y);
  }

  for (i = 0; i < num_communications; i++)
  {
    source = new_sym_var(sizeof(int) * 8);
    dest = new_sym_var(sizeof(int) * 8);
    weight_X = new_sym_var(sizeof(int) * 8);
    addEdge(graph, source, dest, weight_X);
  }

}

void addToQueue(int *queue, int v, int *end)
{
  queue[*end] = v;
  *end += 1;
}

int removeFromQueue(int *queue, int *begin)
{
  int v = 0;
  v = queue[*begin];
  *begin += 1;
  return v;
}

int bfs(GRAPH *graph, int source, int dest, int *parent, int *queue)
{
  int i = 0;
  int v = 0;
  int w = 0;
  int begin = 0;
  int end = 0;
  for (i = 1; i < graph->size; i++)
  {
    graph->nodes[i].color = 0;
  }

  graph->nodes[source].color = 1;
  addToQueue(queue, source, &end);
  while (begin != end)
  {
    v = removeFromQueue(queue, &begin);
    for (i = 0; i < graph->nodes[v].n_edges; i++)
    {
      w = graph->nodes[v].edges[i].dest;
      if ((graph->nodes[w].color == 0) && (graph->nodes[v].edges[i].weight > 0))
      {
        if (w == dest)
        {
          parent[w] = v;
          return 1;
        }
        else
        {
          
        }

        addToQueue(queue, w, &end);
        graph->nodes[w].color = 1;
        parent[w] = v;
      }
      else
      {
        
      }

    }

  }

  return 0;
}

int min(int a, int b)
{
  int min = 0;
  min = (a < b) ? (a) : (b);
  return min;
}

int fordfulkerson(GRAPH *graph, int s, int t)
{
  int i = 0;
  int v = 0;
  int w = 0;
  int flow = 0;
  int max_flow = 0;
  int *parent = (int *) malloc(graph->size * (sizeof(int)));
  int *queue = (int *) malloc(graph->size * (sizeof(int)));
  while (bfs(graph, s, t, parent, queue))
  {
    flow = 10000;
    for (w = t; w != s; w = parent[w])
    {
      v = parent[w];
      for (i = 0; i < graph->nodes[v].n_edges; i++)
      {
        if (graph->nodes[v].edges[i].dest == w)
        {
          flow = min(flow, graph->nodes[v].edges[i].weight);
        }
        else
        {
          
        }

      }

    }

    for (w = t; w != s; w = parent[w])
    {
      v = parent[w];
      for (i = 0; i < graph->nodes[v].n_edges; i++)
      {
        if (graph->nodes[v].edges[i].dest == w)
        {
          graph->nodes[v].edges[i].weight -= flow;
        }
        else
        {
          
        }

      }

      for (i = 0; i < graph->nodes[w].n_edges; i++)
      {
        if (graph->nodes[w].edges[i].dest == v)
        {
          graph->nodes[w].edges[i].weight += flow;
        }
        else
        {
          
        }

      }

    }

    max_flow += flow;
  }

  return max_flow;
}

int main()
{
  int num_processes = 0;
  int num_communications = 0;
  num_processes = new_sym_var(sizeof(int) * 8);
  num_communications = new_sym_var(sizeof(int) * 8);
  GRAPH *graph = createGraph(num_processes);
  initGraph(graph, num_processes, num_communications);
  printf("%d\n", fordfulkerson(graph, 0, graph->size - 1));
  return 0;
}

