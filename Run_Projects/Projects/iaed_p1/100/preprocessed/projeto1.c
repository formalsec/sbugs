/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int p_id;
  char name[64];
  int price;
  int weight;
  int qty_available;
} product;
typedef struct 
{
  int p_id;
  int qty;
} order_item;
typedef struct 
{
  order_item item_list[200];
  int item_list_end;
  int current_weight;
} order;
void command_a();
void command_q();
void command_N();
void command_A();
void command_r();
void command_R();
void command_C();
void command_p();
void command_E();
void command_m();
void command_l();
void command_L();
void add_product_catalog(product p);
void add_item_order(order_item new_item, int order_id);
void remove_product_order(int order_id, int product_id);
int order_cost(int order_id);
void update_price(int product_id, int new_price);
void print_item(int order_id, int product_id);
void print_most_item(int product_id);
int item_qty_order(int order_id, int product_id);
int index_from_pid(int p_id);
void clear_input_buffer();
product catalog[10000];
int catalog_end;
order order_list[500];
int order_list_end;
int main()
{
  char command;
  do
  {
    command = getchar();
    switch (command)
    {
      case 'a':
        command_a();
        break;

      case 'q':
        command_q();
        break;

      case 'N':
        command_N();
        break;

      case 'A':
        command_A();
        break;

      case 'r':
        command_r();
        break;

      case 'R':
        command_R();
        break;

      case 'C':
        command_C();
        break;

      case 'p':
        command_p();
        break;

      case 'E':
        command_E();
        break;

      case 'm':
        command_m();
        break;

      case 'l':
        command_l();
        break;

      case 'L':
        command_L();
        break;

    }

  }
  while (command != 'x');
  return 0;
}

void command_a()
{
  product p;
  for (int p_index = 0; p_index < 10; p_index++)
  {
    p.name[p_index] = new_sym_var(sizeof(char) * 8);
  }

  p.name[10 - 1] = '\0';
  p.price = new_sym_var(sizeof(int) * 8);
  p.weight = new_sym_var(sizeof(int) * 8);
  p.qty_available = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  p.p_id = catalog_end;
  add_product_catalog(p);
  printf("Novo produto %d.\n", p.p_id);
  return;
}

void command_q()
{
  int p_id;
  int qty;
  p_id = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  if (p_id >= catalog_end)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", p_id);
    return;
  }
  else
  {
    
  }

  catalog[index_from_pid(p_id)].qty_available += qty;
  return;
}

void command_N()
{
  order o;
  o.item_list_end = (o.current_weight = 0);
  clear_input_buffer();
  order_list[order_list_end] = o;
  printf("Nova encomenda %d.\n", order_list_end++);
  return;
}

void command_A()
{
  int order_id;
  int product_index;
  order_item item;
  order_id = new_sym_var(sizeof(int) * 8);
  item.p_id = new_sym_var(sizeof(int) * 8);
  item.qty = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  product_index = index_from_pid(item.p_id);
  if (order_id >= order_list_end)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", item.p_id, order_id);
    return;
  }
  else
  {
    if (item.p_id >= catalog_end)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", item.p_id, order_id);
      return;
    }
    else
    {
      if (item.qty > catalog[product_index].qty_available)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", item.p_id, order_id);
        return;
      }
      else
      {
        if ((order_list[order_id].current_weight + (item.qty * catalog[product_index].weight)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", item.p_id, order_id);
          return;
        }
        else
        {
          
        }

      }

    }

  }

  add_item_order(item, order_id);
  catalog[product_index].qty_available -= item.qty;
  return;
}

void command_r()
{
  int p_id;
  int stock_diff;
  int product_index;
  p_id = new_sym_var(sizeof(int) * 8);
  stock_diff = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  product_index = index_from_pid(p_id);
  if (p_id >= catalog_end)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", p_id);
    return;
  }
  else
  {
    if (stock_diff > catalog[product_index].qty_available)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", stock_diff, p_id);
      return;
    }
    else
    {
      
    }

  }

  catalog[product_index].qty_available -= stock_diff;
  return;
}

void command_R()
{
  int order_id;
  int product_id;
  order_id = new_sym_var(sizeof(int) * 8);
  product_id = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  if (order_id >= order_list_end)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", product_id, order_id);
    return;
  }
  else
  {
    if (product_id >= catalog_end)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", product_id, order_id);
      return;
    }
    else
    {
      
    }

  }

  remove_product_order(order_id, product_id);
  return;
}

void command_C()
{
  int order_id;
  order_id = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  if (order_id >= order_list_end)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", order_id);
    return;
  }
  else
  {
    
  }

  printf("Custo da encomenda %d %d.\n", order_id, order_cost(order_id));
  return;
}

void command_p()
{
  int product_id;
  int new_price;
  product_id = new_sym_var(sizeof(int) * 8);
  new_price = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  if (product_id >= catalog_end)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", product_id);
    return;
  }
  else
  {
    
  }

  update_price(product_id, new_price);
  return;
}

void command_E()
{
  int order_id;
  int product_id;
  order_id = new_sym_var(sizeof(int) * 8);
  product_id = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  if (order_id >= order_list_end)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order_id);
    return;
  }
  else
  {
    if (product_id >= catalog_end)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", product_id);
      return;
    }
    else
    {
      
    }

  }

  print_item(order_id, product_id);
  return;
}

void command_m()
{
  int product_id;
  product_id = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  if (product_id >= catalog_end)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", product_id);
    return;
  }
  else
  {
    if (order_list_end == 0)
    {
      return;
    }
    else
    {
      
    }

  }

  print_most_item(product_id);
  return;
}

void command_l()
{
  int k;
  clear_input_buffer();
  puts("Produtos");
  for (k = 0; k < catalog_end; k++)
  {
    printf("* %s %d %d\n", catalog[k].name, catalog[k].price, catalog[k].qty_available);
  }

  return;
}

void command_L()
{
  product current_product;
  order_item current_item;
  int order_id;
  int k;
  int max;
  order_id = new_sym_var(sizeof(int) * 8);
  clear_input_buffer();
  if (order_id >= order_list_end)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order_id);
    return;
  }
  else
  {
    
  }

  printf("Encomenda %d\n", order_id);
  max = order_list[order_id].item_list_end;
  for (k = 0; k < max; k++)
  {
    current_item = order_list[order_id].item_list[k];
    current_product = catalog[index_from_pid(current_item.p_id)];
    printf("* %s %d %d\n", current_product.name, current_product.price, current_item.qty);
  }

  return;
}

void add_product_catalog(product p)
{
  int k;
  product temp;
  for (k = 0; k < catalog_end; k++)
  {
    if (p.price < catalog[k].price)
    {
      temp = catalog[k];
      catalog[k] = p;
      p = temp;
      break;
    }
    else
    {
      
    }

  }

  for (k++; k < catalog_end; k++)
  {
    temp = catalog[k];
    catalog[k] = p;
    p = temp;
  }

  catalog[catalog_end++] = p;
  return;
}

void add_item_order(order_item new_item, int order_id)
{
  int k;
  int current_item_pid;
  int max = order_list[order_id].item_list_end;
  order_item temp;
  order_list[order_id].current_weight += new_item.qty * catalog[index_from_pid(new_item.p_id)].weight;
  for (k = 0; k < max; k++)
  {
    if (order_list[order_id].item_list[k].p_id == new_item.p_id)
    {
      order_list[order_id].item_list[k].qty += new_item.qty;
      return;
    }
    else
    {
      
    }

  }

  for (k = 0; k < max; k++)
  {
    current_item_pid = order_list[order_id].item_list[k].p_id;
    if (strcmp(catalog[index_from_pid(new_item.p_id)].name, catalog[index_from_pid(current_item_pid)].name) < 0)
    {
      temp = order_list[order_id].item_list[k];
      order_list[order_id].item_list[k] = new_item;
      new_item = temp;
    }
    else
    {
      
    }

  }

  order_list[order_id].item_list[order_list[order_id].item_list_end++] = new_item;
  return;
}

void remove_product_order(int order_id, int product_id)
{
  int k;
  int qty;
  int wgt;
  int index_in_catalog;
  int max = order_list[order_id].item_list_end;
  for (k = 0; k < max; k++)
  {
    if (order_list[order_id].item_list[k].p_id == product_id)
    {
      break;
    }
    else
    {
      
    }

  }

  if (k == max)
  {
    return;
  }
  else
  {
    
  }

  index_in_catalog = index_from_pid(product_id);
  qty = order_list[order_id].item_list[k].qty;
  catalog[index_in_catalog].qty_available += qty;
  wgt = qty * catalog[index_in_catalog].weight;
  order_list[order_id].current_weight -= wgt;
  for (; k < (max - 1); k++)
  {
    order_list[order_id].item_list[k] = order_list[order_id].item_list[k + 1];
  }

  order_list[order_id].item_list_end--;
  return;
}

int order_cost(int order_id)
{
  int k;
  int item_price;
  int item_qty;
  int total = 0;
  int max = order_list[order_id].item_list_end;
  for (k = 0; k < max; k++)
  {
    item_price = catalog[index_from_pid(order_list[order_id].item_list[k].p_id)].price;
    item_qty = order_list[order_id].item_list[k].qty;
    total += item_price * item_qty;
  }

  return total;
}

void update_price(int product_id, int new_price)
{
  int k;
  int i;
  int old_product_index = index_from_pid(product_id);
  product new;
  product temp;
  new = catalog[old_product_index];
  new.price = new_price;
  for (k = 0; k < catalog_end; k++)
  {
    if ((new_price < catalog[k].price) || ((new_price == catalog[k].price) && (product_id < catalog[k].p_id)))
    {
      break;
    }
    else
    {
      
    }

  }

  if (k < old_product_index)
  {
    for (i = k; i <= old_product_index; i++)
    {
      temp = catalog[i];
      catalog[i] = new;
      new = temp;
    }

  }
  else
  {
    if (k > old_product_index)
    {
      for (i = k - 1; i >= old_product_index; i--)
      {
        temp = catalog[i];
        catalog[i] = new;
        new = temp;
      }

    }
    else
    {
      catalog[old_product_index].price = new_price;
    }

  }

  return;
}

void print_item(int order_id, int product_id)
{
  int k;
  int qty;
  int max = order_list[order_id].item_list_end;
  for (k = 0; k < max; k++)
  {
    if (order_list[order_id].item_list[k].p_id == product_id)
    {
      qty = order_list[order_id].item_list[k].qty;
      printf("%s %d.\n", catalog[index_from_pid(product_id)].name, qty);
      return;
    }
    else
    {
      
    }

  }

  printf("%s 0.\n", catalog[index_from_pid(product_id)].name);
  return;
}

void print_most_item(int product_id)
{
  int k;
  int most_order_id;
  int most_quantity;
  most_order_id = -1;
  most_quantity = 0;
  for (k = 0; k < order_list_end; k++)
  {
    if (item_qty_order(k, product_id) > most_quantity)
    {
      most_order_id = k;
      most_quantity = item_qty_order(k, product_id);
    }
    else
    {
      
    }

  }

  if (most_order_id == (-1))
  {
    return;
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", product_id, most_order_id, most_quantity);
  return;
}

int item_qty_order(int order_id, int product_id)
{
  int k;
  int max = order_list[order_id].item_list_end;
  for (k = 0; k < max; k++)
  {
    if (order_list[order_id].item_list[k].p_id == product_id)
    {
      return order_list[order_id].item_list[k].qty;
    }
    else
    {
      
    }

  }

  return 0;
}

int index_from_pid(int p_id)
{
  int k;
  for (k = 0; k < catalog_end; k++)
  {
    if (catalog[k].p_id == p_id)
    {
      return k;
    }
    else
    {
      
    }

  }

  return -1;
}

void clear_input_buffer()
{
  char c;
  while (((c = getchar()) != '\n') && (c != EOF))
    ;

  return;
}

