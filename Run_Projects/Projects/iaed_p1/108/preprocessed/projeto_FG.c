/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


int ind_p = 0;
int ind_e = 0;
typedef struct produto
{
  char descricao[63];
  int preco;
  int peso;
  int qtd;
} Produto;
typedef struct encomenda
{
  int produtos[10000];
  int qtd[10000];
  int n_prod;
} Encomenda;
Produto stock[10000] = {0};
Encomenda enc[500] = {0};
int aux1[10000];
int aux2[10000];
void novo_produto()
{
  int preco;
  int peso;
  int qtd;
  char descricao[63];
  for (int descricao_index = 0; descricao_index < 10; descricao_index++)
  {
    descricao[descricao_index] = new_sym_var(sizeof(char) * 8);
  }

  descricao[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  strcpy(stock[ind_p].descricao, descricao);
  stock[ind_p].preco = preco;
  stock[ind_p].peso = peso;
  stock[ind_p].qtd = qtd;
  printf("Novo produto %d.\n", ind_p++);
}

void add_stock()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= ind_p)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    stock[idp].qtd += qtd;
  }

}

void nova_encomenda()
{
  printf("Nova encomenda %d.\n", ind_e++);
}

int calcula_peso(int idp, int qtd)
{
  return stock[idp].peso * qtd;
}

int calcula_peso_encomenda(int ide)
{
  int i;
  int total = 0;
  for (i = 0; i < enc[ide].n_prod; i++)
    total += calcula_peso(enc[ide].produtos[i], enc[ide].qtd[enc[ide].produtos[i]]);

  return total;
}

void add_produto()
{
  int ide;
  int idp;
  int qtd;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= ind_e)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= ind_p)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (stock[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((calcula_peso(idp, qtd) + calcula_peso_encomenda(ide)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          {
            stock[idp].qtd -= qtd;
            for (i = 0; i < enc[ide].n_prod; i++)
              if (enc[ide].produtos[i] == idp)
            {
              {
                enc[ide].qtd[idp] += qtd;
                return;
              }
            }
            else
            {
              
            }


            enc[ide].qtd[idp] = qtd;
            enc[ide].produtos[i] = idp;
            enc[ide].n_prod++;
          }
        }

      }

    }

  }

}

void remove_stock()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= ind_p)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (stock[idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      stock[idp].qtd -= qtd;
    }

  }

}

void remove_produto()
{
  int ide;
  int idp;
  int i;
  int j;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ind_e)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= ind_p)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      {
        for (i = 0; i < enc[ide].n_prod; i++)
          if (enc[ide].produtos[i] == idp)
        {
          {
            for (j = i; j < (enc[ide].n_prod - 1); j++)
              enc[ide].produtos[j] = enc[ide].produtos[j + 1];

            enc[ide].n_prod--;
            stock[idp].qtd += enc[ide].qtd[idp];
            enc[ide].qtd[idp] = 0;
            break;
          }
        }
        else
        {
          
        }


      }
    }

  }

}

void custo_encomenda()
{
  int ide;
  int i;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ind_e)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (i = 0; i < enc[ide].n_prod; i++)
        total += enc[ide].qtd[enc[ide].produtos[i]] * stock[enc[ide].produtos[i]].preco;

      printf("Custo da encomenda %d %d.\n", ide, total);
    }
  }

}

void altera_preco()
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= ind_p)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    stock[idp].preco = preco;
  }

}

void lista_produto()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ind_e)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= ind_p)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      printf("%s %d.\n", stock[idp].descricao, enc[ide].qtd[idp]);
    }

  }

}

void lista_encomenda_produto()
{
  int idp;
  int i;
  int max = 0;
  int max_e = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= ind_p)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      for (i = 0; i < ind_e; i++)
        if (enc[i].qtd[idp] > max)
      {
        {
          max = enc[i].qtd[idp];
          max_e = i;
        }
      }
      else
      {
        
      }


      if ((max != 0) && (ind_e != 0))
      {
        printf("Maximo produto %d %d %d.\n", idp, max_e, max);
      }
      else
      {
        
      }

    }
  }

}

void ordena_auxiliar(int a1[], int a2[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
  {
    aux1[i - 1] = a1[i - 1];
    aux2[i - 1] = a2[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux1[(r + m) - j] = a1[j + 1];
    aux2[(r + m) - j] = a2[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if ((aux1[j] < aux1[i]) || ((aux1[j] == aux1[i]) && (aux2[j] < aux2[i])))
    {
      {
        a1[k] = aux1[j];
        a2[k] = aux2[j--];
      }
    }
    else
    {
      {
        a1[k] = aux1[i];
        a2[k] = aux2[i++];
      }
    }

  }

}

void ordena(int a1[], int a2[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  ordena(a1, a2, l, m);
  ordena(a1, a2, m + 1, r);
  ordena_auxiliar(a1, a2, l, m, r);
}

void lista_todos_produtos()
{
  int tab1[10000];
  int tab2[10000];
  int i;
  if (ind_p != 0)
  {
    {
      for (i = 0; i < ind_p; i++)
      {
        tab1[i] = stock[i].preco;
        tab2[i] = i;
      }

      ordena(tab1, tab2, 0, ind_p - 1);
      printf("Produtos\n");
      for (i = 0; i < ind_p; i++)
        printf("* %s %d %d\n", stock[tab2[i]].descricao, stock[tab2[i]].preco, stock[tab2[i]].qtd);

    }
  }
  else
  {
    printf("Produtos\n");
  }

}

int ordena_s_auxiliar(char a1[10000][63], int a2[], int l, int r)
{
  char v[63];
  char s[63];
  int i = l - 1;
  int j = r;
  strcpy(v, a1[r]);
  while (i < j)
  {
    while (strcmp(a1[++i], v) < 0)
      ;

    while (strcmp(v, a1[--j]) < 0)
      if (j == l)
    {
      break;
    }
    else
    {
      
    }


    if (i < j)
    {
      {
        strcpy(s, a1[i]);
        strcpy(a1[i], a1[j]);
        strcpy(a1[j], s);
        {
          int t = a2[i];
          a2[i] = a2[j];
          a2[j] = t;
        }
        ;
      }
    }
    else
    {
      
    }

  }

  strcpy(v, a1[i]);
  strcpy(a1[i], a1[r]);
  strcpy(a1[r], v);
  {
    int t = a2[i];
    a2[i] = a2[r];
    a2[r] = t;
  }
  ;
  return i;
}

void ordena_s(char a1[10000][63], int a2[], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = ordena_s_auxiliar(a1, a2, l, r);
  ordena_s(a1, a2, l, i - 1);
  ordena_s(a1, a2, i + 1, r);
}

void lista_encomenda_produtos()
{
  char tab1[10000][63];
  int tab2[10000];
  int i;
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ind_e)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (i = 0; i < enc[ide].n_prod; i++)
      {
        strcpy(tab1[i], stock[enc[ide].produtos[i]].descricao);
        tab2[i] = enc[ide].produtos[i];
      }

      ordena_s(tab1, tab2, 0, enc[ide].n_prod - 1);
      printf("Encomenda %d\n", ide);
      for (i = 0; i < enc[ide].n_prod; i++)
        printf("* %s %d %d\n", stock[tab2[i]].descricao, stock[tab2[i]].preco, enc[ide].qtd[tab2[i]]);

    }
  }

}

int main()
{
  int c = 0;
  while (c != EOF)
  {
    switch (c = getchar())
    {
      case 'a':
        c = getchar();
        novo_produto();
        break;

      case 'q':
        c = getchar();
        add_stock();
        break;

      case 'N':
        nova_encomenda();
        break;

      case 'A':
        c = getchar();
        add_produto();
        break;

      case 'r':
        c = getchar();
        remove_stock();
        break;

      case 'R':
        c = getchar();
        remove_produto();
        break;

      case 'C':
        c = getchar();
        custo_encomenda();
        break;

      case 'p':
        c = getchar();
        altera_preco();
        break;

      case 'E':
        c = getchar();
        lista_produto();
        break;

      case 'm':
        c = getchar();
        lista_encomenda_produto();
        break;

      case 'l':
        lista_todos_produtos();
        break;

      case 'L':
        c = getchar();
        lista_encomenda_produtos();
        break;

      case 'x':
        break;

    }

    c = getchar();
  }

  return 0;
}

