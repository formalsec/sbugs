/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


int idp = 0;
int ide = 0;
typedef struct produto
{
  char descricao[64];
  int preco;
  int peso;
  int qtd;
  int posicao;
} produto;
typedef struct encomenda
{
  struct produto lista[500];
  int peso_total;
  int custo_total;
  int num_produtos;
} encomenda;
produto prod;
produto sistema[10000];
encomenda enco;
encomenda g_enco[500];
produto s_ord[10000];
produto any[10000];
produto any2[10000];
int ve_dentro(int ide2, int idp2)
{
  int i;
  for (i = 0; i < g_enco[ide2].num_produtos; i++)
  {
    if (strcmp(g_enco[ide2].lista[i].descricao, sistema[idp2].descricao) == 0)
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return -10;
}

void a(produto prod, produto sistema[])
{
  int preco;
  int peso;
  int qtd;
  for (int prod_index = 0; prod_index < 10; prod_index++)
  {
    prod.descricao[prod_index] = new_sym_var(sizeof(char) * 8);
  }

  prod.descricao[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  prod.preco = preco;
  prod.peso = peso;
  prod.qtd = qtd;
  sistema[idp] = prod;
  sistema[idp].posicao = idp;
  printf("Novo produto %d.\n", idp++);
}

void q(produto sistema[])
{
  int idp2;
  int qtd;
  idp2 = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp2 >= idp)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp2);
    }
  }
  else
  {
    {
      sistema[idp2].qtd += qtd;
    }
  }

}

void N(encomenda enco, encomenda g_enco[])
{
  g_enco[ide] = enco;
  printf("Nova encomenda %d.\n", ide++);
}

void A(encomenda g_enco[], produto sistema[])
{
  int ide2;
  int idp2;
  int qtd2;
  ide2 = new_sym_var(sizeof(int) * 8);
  idp2 = new_sym_var(sizeof(int) * 8);
  qtd2 = new_sym_var(sizeof(int) * 8);
  if (ide2 >= ide)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp2, ide2);
    }
  }
  else
  {
    if (idp2 >= idp)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp2, ide2);
      }
    }
    else
    {
      if (qtd2 > sistema[idp2].qtd)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp2, ide2);
        }
      }
      else
      {
        if ((g_enco[ide2].peso_total + (sistema[idp2].peso * qtd2)) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp2, ide2);
          }
        }
        else
        {
          {
            if (ve_dentro(ide2, idp2) != (-10))
            {
              {
                g_enco[ide2].lista[ve_dentro(ide2, idp2)].qtd += qtd2;
              }
            }
            else
            {
              {
                g_enco[ide2].lista[g_enco[ide2].num_produtos] = sistema[idp2];
                g_enco[ide2].lista[g_enco[ide2].num_produtos].qtd = qtd2;
                g_enco[ide2].num_produtos++;
              }
            }

            g_enco[ide2].peso_total += sistema[idp2].peso * qtd2;
            sistema[idp2].qtd -= qtd2;
          }
        }

      }

    }

  }

}

void r(produto sistema[])
{
  int idp2;
  int qtd2;
  idp2 = new_sym_var(sizeof(int) * 8);
  qtd2 = new_sym_var(sizeof(int) * 8);
  if (idp2 >= idp)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp2);
    }
  }
  else
  {
    if (sistema[idp2].qtd < qtd2)
    {
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd2, idp2);
      }
    }
    else
    {
      {
        sistema[idp2].qtd -= qtd2;
      }
    }

  }

}

void R(encomenda g_enco[], produto sistema[])
{
  int ide2;
  int idp2;
  ide2 = new_sym_var(sizeof(int) * 8);
  idp2 = new_sym_var(sizeof(int) * 8);
  if (ide2 >= ide)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp2, ide2);
    }
  }
  else
  {
    if (idp2 >= idp)
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp2, ide2);
      }
    }
    else
    {
      {
        if (ve_dentro(ide2, idp2) != (-10))
        {
          {
            g_enco[ide2].peso_total -= g_enco[ide2].lista[ve_dentro(ide2, idp2)].qtd * sistema[idp2].peso;
            sistema[idp2].qtd += g_enco[ide2].lista[ve_dentro(ide2, idp2)].qtd;
            g_enco[ide2].lista[ve_dentro(ide2, idp2)].qtd = 0;
          }
        }
        else
        {
          
        }

      }
    }

  }

}

void C(encomenda g_enco[])
{
  int ide2;
  int i;
  ide2 = new_sym_var(sizeof(int) * 8);
  if (ide2 >= ide)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide2);
    }
  }
  else
  {
    {
      for (i = 0; i < g_enco[ide2].num_produtos; i++)
      {
        g_enco[ide2].custo_total += g_enco[ide2].lista[i].preco * g_enco[ide2].lista[i].qtd;
      }

      printf("Custo da encomenda %d %d.\n", ide2, g_enco[ide2].custo_total);
      g_enco[ide2].custo_total = 0;
    }
  }

}

void p(encomenda g_enco[], produto sistema[])
{
  int idp2;
  int preco2;
  int b;
  int e;
  idp2 = new_sym_var(sizeof(int) * 8);
  preco2 = new_sym_var(sizeof(int) * 8);
  if (idp2 >= idp)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp2);
    }
  }
  else
  {
    {
      sistema[idp2].preco = preco2;
      for (b = 0; b < ide; b++)
      {
        for (e = 0; e < g_enco[b].num_produtos; e++)
        {
          if (ve_dentro(b, idp2) != (-10))
          {
            {
              g_enco[b].lista[ve_dentro(b, idp2)].preco = preco2;
            }
          }
          else
          {
            
          }

        }

      }

    }
  }

}

void E(encomenda g_enco[], produto sistema[])
{
  int ide2;
  int idp2;
  ide2 = new_sym_var(sizeof(int) * 8);
  idp2 = new_sym_var(sizeof(int) * 8);
  if (ide2 >= ide)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide2);
    }
  }
  else
  {
    if (idp2 >= idp)
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", idp2);
      }
    }
    else
    {
      {
        if (ve_dentro(ide2, idp2) != (-10))
        {
          {
            printf("%s %d.\n", g_enco[ide2].lista[ve_dentro(ide2, idp2)].descricao, g_enco[ide2].lista[ve_dentro(ide2, idp2)].qtd);
          }
        }
        else
        {
          {
            printf("%s 0.\n", sistema[idp2].descricao);
          }
        }

      }
    }

  }

}

void m(encomenda g_enco[])
{
  int idp2;
  int maior_qtd;
  int b;
  int e;
  int ide_menor;
  idp2 = new_sym_var(sizeof(int) * 8);
  if (idp2 >= idp)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp2);
    }
  }
  else
  {
    
  }

  maior_qtd = 0;
  ide_menor = 0;
  for (b = 0; b < ide; b++)
  {
    for (e = 0; e < g_enco[b].num_produtos; e++)
    {
      if ((ve_dentro(b, idp2) != (-10)) && (maior_qtd < g_enco[b].lista[ve_dentro(b, idp2)].qtd))
      {
        {
          maior_qtd = g_enco[b].lista[ve_dentro(b, idp2)].qtd;
          ide_menor = b;
        }
      }
      else
      {
        
      }

    }

  }

  if (maior_qtd != 0)
  {
    {
      printf("Maximo produto %d %d %d.\n", idp2, ide_menor, maior_qtd);
    }
  }
  else
  {
    
  }

}

int Compara_Preco(produto anterior, produto posterior)
{
  if (anterior.preco < posterior.preco)
  {
    {
      return 1;
    }
  }
  else
  {
    if (anterior.preco == posterior.preco)
    {
      {
        return anterior.posicao < posterior.posicao;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

int Compara_Letras(produto anterior, produto posterior)
{
  if (strcmp(anterior.descricao, posterior.descricao) < 0)
  {
    {
      return 1;
    }
  }
  else
  {
    
  }

  return 0;
}

void merge(int b, produto auxiliar[], int esquerda, int m, int direita)
{
  int i;
  int j;
  int k;
  if (b == (-3))
  {
    {
      for (i = m + 1; i > esquerda; i--)
        any[i - 1] = auxiliar[i - 1];

      for (j = m; j < direita; j++)
        any[(direita + m) - j] = auxiliar[j + 1];

      for (k = esquerda; k <= direita; k++)
        if (Compara_Preco(any[j], any[i]) == 1)
      {
        auxiliar[k] = any[j--];
      }
      else
      {
        auxiliar[k] = any[i++];
      }


    }
  }
  else
  {
    if (b == (-2))
    {
      {
        for (i = m + 1; i > esquerda; i--)
          any2[i - 1] = auxiliar[i - 1];

        for (j = m; j < direita; j++)
          any2[(direita + m) - j] = auxiliar[j + 1];

        for (k = esquerda; k <= direita; k++)
          if (Compara_Letras(any2[j], any2[i]) == 1)
        {
          auxiliar[k] = any2[j--];
        }
        else
        {
          auxiliar[k] = any2[i++];
        }


      }
    }
    else
    {
      
    }

  }

}

void mergesort(int b, produto auxiliar[], int esquerda, int direita)
{
  int m = (direita + esquerda) / 2;
  if (direita <= esquerda)
  {
    return;
  }
  else
  {
    
  }

  mergesort(b, auxiliar, esquerda, m);
  mergesort(b, auxiliar, m + 1, direita);
  merge(b, auxiliar, esquerda, m, direita);
}

void l(produto sistema[])
{
  int i;
  if (idp == 0)
  {
    {
      printf("Produtos\n");
    }
  }
  else
  {
    {
      for (i = 0; i < idp; i++)
      {
        s_ord[i] = sistema[i];
      }

      mergesort(-3, s_ord, 0, idp - 1);
      printf("Produtos\n");
      for (i = 0; i < idp; i++)
      {
        printf("* %s %d %d\n", s_ord[i].descricao, s_ord[i].preco, s_ord[i].qtd);
      }

    }
  }

}

void L(encomenda g_enco[])
{
  int ide2;
  int i;
  ide2 = new_sym_var(sizeof(int) * 8);
  if (ide2 >= ide)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide2);
    }
  }
  else
  {
    if (g_enco[ide2].num_produtos == 0)
    {
      {
        printf("Encomenda %d\n", ide2);
      }
    }
    else
    {
      {
        mergesort(-2, g_enco[ide2].lista, 0, g_enco[ide2].num_produtos - 1);
        printf("Encomenda %d\n", ide2);
        for (i = 0; i < g_enco[ide2].num_produtos; i++)
        {
          if (g_enco[ide2].lista[i].qtd > 0)
          {
            {
              printf("* %s %d %d\n", g_enco[ide2].lista[i].descricao, g_enco[ide2].lista[i].preco, g_enco[ide2].lista[i].qtd);
            }
          }
          else
          {
            
          }

        }

      }
    }

  }

}

int main()
{
  char letra_inicial;
  while (10000 > 0)
  {
    letra_inicial = getchar();
    if (letra_inicial == 'a')
    {
      a(prod, sistema);
    }
    else
    {
      if (letra_inicial == 'x')
      {
        break;
      }
      else
      {
        if (letra_inicial == 'q')
        {
          q(sistema);
        }
        else
        {
          if (letra_inicial == 'l')
          {
            l(sistema);
          }
          else
          {
            if (letra_inicial == 'N')
            {
              N(enco, g_enco);
            }
            else
            {
              if (letra_inicial == 'A')
              {
                A(g_enco, sistema);
              }
              else
              {
                if (letra_inicial == 'r')
                {
                  r(sistema);
                }
                else
                {
                  if (letra_inicial == 'R')
                  {
                    R(g_enco, sistema);
                  }
                  else
                  {
                    if (letra_inicial == 'C')
                    {
                      C(g_enco);
                    }
                    else
                    {
                      if (letra_inicial == 'p')
                      {
                        p(g_enco, sistema);
                      }
                      else
                      {
                        if (letra_inicial == 'E')
                        {
                          E(g_enco, sistema);
                        }
                        else
                        {
                          if (letra_inicial == 'm')
                          {
                            m(g_enco);
                          }
                          else
                          {
                            if (letra_inicial == 'L')
                            {
                              L(g_enco);
                            }
                            else
                            {
                              
                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return 0;
}

