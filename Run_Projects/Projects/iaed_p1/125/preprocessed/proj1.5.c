/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef int booleano;
typedef struct 
{
  char desc[64];
  int preco;
  int peso;
  int qtd;
  int idp;
} Produto;
typedef struct 
{
  int idp[200];
  int qtd[200];
  int alfa[200];
  int peso;
  int preco;
  signed int n;
} Encomenda;
Produto prod[10000 + 1];
Encomenda enc[500];
int naturais[10000];
int aux[10000];
signed int idp_max = -1;
signed int ide_max = -1;
int binarySearch(int v[], int left, int b, int proc, int negativo)
{
  int meio = left + ((b - left) / 2);
  if (b >= left)
  {
    if (v[meio] == proc)
    {
      return meio;
    }
    else
    {
      
    }

    if (v[meio] > proc)
    {
      return binarySearch(v, left, meio - 1, proc, negativo);
    }
    else
    {
      
    }

    return binarySearch(v, meio + 1, b, proc, negativo);
  }
  else
  {
    
  }

  if (negativo == 1)
  {
    return -1;
  }
  else
  {
    return meio;
  }

}

int binarySearchStr(int v[], int left, int b, int idp)
{
  int meio = left + ((b - left) / 2);
  if (b >= left)
  {
    if (strcmp(prod[v[meio]].desc, prod[idp].desc) == 0)
    {
      return meio;
    }
    else
    {
      
    }

    if (strcmp(prod[v[meio]].desc, prod[idp].desc) > 0)
    {
      return binarySearchStr(v, left, meio - 1, idp);
    }
    else
    {
      
    }

    return binarySearchStr(v, meio + 1, b, idp);
  }
  else
  {
    
  }

  return meio;
}

void merge(int a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
    if ((prod[aux[j]].preco < prod[aux[i]].preco) || (i > m))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

void mergesort(int a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, left, m);
  mergesort(a, m + 1, right);
  merge(a, left, m, right);
}

void mover_array(int v[], int dim, int ponto, int casas)
{
  int contador;
  if (casas < 0)
  {
    for (contador = ponto + 1; contador <= dim; contador++)
      v[casas + contador] = v[contador];

  }
  else
  {
    for (contador = dim; contador >= ponto; contador--)
      v[casas + contador] = v[contador];

  }

}

void a()
{
  char desc[64];
  int preco;
  int peso;
  int qtd;
  for (int desc_index = 0; desc_index < 10; desc_index++)
  {
    desc[desc_index] = new_sym_var(sizeof(char) * 8);
  }

  desc[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  idp_max++;
  strcpy(prod[idp_max].desc, desc);
  prod[idp_max].preco = preco;
  prod[idp_max].peso = peso;
  prod[idp_max].qtd = qtd;
  printf("Novo produto %d.\n", idp_max);
}

void q()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp > idp_max)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    prod[idp].qtd += qtd;
  }

}

void N()
{
  ide_max++;
  enc[ide_max].n = -1;
  enc[ide_max].peso = 0;
  enc[ide_max].preco = 0;
  printf("Nova encomenda %d.\n", ide_max);
}

void A()
{
  int ide;
  int idp;
  int qtd;
  int index;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide > ide_max)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp > idp_max)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (prod[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if (enc[ide].n == (-1))
        {
          enc[ide].peso = prod[idp].peso * qtd;
          if (enc[ide].peso <= 200)
          {
            enc[ide].n++;
            enc[ide].idp[0] = idp;
            enc[ide].qtd[0] = qtd;
            enc[ide].alfa[0] = idp;
            enc[ide].preco = prod[idp].preco * qtd;
            prod[idp].qtd -= qtd;
          }
          else
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
            enc[ide].peso = 0;
          }

        }
        else
        {
          enc[ide].peso += prod[idp].peso * qtd;
          if (enc[ide].peso <= 200)
          {
            index = binarySearch(enc[ide].idp, 0, enc[ide].n, idp, 1);
            if (index < 0)
            {
              index = binarySearch(enc[ide].idp, 0, enc[ide].n, idp, 0);
              mover_array(enc[ide].idp, enc[ide].n, index, 1);
              enc[ide].idp[index] = idp;
              mover_array(enc[ide].qtd, enc[ide].n, index, 1);
              enc[ide].qtd[index] = qtd;
              index = binarySearchStr(enc[ide].alfa, 0, enc[ide].n, idp);
              mover_array(enc[ide].alfa, enc[ide].n, index, 1);
              enc[ide].alfa[index] = idp;
              enc[ide].n++;
            }
            else
            {
              enc[ide].qtd[index] += qtd;
            }

            enc[ide].preco += prod[idp].preco * qtd;
            prod[idp].qtd -= qtd;
          }
          else
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
            enc[ide].peso -= prod[idp].peso * qtd;
          }

        }

      }

    }

  }

}

void r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp > idp_max)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (prod[idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      prod[idp].qtd -= qtd;
    }

  }

}

void R()
{
  int ide;
  int idp;
  int index;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > ide_max)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp > idp_max)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      
    }

  }

  index = binarySearch(enc[ide].idp, 0, enc[ide].n, idp, 1);
  if (index >= 0)
  {
    enc[ide].peso -= enc[ide].qtd[index] * prod[idp].peso;
    enc[ide].preco -= enc[ide].qtd[index] * prod[idp].preco;
    prod[idp].qtd += enc[ide].qtd[index];
    mover_array(enc[ide].idp, enc[ide].n + 1, index, -1);
    mover_array(enc[ide].qtd, enc[ide].n + 1, index, -1);
    index = binarySearchStr(enc[ide].alfa, 0, enc[ide].n, idp);
    mover_array(enc[ide].alfa, enc[ide].n + 1, index, -1);
    enc[ide].n--;
  }
  else
  {
    
  }

}

void C()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > ide_max)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    printf("Custo da encomenda %d %d.\n", ide, enc[ide].preco);
  }

}

void p()
{
  int idp;
  int preco;
  int contador;
  int index;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp > idp_max)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (contador = 0; contador <= ide_max; contador++)
    {
      index = binarySearch(enc[contador].idp, 0, enc[contador].n, idp, 1);
      if (index >= 0)
      {
        enc[contador].preco -= enc[contador].qtd[index] * prod[idp].preco;
        enc[contador].preco += enc[contador].qtd[index] * preco;
      }
      else
      {
        
      }

    }

    prod[idp].preco = preco;
  }

}

void E()
{
  int ide;
  int idp;
  int index;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > ide_max)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp > idp_max)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      index = binarySearch(enc[ide].idp, 0, enc[ide].n, idp, 1);
      printf("%s ", prod[idp].desc);
      if (index >= 0)
      {
        printf("%d.\n", enc[ide].qtd[index]);
      }
      else
      {
        printf("0.\n");
      }

    }

  }

}

void m()
{
  int idp;
  int index;
  int contador;
  int qtd = 0;
  int ide_procurado;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp > idp_max)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (contador = 0; contador <= ide_max; contador++)
    {
      index = binarySearch(enc[contador].idp, 0, enc[contador].n, idp, 1);
      if (index >= 0)
      {
        if (enc[contador].qtd[index] > qtd)
        {
          ide_procurado = contador;
          qtd = enc[contador].qtd[index];
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (qtd > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide_procurado, qtd);
    }
    else
    {
      
    }

  }

}

void l()
{
  int contador;
  int idp;
  printf("Produtos\n");
  for (contador = 0; contador <= idp_max; contador++)
    naturais[contador] = contador;

  mergesort(naturais, 0, idp_max);
  for (contador = 0; contador <= idp_max; contador++)
  {
    idp = naturais[contador];
    printf("* %s %d %d\n", prod[idp].desc, prod[idp].preco, prod[idp].qtd);
  }

}

void L()
{
  int ide;
  int idp;
  int index;
  int contador;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > ide_max)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    printf("Encomenda %d\n", ide);
    for (contador = 0; contador <= enc[ide].n; contador++)
    {
      idp = enc[ide].alfa[contador];
      index = binarySearch(enc[ide].idp, 0, enc[ide].n, idp, 1);
      printf("* %s %d %d\n", prod[idp].desc, prod[idp].preco, enc[ide].qtd[index]);
    }

  }

}

int main()
{
  char comando;
  while (comando != 'x')
  {
    comando = new_sym_var(sizeof(char) * 8);
    switch (comando)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

    }

  }

  return 0;
}

