/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int identificador;
  char descricao[64];
  int preco;
  int peso;
  int quantidade;
} produto;
typedef struct 
{
  int identificador;
  int quantidade;
} produto_encomenda;
typedef struct 
{
  int identificador;
  produto_encomenda produtos[200];
  int peso;
} encomenda;
void comando_a(produto produtos[]);
void comando_q(produto produtos[]);
void comando_N(encomenda encomendas[]);
void comando_A(produto produtos[], encomenda encomendas[]);
void comando_r(produto produtos[]);
void comando_R(produto produtos[], encomenda encomendas[]);
void comando_C(produto produtos[], encomenda encomendas[]);
void comando_p(produto produtos[]);
void comando_E(produto produtos[], encomenda encomendas[]);
void comando_m(encomenda encomendas[]);
void comando_l(produto produtos[]);
void comando_L(produto produtos[], encomenda encomendas[]);
int produto_existe(int idp);
int encomenda_existe(int ide);
int indice_produto_encomenda(encomenda encomendas[], int ide, int idp);
void mergesort_preco(produto produtos[], int left, int right);
void merge_preco(produto produtos[], int left, int m, int right);
void mergesort_descricao(produto produtos[], int left, int right);
void merge_descricao(produto produtos[], int left, int m, int right);
int conta_produtos = 0;
int conta_encomendas = 0;
int main()
{
  char comando;
  produto produtos_sistema[10000];
  encomenda encomendas_sistema[500];
  while (1)
  {
    comando = getchar();
    switch (comando)
    {
      case 'a':
      {
        comando_a(produtos_sistema);
        break;
      }

      case 'q':
      {
        comando_q(produtos_sistema);
        break;
      }

      case 'N':
      {
        comando_N(encomendas_sistema);
        break;
      }

      case 'A':
      {
        comando_A(produtos_sistema, encomendas_sistema);
        break;
      }

      case 'r':
      {
        comando_r(produtos_sistema);
        break;
      }

      case 'R':
      {
        comando_R(produtos_sistema, encomendas_sistema);
        break;
      }

      case 'C':
      {
        comando_C(produtos_sistema, encomendas_sistema);
        break;
      }

      case 'p':
      {
        comando_p(produtos_sistema);
        break;
      }

      case 'E':
      {
        comando_E(produtos_sistema, encomendas_sistema);
        break;
      }

      case 'm':
      {
        comando_m(encomendas_sistema);
        break;
      }

      case 'l':
      {
        comando_l(produtos_sistema);
        break;
      }

      case 'L':
      {
        comando_L(produtos_sistema, encomendas_sistema);
        break;
      }

      case 'x':
      {
        return 0;
      }

    }

    getchar();
  }

  return 0;
}

int produto_existe(int idp)
{
  return (idp >= 0) && (idp < conta_produtos);
}

int encomenda_existe(int ide)
{
  return (ide >= 0) && (ide < conta_encomendas);
}

int indice_produto_encomenda(encomenda encomendas[], int ide, int idp)
{
  int i;
  for (i = 0; i < 200; i++)
    if (encomendas[ide].produtos[i].identificador == idp)
  {
    return i;
  }
  else
  {
    
  }


  return -1;
}

void comando_a(produto produtos[])
{
  if (conta_produtos < 10000)
  {
    for (int produtos_index = 0; produtos_index < 10; produtos_index++)
    {
      produtos[conta_produtos].descricao[produtos_index] = new_sym_var(sizeof(char) * 8);
    }

    produtos[conta_produtos].descricao[10 - 1] = '\0';
    produtos[conta_produtos].preco = new_sym_var(sizeof(int) * 8);
    produtos[conta_produtos].peso = new_sym_var(sizeof(int) * 8);
    produtos[conta_produtos].quantidade = new_sym_var(sizeof(int) * 8);
    produtos[conta_produtos].identificador = conta_produtos;
    printf("Novo produto %d.\n", conta_produtos);
    conta_produtos++;
  }
  else
  {
    
  }

}

void comando_q(produto produtos[])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (produto_existe(idp))
  {
    produtos[idp].quantidade += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void comando_N(encomenda encomendas[])
{
  int i;
  if (conta_encomendas < 500)
  {
    encomendas[conta_encomendas].identificador = conta_encomendas;
    for (i = 0; i < 200; i++)
      encomendas[conta_encomendas].produtos[i].identificador = -1;

    printf("Nova encomenda %d.\n", conta_encomendas);
    conta_encomendas++;
  }
  else
  {
    
  }

}

void comando_A(produto produtos[], encomenda encomendas[])
{
  int ide;
  int idp;
  int qtd;
  int novo_peso;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (!produto_existe(idp))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (produtos[idp].quantidade < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((novo_peso = encomendas[ide].peso + (qtd * produtos[idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de %d.\n", idp, ide, 200);
        }
        else
        {
          i = indice_produto_encomenda(encomendas, ide, idp);
          if (i != (-1))
          {
            encomendas[ide].produtos[i].quantidade += qtd;
          }
          else
          {
            i = indice_produto_encomenda(encomendas, ide, -1);
            encomendas[ide].produtos[i].identificador = idp;
            encomendas[ide].produtos[i].quantidade = qtd;
          }

          encomendas[ide].peso = novo_peso;
          produtos[idp].quantidade -= qtd;
        }

      }

    }

  }

}

void comando_r(produto produtos[])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (!produto_existe(idp))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (produtos[idp].quantidade < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      produtos[idp].quantidade -= qtd;
    }

  }

}

void comando_R(produto produtos[], encomenda encomendas[])
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (!produto_existe(idp))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      i = indice_produto_encomenda(encomendas, ide, idp);
      if (i != (-1))
      {
        encomendas[ide].peso -= encomendas[ide].produtos[i].quantidade * produtos[idp].peso;
        produtos[idp].quantidade += encomendas[ide].produtos[i].quantidade;
        encomendas[ide].produtos[i].quantidade = 0;
        encomendas[ide].produtos[i].identificador = -1;
      }
      else
      {
        
      }

    }

  }

}

void comando_C(produto produtos[], encomenda encomendas[])
{
  int ide;
  int idp;
  int i;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < 200; i++)
    {
      if ((idp = encomendas[ide].produtos[i].identificador) != (-1))
      {
        total += produtos[idp].preco * encomendas[ide].produtos[i].quantidade;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d %d.\n", ide, total);
  }

}

void comando_p(produto produtos[])
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (!produto_existe(idp))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].preco = preco;
  }

}

void comando_E(produto produtos[], encomenda encomendas[])
{
  int ide;
  int idp;
  int quantidade;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (!produto_existe(idp))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      i = indice_produto_encomenda(encomendas, ide, idp);
      if (i == (-1))
      {
        quantidade = 0;
      }
      else
      {
        quantidade = encomendas[ide].produtos[i].quantidade;
      }

      printf("%s %d.\n", produtos[idp].descricao, quantidade);
    }

  }

}

void comando_m(encomenda encomendas[])
{
  int idp;
  int ide;
  int i;
  int max_ide = -1;
  int max_qtd = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (!produto_existe(idp))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (conta_encomendas > 0)
    {
      for (ide = 0; ide < conta_encomendas; ide++)
        if ((i = indice_produto_encomenda(encomendas, ide, idp)) != (-1))
      {
        if (encomendas[ide].produtos[i].quantidade > max_qtd)
        {
          max_qtd = encomendas[ide].produtos[i].quantidade;
          max_ide = ide;
        }
        else
        {
          
        }

      }
      else
      {
        
      }


      if (max_qtd > 0)
      {
        printf("Maximo produto %d %d %d.\n", idp, max_ide, max_qtd);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

}

void comando_l(produto produtos[])
{
  int i;
  produto copia[10000];
  for (i = 0; i < conta_produtos; i++)
    copia[i] = produtos[i];

  mergesort_preco(copia, 0, conta_produtos - 1);
  printf("Produtos\n");
  for (i = 0; i < conta_produtos; i++)
  {
    printf("* %s %d %d\n", copia[i].descricao, copia[i].preco, copia[i].quantidade);
  }

}

void mergesort_preco(produto produtos[], int left, int right)
{
  int meio = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort_preco(produtos, left, meio);
  mergesort_preco(produtos, meio + 1, right);
  merge_preco(produtos, left, meio, right);
}

void merge_preco(produto produtos[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  produto aux[10000];
  for (i = m + 1; i > left; i--)
    aux[i - 1] = produtos[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = produtos[j + 1];

  for (k = left; k <= right; k++)
  {
    if ((aux[j].preco < aux[i].preco) || (i > m))
    {
      produtos[k] = aux[j--];
    }
    else
    {
      produtos[k] = aux[i++];
    }

  }

}

void comando_L(produto produtos[], encomenda encomendas[])
{
  int ide;
  int i;
  int j;
  int conta_prods_encom;
  int idp;
  int qtd;
  produto prods_encom[200];
  ide = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    conta_prods_encom = 0;
    for (i = 0; i < 200; i++)
    {
      if ((idp = encomendas[ide].produtos[i].identificador) != (-1))
      {
        prods_encom[conta_prods_encom] = produtos[idp];
        conta_prods_encom++;
      }
      else
      {
        
      }

    }

    mergesort_descricao(prods_encom, 0, conta_prods_encom - 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < conta_prods_encom; i++)
    {
      idp = prods_encom[i].identificador;
      j = indice_produto_encomenda(encomendas, ide, idp);
      qtd = encomendas[ide].produtos[j].quantidade;
      printf("* %s %d %d\n", prods_encom[i].descricao, prods_encom[i].preco, qtd);
    }

  }

}

void mergesort_descricao(produto produtos[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort_descricao(produtos, left, m);
  mergesort_descricao(produtos, m + 1, right);
  merge_descricao(produtos, left, m, right);
}

void merge_descricao(produto produtos[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  produto aux[200];
  for (i = m + 1; i > left; i--)
    aux[i - 1] = produtos[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = produtos[j + 1];

  for (k = left; k <= right; k++)
  {
    if ((strcmp(aux[j].descricao, aux[i].descricao) < 0) || (i > m))
    {
      produtos[k] = aux[j--];
    }
    else
    {
      produtos[k] = aux[i++];
    }

  }

}

