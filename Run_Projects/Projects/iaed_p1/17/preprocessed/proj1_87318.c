/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct produtos
{
  int idp;
  int preco;
  int peso;
  int qtd;
  char descricao[63];
} produtos;
typedef struct encomendas
{
  int ide;
  int num_prods;
  int prod[9999];
  int qtds[9999];
} encomendas;
static struct produtos Produto[9999];
static struct encomendas Encomenda[499];
static int n_produtos = -1;
static int n_encomendas = -1;
void Funcao_a(char argum[])
{
  const char separador[2] = ":";
  char *var_aux;
  char desc[63];
  int price;
  int weight;
  int qt;
  var_aux = strtok(argum, separador);
  strcpy(desc, var_aux);
  var_aux = strtok(0, separador);
  price = atoi(var_aux);
  var_aux = strtok(0, separador);
  weight = atoi(var_aux);
  var_aux = strtok(0, separador);
  qt = atoi(var_aux);
  n_produtos++;
  Produto[n_produtos].idp = n_produtos;
  strcpy(Produto[n_produtos].descricao, desc);
  Produto[n_produtos].preco = price;
  Produto[n_produtos].peso = weight;
  Produto[n_produtos].qtd = qt;
  printf("Novo produto %d.\n", Produto[n_produtos].idp);
}

int Funcao_q(char argum[])
{
  const char separador[2] = ":";
  char *var_aux;
  int id;
  int qt;
  int i;
  var_aux = strtok(argum, separador);
  id = atoi(var_aux);
  var_aux = strtok(0, separador);
  qt = atoi(var_aux);
  for (i = 0; i <= n_produtos; i++)
  {
    if (Produto[i].idp == id)
    {
      Produto[i].qtd = Produto[i].qtd + qt;
      return 0;
    }
    else
    {
      
    }

  }

  printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  return 1;
}

void Funcao_N()
{
  n_encomendas++;
  Encomenda[n_encomendas].ide = n_encomendas;
  Encomenda[n_encomendas].num_prods = 0;
  printf("Nova encomenda %d.\n", Encomenda[n_encomendas].ide);
}

int Funcao_r(int id, int qt)
{
  int i;
  for (i = 0; i <= n_produtos; i++)
  {
    if (Produto[i].idp == id)
    {
      if (Produto[i].qtd >= qt)
      {
        Produto[i].qtd = Produto[i].qtd - qt;
        return 0;
      }
      else
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qt, id);
        return 1;
      }

    }
    else
    {
      
    }

  }

  printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id);
  return 2;
}

int Funcao_A(char argum[])
{
  const char separador[2] = ":";
  char *var_aux;
  int id_e;
  int id_p;
  int qt;
  int i;
  int j;
  int k;
  int l;
  int peso_total = 0;
  var_aux = strtok(argum, separador);
  id_e = atoi(var_aux);
  var_aux = strtok(0, separador);
  id_p = atoi(var_aux);
  var_aux = strtok(0, separador);
  qt = atoi(var_aux);
  for (i = 0; i <= n_encomendas; i++)
  {
    if ((Encomenda[i].ide == id_e) && (id_e >= 0))
    {
      for (j = 0; j <= n_produtos; j++)
      {
        if ((Produto[j].idp == id_p) && (id_p >= 0))
        {
          if (Encomenda[i].num_prods == 0)
          {
            if (Produto[j].qtd >= qt)
            {
              if ((qt * Produto[j].peso) <= 200)
              {
                Encomenda[i].prod[0] = id_p;
                Encomenda[i].qtds[0] = qt;
                Encomenda[i].num_prods++;
                Funcao_r(id_p, qt);
                return 0;
              }
              else
              {
                printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_p, id_e);
                return 1;
              }

            }
            else
            {
              printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_p, id_e);
              return 2;
            }

          }
          else
          {
            if (Encomenda[i].num_prods > 0)
            {
              for (l = 0; l < Encomenda[i].num_prods; l++)
              {
                peso_total = peso_total + (Encomenda[i].qtds[l] * Produto[Encomenda[i].prod[l]].peso);
              }

              for (k = 0; k < Encomenda[i].num_prods; k++)
              {
                if (Encomenda[i].prod[k] == id_p)
                {
                  if (qt <= Produto[j].qtd)
                  {
                    if ((peso_total + (qt * Produto[j].peso)) <= 200)
                    {
                      Encomenda[i].qtds[k] = Encomenda[i].qtds[k] + qt;
                      Funcao_r(id_p, qt);
                      return 0;
                    }
                    else
                    {
                      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_p, id_e);
                      return 1;
                    }

                  }
                  else
                  {
                    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_p, id_e);
                    return 2;
                  }

                }
                else
                {
                  
                }

              }

              if (Produto[j].qtd >= qt)
              {
                if ((peso_total + (qt * Produto[j].peso)) <= 200)
                {
                  Encomenda[i].prod[Encomenda[i].num_prods] = id_p;
                  Encomenda[i].qtds[Encomenda[i].num_prods] = qt;
                  Encomenda[i].num_prods++;
                  Funcao_r(id_p, qt);
                  return 0;
                }
                else
                {
                  printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_p, id_e);
                  return 1;
                }

              }
              else
              {
                printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_p, id_e);
                return 2;
              }

            }
            else
            {
              
            }

          }

        }
        else
        {
          
        }

      }

      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id_p, id_e);
      return 3;
    }
    else
    {
      
    }

  }

  printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id_p, id_e);
  return 4;
}

int Funcao_R(char argum[])
{
  const char separador[2] = ":";
  char *var_aux;
  int id_e;
  int id_p;
  int i;
  int j;
  int k;
  int posi;
  int qt_prod;
  var_aux = strtok(argum, separador);
  id_e = atoi(var_aux);
  var_aux = strtok(0, separador);
  id_p = atoi(var_aux);
  for (i = 0; i <= n_encomendas; i++)
  {
    if (Encomenda[i].ide == id_e)
    {
      for (j = 0; j <= n_produtos; j++)
      {
        if (Produto[j].idp == id_p)
        {
          for (k = 0; k < Encomenda[i].num_prods; k++)
          {
            if (Encomenda[i].prod[k] == id_p)
            {
              qt_prod = Encomenda[i].qtds[k];
              posi = k;
              Encomenda[i].num_prods = Encomenda[i].num_prods - 1;
            }
            else
            {
              
            }

          }

          for (k = posi; k < Encomenda[i].num_prods; k++)
          {
            Encomenda[i].prod[k] = Encomenda[i].prod[k + 1];
            Encomenda[i].qtds[k] = Encomenda[i].qtds[k + 1];
          }

          Produto[j].qtd = Produto[j].qtd + qt_prod;
          return 0;
        }
        else
        {
          
        }

      }

      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_p, id_e);
      return 1;
    }
    else
    {
      
    }

  }

  printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id_p, id_e);
  return 2;
}

int Funcao_C(char argum[])
{
  int id_e;
  int i;
  int j;
  int preco_total = 0;
  id_e = atoi(argum);
  for (i = 0; i <= n_encomendas; i++)
  {
    if (Encomenda[i].ide == id_e)
    {
      for (j = 0; j < Encomenda[i].num_prods; j++)
      {
        preco_total = preco_total + (Encomenda[i].qtds[j] * Produto[Encomenda[i].prod[j]].preco);
      }

      printf("Custo da encomenda %d %d.\n", id_e, preco_total);
      return 0;
    }
    else
    {
      
    }

  }

  printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", id_e);
  return 1;
}

int Funcao_p(char argum[])
{
  const char separador[2] = ":";
  char *var_aux;
  int id;
  int price;
  int i;
  var_aux = strtok(argum, separador);
  id = atoi(var_aux);
  var_aux = strtok(0, separador);
  price = atoi(var_aux);
  for (i = 0; i <= n_produtos; i++)
  {
    if (Produto[i].idp == id)
    {
      Produto[i].preco = price;
      return 0;
    }
    else
    {
      
    }

  }

  printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id);
  return 1;
}

int Funcao_E(char argum[])
{
  const char separador[2] = ":";
  char *var_aux;
  int id_e;
  int id_p;
  int i;
  int j;
  int k;
  int qtd = 0;
  var_aux = strtok(argum, separador);
  id_e = atoi(var_aux);
  var_aux = strtok(0, separador);
  id_p = atoi(var_aux);
  for (i = 0; i <= n_encomendas; i++)
  {
    if (Encomenda[i].ide == id_e)
    {
      for (j = 0; j <= n_produtos; j++)
      {
        if (Produto[j].idp == id_p)
        {
          for (k = 0; k < Encomenda[i].num_prods; k++)
          {
            if (Encomenda[i].prod[k] == id_p)
            {
              qtd = Encomenda[i].qtds[k];
            }
            else
            {
              
            }

          }

          printf("%s %d.\n", Produto[j].descricao, qtd);
          return 0;
        }
        else
        {
          
        }

      }

      printf("Impossivel listar produto %d. Produto inexistente.\n", id_p);
      return 1;
    }
    else
    {
      
    }

  }

  printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_e);
  return 2;
}

int Funcao_m(char argum[])
{
  int id_p;
  int i;
  int j;
  int k;
  int id_e = 0;
  int maior = 0;
  int flag = 0;
  id_p = atoi(argum);
  for (i = 0; i <= n_produtos; i++)
  {
    if (Produto[i].idp == id_p)
    {
      if (n_encomendas < 0)
      {
        return 0;
      }
      else
      {
        for (j = 0; j <= n_encomendas; j++)
        {
          for (k = 0; k < Encomenda[j].num_prods; k++)
          {
            if (Encomenda[j].prod[k] == id_p)
            {
              if (Encomenda[j].qtds[k] > maior)
              {
                id_e = j;
                maior = Encomenda[j].qtds[k];
                flag = 1;
              }
              else
              {
                
              }

            }
            else
            {
              
            }

          }

        }

        if (flag == 1)
        {
          printf("Maximo produto %d %d %d.\n", id_p, id_e, maior);
          return 0;
        }
        else
        {
          return 0;
        }

      }

    }
    else
    {
      
    }

  }

  printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id_p);
  return 1;
}

int Funcao_L(char argum[])
{
  int id;
  int i;
  id = atoi(argum);
  for (i = 0; i <= n_encomendas; i++)
  {
    if (Encomenda[i].ide == id)
    {
      return 0;
    }
    else
    {
      
    }

  }

  printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id);
  return 1;
}

int main()
{
  char c;
  char argum[2048];
  while ((c = getchar()) != EOF)
  {
    getchar();
    switch (c)
    {
      case 'a':
      {
        fgets(argum, 2048, stdin);
        Funcao_a(argum);
        break;
      }

      case 'q':
      {
        fgets(argum, 2048, stdin);
        Funcao_q(argum);
        break;
      }

      case 'N':
      {
        Funcao_N();
        break;
      }

      case 'A':
      {
        fgets(argum, 2048, stdin);
        Funcao_A(argum);
        break;
      }

      case 'r':
      {
        const char separador[2] = ":";
        char *var_aux;
        int id;
        int qt;
        fgets(argum, 2048, stdin);
        var_aux = strtok(argum, separador);
        id = atoi(var_aux);
        var_aux = strtok(0, separador);
        qt = atoi(var_aux);
        Funcao_r(id, qt);
        break;
      }

      case 'R':
      {
        fgets(argum, 2048, stdin);
        Funcao_R(argum);
        break;
      }

      case 'C':
      {
        fgets(argum, 2048, stdin);
        Funcao_C(argum);
        break;
      }

      case 'p':
      {
        fgets(argum, 2048, stdin);
        Funcao_p(argum);
        break;
      }

      case 'E':
      {
        fgets(argum, 2048, stdin);
        Funcao_E(argum);
        break;
      }

      case 'm':
      {
        fgets(argum, 2048, stdin);
        Funcao_m(argum);
        break;
      }

      case 'L':
      {
        fgets(argum, 2048, stdin);
        Funcao_L(argum);
        break;
      }

      case 'x':
      {
        return 0;
      }

      default:
      {
        fprintf(stderr, "Erro: operacao invalida!\n");
        return 1;
      }

    }

  }

  return 0;
}

