/*File generated by PreProcessor.py*/


#include <stdio.h>


typedef struct 
{
  char desc[62];
  int preco;
  int peso;
  int stock;
} produto;
typedef struct 
{
  int produtos[200];
  int quantidade[200];
  int peso;
  int contador;
} encomenda;
void merge(const produto lista_p[9999], int vetor_id[9999], int l_inf, int m, int l_sup)
{
  int i;
  int j;
  int k;
  int aux[9999];
  for (i = m + 1; i > l_inf; i--)
  {
    aux[i - 1] = vetor_id[i - 1];
  }

  for (j = m; j < l_sup; j++)
  {
    aux[(l_sup + m) - j] = vetor_id[j + 1];
  }

  for (k = l_inf; k <= l_sup; k++)
  {
    if ((lista_p[aux[j]].preco < lista_p[aux[i]].preco) || (i > m))
    {
      vetor_id[k] = aux[j--];
    }
    else
    {
      vetor_id[k] = aux[i++];
    }

  }

  return;
}

void mergesort(const produto lista_p[9999], int vetor_id[9999], int l_inf, int l_sup)
{
  int meio;
  meio = (l_inf + l_sup) / 2;
  if (l_sup <= l_inf)
  {
    return;
  }
  else
  {
    
  }

  mergesort(lista_p, vetor_id, l_inf, meio);
  mergesort(lista_p, vetor_id, meio + 1, l_sup);
  merge(lista_p, vetor_id, l_inf, meio, l_sup);
  return;
}

void troca_int(int vetor[], int i, int j)
{
  int aux;
  aux = vetor[j];
  vetor[j] = vetor[i];
  vetor[i] = aux;
  return;
}

int particao(const produto lista_p[9999], encomenda lista_e[499], int ide, int l_inf, int l_sup)
{
  int i;
  int j;
  i = l_inf - 1;
  j = l_sup;
  while (i < j)
  {
    while (strcmp(lista_p[lista_e[ide].produtos[++i]].desc, lista_p[lista_e[ide].produtos[l_sup]].desc) < 0)
      ;

    while (strcmp(lista_p[lista_e[ide].produtos[l_sup]].desc, lista_p[lista_e[ide].produtos[--j]].desc) < 0)
    {
      if (j == l_inf)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      troca_int(lista_e[ide].quantidade, i, j);
      troca_int(lista_e[ide].produtos, i, j);
    }
    else
    {
      
    }

  }

  troca_int(lista_e[ide].quantidade, i, l_sup);
  troca_int(lista_e[ide].produtos, i, l_sup);
  return i;
}

void quicksort(const produto lista_p[9999], encomenda lista_e[499], int ide, int l_inf, int l_sup)
{
  int indice;
  if (l_sup <= l_inf)
  {
    return;
  }
  else
  {
    
  }

  indice = particao(lista_p, lista_e, ide, l_inf, l_sup);
  quicksort(lista_p, lista_e, ide, l_inf, indice - 1);
  quicksort(lista_p, lista_e, ide, indice + 1, l_sup);
  return;
}

void a_adiciona_produto(produto lista[9999], int id)
{
  for (int lista_index = 0; lista_index < 10; lista_index++)
  {
    lista[id].desc[lista_index] = new_sym_var(sizeof(char) * 8);
  }

  lista[id].desc[10 - 1] = '\0';
  lista[id].preco = new_sym_var(sizeof(int) * 8);
  lista[id].peso = new_sym_var(sizeof(int) * 8);
  lista[id].stock = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", id);
  return;
}

void A_adiciona_encomenda(produto lista_p[9999], encomenda lista_e[499], int num_p, int num_e)
{
  int i;
  int ide;
  int idp;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= num_e)
  {
    printf("");
    printf("Encomenda inexistente.\n");
    return;
  }
  else
  {
    if (idp >= num_p)
    {
      printf("");
      printf("Produto inexistente.\n");
      return;
    }
    else
    {
      if (lista_p[idp].stock < qtd)
      {
        printf("");
        printf("Quantidade em stock insuficiente.\n");
        return;
      }
      else
      {
        if ((lista_e[ide].peso + (qtd * lista_p[idp].peso)) > 200)
        {
          printf("");
          printf("Peso da encomenda excede o maximo de 200.\n");
          return;
        }
        else
        {
          
        }

      }

    }

  }

  lista_e[ide].peso += qtd * lista_p[idp].peso;
  lista_p[idp].stock -= qtd;
  for (i = 0; i < lista_e[ide].contador; i++)
  {
    if (lista_e[ide].produtos[i] == idp)
    {
      lista_e[ide].quantidade[i] += qtd;
      return;
    }
    else
    {
      
    }

  }

  lista_e[ide].produtos[i] = idp;
  lista_e[ide].contador++;
  lista_e[ide].quantidade[i] = qtd;
  return;
}

void C_custo(const produto lista_p[9999], const encomenda lista_e[499], int num_e)
{
  int i;
  int ide;
  int custo;
  custo = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= num_e)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < lista_e[ide].contador; i++)
  {
    custo += lista_e[ide].quantidade[i] * lista_p[lista_e[ide].produtos[i]].preco;
  }

  printf("Custo da encomenda %d %d.\n", ide, custo);
  return;
}

void E_lista_prod_enc(const produto lista_p[9999], const encomenda lista_e[499], int num_p, int num_e)
{
  int i;
  int idp;
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= num_e)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    if (idp >= num_p)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      return;
    }
    else
    {
      
    }

  }

  printf("%s ", lista_p[idp].desc);
  for (i = 0; i < lista_e[ide].contador; i++)
  {
    if (lista_e[ide].produtos[i] == idp)
    {
      printf("%d.\n", lista_e[ide].quantidade[i]);
      return;
    }
    else
    {
      
    }

  }

  printf("0.\n");
  return;
}

void lista_produtos(const produto lista_p[9999], const int vetor_id[9999], int limite)
{
  int i;
  printf("Produtos\n");
  for (i = 0; i < limite; i++)
  {
    printf("* %s %d %d\n", lista_p[vetor_id[i]].desc, lista_p[vetor_id[i]].preco, lista_p[vetor_id[i]].stock);
  }

  return;
}

void lista_encomenda(const produto lista_p[9999], const encomenda enc, int ide)
{
  int i;
  printf("Encomenda %d\n", ide);
  for (i = 0; i < enc.contador; i++)
  {
    printf("* %s %d %d\n", lista_p[enc.produtos[i]].desc, lista_p[enc.produtos[i]].preco, enc.quantidade[i]);
  }

  return;
}

void l_lista_produtos_ordenados(const produto lista_p[9999], int limite)
{
  int vetor_id[9999];
  int i;
  for (i = 0; i < limite; i++)
  {
    vetor_id[i] = i;
  }

  mergesort(lista_p, vetor_id, 0, limite - 1);
  lista_produtos(lista_p, vetor_id, limite);
  return;
}

void L_lista_encomenda_ordenada(const produto lista_p[9999], encomenda lista_e[499], int num_e)
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= num_e)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  quicksort(lista_p, lista_e, ide, 0, lista_e[ide].contador - 1);
  lista_encomenda(lista_p, lista_e[ide], ide);
  return;
}

void m_maximo(const encomenda lista_e[499], int num_p, int num_e)
{
  int i;
  int j;
  int idp;
  int id_max;
  int max;
  max = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= num_p)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < num_e; i++)
  {
    for (j = 0; j < lista_e[i].contador; j++)
    {
      if (lista_e[i].produtos[j] == idp)
      {
        if (lista_e[i].quantidade[j] > max)
        {
          max = lista_e[i].quantidade[j];
          id_max = i;
        }
        else
        {
          
        }

        break;
      }
      else
      {
        
      }

    }

  }

  if (max != 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, id_max, max);
  }
  else
  {
    
  }

  return;
}

void N_cria_encomenda(int id)
{
  printf("Nova encomenda %d.\n", id);
  return;
}

void p_altera_preco(produto lista_p[9999], int num_p)
{
  int idp;
  int novo_preco;
  idp = new_sym_var(sizeof(int) * 8);
  novo_preco = new_sym_var(sizeof(int) * 8);
  if (idp >= num_p)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  lista_p[idp].preco = novo_preco;
  return;
}

void q_adiciona_stock(produto lista[9999], int num_p)
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= num_p)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  lista[idp].stock += qtd;
  return;
}

void r_remove_stock(produto lista_p[9999], int num_p)
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= num_p)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    if (qtd > lista_p[idp].stock)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
      return;
    }
    else
    {
      
    }

  }

  lista_p[idp].stock -= qtd;
  return;
}

void remove_elemento(int index, int vetor[], int limite)
{
  for (; index < limite; index++)
  {
    vetor[index] = vetor[index + 1];
  }

  return;
}

void R_remove_produto(produto lista_p[9999], encomenda lista_e[499], int num_p, int num_e)
{
  int i;
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= num_e)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp >= num_p)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < lista_e[ide].contador; i++)
  {
    if (lista_e[ide].produtos[i] == idp)
    {
      lista_p[idp].stock += lista_e[ide].quantidade[i];
      lista_e[ide].peso -= lista_e[ide].quantidade[i] * lista_p[idp].peso;
      remove_elemento(i, lista_e[ide].produtos, --lista_e[ide].contador);
      remove_elemento(i, lista_e[ide].quantidade, lista_e[ide].contador);
      return;
    }
    else
    {
      
    }

  }

  return;
}

int main()
{
  int contador_p;
  int contador_e;
  produto lista_p[9999] = {0};
  encomenda lista_e[499] = {0};
  char c;
  contador_p = 0;
  contador_e = 0;
  while (1)
    switch (c = getchar())
  {
    case 'a':
      a_adiciona_produto(lista_p, contador_p++);
      break;

    case 'A':
      A_adiciona_encomenda(lista_p, lista_e, contador_p, contador_e);
      break;

    case 'C':
      C_custo(lista_p, lista_e, contador_e);
      break;

    case 'E':
      E_lista_prod_enc(lista_p, lista_e, contador_p, contador_e);
      break;

    case 'l':
      l_lista_produtos_ordenados(lista_p, contador_p);
      break;

    case 'L':
      L_lista_encomenda_ordenada(lista_p, lista_e, contador_e);
      break;

    case 'm':
      m_maximo(lista_e, contador_p, contador_e);
      break;

    case 'N':
      N_cria_encomenda(contador_e++);
      break;

    case 'p':
      p_altera_preco(lista_p, contador_p);
      break;

    case 'q':
      q_adiciona_stock(lista_p, contador_p);
      break;

    case 'r':
      r_remove_stock(lista_p, contador_p);
      break;

    case 'R':
      R_remove_produto(lista_p, lista_e, contador_p, contador_e);
      break;

    case 'x':
      return 0;

  }


}

