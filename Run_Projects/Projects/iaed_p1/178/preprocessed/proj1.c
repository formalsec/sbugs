/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int idp;
  int price;
  int weight;
  int stock;
  char description[63];
} product;
typedef struct 
{
  int ide;
  int weight;
  int counter;
  int products[200][2];
} order;
typedef product Item;
product ProductList[10000] = {0};
order OrderList[500] = {0};
int IdpCounter = 0;
int IdeCounter = 0;
void CreatesProduct();
void AddStock();
void CreatesOrder();
void AddProduct();
void RemoveStock();
void RemoveProduct();
void CalculateOrderCost();
void ChangePrice();
void OrderAmount();
void MostRecurringProduct();
void LeastToMostExpensive();
void ListProductsByName();
product FindsProduct(int idp);
int ChecksProductInOrder(int idp, order object);
void InitializeMatrix(int list[][2]);
int ChecksProductInCatalog(int idp);
int CalculateTotalProductQty(int idp);
int Partition(Item a[], int l, int r);
void Quicksort(Item a[], int l, int r);
int Partition_words(product a[], int l, int r);
void Quicksort_words(product a[], int l, int r);
int FindsProductQuantityInOrder(int ide, int idp);
order FindsOrder(int ide);
int ChecksOrder(int ide);
int main()
{
  char command;
  int output = 0;
  do
  {
    command = new_sym_var(sizeof(char) * 8);
    switch (command)
    {
      case 'a':
        CreatesProduct();
        break;

      case 'q':
        AddStock();
        break;

      case 'N':
        CreatesOrder();
        break;

      case 'A':
        AddProduct();
        break;

      case 'r':
        RemoveStock();
        break;

      case 'R':
        RemoveProduct();
        break;

      case 'C':
        CalculateOrderCost();
        break;

      case 'p':
        ChangePrice();
        break;

      case 'E':
        OrderAmount();
        break;

      case 'm':
        MostRecurringProduct();
        break;

      case 'l':
        LeastToMostExpensive();
        break;

      case 'L':
        ListProductsByName();
        break;

      case 'x':
        output = 1;
        break;

      default:
        break;

    }

  }
  while (output != 1);
  return 0;
}

void CreatesProduct()
{
  product object;
  for (int object_index = 0; object_index < 10; object_index++)
  {
    object.description[object_index] = new_sym_var(sizeof(char) * 8);
  }

  object.description[10 - 1] = '\0';
  object.price = new_sym_var(sizeof(int) * 8);
  object.weight = new_sym_var(sizeof(int) * 8);
  object.stock = new_sym_var(sizeof(int) * 8);
  object.idp = IdpCounter;
  ProductList[IdpCounter] = object;
  IdpCounter++;
  printf("Novo produto %d.\n", object.idp);
}

void AddStock()
{
  int idp;
  int quantity;
  idp = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (ChecksProductInCatalog(idp) == 0)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    ProductList[idp].stock += quantity;
    return;
  }

}

void CreatesOrder()
{
  order object;
  object.ide = IdeCounter;
  object.weight = 0;
  object.counter = 0;
  InitializeMatrix(object.products);
  OrderList[IdeCounter] = object;
  IdeCounter++;
  printf("Nova encomenda %d.\n", object.ide);
}

void AddProduct()
{
  int i = 0;
  int ide;
  int idp;
  int qty;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (ChecksOrder(ide) == 0)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (ChecksProductInCatalog(idp) == 0)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      if (FindsProduct(idp).stock < qty)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        return;
      }
      else
      {
        if ((FindsOrder(ide).weight + (FindsProduct(idp).weight * qty)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          return;
        }
        else
        {
          if (ChecksProductInOrder(idp, OrderList[ide]) == 1)
          {
            while (OrderList[ide].products[i][0] != idp)
            {
              i++;
            }

            OrderList[ide].weight += ProductList[idp].weight * qty;
            OrderList[ide].products[i][1] += qty;
            ProductList[idp].stock -= qty;
            return;
          }
          else
          {
            ProductList[idp].stock -= qty;
            OrderList[ide].products[OrderList[ide].counter][0] = idp;
            OrderList[ide].products[OrderList[ide].counter][1] = qty;
            OrderList[ide].weight += ProductList[idp].weight * qty;
            OrderList[ide].counter++;
            return;
          }

        }

      }

    }

  }

}

void RemoveStock()
{
  int idp;
  int quantity;
  idp = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (ChecksProductInCatalog(idp) == 0)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (FindsProduct(idp).stock < quantity)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantity, idp);
    }
    else
    {
      ProductList[idp].stock -= quantity;
      return;
    }

  }

}

void RemoveProduct()
{
  int i = 0;
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ChecksOrder(ide) == 0)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (ChecksProductInCatalog(idp) == 0)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (ChecksProductInOrder(idp, OrderList[ide]) == 1)
      {
        while (OrderList[ide].products[i][0] != idp)
        {
          i++;
        }

        ProductList[idp].stock += OrderList[ide].products[i][1];
        OrderList[ide].weight -= ProductList[idp].weight * OrderList[ide].products[i][1];
        OrderList[ide].products[i][1] = 0;
        return;
      }
      else
      {
        
      }

      return;
    }

  }

}

void CalculateOrderCost()
{
  int i;
  int ide;
  int total_cost = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ChecksOrder(ide) == 0)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < OrderList[ide].counter; i++)
    {
      total_cost += FindsProduct(OrderList[ide].products[i][0]).price * OrderList[ide].products[i][1];
    }

    printf("Custo da encomenda %d %d.\n", ide, total_cost);
    return;
  }

}

void ChangePrice()
{
  int idp;
  int new_price;
  idp = new_sym_var(sizeof(int) * 8);
  new_price = new_sym_var(sizeof(int) * 8);
  if (ChecksProductInCatalog(idp) == 0)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    ProductList[idp].price = new_price;
    return;
  }

}

void OrderAmount()
{
  int i = 0;
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ChecksOrder(ide) == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    if (ChecksProductInCatalog(idp) == 0)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      return;
    }
    else
    {
      if (ChecksProductInOrder(idp, OrderList[ide]) == 0)
      {
        printf("%s 0.\n", ProductList[idp].description);
        return;
      }
      else
      {
        while (OrderList[ide].products[i][0] != idp)
        {
          i++;
        }

        printf("%s %d.\n", ProductList[idp].description, OrderList[ide].products[i][1]);
        return;
      }

    }

  }

}

void MostRecurringProduct()
{
  int i;
  int idp;
  int ide;
  int most_quantity = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (ChecksProductInCatalog(idp) == 0)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    if (IdeCounter == 0)
    {
      return;
    }
    else
    {
      for (i = 0; i < IdeCounter; i++)
      {
        if (ChecksProductInOrder(idp, OrderList[i]) == 1)
        {
          if (FindsProductQuantityInOrder(OrderList[i].ide, idp) > most_quantity)
          {
            most_quantity = FindsProductQuantityInOrder(OrderList[i].ide, idp);
            ide = OrderList[i].ide;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

      if (most_quantity > 0)
      {
        printf("Maximo produto %d %d %d.\n", idp, ide, most_quantity);
        return;
      }
      else
      {
        
      }

    }

  }

}

void LeastToMostExpensive()
{
  int i;
  product array[10000];
  for (i = 0; i < IdpCounter; i++)
  {
    array[i] = ProductList[i];
  }

  Quicksort(array, 0, IdpCounter - 1);
  printf("Produtos\n");
  for (i = 0; i < IdpCounter; i++)
  {
    printf("* %s %d %d\n", array[i].description, array[i].price, array[i].stock);
  }

  return;
}

void ListProductsByName()
{
  int i;
  int ide;
  product array[200];
  ide = new_sym_var(sizeof(int) * 8);
  if (ChecksOrder(ide) == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    for (i = 0; i < OrderList[ide].counter; i++)
    {
      array[i] = FindsProduct(OrderList[ide].products[i][0]);
    }

    Quicksort_words(array, 0, OrderList[ide].counter - 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < OrderList[ide].counter; i++)
    {
      if (ChecksProductInOrder(array[i].idp, OrderList[ide]) == 1)
      {
        if (FindsProductQuantityInOrder(ide, array[i].idp) > 0)
        {
          printf("* %s %d %d\n", array[i].description, array[i].price, FindsProductQuantityInOrder(ide, array[i].idp));
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    return;
  }

}

int Partition(Item a[], int l, int r)
{
  int i = l - 1;
  int j = r;
  Item v = a[r];
  while (i < j)
  {
    while ((a[++i].price < v.price) || ((a[i].price == v.price) && (a[i].idp < v.idp)))
    {
      ;
    }

    while ((v.price < a[--j].price) || ((a[j].price == v.price) && (v.idp < a[j].idp)))
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      {
        Item t = a[i];
        a[i] = a[j];
        a[j] = t;
      }
      ;
    }
    else
    {
      
    }

  }

  {
    Item t = a[i];
    a[i] = a[r];
    a[r] = t;
  }
  ;
  return i;
}

void Quicksort(Item a[], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = Partition(a, l, r);
  Quicksort(a, l, i - 1);
  Quicksort(a, i + 1, r);
}

int Partition_words(product a[], int l, int r)
{
  int i = l - 1;
  int j = r;
  product v = a[r];
  product t;
  while (i < j)
  {
    while (strcmp(a[++i].description, v.description) < 0)
    {
      ;
    }

    while (strcmp(v.description, a[--j].description) < 0)
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      t = a[i];
      a[i] = a[j];
      a[j] = t;
    }
    else
    {
      
    }

  }

  t = a[i];
  a[i] = a[r];
  a[r] = t;
  return i;
}

void Quicksort_words(product a[], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = Partition_words(a, l, r);
  Quicksort_words(a, l, i - 1);
  Quicksort_words(a, i + 1, r);
}

product FindsProduct(int idp)
{
  int i = 0;
  while (ProductList[i].idp != idp)
  {
    i++;
  }

  return ProductList[i];
}

int ChecksOrder(int ide)
{
  int i;
  int OrderTracker = 0;
  for (i = 0; i < IdeCounter; i++)
  {
    if (OrderList[i].ide == ide)
    {
      OrderTracker = 1;
      break;
    }
    else
    {
      
    }

  }

  return OrderTracker;
}

order FindsOrder(int ide)
{
  int i = 0;
  while (OrderList[i].ide != ide)
  {
    i++;
  }

  return OrderList[i];
}

int ChecksProductInOrder(int idp, order object)
{
  int i;
  int ProductTracker = 0;
  for (i = 0; i < object.counter; i++)
  {
    if (object.products[i][0] == idp)
    {
      ProductTracker = 1;
    }
    else
    {
      
    }

  }

  return ProductTracker;
}

void InitializeMatrix(int list[][2])
{
  int i;
  int j;
  for (i = 0; i < 200; i++)
  {
    for (j = 0; j < 2; j++)
    {
      list[i][j] = 0;
    }

  }

}

int ChecksProductInCatalog(int idp)
{
  int i;
  int result = 0;
  for (i = 0; i < IdpCounter; i++)
  {
    if (ProductList[i].idp == idp)
    {
      result = 1;
    }
    else
    {
      
    }

  }

  return result;
}

int FindsProductQuantityInOrder(int ide, int idp)
{
  int i = 0;
  while (OrderList[ide].products[i][0] != idp)
  {
    i++;
  }

  return OrderList[ide].products[i][1];
}

