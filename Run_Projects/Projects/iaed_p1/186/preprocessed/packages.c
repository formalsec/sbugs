/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include "products.h"
#include "packages.h"


Product packages[500][200] = {0};
int packageCount = 0;
int packageExists(int ide)
{
  return (ide >= 0) && (ide < packageCount);
}

int packageWeight(int ide)
{
  int weight = 0;
  int i;
  for (i = 0; (i < 200) && packages[ide][i].alive; i++)
    weight += packages[ide][i].weight * packages[ide][i].quantity;

  return weight;
}

void addProdToPack(int ide, int idp, int qtd)
{
  int exists = 0;
  int i;
  products[idp].quantity -= qtd;
  for (i = 0; (i < 200) && packages[ide][i].alive; i++)
    if (packages[ide][i].id == idp)
  {
    {
      packages[ide][i].quantity += qtd;
      exists = 1;
      break;
    }
  }
  else
  {
    
  }


  if (!exists)
  {
    {
      packages[ide][i] = products[idp];
      packages[ide][i].quantity = qtd;
    }
  }
  else
  {
    
  }

}

void removeProdFromPack(int ide, int idp)
{
  int found = -1;
  int i;
  for (i = 0; (i < 200) && packages[ide][i].alive; i++)
    if (packages[ide][i].id == idp)
  {
    {
      found = i;
    }
  }
  else
  {
    
  }


  if (found >= 0)
  {
    {
      products[idp].quantity += packages[ide][found].quantity;
      packages[ide][found] = packages[ide][i - 1];
      packages[ide][i - 1].alive = 0;
    }
  }
  else
  {
    
  }

}

int partitionAlfa(Product products[], int left, int right)
{
  Product pivot = products[right];
  int i = left - 1;
  int j;
  Product holder;
  for (j = left; j <= (right - 1); j++)
    if (strcmp(products[j].description, pivot.description) < 0)
  {
    {
      i++;
      if (i != j)
      {
        {
          holder = products[i];
          products[i] = products[j];
          products[j] = holder;
        }
      }
      else
      {
        
      }

    }
  }
  else
  {
    
  }


  i++;
  holder = products[i];
  products[i] = products[j];
  products[j] = holder;
  return i;
}

void sortProductsByAlfa(Product products[], int left, int right)
{
  int pivot;
  if (left < right)
  {
    {
      pivot = partitionAlfa(products, left, right);
      sortProductsByAlfa(products, left, pivot - 1);
      sortProductsByAlfa(products, pivot + 1, right);
    }
  }
  else
  {
    
  }

}

void createPackageCmd()
{
  printf("Nova encomenda %d.\n", packageCount);
  packageCount++;
}

void addProdToPackCmd()
{
  int ide;
  int idp;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (!packageExists(ide))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (!productExists(idp))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (products[idp].quantity < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((packageWeight(ide) + (products[idp].weight * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de %d.\n", idp, ide, 200);
        }
        else
        {
          addProdToPack(ide, idp, qtd);
        }

      }

    }

  }

}

void removeProdFromPackCmd()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (!packageExists(ide))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (!productExists(idp))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      removeProdFromPack(ide, idp);
    }

  }

}

void calcPackagePriceCmd()
{
  int ide;
  int cost = 0;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  if (!packageExists(ide))
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    {
      for (i = 0; (i < 200) && packages[ide][i].alive; i++)
        cost += products[packages[ide][i].id].price * packages[ide][i].quantity;

      printf("Custo da encomenda %d %d.\n", ide, cost);
    }
  }

}

void returnProdInfoCmd()
{
  int ide;
  int idp;
  int qtd = 0;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (!packageExists(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (!productExists(idp))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      {
        for (i = 0; (i < 200) && packages[ide][i].alive; i++)
          if (packages[ide][i].id == idp)
        {
          {
            qtd = packages[ide][i].quantity;
            break;
          }
        }
        else
        {
          
        }


        printf("%s %d.\n", products[idp].description, qtd);
      }
    }

  }

}

void listPackageProdsCmd()
{
  int ide;
  int items;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  if (!packageExists(ide))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    {
      for (items = 0; (items < 200) && packages[ide][items].alive; items++)
        ;

      sortProductsByAlfa(packages[ide], 0, items - 1);
      printf("Encomenda %d\n", ide);
      for (i = 0; i < items; i++)
        printf("* %s %d %d\n", packages[ide][i].description, products[packages[ide][i].id].price, packages[ide][i].quantity);

    }
  }

}

void listPackageProdsIDCmd()
{
  int ide;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  printf("Encomenda %d\n%-4s %-5s %-4s %-10s %s\n", ide, "ID", "Preco", "Peso", "Quantidade", "Descricao");
  for (i = 0; (i < 200) && packages[ide][i].alive; i++)
    printf("%-4d %-5d %-4d %-10d %s\n", packages[ide][i].id, packages[ide][i].price, packages[ide][i].weight, packages[ide][i].quantity, packages[ide][i].description);

}

