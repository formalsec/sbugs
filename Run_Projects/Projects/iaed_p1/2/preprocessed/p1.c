/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


struct produto
{
  int identificador;
  char descricao[64];
  int preco;
  int peso;
  int quantidade;
};
struct encomenda
{
  struct produto produtos_na_encomenda[200];
  int peso;
  int numero_de_produtos_criados_em_encomenda;
};
struct produto stock_de_produtos[10000];
struct produto vector_de_ordenacao[10000];
struct produto vector_auxiliar_de_ordenacao[10000];
struct encomenda lista_de_encomendas[500];
char comando_do_utilizador[250];
int numero_de_produtos_criados = 0;
int numero_de_encomendas_criadas = 0;
void merge_por_preco(int esquerda, int meio, int direita)
{
  int iterador_i;
  int iterador_j;
  int iterador_k;
  for (iterador_i = meio + 1; iterador_i > esquerda; iterador_i--)
  {
    vector_auxiliar_de_ordenacao[iterador_i - 1] = vector_de_ordenacao[iterador_i - 1];
  }

  for (iterador_j = meio; iterador_j < direita; iterador_j++)
  {
    vector_auxiliar_de_ordenacao[(direita + meio) - iterador_j] = vector_de_ordenacao[iterador_j + 1];
  }

  for (iterador_k = esquerda; iterador_k <= direita; iterador_k++)
  {
    if ((vector_auxiliar_de_ordenacao[iterador_i].preco > vector_auxiliar_de_ordenacao[iterador_j].preco) || ((vector_auxiliar_de_ordenacao[iterador_i].preco == vector_auxiliar_de_ordenacao[iterador_j].preco) && (vector_auxiliar_de_ordenacao[iterador_i].identificador > vector_auxiliar_de_ordenacao[iterador_j].identificador)))
    {
      {
        vector_de_ordenacao[iterador_k] = vector_auxiliar_de_ordenacao[iterador_j--];
      }
    }
    else
    {
      {
        vector_de_ordenacao[iterador_k] = vector_auxiliar_de_ordenacao[iterador_i++];
      }
    }

  }

}

void mergesort_por_preco(int esquerda, int direita)
{
  int meio = (esquerda + direita) / 2;
  if (esquerda < direita)
  {
    {
      mergesort_por_preco(esquerda, meio);
      mergesort_por_preco(meio + 1, direita);
      merge_por_preco(esquerda, meio, direita);
    }
  }
  else
  {
    
  }

}

void merge_por_ordem_alfabetica(int esquerda, int meio, int direita)
{
  int iterador_i;
  int iterador_j;
  int iterador_k;
  for (iterador_i = meio + 1; iterador_i > esquerda; iterador_i--)
  {
    vector_auxiliar_de_ordenacao[iterador_i - 1] = vector_de_ordenacao[iterador_i - 1];
  }

  for (iterador_j = meio; iterador_j < direita; iterador_j++)
  {
    vector_auxiliar_de_ordenacao[(direita + meio) - iterador_j] = vector_de_ordenacao[iterador_j + 1];
  }

  for (iterador_k = esquerda; iterador_k <= direita; iterador_k++)
  {
    if (strcmp(stock_de_produtos[vector_auxiliar_de_ordenacao[iterador_i].identificador].descricao, stock_de_produtos[vector_auxiliar_de_ordenacao[iterador_j].identificador].descricao) > 0)
    {
      {
        vector_de_ordenacao[iterador_k] = vector_auxiliar_de_ordenacao[iterador_j--];
      }
    }
    else
    {
      {
        vector_de_ordenacao[iterador_k] = vector_auxiliar_de_ordenacao[iterador_i++];
      }
    }

  }

}

void mergesort_por_ordem_alfabetica(int esquerda, int direita)
{
  int meio = (esquerda + direita) / 2;
  if (esquerda < direita)
  {
    {
      mergesort_por_ordem_alfabetica(esquerda, meio);
      mergesort_por_ordem_alfabetica(meio + 1, direita);
      merge_por_ordem_alfabetica(esquerda, meio, direita);
    }
  }
  else
  {
    
  }

}

int existe_produto_em_stock(int id_do_produto)
{
  if (id_do_produto >= numero_de_produtos_criados)
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  return 1;
}

int existe_encomenda(int id_da_encomenda)
{
  if (id_da_encomenda >= numero_de_encomendas_criadas)
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  return 1;
}

int existe_produto_em_encomenda(int id_da_encomenda, int id_do_produto)
{
  int i;
  for (i = 0; i < lista_de_encomendas[id_da_encomenda].numero_de_produtos_criados_em_encomenda; i++)
  {
    if (lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[i].identificador == id_do_produto)
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return -1;
}

void adiciona_produto(char *comando_do_utilizador)
{
  int id_do_produto_adicionado = 0;
  char descricao[64];
  int preco = 0;
  int peso = 0;
  int quantidade = 0;
  struct produto produto_a_adicionar;
  int comprimento_do_comando;
  int i;
  int paragens = 0;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if ((comando_do_utilizador[i] == ':') || (comando_do_utilizador[i] == '\n'))
    {
      {
        aux_componente[contador_componente] = '\0';
        switch (paragens)
        {
          case 0:
            descricao[contador_componente] = '\0';
            break;

          case 1:
            preco = atoi(aux_componente);
            break;

          case 2:
            peso = atoi(aux_componente);
            break;

          case 3:
            quantidade = atoi(aux_componente);
            break;

        }

        paragens++;
        contador_componente = 0;
        continue;
      }
    }
    else
    {
      
    }

    switch (paragens)
    {
      case 0:
        descricao[contador_componente] = comando_do_utilizador[i];
        break;

      case 1:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 2:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 3:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

    }

    contador_componente++;
  }

  strcpy(produto_a_adicionar.descricao, descricao);
  produto_a_adicionar.preco = preco;
  produto_a_adicionar.peso = peso;
  produto_a_adicionar.quantidade = quantidade;
  id_do_produto_adicionado = numero_de_produtos_criados;
  produto_a_adicionar.identificador = id_do_produto_adicionado;
  stock_de_produtos[id_do_produto_adicionado] = produto_a_adicionar;
  printf("Novo produto %d.\n", id_do_produto_adicionado);
  numero_de_produtos_criados++;
  return;
}

void adiciona_stock_a_produto(char *comando_do_utilizador)
{
  int id_do_produto = 0;
  int quantidade = 0;
  int comprimento_do_comando;
  int i;
  int paragens = 0;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if ((comando_do_utilizador[i] == ':') || (comando_do_utilizador[i] == '\n'))
    {
      {
        aux_componente[contador_componente] = '\0';
        switch (paragens)
        {
          case 0:
            id_do_produto = atoi(aux_componente);
            break;

          case 1:
            quantidade = atoi(aux_componente);
            break;

        }

        paragens++;
        contador_componente = 0;
        continue;
      }
    }
    else
    {
      
    }

    switch (paragens)
    {
      case 0:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 1:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

    }

    contador_componente++;
  }

  if (existe_produto_em_stock(id_do_produto) == 0)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id_do_produto);
      return;
    }
  }
  else
  {
    
  }

  stock_de_produtos[id_do_produto].quantidade = stock_de_produtos[id_do_produto].quantidade + quantidade;
  return;
}

void cria_encomenda()
{
  int id_da_encomenda_adicionada = 0;
  id_da_encomenda_adicionada = numero_de_encomendas_criadas;
  printf("Nova encomenda %d.\n", id_da_encomenda_adicionada);
  numero_de_encomendas_criadas++;
  return;
}

void adiciona_produto_a_encomenda(char *comando_do_utilizador)
{
  int id_do_produto = 0;
  int id_da_encomenda = 0;
  int quantidade = 0;
  int peso_produto = 0;
  int peso_encomenda = 0;
  int comprimento_do_comando;
  int i;
  int indice_do_produto_na_encomenda = 0;
  int paragens = 0;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if ((comando_do_utilizador[i] == ':') || (comando_do_utilizador[i] == '\n'))
    {
      {
        aux_componente[contador_componente] = '\0';
        switch (paragens)
        {
          case 0:
            id_da_encomenda = atoi(aux_componente);
            break;

          case 1:
            id_do_produto = atoi(aux_componente);
            break;

          case 2:
            quantidade = atoi(aux_componente);
            break;

        }

        paragens++;
        contador_componente = 0;
        continue;
      }
    }
    else
    {
      
    }

    switch (paragens)
    {
      case 0:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 1:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 2:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

    }

    contador_componente++;
  }

  if (existe_encomenda(id_da_encomenda) == 0)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id_do_produto, id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  if (existe_produto_em_stock(id_do_produto) == 0)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id_do_produto, id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  if (stock_de_produtos[id_do_produto].quantidade < quantidade)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_do_produto, id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  peso_produto = quantidade * stock_de_produtos[id_do_produto].peso;
  peso_encomenda = lista_de_encomendas[id_da_encomenda].peso;
  if ((peso_encomenda + peso_produto) > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_do_produto, id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  indice_do_produto_na_encomenda = existe_produto_em_encomenda(id_da_encomenda, id_do_produto);
  if (indice_do_produto_na_encomenda >= 0)
  {
    {
      lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[indice_do_produto_na_encomenda].quantidade += quantidade;
      lista_de_encomendas[id_da_encomenda].peso += peso_produto;
      stock_de_produtos[id_do_produto].quantidade -= quantidade;
      return;
    }
  }
  else
  {
    {
      indice_do_produto_na_encomenda = lista_de_encomendas[id_da_encomenda].numero_de_produtos_criados_em_encomenda;
      lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[indice_do_produto_na_encomenda].identificador = id_do_produto;
      lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[indice_do_produto_na_encomenda].quantidade = quantidade;
      lista_de_encomendas[id_da_encomenda].peso += peso_produto;
      stock_de_produtos[id_do_produto].quantidade -= quantidade;
      lista_de_encomendas[id_da_encomenda].numero_de_produtos_criados_em_encomenda++;
    }
  }

  return;
}

void remove_stock_a_produto(char *comando_do_utilizador)
{
  int id_do_produto = 0;
  int quantidade = 0;
  int comprimento_do_comando;
  int i;
  int paragens = 0;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if ((comando_do_utilizador[i] == ':') || (comando_do_utilizador[i] == '\n'))
    {
      {
        aux_componente[contador_componente] = '\0';
        switch (paragens)
        {
          case 0:
            id_do_produto = atoi(aux_componente);
            break;

          case 1:
            quantidade = atoi(aux_componente);
            break;

        }

        paragens++;
        contador_componente = 0;
        continue;
      }
    }
    else
    {
      
    }

    switch (paragens)
    {
      case 0:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 1:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

    }

    contador_componente++;
  }

  if (existe_produto_em_stock(id_do_produto) == 0)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id_do_produto);
      return;
    }
  }
  else
  {
    
  }

  if (stock_de_produtos[id_do_produto].quantidade < quantidade)
  {
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantidade, id_do_produto);
      return;
    }
  }
  else
  {
    
  }

  stock_de_produtos[id_do_produto].quantidade = stock_de_produtos[id_do_produto].quantidade - quantidade;
  return;
}

void remove_produto_a_encomenda(char *comando_do_utilizador)
{
  int id_do_produto = 0;
  int id_da_encomenda = 0;
  int comprimento_do_comando;
  int i;
  int peso_produto = 0;
  int indice_do_produto_na_encomenda = 0;
  int paragens = 0;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if ((comando_do_utilizador[i] == ':') || (comando_do_utilizador[i] == '\n'))
    {
      {
        aux_componente[contador_componente] = '\0';
        switch (paragens)
        {
          case 0:
            id_da_encomenda = atoi(aux_componente);
            break;

          case 1:
            id_do_produto = atoi(aux_componente);
            break;

        }

        paragens++;
        contador_componente = 0;
        continue;
      }
    }
    else
    {
      
    }

    switch (paragens)
    {
      case 0:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 1:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

    }

    contador_componente++;
  }

  if (existe_encomenda(id_da_encomenda) == 0)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id_do_produto, id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  if (existe_produto_em_stock(id_do_produto) == 0)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_do_produto, id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  indice_do_produto_na_encomenda = existe_produto_em_encomenda(id_da_encomenda, id_do_produto);
  if (indice_do_produto_na_encomenda >= 0)
  {
    {
      peso_produto = lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[indice_do_produto_na_encomenda].quantidade * stock_de_produtos[id_do_produto].peso;
      stock_de_produtos[id_do_produto].quantidade += lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[indice_do_produto_na_encomenda].quantidade;
      lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[indice_do_produto_na_encomenda].quantidade = 0;
      lista_de_encomendas[id_da_encomenda].peso -= peso_produto;
      return;
    }
  }
  else
  {
    
  }

  return;
}

void calcula_custo_encomenda(char *comando_do_utilizador)
{
  int id_da_encomenda = 0;
  int preco_da_encomenda = 0;
  int comprimento_do_comando;
  int i;
  int preco_produto;
  int id_do_produto;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if (comando_do_utilizador[i] == '\n')
    {
      {
        aux_componente[contador_componente] = '\0';
        id_da_encomenda = atoi(aux_componente);
      }
    }
    else
    {
      
    }

    aux_componente[contador_componente] = comando_do_utilizador[i];
    contador_componente++;
  }

  if (existe_encomenda(id_da_encomenda) == 0)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < lista_de_encomendas[id_da_encomenda].numero_de_produtos_criados_em_encomenda; i++)
  {
    id_do_produto = lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[i].identificador;
    preco_produto = lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[i].quantidade * stock_de_produtos[id_do_produto].preco;
    preco_da_encomenda += preco_produto;
  }

  printf("Custo da encomenda %d %d.\n", id_da_encomenda, preco_da_encomenda);
  return;
}

void altera_preco_de_produto(char *comando_do_utilizador)
{
  int id_do_produto = 0;
  int preco = 0;
  int comprimento_do_comando;
  int i;
  int paragens = 0;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if ((comando_do_utilizador[i] == ':') || (comando_do_utilizador[i] == '\n'))
    {
      {
        aux_componente[contador_componente] = '\0';
        switch (paragens)
        {
          case 0:
            id_do_produto = atoi(aux_componente);
            break;

          case 1:
            preco = atoi(aux_componente);
            break;

        }

        paragens++;
        contador_componente = 0;
        continue;
      }
    }
    else
    {
      
    }

    switch (paragens)
    {
      case 0:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 1:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

    }

    contador_componente++;
  }

  if (existe_produto_em_stock(id_do_produto) == 0)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id_do_produto);
      return;
    }
  }
  else
  {
    
  }

  stock_de_produtos[id_do_produto].preco = preco;
  return;
}

void lista_descricao_e_quantidade_de_produto_numa_encomenda(char *comando_do_utilizador)
{
  int id_do_produto = 0;
  int id_da_encomenda = 0;
  int comprimento_do_comando;
  int i;
  int indice_do_produto_na_encomenda = 0;
  int paragens = 0;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if ((comando_do_utilizador[i] == ':') || (comando_do_utilizador[i] == '\n'))
    {
      {
        aux_componente[contador_componente] = '\0';
        switch (paragens)
        {
          case 0:
            id_da_encomenda = atoi(aux_componente);
            break;

          case 1:
            id_do_produto = atoi(aux_componente);
            break;

        }

        paragens++;
        contador_componente = 0;
        continue;
      }
    }
    else
    {
      
    }

    switch (paragens)
    {
      case 0:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

      case 1:
        aux_componente[contador_componente] = comando_do_utilizador[i];
        break;

    }

    contador_componente++;
  }

  if (existe_encomenda(id_da_encomenda) == 0)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  if (existe_produto_em_stock(id_do_produto) == 0)
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", id_do_produto);
      return;
    }
  }
  else
  {
    
  }

  indice_do_produto_na_encomenda = existe_produto_em_encomenda(id_da_encomenda, id_do_produto);
  if (indice_do_produto_na_encomenda >= 0)
  {
    {
      printf("%s %d.\n", stock_de_produtos[id_do_produto].descricao, lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[indice_do_produto_na_encomenda].quantidade);
      return;
    }
  }
  else
  {
    
  }

  printf("%s 0.\n", stock_de_produtos[id_do_produto].descricao);
  return;
}

void lista_maximo_do_produto(char *comando_do_utilizador)
{
  int id_do_produto = 0;
  int id_da_encomenda = 0;
  int comprimento_do_comando;
  int i;
  int quantidade_de_produto_maximo = 0;
  int indice_do_produto_na_encomenda = 0;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if (comando_do_utilizador[i] == '\n')
    {
      {
        aux_componente[contador_componente] = '\0';
        id_do_produto = atoi(aux_componente);
      }
    }
    else
    {
      
    }

    aux_componente[contador_componente] = comando_do_utilizador[i];
    contador_componente++;
  }

  if (existe_produto_em_stock(id_do_produto) == 0)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id_do_produto);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < numero_de_encomendas_criadas; i++)
  {
    indice_do_produto_na_encomenda = existe_produto_em_encomenda(i, id_do_produto);
    if (indice_do_produto_na_encomenda >= 0)
    {
      {
        if (quantidade_de_produto_maximo < lista_de_encomendas[i].produtos_na_encomenda[indice_do_produto_na_encomenda].quantidade)
        {
          {
            id_da_encomenda = i;
            quantidade_de_produto_maximo = lista_de_encomendas[i].produtos_na_encomenda[indice_do_produto_na_encomenda].quantidade;
          }
        }
        else
        {
          
        }

      }
    }
    else
    {
      
    }

  }

  if (quantidade_de_produto_maximo == 0)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", id_do_produto, id_da_encomenda, quantidade_de_produto_maximo);
  return;
}

void lista_produtos_por_preco()
{
  int i;
  for (i = 0; i < numero_de_produtos_criados; i++)
  {
    vector_de_ordenacao[i] = stock_de_produtos[i];
  }

  mergesort_por_preco(0, numero_de_produtos_criados - 1);
  printf("Produtos\n");
  for (i = 0; i < numero_de_produtos_criados; i++)
  {
    printf("* %s %d %d\n", vector_de_ordenacao[i].descricao, vector_de_ordenacao[i].preco, vector_de_ordenacao[i].quantidade);
  }

  return;
}

void lista_descricao_de_produtos_numa_encomenda_por_ordem(char *comando_do_utilizador)
{
  int id_da_encomenda = 0;
  int comprimento_do_comando;
  int i;
  int contador_componente = 0;
  char aux_componente[250];
  comprimento_do_comando = strlen(comando_do_utilizador);
  for (i = 2; i <= (comprimento_do_comando - 1); i++)
  {
    if (comando_do_utilizador[i] == '\n')
    {
      {
        aux_componente[contador_componente] = '\0';
        id_da_encomenda = atoi(aux_componente);
        break;
      }
    }
    else
    {
      
    }

    aux_componente[contador_componente] = comando_do_utilizador[i];
    contador_componente++;
  }

  if (existe_encomenda(id_da_encomenda) == 0)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_da_encomenda);
      return;
    }
  }
  else
  {
    
  }

  printf("Encomenda %d\n", id_da_encomenda);
  for (i = 0; i < lista_de_encomendas[id_da_encomenda].numero_de_produtos_criados_em_encomenda; i++)
  {
    vector_de_ordenacao[i] = lista_de_encomendas[id_da_encomenda].produtos_na_encomenda[i];
  }

  mergesort_por_ordem_alfabetica(0, lista_de_encomendas[id_da_encomenda].numero_de_produtos_criados_em_encomenda - 1);
  for (i = 0; i < lista_de_encomendas[id_da_encomenda].numero_de_produtos_criados_em_encomenda; i++)
  {
    if (vector_de_ordenacao[i].quantidade > 0)
    {
      {
        printf("* %s %d %d\n", stock_de_produtos[vector_de_ordenacao[i].identificador].descricao, stock_de_produtos[vector_de_ordenacao[i].identificador].preco, vector_de_ordenacao[i].quantidade);
      }
    }
    else
    {
      
    }

  }

  return;
}

int main()
{
  while (1)
  {
    fgets(comando_do_utilizador, 250, stdin);
    switch (comando_do_utilizador[0])
    {
      case 'x':
        return 0;
        break;

      case 'a':
        adiciona_produto(comando_do_utilizador);
        break;

      case 'q':
        adiciona_stock_a_produto(comando_do_utilizador);
        break;

      case 'N':
        cria_encomenda(comando_do_utilizador);
        break;

      case 'A':
        adiciona_produto_a_encomenda(comando_do_utilizador);
        break;

      case 'r':
        remove_stock_a_produto(comando_do_utilizador);
        break;

      case 'R':
        remove_produto_a_encomenda(comando_do_utilizador);
        break;

      case 'C':
        calcula_custo_encomenda(comando_do_utilizador);
        break;

      case 'p':
        altera_preco_de_produto(comando_do_utilizador);
        break;

      case 'E':
        lista_descricao_e_quantidade_de_produto_numa_encomenda(comando_do_utilizador);
        break;

      case 'm':
        lista_maximo_do_produto(comando_do_utilizador);
        break;

      case 'l':
        lista_produtos_por_preco();
        break;

      case 'L':
        lista_descricao_de_produtos_numa_encomenda_por_ordem(comando_do_utilizador);
        break;

    }

  }

  return 0;
}

