/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include "messages.h"


typedef struct product
{
  int id;
  char description[63];
  int price;
  int weight;
  int stock;
} Product;
typedef struct package
{
  int id;
  Product products[200];
  int totalPackageProducts;
  int totalWeight;
} Package;
typedef struct command
{
  char label;
  char description[63];
  int args[3];
} Command;
Product products[10000];
Package packages[500];
int productsQuantity = 0;
int packagesQuantity = 0;
int isProductValid(int id)
{
  return id < productsQuantity;
}

int isPackageValid(int id)
{
  return id < packagesQuantity;
}

void createProduct(Command command)
{
  Product product;
  product.id = productsQuantity;
  productsQuantity++;
  strcpy(product.description, command.description);
  product.price = command.args[0];
  product.weight = command.args[1];
  product.stock = command.args[2];
  products[product.id] = product;
  printf("Novo produto %d.\n", product.id);
}

void restock(int pId, int stock)
{
  if (isProductValid(pId) == 0)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", pId);
      return;
    }
  }
  else
  {
    
  }

  products[pId].stock += stock;
}

void removeStock(int pId, int stockToRemove)
{
  if (isProductValid(pId) == 0)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", pId);
      return;
    }
  }
  else
  {
    if (products[pId].stock < stockToRemove)
    {
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", stockToRemove, pId);
        return;
      }
    }
    else
    {
      
    }

  }

  products[pId].stock -= stockToRemove;
}

void createPackage()
{
  Package package;
  package.id = packagesQuantity;
  package.totalPackageProducts = 0;
  package.totalWeight = 0;
  packagesQuantity++;
  packages[package.id] = package;
  printf("Nova encomenda %d.\n", package.id);
}

int packageContainsProduct(int pkId, int ptId)
{
  int i;
  for (i = 0; i < packages[pkId].totalPackageProducts; i++)
  {
    if (packages[pkId].products[i].id == ptId)
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return -1;
}

void addProduct(int pkId, int ptId, int quantity)
{
  Product product;
  int index;
  if (isPackageValid(pkId) == 0)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", ptId, pkId);
      return;
    }
  }
  else
  {
    if (isProductValid(ptId) == 0)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", ptId, pkId);
        return;
      }
    }
    else
    {
      if (products[ptId].stock < quantity)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", ptId, pkId);
          return;
        }
      }
      else
      {
        if (((products[ptId].weight * quantity) + packages[pkId].totalWeight) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", ptId, pkId);
            return;
          }
        }
        else
        {
          
        }

      }

    }

  }

  index = packageContainsProduct(pkId, ptId);
  if (index == (-1))
  {
    {
      product = products[ptId];
      product.stock = quantity;
      packages[pkId].products[packages[pkId].totalPackageProducts] = product;
      packages[pkId].totalPackageProducts++;
    }
  }
  else
  {
    {
      packages[pkId].products[index].stock += quantity;
    }
  }

  packages[pkId].totalWeight += products[ptId].weight * quantity;
  products[ptId].stock -= quantity;
}

void removeFromProductsArray(int pkId, int index)
{
  int i;
  for (i = index; i < (packages[pkId].totalPackageProducts - 1); i++)
  {
    packages[pkId].products[i] = packages[pkId].products[i + 1];
  }

  packages[pkId].totalPackageProducts--;
}

void removeProduct(int pkId, int ptId)
{
  int i;
  if (isPackageValid(pkId) == 0)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", ptId, pkId);
      return;
    }
  }
  else
  {
    if (isProductValid(ptId) == 0)
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", ptId, pkId);
        return;
      }
    }
    else
    {
      
    }

  }

  i = packageContainsProduct(pkId, ptId);
  if (i == (-1))
  {
    {
      return;
    }
  }
  else
  {
    
  }

  products[ptId].stock += packages[pkId].products[i].stock;
  packages[pkId].totalWeight -= products[ptId].weight * packages[pkId].products[i].stock;
  removeFromProductsArray(pkId, i);
}

void packagePrice(int pkId)
{
  int i;
  int price = 0;
  if (isPackageValid(pkId) == 0)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", pkId);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < packages[pkId].totalPackageProducts; i++)
  {
    price += packages[pkId].products[i].price * packages[pkId].products[i].stock;
  }

  printf("Custo da encomenda %d %d.\n", pkId, price);
}

void setProductPrice(int ptId, int price)
{
  int i;
  int j;
  if (isProductValid(ptId) == 0)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", ptId);
    }
  }
  else
  {
    
  }

  products[ptId].price = price;
  for (i = 0; i < packagesQuantity; i++)
  {
    j = packageContainsProduct(i, ptId);
    if (j != (-1))
    {
      {
        packages[i].products[j].price = price;
      }
    }
    else
    {
      
    }

  }

}

void productInfo(int pkId, int ptId)
{
  int i;
  if (isPackageValid(pkId) == 0)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", pkId);
      return;
    }
  }
  else
  {
    if (isProductValid(ptId) == 0)
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", ptId);
        return;
      }
    }
    else
    {
      
    }

  }

  i = packageContainsProduct(pkId, ptId);
  if (i == (-1))
  {
    {
      printf("%s %d.\n", products[ptId].description, 0);
    }
  }
  else
  {
    {
      printf("%s %d.\n", packages[pkId].products[i].description, packages[pkId].products[i].stock);
    }
  }

}

void mostValuablePackage(int ptId)
{
  int i;
  int j;
  int mvpk = -1;
  int currentStock = 0;
  if (isProductValid(ptId) == 0)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", ptId);
    }
  }
  else
  {
    
  }

  for (i = 0; i < packagesQuantity; i++)
  {
    j = packageContainsProduct(i, ptId);
    if ((j != (-1)) && (packages[i].products[j].stock > currentStock))
    {
      {
        currentStock = packages[i].products[j].stock;
        mvpk = i;
      }
    }
    else
    {
      
    }

  }

  if (mvpk != (-1))
  {
    {
      printf("Maximo produto %d %d %d.\n", ptId, mvpk, currentStock);
    }
  }
  else
  {
    
  }

}

char compareByDesc(Product a, Product b)
{
  return strcmp(a.description, b.description) < 0;
}

char compareByPrice(Product a, Product b)
{
  if (a.price == b.price)
  {
    {
      return a.id < b.id;
    }
  }
  else
  {
    {
      return a.price < b.price;
    }
  }

}

char compareById(Product a, Product b)
{
  return a.id < b.id;
}

void merge(Product a[], int left, int m, int right, char (*compareFunction)(Product, Product))
{
  int i;
  int j;
  int k;
  Product aux[10000];
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if ((*compareFunction)(aux[j], aux[i]))
    {
      {
        a[k] = aux[j--];
      }
    }
    else
    {
      {
        a[k] = aux[i++];
      }
    }

  }

}

void mergeSort(Product a[], int left, int right, char (*compareFuction)(Product, Product))
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  mergeSort(a, left, m, compareFuction);
  mergeSort(a, m + 1, right, compareFuction);
  merge(a, left, m, right, compareFuction);
}

void listProductsByDescription(int pkId)
{
  int i = 0;
  if (isPackageValid(pkId) == 0)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", pkId);
      return;
    }
  }
  else
  {
    
  }

  mergeSort(packages[pkId].products, 0, packages[pkId].totalPackageProducts - 1, &compareByDesc);
  printf("Encomenda %d\n", pkId);
  for (i = 0; i < packages[pkId].totalPackageProducts; i++)
  {
    printf("* %s %d %d\n", packages[pkId].products[i].description, packages[pkId].products[i].price, packages[pkId].products[i].stock);
  }

  mergeSort(packages[pkId].products, 0, packages[pkId].totalPackageProducts - 1, &compareById);
}

void listProductsByPrice()
{
  int i = 0;
  mergeSort(products, 0, productsQuantity - 1, &compareByPrice);
  printf("Produtos\n");
  for (i = 0; i < productsQuantity; i++)
  {
    printf("* %s %d %d\n", products[i].description, products[i].price, products[i].stock);
  }

  mergeSort(products, 0, productsQuantity - 1, &compareById);
}

Command readCommand()
{
  Command command;
  command.label = new_sym_var(sizeof(char) * 8);
  switch (command.label)
  {
    case 'a':
      for (int command_index = 0; command_index < 10; command_index++)
    {
      command.description[command_index] = new_sym_var(sizeof(char) * 8);
    }

      command.description[10 - 1] = '\0';
      command.args[0] = new_sym_var(sizeof(int) * 8);
      command.args[1] = new_sym_var(sizeof(int) * 8);
      command.args[2] = new_sym_var(sizeof(int) * 8);
      createProduct(command);
      break;

    case 'q':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      command.args[1] = new_sym_var(sizeof(int) * 8);
      restock(command.args[0], command.args[1]);
      break;

    case 'N':
      createPackage();
      break;

    case 'A':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      command.args[1] = new_sym_var(sizeof(int) * 8);
      command.args[2] = new_sym_var(sizeof(int) * 8);
      addProduct(command.args[0], command.args[1], command.args[2]);
      break;

    case 'r':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      command.args[1] = new_sym_var(sizeof(int) * 8);
      removeStock(command.args[0], command.args[1]);
      break;

    case 'R':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      command.args[1] = new_sym_var(sizeof(int) * 8);
      removeProduct(command.args[0], command.args[1]);
      break;

    case 'C':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      packagePrice(command.args[0]);
      break;

    case 'p':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      command.args[1] = new_sym_var(sizeof(int) * 8);
      setProductPrice(command.args[0], command.args[1]);
      break;

    case 'E':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      command.args[1] = new_sym_var(sizeof(int) * 8);
      productInfo(command.args[0], command.args[1]);
      break;

    case 'm':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      mostValuablePackage(command.args[0]);
      break;

    case 'l':
      listProductsByPrice();
      break;

    case 'L':
      command.args[0] = new_sym_var(sizeof(int) * 8);
      listProductsByDescription(command.args[0]);
      break;

  }

  return command;
}

int main()
{
  Command command;
  do
  {
    command = readCommand();
  }
  while (command.label != 'x');
  return 0;
}

