/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include "info.h"


product products[10000] = {0};
order orders[500] = {0};
int z = 0;
product aux[10000];
product productscpy[10000];
order copycost[10000];
product createProduct(char desc[], int price, int weight, int stock)
{
  product aux;
  strcpy(aux.desc, desc);
  aux.price = price;
  aux.weight = weight;
  aux.stock = stock;
  aux.standingP = 1;
  aux.idp = z;
  return aux;
}

order createOrder()
{
  int i;
  order aux;
  static int product_counter = 0;
  aux.ide = product_counter;
  aux.price = 0;
  aux.weightOrder = 0;
  for (i = 0; i < 200; i++)
  {
    aux.products[i] = products[i];
  }

  aux.standingO = 1;
  ++product_counter;
  return aux;
}

int stockEvaluate(int idp, int stock)
{
  return products[idp].stock - stock;
}

void a(char desc[], int price, int weight, int stock)
{
  if ((((((z >= 0) && (z < 10000)) && (strlen(desc) <= 64)) && (price > 0)) && (weight > 0)) && (stock >= 0))
  {
    {
      printf("Novo produto %d.\n", z);
      products[z] = createProduct(desc, price, weight, stock);
      products[z].standingP = 1;
      z++;
    }
  }
  else
  {
    
  }

}

void q(int idp, int stock)
{
  if (products[idp].standingP == 1)
  {
    {
      products[idp].stock += stock;
    }
  }
  else
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    }
  }

}

void N()
{
  static int k = 0;
  orders[k] = createOrder();
  printf("Nova encomenda %d.\n", orders[k].ide);
  k++;
}

void A(int ide, int idp, int stock)
{
  orders[ide].weightOrder = (products[idp].weight * stock) + orders[ide].weightOrder;
  if (orders[ide].standingO == 0)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      orders[ide].weightOrder = (products[idp].weight * stock) - orders[ide].weightOrder;
    }
  }
  else
  {
    if (products[idp].standingP == 0)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
        orders[ide].weightOrder = (products[idp].weight * stock) - orders[ide].weightOrder;
      }
    }
    else
    {
      if (stockEvaluate(idp, stock) < 0)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
          orders[ide].weightOrder = (products[idp].weight * stock) - orders[ide].weightOrder;
        }
      }
      else
      {
        if (orders[ide].weightOrder > 200)
        {
          {
            orders[ide].weightOrder = (products[idp].weight * stock) - orders[ide].weightOrder;
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          }
        }
        else
        {
          {
            if ((orders[ide].verifier[idp] == 0) && (orders[ide].weightOrder <= 200))
            {
              {
                orders[ide].products[idp] = products[idp];
                orders[ide].products[idp].stock = stock;
                products[idp].stock -= stock;
                orders[ide].verifier[idp] = 1;
              }
            }
            else
            {
              if ((orders[ide].verifier[idp] == 1) && (orders[ide].weightOrder <= 200))
              {
                {
                  orders[ide].products[idp].stock += stock;
                  products[idp].stock -= stock;
                }
              }
              else
              {
                {
                  printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
                }
              }

            }

          }
        }

      }

    }

  }

}

void r(int idp, int stock)
{
  if (products[idp].standingP == 1)
  {
    {
      if (stockEvaluate(idp, stock) < 0)
      {
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", stock, idp);
        }
      }
      else
      {
        {
          products[idp].stock -= stock;
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    }
  }

}

void R(int idp, int ide)
{
  if (orders[ide].standingO == 1)
  {
    {
      if (products[idp].standingP == 1)
      {
        {
          orders[ide].weightOrder -= products[idp].weight * orders[ide].products[idp].stock;
          products[idp].stock += orders[ide].products[idp].stock;
          orders[ide].products[idp].stock = 0;
        }
      }
      else
      {
        {
          printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
  }

}

void C(int ide)
{
  int x;
  int y;
  int total = 0;
  for (x = 0; x < 10000; x++)
  {
    copycost[x] = orders[x];
  }

  if (copycost[ide].standingO == 1)
  {
    {
      for (y = 0; y < 200; y++)
      {
        if ((copycost[ide].products[y].stock != 0) || (copycost[ide].products[y].price != 0))
        {
          total += copycost[ide].products[y].price * copycost[ide].products[y].stock;
        }
        else
        {
          
        }

      }

      printf("Custo da encomenda %d %d.\n", ide, total);
    }
  }
  else
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    }
  }

}

void p(int idp, int price)
{
  int k;
  if (products[idp].standingP == 1)
  {
    {
      products[idp].price = price;
      for (k = 0; k < 200; k++)
      {
        if (products[idp].idp == orders[k].products[idp].idp)
        {
          {
            orders[k].products[idp].price = price;
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    }
  }

}

void E(int ide, int idp)
{
  if (orders[ide].standingO == 1)
  {
    {
      if (products[idp].standingP == 1)
      {
        {
          printf("%s %d.\n", orders[ide].products[idp].desc, orders[ide].products[idp].stock);
        }
      }
      else
      {
        {
          printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
  }

}

void m(int idp)
{
  if (products[idp].standingP == 1)
  {
    {
      int k;
      int m = 0;
      int i;
      for (k = 0; k < 500; k++)
      {
        if (orders[k].products[idp].stock > m)
        {
          {
            m = orders[k].products[idp].stock;
            i = k;
          }
        }
        else
        {
          if (orders[k].products[idp].stock == m)
          {
            {
              if (k < i)
              {
                {
                  i = k;
                }
              }
              else
              {
                
              }

            }
          }
          else
          {
            
          }

        }

      }

      if (m > 0)
      {
        {
          printf("Maximo produto %d %d %d.\n", idp, i, m);
        }
      }
      else
      {
        
      }

    }
  }
  else
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    }
  }

}

void l(product array[])
{
  int k;
  for (k = 0; k < 10000; k++)
  {
    if ((array[k].standingP == 1) && (array[k].price > 0))
    {
      {
        printf("* %s %d %d\n", array[k].desc, array[k].price, array[k].stock);
      }
    }
    else
    {
      
    }

  }

}

void mergesortPrice(product a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesortPrice(a, left, m);
  mergesortPrice(a, m + 1, right);
  mergePrice(a, left, m, right);
}

void mergePrice(product a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
    if (aux[j].price < aux[i].price)
  {
    a[k] = aux[j--];
  }
  else
  {
    if (aux[j].price == aux[i].price)
    {
      if (aux[j].idp < aux[i].idp)
      {
        a[k] = aux[j--];
      }
      else
      {
        a[k] = aux[i++];
      }

    }
    else
    {
      a[k] = aux[i++];
    }

  }


}

int main()
{
  int price;
  int weight;
  int stock;
  int ide;
  int idp;
  int x;
  char desc[64];
  char input = getchar();
  while (input != 'x')
  {
    switch (input)
    {
      case 'a':
        for (int desc_index = 0; desc_index < 10; desc_index++)
      {
        desc[desc_index] = new_sym_var(sizeof(char) * 8);
      }

        desc[10 - 1] = '\0';
        price = new_sym_var(sizeof(int) * 8);
        weight = new_sym_var(sizeof(int) * 8);
        stock = new_sym_var(sizeof(int) * 8);
        a(desc, price, weight, stock);
        break;

      case 'q':
        idp = new_sym_var(sizeof(int) * 8);
        stock = new_sym_var(sizeof(int) * 8);
        q(idp, stock);
        break;

      case 'N':
        N();
        break;

      case 'A':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        stock = new_sym_var(sizeof(int) * 8);
        A(ide, idp, stock);
        break;

      case 'r':
        idp = new_sym_var(sizeof(int) * 8);
        stock = new_sym_var(sizeof(int) * 8);
        r(idp, stock);
        break;

      case 'R':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        R(idp, ide);
        break;

      case 'C':
        ide = new_sym_var(sizeof(int) * 8);
        C(ide);
        break;

      case 'p':
        idp = new_sym_var(sizeof(int) * 8);
        price = new_sym_var(sizeof(int) * 8);
        p(idp, price);
        break;

      case 'E':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        E(ide, idp);
        break;

      case 'm':
        idp = new_sym_var(sizeof(int) * 8);
        m(idp);
        break;

      case 'l':
        printf("Produtos\n");
        for (x = 0; x < 10000; x++)
      {
        productscpy[x] = products[x];
      }

        mergesortPrice(productscpy, 0, 10000 - 1);
        l(productscpy);
        break;

      case 'x':
        break;

    }

    input = getchar();
  }

  return 0;
}

