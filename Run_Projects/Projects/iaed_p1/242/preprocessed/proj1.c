/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct product
{
  int pid;
  char desc[64];
  int exists;
  int price;
  int weight;
  int stock;
} product;
typedef struct order
{
  int oid;
  int total_w;
  int price_t;
  int in_order;
  int max_s;
  int exists;
  product p_ord[10000];
} order;
int count_orders = 0;
int total_prod = 0;
order orders[500];
product products[10000];
product pcopy[10000];
product swap[10000];
product aux[10000];
void createProd()
{
  int p;
  int w;
  int s;
  char desc[64];
  for (int desc_index = 0; desc_index < 10; desc_index++)
  {
    desc[desc_index] = new_sym_var(sizeof(char) * 8);
  }

  desc[10 - 1] = '\0';
  p = new_sym_var(sizeof(int) * 8);
  w = new_sym_var(sizeof(int) * 8);
  s = new_sym_var(sizeof(int) * 8);
  products[total_prod].pid = total_prod;
  strcpy(products[total_prod].desc, desc);
  products[total_prod].exists = 1;
  products[total_prod].price = p;
  products[total_prod].weight = w;
  products[total_prod].stock = s;
  printf("Novo produto %d.\n", total_prod);
  total_prod++;
}

int addStock()
{
  int p_id;
  int a_qty;
  p_id = new_sym_var(sizeof(int) * 8);
  a_qty = new_sym_var(sizeof(int) * 8);
  if ((p_id > total_prod) || (products[p_id].exists != 1))
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", p_id);
      return 1;
    }
  }
  else
  {
    {
      products[p_id].stock += a_qty;
      return 0;
    }
  }

}

void newOrder()
{
  orders[count_orders].oid = count_orders;
  orders[count_orders].total_w = 0;
  orders[count_orders].price_t = 0;
  orders[count_orders].in_order = 0;
  orders[count_orders].max_s = 0;
  orders[count_orders].exists = 1;
  printf("Nova encomenda %d.\n", count_orders);
  count_orders++;
}

int addProd()
{
  int o_id;
  int p_id;
  int qty;
  o_id = new_sym_var(sizeof(int) * 8);
  p_id = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if ((o_id > count_orders) || (orders[o_id].exists != 1))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", p_id, o_id);
      return 1;
    }
  }
  else
  {
    if ((p_id > total_prod) || (products[p_id].exists != 1))
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", p_id, o_id);
        return 1;
      }
    }
    else
    {
      if ((products[p_id].stock - qty) < 0)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", p_id, o_id);
          return 1;
        }
      }
      else
      {
        if ((orders[o_id].total_w + (qty * products[p_id].weight)) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", p_id, o_id);
            return 1;
          }
        }
        else
        {
          if (orders[o_id].p_ord[p_id].exists == 1)
          {
            {
              orders[o_id].total_w += qty * products[p_id].weight;
              orders[o_id].price_t += qty * products[p_id].price;
              orders[o_id].p_ord[p_id].stock += qty;
              products[p_id].stock -= qty;
              return 0;
            }
          }
          else
          {
            {
              orders[o_id].total_w += qty * products[p_id].weight;
              orders[o_id].price_t += qty * products[p_id].price;
              orders[o_id].p_ord[p_id].pid = p_id;
              strcpy(orders[o_id].p_ord[p_id].desc, products[p_id].desc);
              orders[o_id].p_ord[p_id].exists = 1;
              orders[o_id].p_ord[p_id].price = products[p_id].price;
              orders[o_id].p_ord[p_id].weight = products[p_id].weight;
              orders[o_id].p_ord[p_id].stock = qty;
              orders[o_id].in_order += 1;
              products[p_id].stock -= qty;
              return 0;
            }
          }

        }

      }

    }

  }

}

int removeStock()
{
  int p_id;
  int rm_qty;
  p_id = new_sym_var(sizeof(int) * 8);
  rm_qty = new_sym_var(sizeof(int) * 8);
  if ((p_id > total_prod) || (products[p_id].exists != 1))
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", p_id);
      return 1;
    }
  }
  else
  {
    if ((products[p_id].stock - rm_qty) < 0)
    {
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", rm_qty, p_id);
        return 1;
      }
    }
    else
    {
      {
        products[p_id].stock -= rm_qty;
        return 0;
      }
    }

  }

}

int removeProd()
{
  int o_id;
  int p_id;
  o_id = new_sym_var(sizeof(int) * 8);
  p_id = new_sym_var(sizeof(int) * 8);
  if ((o_id > count_orders) || (orders[o_id].exists != 1))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", p_id, o_id);
      return 1;
    }
  }
  else
  {
    if ((p_id > total_prod) || (products[p_id].exists != 1))
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", p_id, o_id);
        return 1;
      }
    }
    else
    {
      if (orders[o_id].p_ord[p_id].exists == 0)
      {
        {
          return 0;
        }
      }
      else
      {
        {
          products[p_id].stock += orders[o_id].p_ord[p_id].stock;
          orders[o_id].total_w -= orders[o_id].p_ord[p_id].stock * products[p_id].weight;
          orders[o_id].price_t -= orders[o_id].p_ord[p_id].stock * products[p_id].price;
          orders[o_id].max_s = 0;
          orders[o_id].in_order--;
          orders[o_id].p_ord[p_id].exists = 0;
          orders[o_id].p_ord[p_id].price = 0;
          orders[o_id].p_ord[p_id].weight = 0;
          orders[o_id].p_ord[p_id].stock = 0;
          return 0;
        }
      }

    }

  }

}

int calcCost()
{
  int o_id;
  o_id = new_sym_var(sizeof(int) * 8);
  if ((o_id > count_orders) || (orders[o_id].exists != 1))
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", o_id);
      return 1;
    }
  }
  else
  {
    
  }

  printf("Custo da encomenda %d %d.\n", o_id, orders[o_id].price_t);
  return 0;
}

int changePrice()
{
  int p_id;
  int n_price;
  int i;
  int s;
  p_id = new_sym_var(sizeof(int) * 8);
  n_price = new_sym_var(sizeof(int) * 8);
  if ((p_id > total_prod) || (products[p_id].exists != 1))
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", p_id);
      return 1;
    }
  }
  else
  {
    
  }

  for (i = 0; i < count_orders; i++)
  {
    if (orders[i].p_ord[p_id].exists == 1)
    {
      {
        s = orders[i].p_ord[p_id].stock;
        orders[i].price_t += (s * n_price) - (s * orders[i].p_ord[p_id].price);
        orders[i].p_ord[p_id].price = n_price;
      }
    }
    else
    {
      
    }

  }

  products[p_id].price = n_price;
  return 0;
}

int getInfo()
{
  int o_id;
  int p_id;
  int i;
  int j;
  o_id = new_sym_var(sizeof(int) * 8);
  p_id = new_sym_var(sizeof(int) * 8);
  if ((o_id > count_orders) || (orders[o_id].exists != 1))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", o_id);
      return 1;
    }
  }
  else
  {
    if ((p_id > total_prod) || (products[p_id].exists != 1))
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", p_id);
        return 1;
      }
    }
    else
    {
      
    }

  }

  for (i = 0; i < count_orders; i++)
  {
    for (j = 0; j < total_prod; j++)
    {
      orders[i].p_ord[j].pid = j;
      strcpy(orders[i].p_ord[j].desc, products[j].desc);
    }

  }

  printf("%s %d.\n", orders[o_id].p_ord[p_id].desc, orders[o_id].p_ord[p_id].stock);
  return 0;
}

int getID()
{
  int p_id;
  int i;
  int total = 0;
  int ord = 0;
  p_id = new_sym_var(sizeof(int) * 8);
  if ((p_id > total_prod) || (products[p_id].exists != 1))
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", p_id);
      return 1;
    }
  }
  else
  {
    
  }

  for (i = 0; i < count_orders; i++)
  {
    if (orders[i].p_ord[p_id].exists == 1)
    {
      {
        orders[i].max_s = orders[i].p_ord[p_id].stock;
        if (total < orders[i].max_s)
        {
          {
            total = orders[i].max_s;
            ord = i;
          }
        }
        else
        {
          
        }

        total = orders[ord].max_s;
      }
    }
    else
    {
      
    }

  }

  if (orders[ord].p_ord[p_id].exists == 1)
  {
    {
      printf("Maximo produto %d %d %d.\n", p_id, ord, total);
    }
  }
  else
  {
    
  }

  return 0;
}

void mergePrice(product p[10000], int l, int m, int r)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = p[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = p[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if ((aux[j].price < aux[i].price) || (i > m))
    {
      {
        p[k] = aux[j--];
      }
    }
    else
    {
      {
        p[k] = aux[i++];
      }
    }

  }

}

void listProd(product p[10000], int l, int r)
{
  int m = (l + r) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  listProd(p, l, m);
  listProd(p, m + 1, r);
  mergePrice(p, l, m, r);
}

void printProd()
{
  int i;
  for (i = 0; i < total_prod; i++)
  {
    pcopy[i] = products[i];
  }

  listProd(pcopy, 0, total_prod - 1);
  printf("Produtos\n");
  for (i = 0; i < total_prod; i++)
  {
    if (pcopy[i].exists == 1)
    {
      printf("* %s %d %d\n", pcopy[i].desc, pcopy[i].price, pcopy[i].stock);
    }
    else
    {
      
    }

  }

}

void mergeDesc(product p[10000], int l, int m, int r)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = p[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = p[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if ((strcmp(aux[j].desc, aux[i].desc) < 0) || (i > m))
    {
      {
        p[k] = aux[j--];
      }
    }
    else
    {
      {
        p[k] = aux[i++];
      }
    }

  }

}

void listOrd(product p[10000], int l, int r)
{
  int m = (l + r) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  listOrd(p, l, m);
  listOrd(p, m + 1, r);
  mergeDesc(p, l, m, r);
}

int orderProds()
{
  int o_id;
  int i;
  o_id = new_sym_var(sizeof(int) * 8);
  if ((o_id > count_orders) || (orders[o_id].exists != 1))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", o_id);
      return 1;
    }
  }
  else
  {
    
  }

  for (i = 0; i < total_prod; i++)
  {
    swap[i] = orders[o_id].p_ord[i];
  }

  listOrd(swap, 0, total_prod - 1);
  printf("Encomenda %d\n", o_id);
  for (i = 0; i < total_prod; i++)
  {
    if (swap[i].exists == 1)
    {
      printf("* %s %d %d\n", swap[i].desc, swap[i].price, swap[i].stock);
    }
    else
    {
      
    }

  }

  return 0;
}

int main()
{
  char cmd = '\0';
  while (cmd != 'x')
  {
    cmd = getchar();
    switch (cmd)
    {
      case 'a':
        createProd();
        break;

      case 'q':
        addStock();
        break;

      case 'N':
        newOrder();
        break;

      case 'A':
        addProd();
        break;

      case 'r':
        removeStock();
        break;

      case 'R':
        removeProd();
        break;

      case 'C':
        calcCost();
        break;

      case 'p':
        changePrice();
        break;

      case 'E':
        getInfo();
        break;

      case 'm':
        getID();
        break;

      case 'l':
        printProd();
        break;

      case 'L':
        orderProds();
        break;

    }

  }

  return 0;
}

