/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct 
{
  char descr[63];
  int price;
  int peso;
  int qtd;
  int idp;
} Produto;
typedef struct 
{
  int ide;
  Produto Prods[200];
  int peso_total;
  int n_prods;
} Enco;
char in[350];
char cmd;
int num_prod = 0;
int num_enco = -1;
int aux_idp;
int aux_ide;
int aux_qtd;
int indice_st;
Produto Stock[10000];
Enco AllEnco[500];
int leLinha()
{
  int i;
  int c;
  if (((((cmd == 'x') || (cmd == 'k')) || (cmd == 'N')) || (cmd == 'K')) || (cmd == 'l'))
  {
    {
      getchar();
      return 0;
    }
  }
  else
  {
    
  }

  getchar();
  for (i = 0; ((c = getchar()) != EOF) && (c != '\n'); ++i)
  {
    in[i] = c;
  }

  in[i] = '\0';
  return 0;
}

int indice_stock(int idp)
{
  int i;
  for (i = 0; i < num_prod; i++)
  {
    if (Stock[i].idp == idp)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int indice_prod(int idp, int ide)
{
  int i;
  for (i = 0; i < AllEnco[ide].n_prods; i++)
  {
    if (strcmp(AllEnco[ide].Prods[i].descr, Stock[idp].descr) == 0)
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return -1;
}

int CopyInfo()
{
  Produto temp;
  char delim[] = ":";
  char *ptr;
  switch (cmd)
  {
    case 'a':
      ptr = strtok(in, delim);
      strcpy(temp.descr, ptr);
      ptr = strtok(0, delim);
      temp.price = atoi(ptr);
      ptr = strtok(0, delim);
      temp.peso = atoi(ptr);
      ptr = strtok(0, delim);
      temp.qtd = atoi(ptr);
      temp.idp = num_prod;
      Stock[num_prod] = temp;
      break;

    case 'q':
      ptr = strtok(in, delim);
      aux_idp = atoi(ptr);
      indice_st = indice_stock(aux_idp);
      if (aux_idp >= num_prod)
    {
      {
        printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", aux_idp);
        return 0;
      }
    }
    else
    {
      
    }

      ptr = strtok(0, delim);
      Stock[indice_st].qtd += atoi(ptr);
      break;

    case 'A':
      ptr = strtok(in, delim);
      aux_ide = atoi(ptr);
      ptr = strtok(0, delim);
      aux_idp = atoi(ptr);
      ptr = strtok(0, delim);
      aux_qtd = atoi(ptr);
      break;

    case 'r':
      ptr = strtok(in, delim);
      aux_idp = atoi(ptr);
      ptr = strtok(0, delim);
      aux_qtd = atoi(ptr);
      break;

    case 'R':
      ptr = strtok(in, delim);
      aux_ide = atoi(ptr);
      ptr = strtok(0, delim);
      aux_idp = atoi(ptr);
      break;

    case 'C':
      ptr = strtok(in, delim);
      aux_ide = atoi(ptr);
      if ((aux_ide > num_enco) || (aux_ide < 0))
    {
      {
        printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", aux_ide);
        return -1;
      }
    }
    else
    {
      
    }

      return aux_ide;

    case 'p':
      ptr = strtok(in, delim);
      aux_idp = atoi(ptr);
      ptr = strtok(0, delim);
      aux_qtd = atoi(ptr);
      break;

    case 'E':
      ptr = strtok(in, delim);
      aux_ide = atoi(ptr);
      ptr = strtok(0, delim);
      aux_idp = atoi(ptr);
      break;

    case 'm':
      ptr = strtok(in, delim);
      aux_idp = atoi(ptr);
      return aux_idp;

    case 'L':
      ptr = strtok(in, delim);
      aux_ide = atoi(ptr);
      break;

  }

  return 0;
}

int cmd_a()
{
  CopyInfo();
  printf("Novo produto %d.\n", Stock[num_prod].idp);
  num_prod += 1;
  return 0;
}

int cmd_q()
{
  CopyInfo();
  return 0;
}

int cmd_N()
{
  num_enco += 1;
  AllEnco[num_enco].ide = num_enco;
  AllEnco[num_enco].peso_total = 0;
  AllEnco[num_enco].n_prods = 0;
  printf("Nova encomenda %d.\n", AllEnco[num_enco].ide);
  return 0;
}

int cmd_A()
{
  int k;
  CopyInfo();
  if ((aux_ide > num_enco) || (aux_ide < 0))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", aux_idp, aux_ide);
      return 0;
    }
  }
  else
  {
    
  }

  if (aux_idp >= num_prod)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", aux_idp, aux_ide);
      return 0;
    }
  }
  else
  {
    
  }

  indice_st = indice_stock(aux_idp);
  if (Stock[indice_st].qtd < aux_qtd)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", aux_idp, aux_ide);
      return 0;
    }
  }
  else
  {
    
  }

  if (((Stock[indice_st].peso * aux_qtd) + AllEnco[aux_ide].peso_total) > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", aux_idp, aux_ide);
      return 0;
    }
  }
  else
  {
    
  }

  for (k = 0; k < 200; k++)
  {
    if (strcmp(AllEnco[aux_ide].Prods[k].descr, Stock[indice_st].descr) == 0)
    {
      {
        AllEnco[aux_ide].Prods[k].qtd += aux_qtd;
        Stock[indice_st].qtd = Stock[indice_st].qtd - aux_qtd;
        AllEnco[aux_ide].peso_total += Stock[indice_st].peso * aux_qtd;
        return 0;
      }
    }
    else
    {
      
    }

  }

  k = AllEnco[aux_ide].n_prods;
  strcpy(AllEnco[aux_ide].Prods[k].descr, Stock[indice_st].descr);
  AllEnco[aux_ide].Prods[k].price = Stock[indice_st].price;
  AllEnco[aux_ide].Prods[k].peso = Stock[indice_st].peso;
  AllEnco[aux_ide].Prods[k].idp = aux_idp;
  Stock[indice_st].qtd -= aux_qtd;
  AllEnco[aux_ide].Prods[k].qtd += aux_qtd;
  AllEnco[aux_ide].peso_total += Stock[indice_st].peso * aux_qtd;
  AllEnco[aux_ide].n_prods++;
  return 0;
}

int cmd_r()
{
  CopyInfo();
  if (aux_idp >= num_prod)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", aux_idp);
      return 0;
    }
  }
  else
  {
    
  }

  indice_st = indice_stock(aux_idp);
  if (aux_qtd > Stock[indice_st].qtd)
  {
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", aux_qtd, aux_idp);
      return 0;
    }
  }
  else
  {
    
  }

  Stock[indice_st].qtd -= aux_qtd;
  return 0;
}

int cmd_R()
{
  int k;
  CopyInfo();
  if ((aux_ide > num_enco) || (aux_ide < 0))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", aux_idp, aux_ide);
      return 0;
    }
  }
  else
  {
    
  }

  if (aux_idp >= num_prod)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", aux_idp, aux_ide);
      return 0;
    }
  }
  else
  {
    
  }

  indice_st = indice_stock(aux_idp);
  k = indice_prod(indice_st, aux_ide);
  if (k == (-1))
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  AllEnco[aux_ide].peso_total -= AllEnco[aux_ide].Prods[k].peso * AllEnco[aux_ide].Prods[k].qtd;
  Stock[indice_st].qtd += AllEnco[aux_ide].Prods[k].qtd;
  for (; k <= AllEnco[aux_ide].n_prods; k++)
  {
    AllEnco[aux_ide].Prods[k] = AllEnco[aux_ide].Prods[k + 1];
  }

  AllEnco[aux_ide].n_prods--;
  return 0;
}

int cmd_C()
{
  int ide = CopyInfo();
  int i;
  int total = 0;
  if (ide == (-1))
  {
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < AllEnco[ide].n_prods; i++)
  {
    if (AllEnco[ide].Prods[i].qtd > 0)
    {
      {
        total = total + (AllEnco[ide].Prods[i].qtd * AllEnco[ide].Prods[i].price);
      }
    }
    else
    {
      
    }

  }

  printf("Custo da encomenda %d %d.\n", ide, total);
  return 0;
}

int cmd_p()
{
  int i;
  int k;
  CopyInfo();
  if (aux_idp >= num_prod)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", aux_idp);
      return 0;
    }
  }
  else
  {
    
  }

  indice_st = indice_stock(aux_idp);
  Stock[indice_st].price = aux_qtd;
  for (i = 0; i <= num_enco; i++)
  {
    for (k = 0; k < AllEnco[i].n_prods; k++)
    {
      if (AllEnco[i].Prods[k].idp == aux_idp)
      {
        {
          AllEnco[i].Prods[k].price = aux_qtd;
        }
      }
      else
      {
        
      }

    }

  }

  return 0;
}

int cmd_E()
{
  int k;
  CopyInfo();
  if ((aux_ide > num_enco) || (aux_ide < 0))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", aux_ide);
      return 0;
    }
  }
  else
  {
    
  }

  if (aux_idp >= num_prod)
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", aux_idp);
      return 0;
    }
  }
  else
  {
    
  }

  indice_st = indice_stock(aux_idp);
  k = indice_prod(indice_st, aux_ide);
  if (k != (-1))
  {
    printf("%s %d.\n", Stock[indice_st].descr, AllEnco[aux_ide].Prods[k].qtd);
  }
  else
  {
    printf("%s 0.\n", Stock[indice_st].descr);
  }

  return 0;
}

int cmd_m()
{
  int idp = CopyInfo();
  int menor_ide = -1;
  int maior_qtd = 0;
  int i;
  int pi;
  if (num_enco == (-1))
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  if (idp >= num_prod)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
      return 0;
    }
  }
  else
  {
    
  }

  indice_st = indice_stock(idp);
  for (i = 0; i <= num_enco; i++)
  {
    pi = indice_prod(indice_st, i);
    if (pi == (-1))
    {
      continue;
    }
    else
    {
      {
        if (AllEnco[i].Prods[pi].qtd > maior_qtd)
        {
          {
            maior_qtd = AllEnco[i].Prods[pi].qtd;
            menor_ide = i;
          }
        }
        else
        {
          
        }

      }
    }

  }

  if (menor_ide != (-1))
  {
    {
      printf("Maximo produto %d %d %d.\n", idp, menor_ide, maior_qtd);
    }
  }
  else
  {
    
  }

  return 0;
}

void merge(Produto arr[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  Produto L[10000];
  Produto R[10000];
  for (i = 0; i < n1; i++)
    L[i] = arr[l + i];

  for (j = 0; j < n2; j++)
    R[j] = arr[(m + 1) + j];

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (L[i].price == R[j].price)
    {
      {
        if (L[i].idp < R[j].idp)
        {
          {
            arr[k] = L[i];
            i++;
          }
        }
        else
        {
          {
            arr[k] = R[j];
            j++;
          }
        }

      }
    }
    else
    {
      if (L[i].price < R[j].price)
      {
        {
          arr[k] = L[i];
          i++;
        }
      }
      else
      {
        {
          arr[k] = R[j];
          j++;
        }
      }

    }

    k++;
  }

  while (i < n1)
  {
    arr[k] = L[i];
    i++;
    k++;
  }

  while (j < n2)
  {
    arr[k] = R[j];
    j++;
    k++;
  }

}

void mergeSort(Produto arr[], int l, int r)
{
  if (l < r)
  {
    {
      int m = l + ((r - l) / 2);
      mergeSort(arr, l, m);
      mergeSort(arr, m + 1, r);
      merge(arr, l, m, r);
    }
  }
  else
  {
    
  }

}

int cmd_aux_k()
{
  int i;
  printf("Produtos\n");
  for (i = 0; i < num_prod; i++)
  {
    printf("* %s %d %d\n", Stock[i].descr, Stock[i].price, Stock[i].qtd);
  }

  return 0;
}

int cmd_l()
{
  mergeSort(Stock, 0, num_prod - 1);
  cmd_aux_k();
  return 0;
}

int partitionQS(Produto a[], int l, int r)
{
  int i = l - 1;
  int j = r;
  Produto v = a[r];
  while (i < j)
  {
    while (strcmp(a[++i].descr, v.descr) < 0)
      ;

    while (strcmp(v.descr, a[--j].descr) < 0)
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      {
        Produto t = a[i];
        a[i] = a[j];
        a[j] = t;
      }
    }
    else
    {
      
    }

    ;
  }

  {
    Produto t = a[i];
    a[i] = a[r];
    a[r] = t;
  }
  ;
  return i;
}

void quicksort(Produto a[], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partitionQS(a, l, r);
  quicksort(a, l, i - 1);
  quicksort(a, i + 1, r);
}

int cmd_L()
{
  int k;
  CopyInfo();
  if ((aux_ide > num_enco) || (aux_ide < 0))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", aux_ide);
      return 0;
    }
  }
  else
  {
    
  }

  quicksort(AllEnco[aux_ide].Prods, 0, AllEnco[aux_ide].n_prods - 1);
  printf("Encomenda %d\n", aux_ide);
  for (k = 0; k < AllEnco[aux_ide].n_prods; k++)
  {
    printf("* %s %d %d\n", AllEnco[aux_ide].Prods[k].descr, AllEnco[aux_ide].Prods[k].price, AllEnco[aux_ide].Prods[k].qtd);
  }

  return 0;
}

int main()
{
  while (1)
  {
    cmd = getchar();
    leLinha();
    switch (cmd)
    {
      case 'a':
        cmd_a();
        break;

      case 'q':
        cmd_q();
        break;

      case 'N':
        cmd_N();
        break;

      case 'A':
        cmd_A();
        break;

      case 'r':
        cmd_r();
        break;

      case 'R':
        cmd_R();
        break;

      case 'C':
        cmd_C();
        break;

      case 'p':
        cmd_p();
        break;

      case 'E':
        cmd_E();
        break;

      case 'm':
        cmd_m();
        break;

      case 'l':
        cmd_l();
        break;

      case 'L':
        cmd_L();
        break;

      case 'x':
        return 0;

    }

  }

  return 0;
}

