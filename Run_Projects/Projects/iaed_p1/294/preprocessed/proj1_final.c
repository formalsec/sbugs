/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>


typedef struct 
{
  int identificador;
  char descricao[64];
  int preco;
  int peso;
  int quantidade_stock;
  int quantidade_encomenda[500];
} Product;
Product produto[10000];
int encomendas[500][201];
int idp_a;
int ide_N;
Product aux_comando_l[10000];
Product produtos_comando_l[10000];
void comando_a()
{
  char descricao[64];
  int preco;
  int peso;
  int qtd;
  for (int descricao_index = 0; descricao_index < 10; descricao_index++)
  {
    descricao[descricao_index] = new_sym_var(sizeof(char) * 8);
  }

  descricao[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  produto[idp_a].identificador = idp_a;
  strcpy(produto[idp_a].descricao, descricao);
  produto[idp_a].preco = preco;
  produto[idp_a].peso = peso;
  produto[idp_a].quantidade_stock = qtd;
  printf("Novo produto %d.\n", produto[idp_a].identificador);
  idp_a++;
}

void comando_q()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp < idp_a)
  {
    produto[idp].quantidade_stock += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void comando_N()
{
  encomendas[ide_N][0] = ide_N;
  printf("Nova encomenda %d.\n", encomendas[ide_N][0]);
  ide_N++;
}

void comando_A()
{
  int iden;
  int idprod;
  int quant;
  int peso_encomenda = 0;
  int i;
  int p;
  iden = new_sym_var(sizeof(int) * 8);
  idprod = new_sym_var(sizeof(int) * 8);
  quant = new_sym_var(sizeof(int) * 8);
  if (iden < ide_N)
  {
    if (idprod < idp_a)
    {
      if (quant <= produto[idprod].quantidade_stock)
      {
        for (i = 1; i < 201; i++)
        {
          if (encomendas[iden][i] != 0)
          {
            peso_encomenda += produto[encomendas[iden][i]].peso * produto[encomendas[iden][i]].quantidade_encomenda[iden];
          }
          else
          {
            
          }

        }

        if (produto[0].quantidade_encomenda[iden] != 0)
        {
          peso_encomenda += produto[0].quantidade_encomenda[iden] * produto[0].peso;
        }
        else
        {
          
        }

        if ((peso_encomenda + (produto[idprod].peso * quant)) <= 200)
        {
          if (produto[idprod].quantidade_encomenda[iden] == 0)
          {
            for (p = 1; p < 201; p++)
            {
              if (encomendas[iden][p] == 0)
              {
                encomendas[iden][p] = produto[idprod].identificador;
                break;
              }
              else
              {
                
              }

            }

          }
          else
          {
            
          }

          produto[idprod].quantidade_stock -= quant;
          produto[idprod].quantidade_encomenda[iden] += quant;
        }
        else
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idprod, iden);
        }

      }
      else
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idprod, iden);
      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idprod, iden);
    }

  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idprod, iden);
  }

}

void comando_r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp < idp_a)
  {
    if (qtd <= produto[idp].quantidade_stock)
    {
      produto[idp].quantidade_stock -= qtd;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }

}

void comando_R()
{
  int ide;
  int idp;
  int i;
  int j;
  int colunas_encomendas_R = 201;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide < ide_N)
  {
    if (idp < idp_a)
    {
      for (i = 1; i <= colunas_encomendas_R; i++)
        if (idp == encomendas[ide][i])
      {
        break;
      }
      else
      {
        
      }


      if (i < colunas_encomendas_R)
      {
        colunas_encomendas_R -= 1;
        for (j = i; j < colunas_encomendas_R; j++)
        {
          encomendas[ide][j] = encomendas[ide][j + 1];
        }

        encomendas[ide][j] = 0;
        produto[idp].quantidade_stock += produto[idp].quantidade_encomenda[ide];
        produto[idp].quantidade_encomenda[ide] = 0;
      }
      else
      {
        
      }

    }
    else
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void comando_C()
{
  int ide;
  int preco_encomenda = 0;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide < ide_N)
  {
    for (i = 1; i < 201; i++)
    {
      if (encomendas[ide][i] != 0)
      {
        preco_encomenda += produto[encomendas[ide][i]].preco * produto[encomendas[ide][i]].quantidade_encomenda[ide];
      }
      else
      {
        
      }

    }

    if (produto[0].quantidade_encomenda[ide] != 0)
    {
      preco_encomenda += produto[0].preco * produto[0].quantidade_encomenda[ide];
    }
    else
    {
      
    }

    printf("Custo da encomenda %d %d.\n", ide, preco_encomenda);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void comando_p()
{
  int idp;
  int novo_preco;
  idp = new_sym_var(sizeof(int) * 8);
  novo_preco = new_sym_var(sizeof(int) * 8);
  if (idp < idp_a)
  {
    produto[idp].preco = novo_preco;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

void comando_E()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide < ide_N)
  {
    if (idp < idp_a)
    {
      for (i = 1; i <= 201; i++)
      {
        if (idp == encomendas[ide][i])
        {
          break;
        }
        else
        {
          
        }

      }

      printf("%s %d.\n", produto[idp].descricao, produto[idp].quantidade_encomenda[ide]);
    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void comando_m()
{
  int idp;
  int i;
  int maior = 0;
  int controlo_m = -1;
  int ind_encomenda = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp < idp_a)
  {
    if (ide_N != 0)
    {
      for (i = 0; i < 500; i++)
      {
        if (produto[idp].quantidade_encomenda[i] != 0)
        {
          controlo_m = 0;
          if (maior < produto[idp].quantidade_encomenda[i])
          {
            maior = produto[idp].quantidade_encomenda[i];
            ind_encomenda = i;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

      if (controlo_m != (-1))
      {
        printf("Maximo produto %d %d %d.\n", idp, ind_encomenda, maior);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }

}

void merge(Product aux_comando_l[], Product vet[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
  {
    aux_comando_l[i - 1] = vet[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux_comando_l[(r + m) - j] = vet[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if ((aux_comando_l[j].preco < aux_comando_l[i].preco) || (i > m))
    {
      vet[k] = aux_comando_l[j--];
    }
    else
    {
      vet[k] = aux_comando_l[i++];
    }

  }

}

void mergeSort(Product aux_comando_l[], Product arr[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergeSort(aux_comando_l, arr, l, m);
  mergeSort(aux_comando_l, arr, m + 1, r);
  merge(aux_comando_l, arr, l, m, r);
}

void comando_l()
{
  int p;
  int e;
  printf("Produtos\n");
  for (p = 0; p < idp_a; p++)
  {
    produtos_comando_l[p].identificador = produto[p].identificador;
    produtos_comando_l[p].preco = produto[p].preco;
    strcpy(produtos_comando_l[p].descricao, produto[p].descricao);
    produtos_comando_l[p].quantidade_stock = produto[p].quantidade_stock;
  }

  mergeSort(aux_comando_l, produtos_comando_l, 0, idp_a - 1);
  for (e = 0; e < idp_a; e++)
  {
    printf("* %s %d %d\n", produtos_comando_l[e].descricao, produtos_comando_l[e].preco, produtos_comando_l[e].quantidade_stock);
  }

}

int main()
{
  char letra;
  while (1)
  {
    letra = new_sym_var(sizeof(char) * 8);
    switch (letra)
    {
      case 'N':
        comando_N();
        break;

      case 'A':
        comando_A();
        break;

      case 'R':
        comando_R();
        break;

      case 'C':
        comando_C();
        break;

      case 'E':
        comando_E();
        break;

      case 'a':
        comando_a();
        break;

      case 'q':
        comando_q();
        break;

      case 'r':
        comando_r();
        break;

      case 'p':
        comando_p();
        break;

      case 'm':
        comando_m();
        break;

      case 'l':
        comando_l();
        break;

      case 'x':
        return 0;

      default:
        break;

    }

  }

}

