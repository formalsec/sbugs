/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct 
{
  int id_produto;
  char desc_produto[64];
  int preco_produto;
  int peso_produto;
  int stock_produto;
} produto;
typedef struct 
{
  int id_encomenda;
  produto e[200];
  int quantidade;
  int peso_encomenda;
} encomenda;
int idp = 0;
int ide = 0;
produto inventario_produtos[10000];
encomenda lista_encomendas[500];
int split_string(char to_split[64], char target[5][64])
{
  int i;
  char *word;
  for (i = 0; i < 5; i++)
  {
    strncpy(target[i], "", 64);
  }

  word = strtok(to_split, ":");
  for (i = 0; word != 0; i++)
  {
    strncpy(target[i], word, 64);
    word = strtok(0, ":");
  }

  return i;
}

int read_line(char s[])
{
  int c;
  int i = 0;
  while ((((c = getchar()) != EOF) && (c != '\n')) && (c != '\0'))
  {
    s[i] = c;
    i++;
  }

  s[i] = '\0';
  return i;
}

void adiciona_produto()
{
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  inventario_produtos[idp].id_produto = idp;
  strcpy(inventario_produtos[idp].desc_produto, dados[0]);
  inventario_produtos[idp].preco_produto = atoi(dados[1]);
  inventario_produtos[idp].peso_produto = atoi(dados[2]);
  inventario_produtos[idp].stock_produto = atoi(dados[3]);
  printf("Novo produto %d.\n", inventario_produtos[idp].id_produto);
  idp++;
}

void adiciona_stock()
{
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= idp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", atoi(dados[0]));
    return;
  }
  else
  {
    
  }

  inventario_produtos[atoi(dados[0])].stock_produto += atoi(dados[1]);
}

void cria_nova_encomenda()
{
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  lista_encomendas[ide].id_encomenda = ide;
  printf("Nova encomenda %d.\n", ide);
  ide++;
}

void adiciona_produto_encomenda()
{
  int a = 1;
  int i;
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", atoi(dados[1]), atoi(dados[0]));
    return;
  }
  else
  {
    if (atoi(dados[1]) >= idp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", atoi(dados[1]), atoi(dados[0]));
      return;
    }
    else
    {
      if (inventario_produtos[atoi(dados[1])].stock_produto < atoi(dados[2]))
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", atoi(dados[1]), atoi(dados[0]));
        return;
      }
      else
      {
        if ((lista_encomendas[atoi(dados[0])].peso_encomenda + (atoi(dados[2]) * inventario_produtos[atoi(dados[1])].peso_produto)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", atoi(dados[1]), atoi(dados[0]));
          return;
        }
        else
        {
          
        }

      }

    }

  }

  for (i = 0; i < lista_encomendas[atoi(dados[0])].quantidade; i++)
  {
    if (lista_encomendas[atoi(dados[0])].e[i].id_produto == atoi(dados[1]))
    {
      lista_encomendas[atoi(dados[0])].e[i].stock_produto += atoi(dados[2]);
      lista_encomendas[atoi(dados[0])].peso_encomenda += atoi(dados[2]) * inventario_produtos[atoi(dados[1])].peso_produto;
      inventario_produtos[atoi(dados[1])].stock_produto -= atoi(dados[2]);
      a = 0;
      break;
    }
    else
    {
      
    }

  }

  if (a == 1)
  {
    strcpy(lista_encomendas[atoi(dados[0])].e[lista_encomendas[atoi(dados[0])].quantidade].desc_produto, inventario_produtos[atoi(dados[1])].desc_produto);
    lista_encomendas[atoi(dados[0])].e[lista_encomendas[atoi(dados[0])].quantidade].id_produto = atoi(dados[1]);
    lista_encomendas[atoi(dados[0])].e[lista_encomendas[atoi(dados[0])].quantidade].stock_produto = atoi(dados[2]);
    lista_encomendas[atoi(dados[0])].peso_encomenda += atoi(dados[2]) * inventario_produtos[atoi(dados[1])].peso_produto;
    inventario_produtos[atoi(dados[1])].stock_produto -= atoi(dados[2]);
    lista_encomendas[atoi(dados[0])].quantidade++;
  }
  else
  {
    
  }

}

void remove_stock()
{
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", atoi(dados[0]));
    return;
  }
  else
  {
    if (inventario_produtos[atoi(dados[0])].stock_produto < atoi(dados[1]))
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", atoi(dados[1]), atoi(dados[0]));
      return;
    }
    else
    {
      
    }

  }

  inventario_produtos[atoi(dados[0])].stock_produto -= atoi(dados[1]);
}

void remove_produto_encomenda()
{
  int i;
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", atoi(dados[1]), atoi(dados[0]));
    return;
  }
  else
  {
    if (atoi(dados[1]) >= idp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", atoi(dados[1]), atoi(dados[0]));
      return;
    }
    else
    {
      for (i = 0; i < lista_encomendas[atoi(dados[0])].quantidade; i++)
      {
        if (lista_encomendas[atoi(dados[0])].e[i].id_produto == atoi(dados[1]))
        {
          lista_encomendas[atoi(dados[0])].peso_encomenda -= lista_encomendas[atoi(dados[0])].e[i].stock_produto * inventario_produtos[atoi(dados[1])].peso_produto;
          inventario_produtos[atoi(dados[1])].stock_produto += lista_encomendas[atoi(dados[0])].e[i].stock_produto;
          lista_encomendas[atoi(dados[0])].e[i].id_produto = 0;
          lista_encomendas[atoi(dados[0])].e[i].preco_produto = 0;
          lista_encomendas[atoi(dados[0])].e[i].stock_produto = 0;
          lista_encomendas[atoi(dados[0])].e[i].peso_produto = 0;
        }
        else
        {
          
        }

      }

    }

  }

}

void calcula_custo()
{
  int i;
  int c = 0;
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", atoi(dados[0]));
    return;
  }
  else
  {
    
  }

  for (i = 0; i < lista_encomendas[atoi(dados[0])].quantidade; i++)
  {
    c += lista_encomendas[atoi(dados[0])].e[i].stock_produto * inventario_produtos[lista_encomendas[atoi(dados[0])].e[i].id_produto].preco_produto;
  }

  printf("Custo da encomenda %d %d.\n", atoi(dados[0]), c);
}

void altera_preco_produto()
{
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", atoi(dados[0]));
    return;
  }
  else
  {
    
  }

  inventario_produtos[atoi(dados[0])].preco_produto = atoi(dados[1]);
}

void descricao_quantidade()
{
  int qtd = 0;
  int i;
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", atoi(dados[0]));
    return;
  }
  else
  {
    if (atoi(dados[1]) >= idp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", atoi(dados[1]));
      return;
    }
    else
    {
      
    }

  }

  for (i = 0; i < lista_encomendas[atoi(dados[0])].quantidade; i++)
  {
    if (lista_encomendas[atoi(dados[0])].e[i].id_produto == atoi(dados[1]))
    {
      qtd += lista_encomendas[atoi(dados[0])].e[i].stock_produto;
    }
    else
    {
      
    }

  }

  printf("%s %d.\n", inventario_produtos[atoi(dados[1])].desc_produto, qtd);
}

void lista_identificador()
{
  int i = 0;
  int e;
  int x = 0;
  int final = -10;
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", atoi(dados[0]));
    return;
  }
  else
  {
    
  }

  while (i < ide)
  {
    for (e = 0; e < lista_encomendas[i].quantidade; e++)
    {
      if (lista_encomendas[i].e[e].id_produto == atoi(dados[0]))
      {
        if (lista_encomendas[i].e[e].stock_produto > x)
        {
          final = lista_encomendas[i].id_encomenda;
          x = lista_encomendas[i].e[e].stock_produto;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    i++;
  }

  if (final >= 0)
  {
    printf("Maximo produto %d %d %d.\n", atoi(dados[0]), final, x);
  }
  else
  {
    
  }

}

void intercala_1(produto aux[], produto a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if ((aux[j].preco_produto < aux[i].preco_produto) || (i > m))
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void m_s_1(produto aux[], produto a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  m_s_1(aux, a, left, m);
  m_s_1(aux, a, m + 1, right);
  intercala_1(aux, a, left, m, right);
}

void auxiliar()
{
  int i;
  produto aux[10000];
  produto final[10000];
  for (i = 0; i < idp; i++)
  {
    final[i] = inventario_produtos[i];
  }

  m_s_1(aux, final, 0, idp - 1);
  printf("Produtos\n");
  for (i = 0; i < idp; i++)
  {
    printf("* %s %d %d\n", final[i].desc_produto, final[i].preco_produto, final[i].stock_produto);
  }

}

void intercala_2(produto aux[], produto a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if ((strcmp(aux[j].desc_produto, aux[i].desc_produto) < 0) || (i > m))
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void m_s_2(produto aux[], produto a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  m_s_2(aux, a, left, m);
  m_s_2(aux, a, m + 1, right);
  intercala_2(aux, a, left, m, right);
}

void auxiliar_2()
{
  produto aux[200];
  produto final[200];
  int i;
  char s[1000];
  char dados[5][64];
  read_line(s);
  split_string(s, dados);
  if (atoi(dados[0]) >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", atoi(dados[0]));
    return;
  }
  else
  {
    
  }

  for (i = 0; i < lista_encomendas[atoi(dados[0])].quantidade; i++)
  {
    final[i].id_produto = lista_encomendas[atoi(dados[0])].e[i].id_produto;
    final[i].stock_produto = lista_encomendas[atoi(dados[0])].e[i].stock_produto;
    final[i].preco_produto = lista_encomendas[atoi(dados[0])].e[i].preco_produto;
    strcpy(final[i].desc_produto, lista_encomendas[atoi(dados[0])].e[i].desc_produto);
  }

  m_s_2(aux, final, 0, lista_encomendas[atoi(dados[0])].quantidade - 1);
  printf("Encomenda %d\n", atoi(dados[0]));
  for (i = 0; i < lista_encomendas[atoi(dados[0])].quantidade; i++)
  {
    if (final[i].stock_produto > 0)
    {
      printf("* %s %d %d\n", final[i].desc_produto, inventario_produtos[final[i].id_produto].preco_produto, final[i].stock_produto);
    }
    else
    {
      
    }

  }

}

int menu()
{
  int run = 1;
  char operation;
  while (run == 1)
  {
    operation = getchar();
    if (operation != 'N')
    {
      getchar();
    }
    else
    {
      
    }

    switch (operation)
    {
      case 'a':
        adiciona_produto();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        cria_nova_encomenda();
        break;

      case 'A':
        adiciona_produto_encomenda();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_produto_encomenda();
        break;

      case 'C':
        calcula_custo();
        break;

      case 'p':
        altera_preco_produto();
        break;

      case 'E':
        descricao_quantidade();
        break;

      case 'm':
        lista_identificador();
        break;

      case 'l':
        auxiliar();
        break;

      case 'L':
        auxiliar_2();
        break;

      case 'x':
        run = 0;
        break;

    }

  }

  return 0;
}

int main()
{
  menu();
  return 0;
}

