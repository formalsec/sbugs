/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


void cria_produto();
void adiciona_stock();
void retira_stock();
void altera_preco();
void precos_ordem();
void cria_encomenda();
void adiciona_produto();
void retira_produto();
void custo_encomenda();
void produto_em_encomenda();
void produto_mais_vezes();
void descr_ordem();
int particao_precos();
void quicksort_precos();
int particao_descr();
void quicksort_descr();
void restart_contagens();
char descr[10000][64];
int preco_prod[10000][2];
int peso_prod[10000];
int stock_prod[10000];
int encomenda[500][200];
int peso_enc[500];
int stock_enc[500][200];
int nmr_prod_enc[500];
int idp = 0;
int ide = 0;
int ord[10000][2];
int idp_ord[10000];
int stock_enc_ord[200];
int main()
{
  char n;
  restart_contagens();
  while (1 != 'x')
  {
    n = new_sym_var(sizeof(char) * 8);
    switch (n)
    {
      case 'a':
        getchar();
        cria_produto();
        break;

      case 'q':
        getchar();
        adiciona_stock();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        getchar();
        adiciona_produto();
        break;

      case 'r':
        getchar();
        retira_stock();
        break;

      case 'R':
        getchar();
        retira_produto();
        break;

      case 'C':
        getchar();
        custo_encomenda();
        break;

      case 'p':
        getchar();
        altera_preco();
        break;

      case 'E':
        getchar();
        produto_em_encomenda();
        break;

      case 'm':
        getchar();
        produto_mais_vezes();
        break;

      case 'l':
        precos_ordem();
        break;

      case 'L':
        getchar();
        descr_ordem();
        break;

      case 'x':
        return 0;
        break;

    }

  }

  return 0;
}

void cria_produto()
{
  char c;
  int atual = 0;
  while (atual != 4)
  {
    int j = 0;
    int i = 0;
    switch (atual)
    {
      case 0:
        for (; (c = getchar()) != ':'; ++i)
        descr[idp][i] = c;

        ++atual;
        break;

      case 1:
        while ((c = getchar()) != ':')
        j = (j * 10) + (c - 48);

        preco_prod[idp][0] = j;
        preco_prod[idp][1] = idp;
        ++atual;
        break;

      case 2:
        while ((c = getchar()) != ':')
        j = (j * 10) + (c - 48);

        peso_prod[idp] = j;
        ++atual;
        break;

      case 3:
        while ((c = getchar()) != '\n')
        j = (j * 10) + (c - 48);

        stock_prod[idp] = j;
        ++atual;
        break;

    }

  }

  printf("Novo produto %d.\n", idp);
  ++idp;
}

void adiciona_stock()
{
  char c;
  int prod = 0;
  int atual = 0;
  while (atual != 2)
  {
    int j = 0;
    switch (atual)
    {
      case 0:
        while ((c = getchar()) != ':')
        prod = (prod * 10) + (c - 48);

        ++atual;
        break;

      case 1:
        if (prod >= idp)
      {
        {
          printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", prod);
        }
      }
      else
      {
        {
          while ((c = getchar()) != '\n')
            j = (j * 10) + (c - 48);

          stock_prod[prod] += j;
        }
      }

        ++atual;
        break;

    }

  }

}

void cria_encomenda()
{
  printf("Nova encomenda %d.\n", ide);
  ++ide;
}

void adiciona_produto()
{
  char c;
  char repetido = 'n';
  int prod = 0;
  int enc = 0;
  int atual = 0;
  int qnt = 0;
  int posicao_repetido = 0;
  int i = 0;
  while (atual != 3)
  {
    switch (atual)
    {
      case 0:
        while ((c = getchar()) != ':')
        enc = (enc * 10) + (c - 48);

        ++atual;
        break;

      case 1:
        while ((c = getchar()) != ':')
        prod = (prod * 10) + (c - 48);

        if (enc >= ide)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", prod, enc);
          return;
        }
      }
      else
      {
        if (prod >= idp)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", prod, enc);
            return;
          }
        }
        else
        {
          ++atual;
        }

      }

        break;

      case 2:
        while ((c = getchar()) != '\n')
      {
        qnt = (qnt * 10) + (c - 48);
      }

        if (qnt > stock_prod[prod])
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", prod, enc);
      }
      else
      {
        if (((peso_prod[prod] * qnt) + peso_enc[enc]) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", prod, enc);
        }
        else
        {
          {
            if (nmr_prod_enc[enc] > 0)
            {
              {
                for (; i < nmr_prod_enc[enc]; ++i)
                {
                  if (prod == encomenda[enc][i])
                  {
                    {
                      repetido = 'y';
                      posicao_repetido = i;
                    }
                  }
                  else
                  {
                    
                  }

                }

              }
            }
            else
            {
              
            }

            if (repetido == 'y')
            {
              stock_enc[enc][posicao_repetido] += qnt;
            }
            else
            {
              {
                encomenda[enc][nmr_prod_enc[enc]] = prod;
                stock_enc[enc][nmr_prod_enc[enc]] = qnt;
                nmr_prod_enc[enc] += 1;
              }
            }

            peso_enc[enc] += peso_prod[prod] * qnt;
            stock_prod[prod] -= qnt;
          }
        }

      }

        return;

    }

  }

}

void retira_stock()
{
  char c;
  int prod = 0;
  int atual = 0;
  while (atual != 2)
  {
    int j = 0;
    switch (atual)
    {
      case 0:
        while ((c = getchar()) != ':')
        prod = (prod * 10) + (c - 48);

        ++atual;
        break;

      case 1:
        if (prod >= idp)
      {
        printf("Impossivel remover stock do produto %d. Produto inexistente.\n", prod);
      }
      else
      {
        {
          while ((c = getchar()) != '\n')
            j = (j * 10) + (c - 48);

          if (j > stock_prod[prod])
          {
            printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", j, prod);
          }
          else
          {
            stock_prod[prod] -= j;
          }

        }
      }

        ++atual;
        break;

    }

  }

}

void retira_produto()
{
  char c;
  char aux = 'n';
  int i = 0;
  int prod = 0;
  int atual = 0;
  int enc = 0;
  int posicao = 0;
  while (atual != 2)
  {
    switch (atual)
    {
      case 0:
        while ((c = getchar()) != ':')
        enc = (enc * 10) + (c - 48);

        ++atual;
        break;

      case 1:
        while ((c = getchar()) != '\n')
        prod = (prod * 10) + (c - 48);

        if (enc >= ide)
      {
        printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", prod, enc);
      }
      else
      {
        if (prod >= idp)
        {
          printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", prod, enc);
        }
        else
        {
          {
            while (i < nmr_prod_enc[enc])
            {
              if (encomenda[enc][i] == prod)
              {
                {
                  posicao = i;
                  aux = 'y';
                }
              }
              else
              {
                
              }

              ++i;
            }

            if (aux == 'y')
            {
              {
                stock_prod[prod] += stock_enc[enc][posicao];
                peso_enc[enc] -= stock_enc[enc][posicao] * peso_prod[prod];
                for (; posicao < nmr_prod_enc[enc]; ++posicao)
                {
                  stock_enc[enc][posicao] = stock_enc[enc][posicao + 1];
                  encomenda[enc][posicao] = encomenda[enc][posicao + 1];
                }

                --nmr_prod_enc[enc];
              }
            }
            else
            {
              
            }

          }
        }

      }

        ++atual;
        break;

    }

  }

}

void custo_encomenda()
{
  int total = 0;
  int enc = 0;
  int i = 0;
  char c;
  while ((c = getchar()) != '\n')
    enc = (enc * 10) + (c - 48);

  if (enc >= ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", enc);
  }
  else
  {
    {
      for (; i < nmr_prod_enc[enc]; ++i)
        total += stock_enc[enc][i] * preco_prod[encomenda[enc][i]][0];

      printf("Custo da encomenda %d %d.\n", enc, total);
    }
  }

}

void altera_preco()
{
  char c;
  int prod = 0;
  int atual = 0;
  while (atual != 2)
  {
    int j = 0;
    switch (atual)
    {
      case 0:
        while ((c = getchar()) != ':')
        prod = (prod * 10) + (c - 48);

        ++atual;
        break;

      case 1:
        if (prod >= idp)
      {
        printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", prod);
      }
      else
      {
        {
          while ((c = getchar()) != '\n')
            j = (j * 10) + (c - 48);

          preco_prod[prod][0] = j;
        }
      }

        ++atual;
        break;

    }

  }

}

void produto_em_encomenda()
{
  char c;
  char aux = 'n';
  int atual = 0;
  int i = 0;
  int enc = 0;
  int prod = 0;
  int j = 0;
  int posicao = 0;
  while (atual != 2)
  {
    switch (atual)
    {
      case 0:
        while ((c = getchar()) != ':')
        enc = (enc * 10) + (c - 48);

        ++atual;
        break;

      case 1:
        while ((c = getchar()) != '\n')
        prod = (prod * 10) + (c - 48);

        if (enc >= ide)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", enc);
      }
      else
      {
        if (prod >= idp)
        {
          printf("Impossivel listar produto %d. Produto inexistente.\n", prod);
        }
        else
        {
          {
            while (i < nmr_prod_enc[enc])
            {
              if (encomenda[enc][i] == prod)
              {
                {
                  aux = 'y';
                  posicao = i;
                }
              }
              else
              {
                
              }

              ++i;
            }

            for (; descr[prod][j] != '\0'; ++j)
              printf("%c", descr[prod][j]);

            if (aux == 'y')
            {
              printf(" %d.\n", stock_enc[enc][posicao]);
            }
            else
            {
              printf(" 0.\n");
            }

          }
        }

      }

        return;

    }

  }

}

void produto_mais_vezes()
{
  int i = 0;
  int j;
  int prod = 0;
  int enc_max = 0;
  int quant_max = 0;
  char c;
  while ((c = getchar()) != '\n')
    prod = (prod * 10) + (c - 48);

  if (prod >= idp)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", prod);
      return;
    }
  }
  else
  {
    
  }

  for (; i < ide; ++i)
  {
    for (j = 0; j < nmr_prod_enc[i]; ++j)
    {
      if ((prod == encomenda[i][j]) && (stock_enc[i][j] > quant_max))
      {
        {
          enc_max = i;
          quant_max = stock_enc[i][j];
        }
      }
      else
      {
        
      }

    }

  }

  if (quant_max != 0)
  {
    printf("Maximo produto %d %d %d.\n", prod, enc_max, quant_max);
  }
  else
  {
    
  }

  return;
}

void precos_ordem()
{
  int i;
  int j;
  char c;
  for (i = 0; i < idp; ++i)
  {
    ord[i][0] = preco_prod[i][0];
    ord[i][1] = preco_prod[i][1];
  }

  quicksort_precos(ord, 0, idp - 1);
  printf("Produtos\n");
  for (i = 0; i < idp; ++i)
  {
    printf("* ");
    for (j = 0; (c = descr[ord[i][1]][j]) != '\0'; ++j)
      printf("%c", c);

    printf(" %d", ord[i][0]);
    printf(" %d\n", stock_prod[ord[i][1]]);
  }

}

int particao_precos(int ord[][2], int menor, int maior)
{
  int j;
  int i = menor - 1;
  int pivot = ord[maior][0];
  int trocado_preco = 0;
  int trocado_idp = 0;
  for (j = menor; j <= (maior - 1); j++)
  {
    if ((ord[j][0] < pivot) || ((ord[j][0] == pivot) && (ord[maior][1] > ord[j][1])))
    {
      {
        i++;
        trocado_preco = ord[i][0];
        trocado_idp = ord[i][1];
        ord[i][0] = ord[j][0];
        ord[i][1] = ord[j][1];
        ord[j][0] = trocado_preco;
        ord[j][1] = trocado_idp;
      }
    }
    else
    {
      
    }

  }

  trocado_preco = ord[i + 1][0];
  trocado_idp = ord[i + 1][1];
  ord[i + 1][0] = ord[maior][0];
  ord[i + 1][1] = ord[maior][1];
  ord[maior][0] = trocado_preco;
  ord[maior][1] = trocado_idp;
  return i + 1;
}

void quicksort_precos(int ord[][2], int menor, int maior)
{
  int pivot;
  if (menor < maior)
  {
    {
      pivot = particao_precos(ord, menor, maior);
      quicksort_precos(ord, menor, pivot - 1);
      quicksort_precos(ord, pivot + 1, maior);
    }
  }
  else
  {
    
  }

}

void descr_ordem()
{
  char c;
  int enc = 0;
  int i;
  int j;
  while ((c = getchar()) != '\n')
    enc = (enc * 10) + (c - 48);

  if (enc >= ide)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", enc);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < nmr_prod_enc[enc]; ++i)
  {
    idp_ord[i] = encomenda[enc][i];
    stock_enc_ord[i] = stock_enc[enc][i];
  }

  quicksort_descr(idp_ord, stock_enc_ord, 0, nmr_prod_enc[enc] - 1);
  printf("Encomenda %d\n", enc);
  for (i = 0; i < nmr_prod_enc[enc]; ++i)
  {
    printf("* ");
    for (j = 0; (c = descr[idp_ord[i]][j]) != '\0'; ++j)
      printf("%c", c);

    printf(" %d", preco_prod[idp_ord[i]][0]);
    printf(" %d\n", stock_enc_ord[i]);
  }

}

int particao_descr(int ord[], int s_e[], int menor, int maior)
{
  int i = menor - 1;
  int pivot = idp_ord[maior];
  int t = 0;
  int j;
  int s;
  for (j = menor; j <= (maior - 1); j++)
  {
    if ((strcmp(descr[ord[j]], descr[pivot]) < 0) || ((strcmp(descr[ord[j]], descr[pivot]) == 0) && (pivot > ord[j])))
    {
      {
        ++i;
        t = ord[i];
        ord[i] = ord[j];
        ord[j] = t;
        s = s_e[i];
        s_e[i] = s_e[j];
        s_e[j] = s;
      }
    }
    else
    {
      
    }

  }

  t = ord[i + 1];
  ord[i + 1] = ord[maior];
  ord[maior] = t;
  s = s_e[i + 1];
  s_e[i + 1] = s_e[maior];
  s_e[maior] = s;
  return i + 1;
}

void quicksort_descr(int ord[], int s_e[], int menor, int maior)
{
  int pivot;
  if (menor < maior)
  {
    {
      pivot = particao_descr(ord, s_e, menor, maior);
      quicksort_descr(ord, s_e, menor, maior - 1);
      quicksort_descr(ord, s_e, pivot + 1, maior);
    }
  }
  else
  {
    
  }

}

void restart_contagens()
{
  int i = 0;
  for (; i < 500; ++i)
  {
    peso_enc[i] = 0;
    nmr_prod_enc[i] = 0;
  }

}

