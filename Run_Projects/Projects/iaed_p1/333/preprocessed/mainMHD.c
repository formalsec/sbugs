/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct produto
{
  char des[63];
  int preco;
  int qtd;
  int peso;
  int idp;
} P;
typedef struct encomenda
{
  int peso;
  int ide;
  P prode[9999];
  int precoe;
  int cont;
} E;
int prodE;
int m;
int cont;
P prod[9999];
int numero;
E enco[500];
int nenco;
int pre;
void case_a()
{
  printf("Novo produto %d.\n", numero);
}

void case_q(int idp, int qtd)
{
  if (idp == prod[idp].idp)
  {
    {
      prod[idp].qtd += qtd;
    }
  }
  else
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    }
  }

}

void case_N()
{
  printf("Nova encomenda %d.\n", nenco);
}

void case_A(int ide, int idp, int qtd)
{
  if (ide != enco[ide].ide)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
  }
  else
  {
    if (idp != prod[idp].idp)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
    }
    else
    {
      if (qtd > prod[idp].qtd)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        }
      }
      else
      {
        if ((enco[ide].peso + (prod[idp].peso * qtd)) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          }
        }
        else
        {
          if (ide == enco[ide].ide)
          {
            {
              if ((idp != enco[ide].prode[idp].idp) || (idp == 0))
              {
                {
                  enco[ide].prode[idp] = prod[idp];
                  enco[ide].prode[idp].idp = prod[idp].idp;
                  enco[ide].prode[idp].qtd = qtd;
                  prod[idp].qtd = prod[idp].qtd - qtd;
                  enco[ide].peso += prod[idp].peso * qtd;
                  enco[ide].cont++;
                }
              }
              else
              {
                {
                  enco[ide].prode[idp].qtd += qtd;
                  prod[idp].qtd = prod[idp].qtd - qtd;
                  enco[ide].peso += prod[idp].peso * qtd;
                }
              }

            }
          }
          else
          {
            
          }

        }

      }

    }

  }

}

void case_r(int idp, int qtd)
{
  if (idp != prod[idp].idp)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    
  }

  if (idp == prod[idp].idp)
  {
    {
      if (qtd > prod[idp].qtd)
      {
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
        }
      }
      else
      {
        {
          prod[idp].qtd = prod[idp].qtd - qtd;
        }
      }

    }
  }
  else
  {
    
  }

}

void case_R(int ide, int idp)
{
  if (ide == enco[ide].ide)
  {
    {
      if (idp == prod[idp].idp)
      {
        {
          prod[idp].qtd += enco[ide].prode[idp].qtd;
          enco[ide].prode[idp].qtd = 0;
        }
      }
      else
      {
        {
          printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
        }
      }

    }
  }
  else
  {
    if (ide != enco[ide].ide)
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      }
    }
    else
    {
      
    }

  }

}

void case_C(int ide)
{
  int pre = 0;
  int n;
  if (ide != enco[ide].ide)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    if (ide == enco[ide].ide)
    {
      {
        for (n = 0; n <= enco[ide].cont; n++)
        {
          pre += enco[ide].prode[n].qtd * prod[n].preco;
        }

        printf("Custo da encomenda %d %d.\n", ide, pre);
      }
    }
    else
    {
      
    }

  }

}

void case_p(int idp, int preco)
{
  if (idp != prod[idp].idp)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    if (idp == prod[idp].idp)
    {
      {
        prod[idp].preco = preco;
      }
    }
    else
    {
      
    }

  }

}

void case_E(int ide, int idp)
{
  if (ide != enco[ide].ide)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    
  }

  if (idp != prod[idp].idp)
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    
  }

  if (ide == enco[ide].ide)
  {
    {
      if (idp == prod[idp].idp)
      {
        {
          printf("%s %d.\n", prod[idp].des, enco[ide].prode[idp].qtd);
        }
      }
      else
      {
        
      }

    }
  }
  else
  {
    
  }

}

void case_m(int idp)
{
  int x = 0;
  int f = 0;
  int ide = 0;
  if (idp != prod[idp].idp)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    {
      while (x < nenco)
      {
        if (enco[x].prode[idp].qtd > f)
        {
          {
            f = enco[x].prode[idp].qtd;
            ide = x;
          }
        }
        else
        {
          
        }

        x++;
      }

      printf("Maximo produto %d %d %d.\n", idp, ide, f);
    }
  }

}

void merge(int a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if ((prod[aux[j]].preco < prod[aux[i]].preco) || (i > m))
    {
      {
        a[k] = aux[j--];
      }
    }
    else
    {
      {
        a[k] = aux[i++];
      }
    }

  }

}

void mergesort(int a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, l, m);
  mergesort(a, m + 1, r);
  merge(a, l, m, r);
}

void merge1(int a[], int left, int m, int right, int ide)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if (strcmp(enco[ide].prode[aux[j]].des, enco[ide].prode[aux[i]].des) < 0)
    {
      {
        a[k] = aux[j--];
      }
    }
    else
    {
      {
        a[k] = aux[i++];
      }
    }

  }

}

void mergesort1(int a[], int l, int r, int ide)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort1(a, l, m, ide);
  mergesort1(a, m + 1, r, ide);
  merge1(a, l, m, r, ide);
}

int main()
{
  char c;
  int qtd = 0;
  int preco = 0;
  int idp = 0;
  int ide = 0;
  int x = 0;
  int a[10000];
  while (c != 'x')
  {
    switch (c = getchar())
    {
      case 'a':
        getchar();
        for (int prod_index = 0; prod_index < 10; prod_index++)
      {
        prod[numero].des[prod_index] = new_sym_var(sizeof(char) * 8);
      }

        prod[numero].des[10 - 1] = '\0';
        prod[numero].preco = new_sym_var(sizeof(int) * 8);
        prod[numero].peso = new_sym_var(sizeof(int) * 8);
        prod[numero].qtd = new_sym_var(sizeof(int) * 8);
        case_a();
        prod[numero].idp = numero;
        numero++;
        break;

      case 'q':
        c = getchar();
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        case_q(idp, qtd);
        break;

      case 'N':
        case_N();
        enco[nenco].ide = nenco;
        nenco++;
        enco[nenco].cont = 0;
        break;

      case 'A':
        getchar();
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        case_A(ide, idp, qtd);
        break;

      case 'r':
        getchar();
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        case_r(idp, qtd);
        break;

      case 'R':
        getchar();
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        case_R(ide, idp);
        break;

      case 'C':
        getchar();
        ide = new_sym_var(sizeof(int) * 8);
        case_C(ide);
        break;

      case 'p':
        getchar();
        idp = new_sym_var(sizeof(int) * 8);
        preco = new_sym_var(sizeof(int) * 8);
        case_p(idp, preco);
        break;

      case 'E':
        getchar();
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        case_E(ide, idp);
        break;

      case 'm':
        getchar();
        idp = new_sym_var(sizeof(int) * 8);
        case_m(idp);
        break;

      case 'l':
        while (x < numero)
      {
        a[x] = x;
        x++;
      }

        mergesort(a, 0, numero - 1);
        x = 0;
        printf("Produtos\n");
        while (x < numero)
      {
        printf("* %s %d %d\n", prod[a[x]].des, prod[a[x]].preco, prod[a[x]].qtd);
        x++;
      }

        break;

      case 'L':
        getchar();
        ide = new_sym_var(sizeof(int) * 8);
        if (enco[ide].ide != ide)
      {
        {
          printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
        }
      }
      else
      {
        {
          while (x < numero)
          {
            a[x] = x;
            x++;
          }

          mergesort1(a, 0, numero - 1, ide);
          x = 0;
          printf("Encomenda %d\n", ide);
          while (x < numero)
          {
            if (enco[ide].prode[a[x]].idp == a[x])
            {
              {
                printf("* %s %d %d\n", enco[ide].prode[a[x]].des, prod[a[x]].preco, enco[ide].prode[a[x]].qtd);
              }
            }
            else
            {
              
            }

            x++;
          }

        }
      }

        break;

      case 'x':
        exit(0);

    }

    c = getchar();
  }

  return 0;
}

