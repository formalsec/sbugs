/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int idp;
  char desc[63];
  int preco;
  int peso;
  int qtd;
} Produto;
typedef struct 
{
  int qtd_prod;
  Produto produtos[10000];
} Encomenda;
Produto sistema[10000];
Encomenda encomendas[500];
int idp_atual = 0;
int ide_atual = 0;
int cmp = 0;
int existe_encomenda(int id)
{
  return id < ide_atual;
}

int existe_produto_sistema(int id)
{
  return id < idp_atual;
}

int existe_produto_encomenda(int ide, int id)
{
  int i;
  int j = encomendas[ide].qtd_prod;
  for (i = 0; i < j; i++)
    if (encomendas[ide].produtos[i].idp == id)
  {
    return i;
  }
  else
  {
    
  }


  return -1;
}

int verifica_peso_encomenda(Encomenda encomenda, int peso, int qtd)
{
  int i;
  int res = 0;
  int j = encomenda.qtd_prod;
  for (i = 0; i < j; i++)
    res += encomenda.produtos[i].peso * encomenda.produtos[i].qtd;

  return (res + (peso * qtd)) <= 200;
}

int cmp_produtos(Produto a, Produto b)
{
  if (cmp == 0)
  {
    return (a.preco == b.preco) ? (a.idp < b.idp) : (a.preco < b.preco);
  }
  else
  {
    
  }

  return strcmp(a.desc, b.desc) < 0;
}

void quicksort(Produto a[], int l, int r)
{
  Produto v;
  int i;
  int j;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = l - 1;
  j = r;
  v = a[r];
  while (i < j)
  {
    while (cmp_produtos(a[++i], v))
      ;

    while (cmp_produtos(v, a[--j]))
      if (j == l)
    {
      break;
    }
    else
    {
      
    }


    if (i < j)
    {
      Produto t = a[i];
      a[i] = a[j];
      a[j] = t;
    }
    else
    {
      
    }

    ;
  }

  {
    Produto t = a[i];
    a[i] = a[r];
    a[r] = t;
  }
  ;
  quicksort(a, l, i - 1);
  quicksort(a, i + 1, r);
}

void adiciona_produto(Produto prod)
{
  prod.idp = idp_atual;
  sistema[idp_atual] = prod;
  printf("Novo produto %d.\n", idp_atual++);
}

void adiciona_stock(int idp, int qtd)
{
  if (existe_produto_sistema(idp))
  {
    sistema[idp].qtd += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void remove_stock(int idp, int qtd)
{
  if (!existe_produto_sistema(idp))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (sistema[idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      sistema[idp].qtd -= qtd;
    }

  }

}

void adiciona_produto_encomenda(int ide, int idp, int qtd)
{
  int id_atual;
  int i;
  if (!existe_encomenda(ide))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (!existe_produto_sistema(idp))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (sistema[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if (!verifica_peso_encomenda(encomendas[ide], sistema[idp].peso, qtd))
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          id_atual = encomendas[ide].qtd_prod;
          i = existe_produto_encomenda(ide, idp);
          remove_stock(idp, qtd);
          if (i == (-1))
          {
            encomendas[ide].produtos[id_atual] = sistema[idp];
            encomendas[ide].produtos[id_atual].qtd = qtd;
            encomendas[ide].qtd_prod++;
          }
          else
          {
            encomendas[ide].produtos[i].qtd += qtd;
          }

        }

      }

    }

  }

}

void remove_produto(int ide, int idp)
{
  int i;
  if (!existe_encomenda(ide))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (!existe_produto_sistema(idp))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      i = existe_produto_encomenda(ide, idp);
      if (i > (-1))
      {
        sistema[idp].qtd += encomendas[ide].produtos[i].qtd;
        encomendas[ide].produtos[i].qtd = 0;
      }
      else
      {
        
      }

    }

  }

}

void custo_encomenda(int ide)
{
  int i;
  int res = 0;
  if (!existe_encomenda(ide))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < encomendas[ide].qtd_prod; i++)
      res += encomendas[ide].produtos[i].preco * encomendas[ide].produtos[i].qtd;

    printf("Custo da encomenda %d %d.\n", ide, res);
  }

}

void altera_preco_produto(int idp, int preco)
{
  int i;
  int j;
  if (!existe_produto_sistema(idp))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    sistema[idp].preco = preco;
    for (i = 0; i < ide_atual; i++)
    {
      j = existe_produto_encomenda(i, idp);
      if (j > (-1))
      {
        encomendas[i].produtos[j].preco = preco;
      }
      else
      {
        
      }

    }

  }

}

void lista_produto_encomenda(int ide, int idp)
{
  int qtd = 0;
  int i;
  if (!existe_encomenda(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (!existe_produto_sistema(idp))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      i = existe_produto_encomenda(ide, idp);
      if (i > (-1))
      {
        qtd = encomendas[ide].produtos[i].qtd;
      }
      else
      {
        
      }

      printf("%s %d.\n", sistema[idp].desc, qtd);
    }

  }

}

void lista_maximo_produto(int idp)
{
  Produto prod;
  int i;
  int j;
  int ide_menor;
  int maior_quantidade = -1;
  if (!existe_produto_sistema(idp))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; i < ide_atual; i++)
      if (existe_encomenda(i))
    {
      j = existe_produto_encomenda(i, idp);
      if (j > (-1))
      {
        prod = encomendas[i].produtos[j];
        if (maior_quantidade < prod.qtd)
        {
          maior_quantidade = prod.qtd;
          ide_menor = i;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }
    else
    {
      
    }


    if (maior_quantidade > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide_menor, maior_quantidade);
    }
    else
    {
      
    }

  }

}

void lista_produtos_sistema()
{
  int i;
  Produto aux[10000];
  for (i = 0; i < idp_atual; i++)
    aux[i] = sistema[i];

  cmp = 0;
  quicksort(aux, 0, idp_atual - 1);
  printf("Produtos\n");
  for (i = 0; i < idp_atual; i++)
    printf("* %s %d %d\n", aux[i].desc, aux[i].preco, aux[i].qtd);

}

void lista_encomenda(int ide)
{
  int i;
  int j;
  if (!existe_encomenda(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    j = encomendas[ide].qtd_prod;
    cmp = 1;
    quicksort(encomendas[ide].produtos, 0, j - 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < j; i++)
      if (encomendas[ide].produtos[i].qtd > 0)
    {
      printf("* %s %d %d\n", encomendas[ide].produtos[i].desc, encomendas[ide].produtos[i].preco, encomendas[ide].produtos[i].qtd);
    }
    else
    {
      
    }


  }

}

int main()
{
  Produto prod;
  int ide;
  int idp;
  int qtd;
  int preco;
  char opcao;
  while ((1 != EOF) && (opcao != 'x'))
  {
    opcao = new_sym_var(sizeof(char) * 8);
    switch (opcao)
    {
      case 'a':
        for (int prod_index = 0; prod_index < 10; prod_index++)
      {
        prod.desc[prod_index] = new_sym_var(sizeof(char) * 8);
      }

        prod.desc[10 - 1] = '\0';
        prod.preco = new_sym_var(sizeof(int) * 8);
        prod.peso = new_sym_var(sizeof(int) * 8);
        prod.qtd = new_sym_var(sizeof(int) * 8);
        adiciona_produto(prod);
        break;

      case 'q':
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        adiciona_stock(idp, qtd);
        break;

      case 'N':
        printf("Nova encomenda %d.\n", ide_atual++);
        break;

      case 'A':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        adiciona_produto_encomenda(ide, idp, qtd);
        break;

      case 'r':
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        remove_stock(idp, qtd);
        break;

      case 'R':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        remove_produto(ide, idp);
        break;

      case 'C':
        ide = new_sym_var(sizeof(int) * 8);
        custo_encomenda(ide);
        break;

      case 'p':
        idp = new_sym_var(sizeof(int) * 8);
        preco = new_sym_var(sizeof(int) * 8);
        altera_preco_produto(idp, preco);
        break;

      case 'E':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        lista_produto_encomenda(ide, idp);
        break;

      case 'm':
        idp = new_sym_var(sizeof(int) * 8);
        lista_maximo_produto(idp);
        break;

      case 'l':
        lista_produtos_sistema();
        break;

      case 'L':
        ide = new_sym_var(sizeof(int) * 8);
        lista_encomenda(ide);
        break;

    }

    opcao = new_sym_var(sizeof(char) * 8);
  }

  return 0;
}

