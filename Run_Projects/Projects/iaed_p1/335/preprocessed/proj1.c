/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct product
{
  char desc[63 + 1];
  int idp;
  int preco;
  int peso;
  int qtd;
} product;
product sistema[10000];
product encomendas[500][200];
product aux[10000];
int ids[2];
int min(int a, int b)
{
  return (a <= b) ? (a) : (b);
}

int partition(product caixa[], int l, int r)
{
  int i = l - 1;
  int j = r;
  product p = caixa[r];
  while (i < j)
  {
    while ((caixa[++i].preco < p.preco) || ((caixa[i].preco == p.preco) && (caixa[i].idp < p.idp)))
      ;

    while ((p.preco < caixa[--j].preco) || ((p.preco == caixa[j].preco) && (caixa[j].idp > p.idp)))
      ;

    if (j == l)
    {
      break;
    }
    else
    {
      
    }

    if (i < j)
    {
      {
        product t = caixa[i];
        caixa[i] = caixa[j];
        caixa[j] = t;
      }
    }
    else
    {
      
    }

    ;
  }

  {
    product t = caixa[i];
    caixa[i] = caixa[r];
    caixa[r] = t;
  }
  ;
  return i;
}

void quicksort(product caixa[], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition(caixa, l, r);
  quicksort(caixa, l, i - 1);
  quicksort(caixa, i + 1, r);
}

int tamanho_encomenda(product encomenda[])
{
  int i;
  for (i = 0; i < 200; i++)
    if (encomenda[i].qtd == 0)
  {
    break;
  }
  else
  {
    
  }


  return i;
}

int total_status_enc(char arg[], product caixa[])
{
  int i;
  int total = 0;
  int tam = tamanho_encomenda(caixa);
  for (i = 0; i < tam; i++)
  {
    if (!strcmp(arg, "preco"))
    {
      total += caixa[i].preco * caixa[i].qtd;
    }
    else
    {
      
    }

    if (!strcmp(arg, "peso"))
    {
      total += caixa[i].peso * caixa[i].qtd;
    }
    else
    {
      
    }

  }

  return total;
}

int produto_na_caixa(int idp, product caixa[])
{
  int i;
  int prod_in = 0;
  int tam = tamanho_encomenda(caixa);
  for (i = 0; i < tam; i++)
  {
    if (caixa[i].idp == idp)
    {
      {
        prod_in = 1;
        break;
      }
    }
    else
    {
      
    }

  }

  if (prod_in)
  {
    return i;
  }
  else
  {
    
  }

  return -1;
}

void adiciona_produto_enc(int qtd, product produto, product encomenda[])
{
  int i = produto_na_caixa(produto.idp, encomenda);
  if (i >= 0)
  {
    encomenda[i].qtd += qtd;
  }
  else
  {
    {
      i = tamanho_encomenda(encomenda);
      encomenda[i].idp = produto.idp;
      strcpy(encomenda[i].desc, produto.desc);
      encomenda[i].preco = produto.preco;
      encomenda[i].peso = produto.peso;
      encomenda[i].qtd = qtd;
    }
  }

}

void remove_produto_enc(int id, product encomenda[])
{
  int i = produto_na_caixa(id, encomenda);
  int tam_enc = tamanho_encomenda(encomenda);
  if (i >= 0)
  {
    {
      sistema[id].qtd += encomenda[i].qtd;
      for (; (i + 1) < tam_enc; i++)
      {
        encomenda[i] = encomenda[i + 1];
      }

      encomenda[i].qtd = 0;
    }
  }
  else
  {
    
  }

}

void atualiza_encomendas(int n_enc, product prod, product enc[500][200])
{
  int i;
  int at;
  for (i = 0; i <= n_enc; i++)
  {
    at = produto_na_caixa(prod.idp, enc[i]);
    if (at >= 0)
    {
      enc[i][at].preco = prod.preco;
    }
    else
    {
      
    }

  }

}

int id_maxqtd_enc(int ide, product produto, product encomendas[500][200])
{
  int i;
  int j;
  int tam_enc;
  int max = 0;
  int enc_max;
  int prod_in = 0;
  for (i = 0; i <= ide; i++)
  {
    tam_enc = tamanho_encomenda(encomendas[i]);
    for (j = 0; j < tam_enc; j++)
    {
      if (encomendas[i][j].idp == produto.idp)
      {
        {
          if (encomendas[i][j].qtd > max)
          {
            {
              max = encomendas[i][j].qtd;
              enc_max = i;
            }
          }
          else
          {
            
          }

          prod_in = 1;
          break;
        }
      }
      else
      {
        
      }

    }

  }

  if (prod_in)
  {
    return enc_max;
  }
  else
  {
    
  }

  return -1;
}

int descr_ordenada(product p1, product p2)
{
  int i;
  int tam = min(strlen(p1.desc), strlen(p2.desc));
  for (i = 0; i < tam; i++)
  {
    if (p1.desc[i] < p2.desc[i])
    {
      return 1;
    }
    else
    {
      
    }

    if (p2.desc[i] < p1.desc[i])
    {
      return 0;
    }
    else
    {
      
    }

  }

  return 0;
}

void ordena_desc(int n_prod, product armazem[])
{
  int i;
  int j;
  int done;
  for (i = 0; i < (n_prod - 1); i++)
  {
    done = 1;
    for (j = n_prod - 1; j > i; j--)
      if (descr_ordenada(armazem[j], armazem[j - 1]))
    {
      {
        {
          product t = armazem[j];
          armazem[j] = armazem[j - 1];
          armazem[j - 1] = t;
        }
        ;
        done = 0;
      }
    }
    else
    {
      
    }


    if (done)
    {
      break;
    }
    else
    {
      
    }

  }

}

void a()
{
  ids[0]++;
  for (int sistema_index = 0; sistema_index < (63 + 1); sistema_index++)
  {
    sistema[ids[0]].desc[sistema_index] = new_sym_var(sizeof(char) * 8);
  }

  sistema[ids[0]].desc[(63 + 1) - 1] = '\0';
  sistema[ids[0]].preco = new_sym_var(sizeof(int) * 8);
  sistema[ids[0]].peso = new_sym_var(sizeof(int) * 8);
  sistema[ids[0]].qtd = new_sym_var(sizeof(int) * 8);
  sistema[ids[0]].idp = ids[0];
  printf("Novo produto %d.\n", ids[0]);
}

void q()
{
  int pr_in;
  int qtd_in;
  pr_in = new_sym_var(sizeof(int) * 8);
  qtd_in = new_sym_var(sizeof(int) * 8);
  if (pr_in > ids[0])
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", pr_in);
  }
  else
  {
    sistema[pr_in].qtd += qtd_in;
  }

}

void N()
{
  ids[1]++;
  printf("Nova encomenda %d.\n", ids[1]);
}

void A()
{
  int enc_in;
  int pr_in;
  int qtd_in;
  enc_in = new_sym_var(sizeof(int) * 8);
  pr_in = new_sym_var(sizeof(int) * 8);
  qtd_in = new_sym_var(sizeof(int) * 8);
  if (enc_in > ids[1])
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", pr_in, enc_in);
  }
  else
  {
    if (pr_in > ids[0])
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", pr_in, enc_in);
    }
    else
    {
      if (sistema[pr_in].qtd < qtd_in)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", pr_in, enc_in);
      }
      else
      {
        if ((total_status_enc("peso", encomendas[enc_in]) + (qtd_in * sistema[pr_in].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", pr_in, enc_in);
        }
        else
        {
          {
            adiciona_produto_enc(qtd_in, sistema[pr_in], encomendas[enc_in]);
            sistema[pr_in].qtd -= qtd_in;
          }
        }

      }

    }

  }

}

void r()
{
  int pr_in;
  int qtd_in;
  pr_in = new_sym_var(sizeof(int) * 8);
  qtd_in = new_sym_var(sizeof(int) * 8);
  if (pr_in > ids[0])
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", pr_in);
  }
  else
  {
    if (sistema[pr_in].qtd < qtd_in)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd_in, pr_in);
    }
    else
    {
      sistema[pr_in].qtd -= qtd_in;
    }

  }

}

void R()
{
  int enc_in;
  int pr_in;
  enc_in = new_sym_var(sizeof(int) * 8);
  pr_in = new_sym_var(sizeof(int) * 8);
  if (enc_in > ids[1])
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", pr_in, enc_in);
  }
  else
  {
    if (pr_in > ids[0])
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", pr_in, enc_in);
    }
    else
    {
      remove_produto_enc(pr_in, encomendas[enc_in]);
    }

  }

}

void C()
{
  int enc_in;
  enc_in = new_sym_var(sizeof(int) * 8);
  if (enc_in > ids[1])
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", enc_in);
  }
  else
  {
    printf("Custo da encomenda %d %d.\n", enc_in, total_status_enc("preco", encomendas[enc_in]));
  }

}

void p()
{
  int pr_in;
  int p;
  pr_in = new_sym_var(sizeof(int) * 8);
  p = new_sym_var(sizeof(int) * 8);
  if (pr_in > ids[0])
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", pr_in);
  }
  else
  {
    {
      sistema[pr_in].preco = p;
      atualiza_encomendas(ids[1], sistema[pr_in], encomendas);
    }
  }

}

void E()
{
  int enc_in;
  int pr_in;
  int id_pr_enc;
  enc_in = new_sym_var(sizeof(int) * 8);
  pr_in = new_sym_var(sizeof(int) * 8);
  if (enc_in > ids[1])
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", enc_in);
  }
  else
  {
    if (pr_in > ids[0])
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", pr_in);
    }
    else
    {
      {
        id_pr_enc = produto_na_caixa(pr_in, encomendas[enc_in]);
        printf("%s %d.\n", sistema[pr_in].desc, encomendas[enc_in][id_pr_enc].qtd);
      }
    }

  }

}

void m()
{
  int pr_in;
  int id_enc;
  pr_in = new_sym_var(sizeof(int) * 8);
  if (pr_in > ids[0])
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", pr_in);
  }
  else
  {
    {
      id_enc = id_maxqtd_enc(ids[1], sistema[pr_in], encomendas);
      if (id_enc >= 0)
      {
        printf("Maximo produto %d %d %d.\n", pr_in, id_enc, encomendas[id_enc][produto_na_caixa(pr_in, encomendas[id_enc])].qtd);
      }
      else
      {
        
      }

    }
  }

}

void l()
{
  int i;
  for (i = 0; i <= ids[0]; i++)
    aux[i] = sistema[i];

  quicksort(aux, 0, ids[0]);
  printf("Produtos\n");
  for (i = 0; i <= ids[0]; i++)
    printf("* %s %d %d\n", aux[i].desc, aux[i].preco, aux[i].qtd);

}

void L()
{
  int enc_in;
  enc_in = new_sym_var(sizeof(int) * 8);
  if (enc_in > ids[1])
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", enc_in);
  }
  else
  {
    {
      int i;
      int tam = tamanho_encomenda(encomendas[enc_in]);
      for (i = 0; i < tam; i++)
        aux[i] = encomendas[enc_in][i];

      ordena_desc(tam, aux);
      printf("Encomenda %d\n", enc_in);
      for (i = 0; i < tam; i++)
        printf("* %s %d %d\n", aux[i].desc, aux[i].preco, aux[i].qtd);

    }
  }

}

int main()
{
  char cmd;
  ids[0] = -1;
  ids[1] = -1;
  while (1)
  {
    cmd = new_sym_var(sizeof(char) * 8);
    switch (cmd)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

      case 'x':
        return 0;

    }

  }

}

