/*File generated by PreProcessor.py*/


#include <stdio.h>                
#include <string.h>               


typedef struct 
{
  int idp;
  int preco;
  int peso;
  int qtd;
  char describe[63];
} PRODUCT;
typedef struct 
{
  int idp;
  int qtd;
} PROENCOMENDA;
typedef struct 
{
  int ide;
  int peso;
  int numprod;
  PROENCOMENDA pro[200];
} ENCOMENDA;
int prcur_aux(ENCOMENDA enc[500], int idp, int ide, int numprod);
void merge(PRODUCT ord[10000], int l, int m, int r, int estado);
void mergesort(PRODUCT ord[10000], int l, int h, int estado);
void command_a_(PRODUCT sto[10000], int idp);
void command_q_(PRODUCT sto[10000]);
void command_N_(ENCOMENDA enc[500], int ide, int ati[500][2]);
void command_A_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2]);
void command_r_(PRODUCT sto[10000]);
void command_R_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2]);
void command_C_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2]);
void command_p_(PRODUCT sto[10000]);
void command_E_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2]);
void command_m_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2]);
void command_l_(PRODUCT sto[10000], int idp);
void command_L_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2], int idp);
int main()
{
  int idp = -1;
  int estado = 1;
  int ide = -1;
  char c;
  static int ati[500][2] = {0};
  static PRODUCT sto[10000] = {0};
  static ENCOMENDA enc[500] = {0};
  while (1)
  {
    c = new_sym_var(sizeof(char) * 8);
    if (estado == 1)
    {
      {
        switch (c)
        {
          case 'a':
            idp++;
            command_a_(sto, idp);
            break;

          case 'q':
            command_q_(sto);
            break;

          case 'N':
            ide++;
            command_N_(enc, ide, ati);
            break;

          case 'A':
            command_A_(enc, sto, ati);
            break;

          case 'r':
            command_r_(sto);
            break;

          case 'R':
            command_R_(enc, sto, ati);
            break;

          case 'C':
            command_C_(enc, sto, ati);
            break;

          case 'p':
            command_p_(sto);
            break;

          case 'E':
            command_E_(enc, sto, ati);
            break;

          case 'm':
            command_m_(enc, sto, ati);
            break;

          case 'l':
            command_l_(sto, idp);
            break;

          case 'L':
            command_L_(enc, sto, ati, idp);
            break;

          case 'x':
            return 0;

        }

      }
    }
    else
    {
      
    }

    if (c == '\n')
    {
      estado = 1;
    }
    else
    {
      estado = 0;
    }

  }

}

int prcur_aux(ENCOMENDA enc[500], int idp, int ide, int numprod)
{
  int prcur = -1;
  int i;
  for (i = 0; i < numprod; i++)
  {
    if (enc[ide].pro[i].idp == idp)
    {
      {
        prcur = i;
        break;
      }
    }
    else
    {
      
    }

  }

  return prcur;
}

void merge(PRODUCT ord[10000], int l, int m, int r, int estado)
{
  int k = l;
  int ie;
  int id;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  PRODUCT e[10000];
  PRODUCT d[10000];
  for (ie = l; ie <= m; ie++)
    e[ie - l] = ord[ie];

  for (id = m + 1; id <= r; id++)
    d[(id - m) - 1] = ord[id];

  ie = 0;
  id = 0;
  while ((ie < n1) && (id < n2))
  {
    if (estado)
    {
      {
        if (e[ie].preco <= d[id].preco)
        {
          ord[k++] = e[ie++];
        }
        else
        {
          ord[k++] = d[id++];
        }

      }
    }
    else
    {
      {
        if (strcmp(d[id].describe, e[ie].describe) > 0)
        {
          ord[k++] = e[ie++];
        }
        else
        {
          ord[k++] = d[id++];
        }

      }
    }

  }

  while (ie < n1)
    ord[k++] = e[ie++];

  while (id < n2)
    ord[k++] = d[id++];

}

void mergesort(PRODUCT ord[10000], int l, int h, int estado)
{
  int mid;
  if (l < h)
  {
    {
      mid = (l + h) / 2;
      mergesort(ord, l, mid, estado);
      mergesort(ord, mid + 1, h, estado);
      merge(ord, l, mid, h, estado);
    }
  }
  else
  {
    
  }

}

void command_a_(PRODUCT sto[10000], int idp)
{
  sto[idp].idp = idp;
  for (int sto_index = 0; sto_index < 10; sto_index++)
  {
    sto[idp].describe[sto_index] = new_sym_var(sizeof(char) * 8);
  }

  sto[idp].describe[10 - 1] = '\0';
  sto[idp].preco = new_sym_var(sizeof(int) * 8);
  sto[idp].peso = new_sym_var(sizeof(int) * 8);
  sto[idp].qtd = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", idp);
}

void command_q_(PRODUCT sto[10000])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (sto[idp].preco != 0)
  {
    {
      sto[idp].qtd += qtd;
    }
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void command_N_(ENCOMENDA enc[500], int ide, int ati[500][2])
{
  ati[ide][0] = 1;
  enc[ide].ide = ide;
  printf("Nova encomenda %d.\n", enc[ide].ide);
}

void command_A_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2])
{
  int ide;
  int idp;
  int qtd;
  int prcur;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ati[ide][0] != 1)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
  }
  else
  {
    {
      if (sto[idp].preco == 0)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
        }
      }
      else
      {
        {
          if (sto[idp].qtd < qtd)
          {
            {
              printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
            }
          }
          else
          {
            {
              if ((enc[ide].peso + (sto[idp].peso * qtd)) > 200)
              {
                {
                  printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
                }
              }
              else
              {
                {
                  prcur = prcur_aux(enc, idp, ide, ati[ide][1]);
                  if (prcur == (-1))
                  {
                    {
                      for (i = 0; i < 500; i++)
                      {
                        if (enc[ide].pro[i].qtd == 0)
                        {
                          {
                            prcur = i;
                            break;
                          }
                        }
                        else
                        {
                          
                        }

                      }

                      enc[ide].pro[prcur].idp = sto[idp].idp;
                      enc[ide].pro[prcur].qtd = qtd;
                      ati[ide][1] += 1;
                    }
                  }
                  else
                  {
                    enc[ide].pro[prcur].qtd += qtd;
                  }

                  sto[idp].qtd -= qtd;
                  enc[ide].peso += sto[idp].peso * qtd;
                }
              }

            }
          }

        }
      }

    }
  }

}

void command_r_(PRODUCT sto[10000])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (sto[idp].preco == 0)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      if (sto[idp].qtd < qtd)
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
      }
      else
      {
        sto[idp].qtd -= qtd;
      }

    }
  }

}

void command_R_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2])
{
  int ide;
  int idp;
  int i;
  int prcur;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ati[ide][0] != 1)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    {
      if (sto[idp].preco == 0)
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
      else
      {
        {
          prcur = prcur_aux(enc, idp, ide, ati[ide][1]);
          if (prcur != (-1))
          {
            {
              enc[ide].peso -= sto[idp].peso * enc[ide].pro[prcur].qtd;
              sto[idp].qtd += enc[ide].pro[prcur].qtd;
              for (i = prcur; i < ati[ide][1]; i++)
                enc[ide].pro[i] = enc[ide].pro[i + 1];

              ati[ide][1] -= 1;
            }
          }
          else
          {
            
          }

        }
      }

    }
  }

}

void command_C_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2])
{
  int ide;
  int i;
  int subtotal = 0;
  int total = 0;
  int prcur;
  ide = new_sym_var(sizeof(int) * 8);
  if (ati[ide][0] != 1)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (i = 0; i < 10000; i++)
      {
        prcur = prcur_aux(enc, i, ide, ati[ide][1]);
        if (enc[ide].pro[prcur].idp == sto[i].idp)
        {
          {
            subtotal = sto[i].preco * enc[ide].pro[prcur].qtd;
            total += subtotal;
          }
        }
        else
        {
          
        }

      }

      printf("Custo da encomenda %d %d.\n", ide, total);
    }
  }

}

void command_p_(PRODUCT sto[10000])
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (sto[idp].preco == 0)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    sto[idp].preco = preco;
  }

}

void command_E_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2])
{
  int ide;
  int idp;
  int prcur;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ati[ide][0] != 1)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      if (sto[idp].preco == 0)
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      }
      else
      {
        {
          prcur = prcur_aux(enc, idp, ide, ati[ide][1]);
          if (prcur != (-1))
          {
            printf("%s %d.\n", sto[idp].describe, enc[ide].pro[prcur].qtd);
          }
          else
          {
            printf("%s %d.\n", sto[idp].describe, 0);
          }

        }
      }

    }
  }

}

void command_m_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2])
{
  int idp;
  int a;
  int i;
  int maior = 0;
  int ide = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (sto[idp].preco == 0)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      for (a = 0; a < 500; a++)
      {
        if (ati[a][0])
        {
          {
            for (i = 0; i < ati[a][1]; i++)
            {
              if ((enc[a].pro[i].qtd > maior) && (enc[a].pro[i].idp == idp))
              {
                {
                  maior = enc[a].pro[i].qtd;
                  ide = a;
                }
              }
              else
              {
                
              }

            }

          }
        }
        else
        {
          break;
        }

      }

      if (maior != 0)
      {
        printf("Maximo produto %d %d %d.\n", idp, ide, maior);
      }
      else
      {
        
      }

    }
  }

}

void command_l_(PRODUCT sto[10000], int idp)
{
  int p;
  int n;
  PRODUCT ord[10000];
  for (n = 0; n <= idp; n++)
  {
    ord[n] = sto[n];
  }

  mergesort(ord, 0, idp, 1);
  printf("Produtos\n");
  for (p = 0; p < (idp + 1); p++)
  {
    printf("* %s %d %d\n", sto[ord[p].idp].describe, sto[ord[p].idp].preco, sto[ord[p].idp].qtd);
  }

}

void command_L_(ENCOMENDA enc[500], PRODUCT sto[10000], int ati[500][2], int idp)
{
  int ide;
  int p;
  int e;
  int prcur;
  PRODUCT ord[500];
  ide = new_sym_var(sizeof(int) * 8);
  if (ati[ide][0] != 1)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (e = 0; e < ati[ide][1]; e++)
      {
        for (p = 0; p <= idp; p++)
        {
          if (enc[ide].pro[e].idp == sto[p].idp)
          {
            {
              ord[e] = sto[p];
              break;
            }
          }
          else
          {
            
          }

        }

      }

      mergesort(ord, 0, ati[ide][1] - 1, 0);
      printf("Encomenda %d\n", ide);
      for (p = 0; p < ati[ide][1]; p++)
      {
        prcur = prcur_aux(enc, ord[p].idp, ide, ati[ide][1]);
        printf("* %s %d %d\n", ord[p].describe, ord[p].preco, enc[ide].pro[prcur].qtd);
      }

    }
  }

}

