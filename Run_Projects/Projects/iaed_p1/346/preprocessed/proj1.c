/*File generated by PreProcessor.py*/


#include <stdio.h>


int idp = 0;
int ide = 0;
typedef struct Stock
{
  char desc[63];
  int preco;
  int peso;
  int qtd;
} Stock;
Stock stock[10000];
typedef struct Encomenda
{
  int preco;
  int peso;
  int produtos[10000];
  int idps[10000];
} Encomenda;
Encomenda encomenda[500];
void merge_l(int p[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > l; i--)
    aux[i - 1] = p[i - 1];

  for (j = m; j < r; j++)
    aux[(r + m) - j] = p[j + 1];

  for (k = l; k <= r; k++)
  {
    if ((stock[aux[i]].preco > stock[aux[j]].preco) || ((stock[aux[i]].preco == stock[aux[j]].preco) && (aux[i] > aux[j])))
    {
      p[k] = aux[j--];
    }
    else
    {
      p[k] = aux[i++];
    }

  }

}

void mergesort_l(int p[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_l(p, l, m);
  mergesort_l(p, m + 1, r);
  merge_l(p, l, m, r);
}

int ordena_desc(char a[], char b[])
{
  int i;
  for (i = 0; i < 63; i++)
  {
    if (a[i] > b[i])
    {
      return 1;
    }
    else
    {
      if (a[i] < b[i])
      {
        return 0;
      }
      else
      {
        
      }

    }

  }

  return 0;
}

void merge_L(int p[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > l; i--)
    aux[i - 1] = p[i - 1];

  for (j = m; j < r; j++)
    aux[(r + m) - j] = p[j + 1];

  for (k = l; k <= r; k++)
    if (ordena_desc(stock[aux[i]].desc, stock[aux[j]].desc))
  {
    p[k] = aux[j--];
  }
  else
  {
    p[k] = aux[i++];
  }


}

void mergesort_L(int p[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_L(p, l, m);
  mergesort_L(p, m + 1, r);
  merge_L(p, l, m, r);
}

void comando_a()
{
  char s;
  char desc[63];
  int i;
  int preco = 0;
  int peso = 0;
  int qtd = 0;
  for (i = 0; i < 63; i++)
  {
    s = getchar();
    if (s != ' ')
    {
      if (s == ':')
      {
        break;
      }
      else
      {
        desc[i - 1] = s;
        desc[i] = '\0';
      }

    }
    else
    {
      
    }

  }

  for (i = 0; i < 10000; i++)
  {
    s = getchar();
    if (s == ':')
    {
      break;
    }
    else
    {
      s = s - '0';
      preco = (preco * 10) + s;
    }

  }

  for (i = 0; i < 10000; i++)
  {
    s = getchar();
    if (s == ':')
    {
      break;
    }
    else
    {
      s = s - '0';
      peso = (peso * 10) + s;
    }

  }

  for (i = 0; i < 10000; i++)
  {
    s = getchar();
    if (s == '\n')
    {
      break;
    }
    else
    {
      s = s - '0';
      qtd = (qtd * 10) + s;
    }

  }

  for (i = 0; i < 63; i++)
  {
    if (desc[i] == '\0')
    {
      break;
    }
    else
    {
      stock[idp].desc[i] = desc[i];
      stock[idp].desc[i + 1] = '\0';
    }

  }

  stock[idp].preco = preco;
  stock[idp].peso = peso;
  stock[idp].qtd = qtd;
  printf("Novo produto %d.\n", idp);
  idp++;
}

void comando_q()
{
  int indice;
  int qtd;
  indice = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if ((idp - 1) < indice)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", indice);
  }
  else
  {
    stock[indice].qtd = stock[indice].qtd + qtd;
  }

}

void comando_N()
{
  int i;
  printf("Nova encomenda %d.\n", ide);
  encomenda[ide].preco = 0;
  encomenda[ide].peso = 0;
  encomenda[ide].produtos[10000] = 0;
  for (i = 0; i < 10000; i++)
    encomenda[ide].idps[i] = -1;

  ide++;
}

void comando_A()
{
  int indice_e;
  int indice_p;
  int qtd;
  indice_e = new_sym_var(sizeof(int) * 8);
  indice_p = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if ((ide - 1) < indice_e)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", indice_p, indice_e);
  }
  else
  {
    if ((idp - 1) < indice_p)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", indice_p, indice_e);
    }
    else
    {
      if (qtd > stock[indice_p].qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", indice_p, indice_e);
      }
      else
      {
        if (((qtd * stock[indice_p].peso) + encomenda[indice_e].peso) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", indice_p, indice_e);
        }
        else
        {
          encomenda[indice_e].peso = encomenda[indice_e].peso + (qtd * stock[indice_p].peso);
          encomenda[indice_e].preco = encomenda[indice_e].preco + (qtd * stock[indice_p].preco);
          stock[indice_p].qtd = stock[indice_p].qtd - qtd;
          encomenda[indice_e].produtos[indice_p] = encomenda[indice_e].produtos[indice_p] + qtd;
          encomenda[indice_e].idps[indice_p] = indice_p;
        }

      }

    }

  }

}

void comando_r()
{
  int indice_p;
  int qtd;
  indice_p = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if ((idp - 1) < indice_p)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", indice_p);
  }
  else
  {
    if ((stock[indice_p].qtd - qtd) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, indice_p);
    }
    else
    {
      stock[indice_p].qtd = stock[indice_p].qtd - qtd;
    }

  }

}

void comando_R()
{
  int indice_e;
  int indice_p;
  indice_e = new_sym_var(sizeof(int) * 8);
  indice_p = new_sym_var(sizeof(int) * 8);
  if ((ide - 1) < indice_e)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", indice_p, indice_e);
  }
  else
  {
    if ((idp - 1) < indice_p)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", indice_p, indice_e);
    }
    else
    {
      encomenda[indice_e].peso = encomenda[indice_e].peso - (encomenda[indice_e].produtos[indice_p] * stock[indice_p].peso);
      encomenda[indice_e].preco = encomenda[indice_e].preco - (encomenda[indice_e].produtos[indice_p] * stock[indice_p].preco);
      stock[indice_p].qtd = stock[indice_p].qtd + encomenda[indice_e].produtos[indice_p];
      encomenda[indice_e].produtos[indice_p] = 0;
      encomenda[indice_e].idps[indice_p] = -1;
    }

  }

}

void comando_C()
{
  int indice_e;
  indice_e = new_sym_var(sizeof(int) * 8);
  if ((ide - 1) < indice_e)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", indice_e);
  }
  else
  {
    printf("Custo da encomenda %d %d.\n", indice_e, encomenda[indice_e].preco);
  }

}

void comando_p()
{
  int i;
  int indice_p;
  int preco;
  indice_p = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if ((idp - 1) < indice_p)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", indice_p);
  }
  else
  {
    for (i = 0; i < ide; i++)
    {
      encomenda[i].preco = (encomenda[i].preco - (encomenda[i].produtos[indice_p] * stock[indice_p].preco)) + (encomenda[i].produtos[indice_p] * preco);
    }

    stock[indice_p].preco = preco;
  }

}

void comando_E()
{
  int i;
  int indice_e;
  int indice_p;
  indice_e = new_sym_var(sizeof(int) * 8);
  indice_p = new_sym_var(sizeof(int) * 8);
  if ((ide - 1) < indice_e)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", indice_e);
  }
  else
  {
    if ((idp - 1) < indice_p)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", indice_p);
    }
    else
    {
      for (i = 0; i < 63; i++)
        if (stock[indice_p].desc[i] == '\0')
      {
        break;
      }
      else
      {
        printf("%c", stock[indice_p].desc[i]);
      }


      printf(" %d.\n", encomenda[indice_e].produtos[indice_p]);
    }

  }

}

void comando_m()
{
  int i;
  int e;
  int maiorqtd;
  int indice_p;
  indice_p = new_sym_var(sizeof(int) * 8);
  if ((idp - 1) < indice_p)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", indice_p);
  }
  else
  {
    maiorqtd = 0;
    for (i = 0; i < ide; i++)
    {
      if (encomenda[i].produtos[indice_p] > maiorqtd)
      {
        maiorqtd = encomenda[i].produtos[indice_p];
        e = i;
      }
      else
      {
        
      }

    }

    if (maiorqtd > 0)
    {
      printf("Maximo produto %d %d %d.\n", indice_p, e, encomenda[e].produtos[indice_p]);
    }
    else
    {
      
    }

  }

}

void comando_l()
{
  int i;
  int a[10000];
  int l = 0;
  for (i = 0; i < idp; i++)
    a[i] = i;

  mergesort_l(a, l, idp - 1);
  printf("Produtos\n");
  for (i = 0; i < idp; i++)
  {
    printf("* %s %d %d\n", stock[a[i]].desc, stock[a[i]].preco, stock[a[i]].qtd);
  }

}

void comando_L()
{
  int i;
  int indice_e = 0;
  int produtos[200];
  int q;
  int l = 0;
  indice_e = new_sym_var(sizeof(int) * 8);
  if (indice_e > (ide - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", indice_e);
  }
  else
  {
    q = 0;
    for (i = 0; i < 10000; i++)
    {
      if (encomenda[indice_e].idps[i] != (-1))
      {
        produtos[q++] = encomenda[indice_e].idps[i];
      }
      else
      {
        
      }

    }

    mergesort_L(produtos, l, q - 1);
    printf("Encomenda %d\n", indice_e);
    for (i = 0; i < q; i++)
      printf("* %s %d %d\n", stock[produtos[i]].desc, stock[produtos[i]].preco, encomenda[indice_e].produtos[produtos[i]]);

  }

}

void lercomando(char c)
{
  switch (c)
  {
    case 'a':
      comando_a();
      break;

    case 'q':
      comando_q();
      break;

    case 'N':
      comando_N();
      break;

    case 'A':
      comando_A();
      break;

    case 'r':
      comando_r();
      break;

    case 'R':
      comando_R();
      break;

    case 'C':
      comando_C();
      break;

    case 'p':
      comando_p();
      break;

    case 'E':
      comando_E();
      break;

    case 'm':
      comando_m();
      break;

    case 'l':
      comando_l();
      break;

    case 'L':
      comando_L();
      break;

  }

}

int main()
{
  char c;
  c = getchar();
  while (c != 'x')
  {
    lercomando(c);
    c = getchar();
  }

  return 0;
}

