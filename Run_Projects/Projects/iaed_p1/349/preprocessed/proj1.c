/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct Produto
{
  int identificador;
  char descricao[64];
  int preco;
  int peso;
  int quantidade;
} Produto;
typedef struct Encomenda
{
  Produto prod[10000];
  int qt_prod;
  int id_e;
  int peso_e;
} Encomenda;
Produto pvetor[10000];
Encomenda evetor[500];
int cont_pgeral = 0;
int cont_egeral = 0;
void AddProduct()
{
  getchar();
  for (int pvetor_index = 0; pvetor_index < 10; pvetor_index++)
  {
    pvetor[cont_pgeral].descricao[pvetor_index] = new_sym_var(sizeof(char) * 8);
  }

  pvetor[cont_pgeral].descricao[10 - 1] = '\0';
  pvetor[cont_pgeral].preco = new_sym_var(sizeof(int) * 8);
  pvetor[cont_pgeral].peso = new_sym_var(sizeof(int) * 8);
  pvetor[cont_pgeral].quantidade = new_sym_var(sizeof(int) * 8);
  pvetor[cont_pgeral].identificador = cont_pgeral;
  printf("Novo produto %d.\n", cont_pgeral);
}

void AddStock()
{
  int idp = 0;
  int qtd = 0;
  getchar();
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= cont_pgeral)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    pvetor[idp].quantidade += qtd;
  }

}

void NewOrder()
{
  printf("Nova encomenda %d.\n", cont_egeral);
}

void AddToOrder()
{
  int ide;
  int idp;
  int quantidade;
  int x = 0;
  int estado = 0;
  int tamanho = 0;
  int peso_atual = 0;
  int peso_entrar = 0;
  int peso_produto = 0;
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (ide >= cont_egeral)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    estado = 1;
  }
  else
  {
    if (idp >= cont_pgeral)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      estado = 1;
    }
    else
    {
      
    }

  }

  for (x = 0; x < evetor[ide].qt_prod; x++)
  {
    if (evetor[ide].prod[x].identificador == idp)
    {
      estado = 1;
      peso_atual = evetor[ide].peso_e;
      peso_entrar = quantidade * pvetor[idp].peso;
      if ((pvetor[idp].quantidade - quantidade) < 0)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((peso_atual + peso_entrar) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          evetor[ide].prod[x].quantidade += quantidade;
          pvetor[idp].quantidade -= quantidade;
          evetor[ide].peso_e += peso_entrar;
        }

      }

    }
    else
    {
      
    }

  }

  if (estado == 0)
  {
    tamanho = evetor[ide].qt_prod;
    peso_produto = pvetor[idp].peso * quantidade;
    if ((pvetor[idp].quantidade - quantidade) < 0)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    }
    else
    {
      if ((evetor[ide].peso_e + peso_produto) > 200)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
      }
      else
      {
        evetor[ide].prod[tamanho].identificador = idp;
        strcpy(evetor[ide].prod[tamanho].descricao, pvetor[idp].descricao);
        evetor[ide].prod[tamanho].quantidade = quantidade;
        pvetor[idp].quantidade -= quantidade;
        evetor[ide].peso_e += peso_produto;
        evetor[ide].qt_prod += 1;
      }

    }

  }
  else
  {
    
  }

}

void RemoveStock()
{
  int idp = 0;
  int qtd = 0;
  getchar();
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= cont_pgeral)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if ((pvetor[idp].quantidade - qtd) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      pvetor[idp].quantidade -= qtd;
    }

  }

}

void RemoveFromOrder()
{
  int ide;
  int idp;
  int i = 0;
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= cont_egeral)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= cont_pgeral)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      
    }

  }

  for (i = 0; i < evetor[ide].qt_prod; i++)
  {
    if (evetor[ide].prod[i].identificador == idp)
    {
      pvetor[idp].quantidade += evetor[ide].prod[i].quantidade;
      evetor[ide].peso_e -= evetor[ide].prod[i].quantidade * pvetor[idp].peso;
      evetor[ide].prod[i].quantidade = 0;
    }
    else
    {
      continue;
    }

  }

}

void OrderCost()
{
  int ide;
  int i;
  int total = 0;
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= cont_egeral)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < evetor[ide].qt_prod; i++)
    {
      if (evetor[ide].prod[i].quantidade > 0)
      {
        total += evetor[ide].prod[i].quantidade * pvetor[evetor[ide].prod[i].identificador].preco;
      }
      else
      {
        continue;
      }

    }

    printf("Custo da encomenda %d %d.\n", ide, total);
  }

}

void ChangePrice()
{
  int idp = 0;
  int pric = 0;
  getchar();
  idp = new_sym_var(sizeof(int) * 8);
  pric = new_sym_var(sizeof(int) * 8);
  if (idp >= cont_pgeral)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    pvetor[idp].preco = pric;
  }

}

void OrderProperties()
{
  int ide;
  int idp;
  int estado = 0;
  int i;
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= cont_egeral)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= cont_pgeral)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      for (i = 0; i < evetor[ide].qt_prod; i++)
      {
        if (evetor[ide].prod[i].identificador == idp)
        {
          printf("%s %d.\n", pvetor[idp].descricao, evetor[ide].prod[i].quantidade);
          estado = 1;
        }
        else
        {
          continue;
        }

      }

      if (estado == 0)
      {
        printf("%s 0.\n", pvetor[idp].descricao);
      }
      else
      {
        
      }

    }

  }

}

void LargestProductinOrder()
{
  int idp;
  int i;
  int e;
  int maior = 0;
  int maior2 = 0;
  int estado = 0;
  getchar();
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= cont_pgeral)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; i < cont_egeral; i++)
    {
      for (e = 0; e < evetor[i].qt_prod; e++)
      {
        if (evetor[i].prod[e].identificador == idp)
        {
          if (evetor[i].prod[e].quantidade > maior)
          {
            maior = evetor[i].prod[e].quantidade;
            maior2 = i;
            estado = 1;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

  }

  if (estado == 1)
  {
    printf("Maximo produto %d %d %d.\n", idp, maior2, maior);
  }
  else
  {
    
  }

}

void Merge(int arr[10000], int ids[10000], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  int L[10000];
  int R[10000];
  int P[10000];
  int Q[10000];
  for (i = 0; i < n1; i++)
  {
    L[i] = arr[l + i];
    P[i] = ids[l + i];
  }

  for (j = 0; j < n2; j++)
  {
    R[j] = arr[(m + 1) + j];
    Q[j] = ids[(m + 1) + j];
  }

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (L[i] <= R[j])
    {
      arr[k] = L[i];
      ids[k] = P[i];
      i++;
    }
    else
    {
      arr[k] = R[j];
      ids[k] = Q[j];
      j++;
    }

    k++;
  }

  while (i < n1)
  {
    arr[k] = L[i];
    ids[k] = P[i];
    i++;
    k++;
  }

  while (j < n2)
  {
    arr[k] = R[j];
    ids[k] = Q[j];
    j++;
    k++;
  }

}

void MergeSort(int arr[10000], int ids[10000], int l, int r)
{
  if (l < r)
  {
    int m = l + ((r - l) / 2);
    MergeSort(arr, ids, l, m);
    MergeSort(arr, ids, m + 1, r);
    Merge(arr, ids, l, m, r);
  }
  else
  {
    
  }

}

void SortPrice()
{
  int i = 0;
  int j = 0;
  int arr[10000];
  int ids[10000];
  for (i = 0; i < cont_pgeral; i++)
  {
    arr[i] = pvetor[i].preco;
    ids[i] = pvetor[i].identificador;
  }

  MergeSort(arr, ids, 0, cont_pgeral - 1);
  printf("Produtos\n");
  for (j = 0; j < cont_pgeral; j++)
    printf("* %s %d %d\n", pvetor[ids[j]].descricao, pvetor[ids[j]].preco, pvetor[ids[j]].quantidade);

}

void AlphabeticalSort(char arr[10000][64], int ids[10000], int ide)
{
  int i;
  int j;
  int aux2;
  char aux[64];
  for (i = 1; i < evetor[ide].qt_prod; i++)
  {
    for (j = 1; j < evetor[ide].qt_prod; j++)
    {
      if (strcmp(arr[j - 1], arr[j]) > 0)
      {
        strcpy(aux, arr[j - 1]);
        aux2 = ids[j - 1];
        strcpy(arr[j - 1], arr[j]);
        ids[j - 1] = ids[j];
        strcpy(arr[j], aux);
        ids[j] = aux2;
      }
      else
      {
        
      }

    }

  }

}

void SortName()
{
  int l;
  int x;
  int e;
  int ide;
  int ids[10000];
  char arr[10000][64];
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= cont_egeral)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (e = 0; e < evetor[ide].qt_prod; e++)
    {
      ids[e] = evetor[ide].prod[e].identificador;
      strcpy(arr[e], evetor[ide].prod[e].descricao);
    }

    AlphabeticalSort(arr, ids, ide);
    printf("Encomenda %d\n", ide);
    for (x = 0; x < evetor[ide].qt_prod; x++)
    {
      for (l = 0; l < evetor[ide].qt_prod; l++)
      {
        if ((evetor[ide].prod[l].identificador == ids[x]) && (evetor[ide].prod[l].quantidade > 0))
        {
          printf("* %s %d %d\n", pvetor[ids[x]].descricao, pvetor[ids[x]].preco, evetor[ide].prod[l].quantidade);
        }
        else
        {
          
        }

      }

    }

  }

}

int main()
{
  char c;
  while (((c = getchar()) != EOF) && (c != 'x'))
  {
    if (c == 'a')
    {
      AddProduct();
      cont_pgeral += 1;
    }
    else
    {
      if (c == 'q')
      {
        AddStock();
      }
      else
      {
        if (c == 'N')
        {
          NewOrder();
          cont_egeral += 1;
        }
        else
        {
          if (c == 'A')
          {
            AddToOrder();
          }
          else
          {
            if (c == 'r')
            {
              RemoveStock();
            }
            else
            {
              if (c == 'R')
              {
                RemoveFromOrder();
              }
              else
              {
                if (c == 'C')
                {
                  OrderCost();
                }
                else
                {
                  if (c == 'p')
                  {
                    ChangePrice();
                  }
                  else
                  {
                    if (c == 'E')
                    {
                      OrderProperties();
                    }
                    else
                    {
                      if (c == 'm')
                      {
                        LargestProductinOrder();
                      }
                      else
                      {
                        if (c == 'l')
                        {
                          SortPrice();
                        }
                        else
                        {
                          if (c == 'L')
                          {
                            SortName();
                          }
                          else
                          {
                            continue;
                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return 0;
}

