/*File generated by PreProcessor.py*/


#include "IAED.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void a_parsing(char input[100], int productid)
{
  int i = 1;
  char *token = 0;
  PRODUCT *product = (PRODUCT *) calloc(1, sizeof(PRODUCT));
  product->id = productid;
  token = strtok(input, ":");
  while (token != 0)
  {
    switch (i)
    {
      case 1:
      {
        strcpy(product->desc, token);
        break;
      }

      case 2:
      {
        product->price = atoi(token);
        break;
      }

      case 3:
      {
        product->weight = atoi(token);
        break;
      }

      case 4:
      {
        product->stock = atoi(token);
      }

      default:
        break;

    }

    i++;
    token = strtok(0, ":");
  }

  lstproducts[productid] = product;
}

void add_stock(char input[100])
{
  int i = 0;
  int qtd = 0;
  char *token = 0;
  token = strtok(input, ":");
  i = atoi(token);
  if (lstproducts[i] == 0)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", i);
    }
  }
  else
  {
    {
      token = strtok(0, "\0");
      qtd = atoi(token);
      lstproducts[i]->stock += qtd;
    }
  }

}

void remove_stock(char input[100])
{
  int i = 0;
  int qtd = 0;
  char *token = 0;
  token = strtok(input, ":");
  i = atoi(token);
  if (lstproducts[i] == 0)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", i);
    }
  }
  else
  {
    {
      token = strtok(0, "\0");
      qtd = atoi(token);
      if (lstproducts[i]->stock >= qtd)
      {
        {
          lstproducts[i]->stock -= qtd;
        }
      }
      else
      {
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, i);
        }
      }

    }
  }

}

void create_order(int orderid)
{
  ORDER *order = (ORDER *) calloc(1, sizeof(ORDER));
  order->orderid = orderid;
  order->orderweight = 0;
  order->sizelstproducts = 0;
  lstorders[orderid] = order;
}

void add_product_to_order(char input[100])
{
  int ide = 0;
  int qtd = 0;
  int idp = 0;
  int i = 0;
  int flag = 0;
  int c = 0;
  char *token = 0;
  token = strtok(input, ":");
  ide = atoi(token);
  token = strtok(0, ":");
  idp = atoi(token);
  token = strtok(0, "\0");
  qtd = atoi(token);
  if (lstorders[ide] == 0)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
  }
  else
  {
    if (lstproducts[idp] == 0)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
    }
    else
    {
      if (qtd > lstproducts[idp]->stock)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        }
      }
      else
      {
        {
          if ((lstorders[ide]->orderweight + (lstproducts[idp]->weight * qtd)) <= 200)
          {
            {
              for (i = 0; i < lstorders[ide]->sizelstproducts; i++)
              {
                if (strcmp(lstproducts[idp]->desc, lstorders[ide]->orderlstproducts[i].desc) == 0)
                {
                  {
                    flag++;
                    c = i;
                  }
                }
                else
                {
                  
                }

              }

              if (flag == 0)
              {
                {
                  lstorders[ide]->orderlstproducts[lstorders[ide]->sizelstproducts] = *lstproducts[idp];
                  lstorders[ide]->orderlstproducts[lstorders[ide]->sizelstproducts].stock = qtd;
                  lstorders[ide]->sizelstproducts++;
                  lstorders[ide]->orderweight += lstproducts[idp]->weight * qtd;
                  lstproducts[idp]->stock -= qtd;
                  lstproducts[idp]->times_in_order++;
                }
              }
              else
              {
                {
                  lstorders[ide]->orderlstproducts[c].stock += qtd;
                  lstproducts[idp]->stock -= qtd;
                  lstorders[ide]->orderweight += lstproducts[idp]->weight * qtd;
                }
              }

            }
          }
          else
          {
            {
              printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
            }
          }

        }
      }

    }

  }

}

void remove_product_from_order(char input[100])
{
  int ide = 0;
  int idp = 0;
  int i = 0;
  int flag = 0;
  int c = 0;
  char *token = 0;
  token = strtok(input, ":");
  ide = atoi(token);
  token = strtok(0, "\0");
  idp = atoi(token);
  if (lstorders[ide] == 0)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
  }
  else
  {
    if (lstproducts[idp] == 0)
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
    }
    else
    {
      {
        for (i = 0; i < lstorders[ide]->sizelstproducts; i++)
        {
          if (strcmp(lstorders[ide]->orderlstproducts[i].desc, lstproducts[idp]->desc) == 0)
          {
            {
              flag = i;
              lstproducts[idp]->stock += lstorders[ide]->orderlstproducts[flag].stock;
              lstorders[ide]->orderweight -= lstorders[ide]->orderlstproducts[flag].weight * lstorders[ide]->orderlstproducts[flag].stock;
              if (flag == (lstorders[ide]->sizelstproducts - 1))
              {
                {
                  lstorders[ide]->orderlstproducts[flag].id = 0;
                  strcpy(lstorders[ide]->orderlstproducts[flag].desc, "\0");
                  lstorders[ide]->orderlstproducts[flag].price = 0;
                  lstorders[ide]->orderlstproducts[flag].weight = 0;
                  lstorders[ide]->orderlstproducts[flag].stock = 0;
                }
              }
              else
              {
                
              }

              for (c = flag; c < (lstorders[ide]->sizelstproducts - 1); c++)
              {
                lstorders[ide]->orderlstproducts[c] = lstorders[ide]->orderlstproducts[c + 1];
              }

              lstorders[ide]->sizelstproducts--;
              lstproducts[idp]->times_in_order--;
            }
          }
          else
          {
            
          }

        }

      }
    }

  }

}

void calc_order_cost(char input[100])
{
  int ide = 0;
  int total = 0;
  int i = 0;
  ide = atoi(input);
  if (lstorders[ide] == 0)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    {
      for (i = 0; i < lstorders[ide]->sizelstproducts; i++)
      {
        total += lstproducts[lstorders[ide]->orderlstproducts[i].id]->price * lstorders[ide]->orderlstproducts[i].stock;
      }

      printf("Custo da encomenda %d %d.\n", ide, total);
    }
  }

}

void change_product_price(char input[100])
{
  int idp = 0;
  int new_price = 0;
  char *token = 0;
  token = strtok(input, ":");
  idp = atoi(token);
  token = strtok(0, "\0");
  new_price = atoi(token);
  if (lstproducts[idp] == 0)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    {
      lstproducts[idp]->price = new_price;
    }
  }

}

void list_product_in_order(char input[100])
{
  int idp = 0;
  int ide = 0;
  int i = 0;
  int flag = 0;
  char *token = 0;
  token = strtok(input, ":");
  ide = atoi(token);
  token = strtok(0, "\0");
  idp = atoi(token);
  if (lstorders[ide] == 0)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    if (lstproducts[idp] == 0)
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      }
    }
    else
    {
      {
        for (i = 0; i < lstorders[ide]->sizelstproducts; i++)
        {
          if (strcmp(lstproducts[idp]->desc, lstorders[ide]->orderlstproducts[i].desc) == 0)
          {
            {
              flag++;
              printf("%s %d.\n", lstorders[ide]->orderlstproducts[i].desc, lstorders[ide]->orderlstproducts[i].stock);
            }
          }
          else
          {
            
          }

        }

        if (flag == 0)
        {
          {
            printf("%s 0.\n", lstproducts[idp]->desc);
          }
        }
        else
        {
          
        }

      }
    }

  }

}

void show_order_of_max_times_product(char input[100], int max)
{
  int idp = 0;
  int ide = 0;
  int i = 0;
  int final_ide = 0;
  int qtd = 0;
  idp = atoi(input);
  if (lstproducts[idp] == 0)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    if (lstproducts[idp]->times_in_order != 0)
    {
      {
        for (ide = 0; ide < max; ide++)
        {
          for (i = 0; i < lstorders[ide]->sizelstproducts; i++)
          {
            if ((strcmp(lstorders[ide]->orderlstproducts[i].desc, lstproducts[idp]->desc) == 0) && (lstorders[ide]->orderlstproducts[i].stock > qtd))
            {
              {
                final_ide = ide;
                qtd = lstorders[final_ide]->orderlstproducts[i].stock;
              }
            }
            else
            {
              
            }

          }

        }

        printf("Maximo produto %d %d %d.\n", idp, final_ide, qtd);
      }
    }
    else
    {
      
    }

  }

}

void merge(PRODUCT a[], int left, int m, int right)
{
  int i = 0;
  int j = 0;
  int k = 0;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
  {
    if ((aux[j].price < aux[i].price) || (i > m))
    {
      {
        a[k] = aux[j--];
      }
    }
    else
    {
      if (aux[j].id == aux[i].id)
      {
        {
          if (aux[j].id < aux[i].id)
          {
            {
              a[k] = aux[j--];
            }
          }
          else
          {
            {
              a[k] = aux[i++];
            }
          }

        }
      }
      else
      {
        {
          a[k] = aux[i++];
        }
      }

    }

  }

}

void mergesort(PRODUCT a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, l, m);
  mergesort(a, m + 1, r);
  merge(a, l, m, r);
}

void merge_alphabet(PRODUCT a[], int left, int m, int right)
{
  int i = 0;
  int j = 0;
  int k = 0;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
  {
    if ((strcmp(aux[j].desc, aux[i].desc) < 0) || (i > m))
    {
      {
        a[k] = aux[j--];
      }
    }
    else
    {
      {
        a[k] = aux[i++];
      }
    }

  }

}

void mergesort_alphabet(PRODUCT a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_alphabet(a, l, m);
  mergesort_alphabet(a, m + 1, r);
  merge_alphabet(a, l, m, r);
}

void print_lst_products(int max)
{
  int i = 0;
  PRODUCT *lstproducts_aux = (PRODUCT *) calloc(10000, sizeof(PRODUCT));
  for (i = 0; i < max; i++)
  {
    lstproducts_aux[i] = *lstproducts[i];
  }

  mergesort(lstproducts_aux, 0, max - 1);
  printf("Produtos\n");
  for (i = 0; i < max; i++)
  {
    printf("* %s %d %d\n", lstproducts_aux[i].desc, lstproducts_aux[i].price, lstproducts_aux[i].stock);
  }

  free(lstproducts_aux);
}

void print_lst_products_in_order(char input[100])
{
  int i = 0;
  int ide = 0;
  ORDER *order_aux = (ORDER *) calloc(1, sizeof(ORDER));
  ide = atoi(input);
  if (lstorders[ide] == 0)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    {
      order_aux->sizelstproducts = lstorders[ide]->sizelstproducts;
      for (i = 0; i < lstorders[ide]->sizelstproducts; i++)
      {
        order_aux->orderlstproducts[i] = lstorders[ide]->orderlstproducts[i];
      }

      mergesort_alphabet(order_aux->orderlstproducts, 0, order_aux->sizelstproducts - 1);
      printf("Encomenda %d\n", ide);
      for (i = 0; i < order_aux->sizelstproducts; i++)
      {
        printf("* %s %d %d\n", order_aux->orderlstproducts[i].desc, lstproducts[order_aux->orderlstproducts[i].id]->price, order_aux->orderlstproducts[i].stock);
      }

    }
  }

  free(order_aux);
}

int main()
{
  int i = 0;
  int j = 0;
  int c = 0;
  int k = 0;
  while (1)
  {
    char command = '\0';
    char input[100] = "\0";
    command = new_sym_var(sizeof(char) * 8);
    switch (command)
    {
      case 'a':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        a_parsing(input, i);
        printf("Novo produto %d.\n", i);
        i++;
        break;
      }

      case 'q':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        add_stock(input);
        break;
      }

      case 'r':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        remove_stock(input);
        break;
      }

      case 'R':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        remove_product_from_order(input);
        break;
      }

      case 'C':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        calc_order_cost(input);
        break;
      }

      case 'p':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        change_product_price(input);
        break;
      }

      case 'E':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        list_product_in_order(input);
        break;
      }

      case 'N':
      {
        create_order(j);
        printf("Nova encomenda %d.\n", j);
        j++;
        break;
      }

      case 'm':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        show_order_of_max_times_product(input, j);
        break;
      }

      case 'A':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        add_product_to_order(input);
        break;
      }

      case 'l':
      {
        print_lst_products(i);
        break;
      }

      case 'L':
      {
        for (int input_index = 0; input_index < 10; input_index++)
        {
          input[input_index] = new_sym_var(sizeof(char) * 8);
        }

        input[10 - 1] = '\0';
        print_lst_products_in_order(input);
        break;
      }

      case 'x':
      {
        for (c = 0; c < i; c++)
        {
          free(lstproducts[c]);
        }

        for (k = 0; k < j; k++)
        {
          free(lstorders[k]);
        }

        return 0;
      }

      default:
        break;

    }

  }

}

