/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


struct product
{
  int id;
  int peso;
  int preco;
  int quant;
  char descricao[64];
};
struct product lista_produtos[10000];
struct product encomendas[500][200];
struct product aux_produtos[10000];
struct product aux_encomendas[200];
int idp_atual = 0;
int ide_atual = 0;
void init()
{
  int cont;
  int cont2;
  for (cont = 0; cont < 10000; cont++)
    lista_produtos[cont].preco = 0;

  for (cont = 0; cont < 500; cont++)
    for (cont2 = 0; cont2 < 200; cont2++)
    encomendas[cont][cont2].preco = 0;


}

void merge_produtos(struct product produtos[], int l_inf, int meio, int l_sup)
{
  int i;
  int j;
  int k;
  for (i = meio + 1; i > l_inf; i--)
    aux_produtos[i - 1] = produtos[i - 1];

  for (j = meio; j < l_sup; j++)
    aux_produtos[(l_sup + meio) - j] = produtos[j + 1];

  for (k = l_inf; k <= l_sup; k++)
  {
    if ((aux_produtos[j].preco < aux_produtos[i].preco) || ((aux_produtos[j].preco == aux_produtos[i].preco) && (aux_produtos[j].id < aux_produtos[i].id)))
    {
      produtos[k] = aux_produtos[j--];
    }
    else
    {
      produtos[k] = aux_produtos[i++];
    }

  }

}

void mergesort_produtos(struct product produtos[], int l_inf, int l_sup)
{
  int meio = (l_sup + l_inf) / 2;
  if (l_sup <= l_inf)
  {
    return;
  }
  else
  {
    
  }

  mergesort_produtos(produtos, l_inf, meio);
  mergesort_produtos(produtos, meio + 1, l_sup);
  merge_produtos(produtos, l_inf, meio, l_sup);
}

void merge_encomenda(struct product encomenda[], int l_inf, int meio, int l_sup)
{
  int i;
  int j;
  int k;
  for (i = meio + 1; i > l_inf; i--)
    aux_encomendas[i - 1] = encomenda[i - 1];

  for (j = meio; j < l_sup; j++)
    aux_encomendas[(l_sup + meio) - j] = encomenda[j + 1];

  for (k = l_inf; k <= l_sup; k++)
  {
    if (strcmp(aux_encomendas[j].descricao, aux_encomendas[i].descricao) < 0)
    {
      encomenda[k] = aux_encomendas[j--];
    }
    else
    {
      encomenda[k] = aux_encomendas[i++];
    }

  }

}

void mergesort_encomendas(struct product encomenda[], int l_inf, int l_sup)
{
  int meio = (l_sup + l_inf) / 2;
  if (l_sup <= l_inf)
  {
    return;
  }
  else
  {
    
  }

  mergesort_encomendas(encomenda, l_inf, meio);
  mergesort_encomendas(encomenda, meio + 1, l_sup);
  merge_encomenda(encomenda, l_inf, meio, l_sup);
}

int peso_encomenda(int id)
{
  int i;
  int peso_total = 0;
  for (i = 0; i < 200; i++)
  {
    if (encomendas[id][i].preco == 0)
    {
      break;
    }
    else
    {
      peso_total += encomendas[id][i].peso * encomendas[id][i].quant;
    }

  }

  return peso_total;
}

int produto_na_encomenda(int idp, int ide)
{
  int cont;
  for (cont = 0; cont < 200; cont++)
    if ((encomendas[ide][cont].id == idp) && (encomendas[ide][cont].preco != 0))
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

void a()
{
  struct product produto;
  for (int produto_index = 0; produto_index < 10; produto_index++)
  {
    produto.descricao[produto_index] = new_sym_var(sizeof(char) * 8);
  }

  produto.descricao[10 - 1] = '\0';
  produto.preco = new_sym_var(sizeof(int) * 8);
  produto.peso = new_sym_var(sizeof(int) * 8);
  produto.quant = new_sym_var(sizeof(int) * 8);
  produto.id = idp_atual;
  lista_produtos[idp_atual] = produto;
  printf("Novo produto %d.\n", idp_atual);
  idp_atual++;
}

void q()
{
  int id;
  int qtd;
  id = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (id >= idp_atual)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  }
  else
  {
    lista_produtos[id].quant += qtd;
  }

}

void N()
{
  printf("Nova encomenda %d.\n", ide_atual);
  ide_atual++;
}

void A()
{
  int ide;
  int idp;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_atual)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= idp_atual)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (qtd > lista_produtos[idp].quant)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((peso_encomenda(ide) + (qtd * lista_produtos[idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          if (produto_na_encomenda(idp, ide))
          {
            {
              int i;
              for (i = 0; i < 200; i++)
              {
                if ((encomendas[ide][i].id == idp) && (encomendas[ide][i].preco != 0))
                {
                  {
                    encomendas[ide][i].quant += qtd;
                    lista_produtos[idp].quant -= qtd;
                    return;
                  }
                }
                else
                {
                  
                }

              }

            }
          }
          else
          {
            {
              int i;
              for (i = 0; i < 200; i++)
              {
                if (encomendas[ide][i].preco == 0)
                {
                  {
                    encomendas[ide][i] = lista_produtos[idp];
                    encomendas[ide][i].quant = qtd;
                    lista_produtos[idp].quant -= qtd;
                    return;
                  }
                }
                else
                {
                  
                }

              }

            }
          }

        }

      }

    }

  }

}

void r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= idp_atual)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (lista_produtos[idp].quant < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      lista_produtos[idp].quant -= qtd;
    }

  }

}

void R()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_atual)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= idp_atual)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      {
        int i;
        int j;
        struct product produto;
        for (i = 0; i < 200; i++)
        {
          if ((encomendas[ide][i].id == idp) && (encomendas[ide][i].preco != 0))
          {
            {
              encomendas[ide][i].preco = 0;
              lista_produtos[idp].quant += encomendas[ide][i].quant;
              break;
            }
          }
          else
          {
            
          }

        }

        for (j = i; j < (200 - 1); j++)
        {
          if (encomendas[ide][j + 1].preco == 0)
          {
            return;
          }
          else
          {
            {
              produto = encomendas[ide][j];
              encomendas[ide][j] = encomendas[ide][j + 1];
              encomendas[ide][j + 1] = produto;
            }
          }

        }

      }
    }

  }

}

void C()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_atual)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      int i;
      int custo = 0;
      for (i = 0; i < 200; i++)
      {
        if (encomendas[ide][i].preco == 0)
        {
          break;
        }
        else
        {
          custo += encomendas[ide][i].preco * encomendas[ide][i].quant;
        }

      }

      printf("Custo da encomenda %d %d.\n", ide, custo);
    }
  }

}

void p()
{
  int idp;
  int new_preco;
  idp = new_sym_var(sizeof(int) * 8);
  new_preco = new_sym_var(sizeof(int) * 8);
  if (idp >= idp_atual)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      int i;
      int j;
      lista_produtos[idp].preco = new_preco;
      for (i = 0; i < ide_atual; i++)
      {
        for (j = 0; j < 200; j++)
        {
          if (encomendas[i][j].preco == 0)
          {
            break;
          }
          else
          {
            if (encomendas[i][j].id == idp)
            {
              {
                encomendas[i][j].preco = new_preco;
                break;
              }
            }
            else
            {
              
            }

          }

        }

      }

    }
  }

}

void E()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_atual)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= idp_atual)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      if (!produto_na_encomenda(idp, ide))
      {
        printf("%s 0.\n", lista_produtos[idp].descricao);
      }
      else
      {
        {
          int i;
          for (i = 0; i < 200; i++)
          {
            if (encomendas[ide][i].preco == 0)
            {
              return;
            }
            else
            {
              if (encomendas[ide][i].id == idp)
              {
                {
                  printf("%s %d.\n", encomendas[ide][i].descricao, encomendas[ide][i].quant);
                  return;
                }
              }
              else
              {
                
              }

            }

          }

        }
      }

    }

  }

}

void m()
{
  int idp;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= idp_atual)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      int i;
      int j;
      int maior_qtd = 0;
      int ide = 0;
      for (i = 0; i < ide_atual; i++)
      {
        for (j = 0; j < 200; j++)
        {
          if (encomendas[i][j].preco == 0)
          {
            break;
          }
          else
          {
            if ((encomendas[i][j].id == idp) && ((encomendas[i][j].quant > maior_qtd) || ((encomendas[i][j].quant == maior_qtd) && (i < ide))))
            {
              {
                ide = i;
                maior_qtd = encomendas[i][j].quant;
              }
            }
            else
            {
              
            }

          }

        }

      }

      if (maior_qtd != 0)
      {
        printf("Maximo produto %d %d %d.\n", idp, ide, maior_qtd);
      }
      else
      {
        
      }

    }
  }

}

void l()
{
  int i;
  struct product produtos[10000];
  for (i = 0; i < idp_atual; i++)
    produtos[i] = lista_produtos[i];

  printf("Produtos\n");
  mergesort_produtos(produtos, 0, idp_atual - 1);
  for (i = 0; i < idp_atual; i++)
    printf("* %s %d %d\n", produtos[i].descricao, produtos[i].preco, produtos[i].quant);

}

void L()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_atual)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      int limit;
      int i;
      struct product encomenda[200];
      for (i = 0; i < 200; i++)
      {
        if (encomendas[ide][i].preco == 0)
        {
          break;
        }
        else
        {
          encomenda[i] = encomendas[ide][i];
        }

      }

      limit = i;
      printf("Encomenda %d\n", ide);
      mergesort_encomendas(encomenda, 0, limit - 1);
      for (i = 0; i < limit; i++)
        printf("* %s %d %d\n", encomenda[i].descricao, encomenda[i].preco, encomenda[i].quant);

    }
  }

}

int main()
{
  char comando;
  init();
  comando = getchar();
  while (comando != 'x')
  {
    switch (comando)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

    }

    comando = getchar();
  }

  return 0;
}

