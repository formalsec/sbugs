/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef int Item;
typedef struct 
{
  int id;
  char des[64];
  int preco;
  int peso;
  int stck;
} produto;
typedef struct 
{
  produto prod;
  int peso;
  int prod_stck[10000];
  int preco;
} encomenda;
int id_prod;
int id_enc;
int id_enc_prod;
produto prod[9999];
encomenda enc[499];
int aux;
void Setproduto(int id, char prod_des[64], int preco, int peso, int stck);
void command_a();
void adiciona_stock();
void command_N();
void command_A();
void remove_stock(int idp, int qnt);
void command_r();
void command_R();
void command_C();
void command_p();
void command_E();
void command_m();
void swap(int *a, int *b);
void quickSort(int arr[], int low, int high);
int partition(int arr[], int low, int high);
void copia_vect(produto orig[10000], int ordenar[10000])
{
  for (aux = 0; aux < id_prod; aux++)
  {
    ordenar[aux] = orig[aux].preco;
    printf("input:%d\n", ordenar[aux]);
  }

  return;
}

void Merge(Item a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = a[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if (aux[j] < aux[i])
    {
      {
        a[k] = aux[j--];
      }
    }
    else
    {
      {
        a[k] = aux[i++];
      }
    }

  }

}

void MergeSort(Item a[], int l, int r)
{
  int m = (l + r) / 2;
  if (r <= l)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  MergeSort(a, l, m);
  MergeSort(a, m + 1, r);
  Merge(a, l, m, r);
}

int idp;
int qnt;
int preco;
int peso;
int aux;
int exist;
int ide;
int copia[10000];
char crct;
char des[64];
int main()
{
  while (((crct = getchar()) != EOF) && (crct != 'x'))
  {
    switch (crct)
    {
      case 'a':
        command_a();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        command_N();
        break;

      case 'A':
        command_A();
        break;

      case 'r':
        command_r();
        break;

      case 'R':
        command_R();
        break;

      case 'C':
        command_C();
        break;

      case 'p':
        command_p();
        break;

      case 'E':
        command_E();
        break;

      case 'm':
        command_m();
        break;

      case 'l':
        printf("Produtos\n");
        copia_vect(prod, copia);
        MergeSort(copia, 0, id_prod - 1);
        for (aux = 0; aux < id_prod; aux++)
        printf("*%s %d %d\n", prod[copia[aux]].des, prod[copia[aux]].preco, prod[copia[aux]].stck);

        break;

    }

  }

  return 0;
}

void Setproduto(int id, char prod_des[64], int preco, int peso, int stck)
{
  prod[id].id = id;
  strcpy(prod[id].des, prod_des);
  prod[id].preco = preco;
  prod[id].peso = peso;
  prod[id].stck = stck;
}

void command_a()
{
  idp = id_prod++;
  for (int des_index = 0; des_index < 10; des_index++)
  {
    des[des_index] = new_sym_var(sizeof(char) * 8);
  }

  des[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  Setproduto(idp, des, preco, peso, qnt);
  printf("Novo produto %d.\n", idp);
}

void adiciona_stock()
{
  idp = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  if (idp >= id_prod)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    {
      prod[idp].stck += qnt;
    }
  }

}

void command_N()
{
  ide = id_enc++;
  printf("Nova encomenda %d\n", ide);
}

void command_A()
{
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  if (ide >= id_enc)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
  }
  else
  {
    if (idp >= id_prod)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
    }
    else
    {
      if (prod[idp].stck < qnt)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        }
      }
      else
      {
        if (((prod[idp].peso * qnt) + enc[ide].peso) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          }
        }
        else
        {
          {
            exist = 1;
            for (aux = 0; aux < id_prod; aux++)
            {
              if (aux == idp)
              {
                {
                  exist = 0;
                  enc[ide].prod_stck[aux] += qnt;
                  enc[ide].peso += prod[idp].peso * qnt;
                  remove_stock(idp, qnt);
                  break;
                }
              }
              else
              {
                
              }

            }

            if (exist)
            {
              {
                enc[ide].prod_stck[idp] = qnt;
                enc[ide].peso = prod[idp].peso * qnt;
                remove_stock(idp, qnt);
              }
            }
            else
            {
              
            }

          }
        }

      }

    }

  }

}

void remove_stock(int idp, int qnt)
{
  if (idp >= id_prod)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (prod[idp].stck < qnt)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qnt, idp);
    }
    else
    {
      {
        prod[idp].stck -= qnt;
      }
    }

  }

}

void command_r()
{
  idp = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  remove_stock(idp, qnt);
}

void command_R()
{
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= id_enc)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= id_prod)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", qnt, idp);
    }
    else
    {
      if (enc[ide].prod_stck[idp] != 0)
      {
        {
          enc[ide].prod_stck[idp] = 0;
          enc[ide].peso -= prod[idp].peso * qnt;
          adiciona_stock(idp, qnt);
        }
      }
      else
      {
        
      }

    }

  }

}

void command_C()
{
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= id_enc)
  {
    printf("Impossivel calcular custo da encomenda %d\n", ide);
  }
  else
  {
    {
      enc[ide].preco = 0;
      for (aux = 0; aux < id_prod; aux++)
      {
        enc[ide].preco += prod[aux].preco * enc[ide].prod_stck[aux];
      }

      printf("Custo da encomenda %d %d.\n", ide, enc[ide].preco);
    }
  }

}

void command_p()
{
  idp = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  if (idp >= id_prod)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      prod[idp].preco = qnt;
    }
  }

}

void command_E()
{
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= id_prod)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (ide >= id_enc)
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
    else
    {
      {
        printf("%s %d\n", prod[idp].des, enc[ide].prod_stck[idp]);
      }
    }

  }

}

void command_m()
{
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= id_prod)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.", idp);
  }
  else
  {
    {
      exist = 0;
      qnt = 0;
      for (aux = 0; aux < id_enc; aux++)
      {
        if (enc[aux].prod_stck[idp] > qnt)
        {
          {
            exist = 1;
            qnt = enc[aux].prod_stck[idp];
            ide = aux;
          }
        }
        else
        {
          
        }

      }

      if (exist)
      {
        printf("Maximo produto %d %d %d", idp, ide, qnt);
      }
      else
      {
        
      }

    }
  }

}

