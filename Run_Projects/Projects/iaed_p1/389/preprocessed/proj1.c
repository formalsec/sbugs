/*File generated by PreProcessor.py*/


#include <stdio.h>


typedef struct 
{
  char descricao[63];
  long preco;
  long peso;
  long stock;
  int idp;
} product;
typedef struct 
{
  char descricao[63];
  long preco;
  long peso;
  long stock;
  int idp;
} order;
product vector[10000];
product orders[500][10000];
order orderes[500][10000];
char new_str[10000];
int sort[10000];
int aux[10000];
int ide_count;
int select_letter();
void formats_input();
void add_product(product v[]);
void add_stock(product v[]);
int create_order(int ide_count);
void add_prod2order(product o[500][10000], product v[], int ide_count);
void rem_stock(product v[]);
void rem_prodorder(product o[500][10000], product v[], int ide_count);
void order_cost(product o[500][10000], product v[], int ide_count);
void change_price(product v[]);
void prod_order(product v[], product o[500][10000], int ide_count);
void max_prod(product o[500][10000], product v[], int ide_count);
void merge_sort(int sort[], int l, int r);
void merge(int sort[], int left, int m, int right);
void merge_prices(product v[]);
void merge_description(product o[500][10000], product v[], int ide_count);
int main()
{
  while (select_letter())
    ;

  return 0;
}

int select_letter()
{
  char command;
  command = getchar();
  switch (command)
  {
    case 'a':
      add_product(vector);
      return 1;

    case 'q':
      add_stock(vector);
      return 1;

    case 'N':
      ide_count = create_order(ide_count);
      return 1;

    case 'A':
      add_prod2order(orders, vector, ide_count);
      return 1;

    case 'r':
      rem_stock(vector);
      return 1;

    case 'R':
      rem_prodorder(orders, vector, ide_count);
      return 1;

    case 'C':
      order_cost(orders, vector, ide_count);
      return 1;

    case 'p':
      change_price(vector);
      return 1;

    case 'E':
      prod_order(vector, orders, ide_count);
      return 1;

    case 'm':
      max_prod(orders, vector, ide_count);
      return 1;

    case 'l':
      merge_prices(vector);
      return 1;

    case 'L':
      merge_description(orders, vector, ide_count);
      return 1;

    case 'x':
      return 0;

    default:
      return 1;

  }

}

void formats_input()
{
  int i2 = 0;
  int c;
  while ((c = getchar()) != '\n')
  {
    if (c == ':')
    {
      c = ' ';
      new_str[i2] = c;
      i2++;
    }
    else
    {
      new_str[i2] = c;
      i2++;
    }

  }

  new_str[i2] = '\0';
}

void add_product(product v[])
{
  int i = 0;
  while (v[i].peso != 0)
  {
    i++;
  }

  v[i].idp = i;
  formats_input();
  for (int v_index = 0; v_index < 10; v_index++)
  {
    v[i].descricao[v_index] = new_sym_var(sizeof(char) * 8);
  }

  v[i].descricao[10 - 1] = '\0';
  v[i].preco = new_sym_var(sizeof(long) * 8);
  v[i].peso = new_sym_var(sizeof(long) * 8);
  v[i].stock = new_sym_var(sizeof(long) * 8);
  printf("Novo produto %d.\n", v[i].idp);
}

void add_stock(product v[])
{
  int idp_comp;
  long qtd_add;
  formats_input();
  idp_comp = new_sym_var(sizeof(int) * 8);
  qtd_add = new_sym_var(sizeof(long) * 8);
  if (v[idp_comp].preco != 0)
  {
    v[idp_comp].stock += qtd_add;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp_comp);
  }

}

int create_order(int ide_count)
{
  printf("Nova encomenda %d.\n", ide_count);
  ide_count++;
  return ide_count;
}

void add_prod2order(product o[500][10000], product v[], int ide_count)
{
  int ide;
  int idp;
  int qtd;
  int peso_total = 0;
  int i = 0;
  formats_input();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_count)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (v[idp].peso == 0)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      if (v[idp].stock < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        return;
      }
      else
      {
        
      }

    }

  }

  o[ide][idp].stock += qtd;
  v[idp].stock -= qtd;
  for (i = 0; i < 10000; i++)
  {
    if (o[ide][i].stock > 0)
    {
      peso_total += o[ide][i].stock * v[i].peso;
    }
    else
    {
      
    }

  }

  if (peso_total > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    o[ide][idp].stock -= qtd;
    v[idp].stock += qtd;
  }
  else
  {
    
  }

}

void rem_stock(product v[])
{
  int idp;
  int qtd;
  int i = 0;
  formats_input();
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  while (v[i].peso > 0)
  {
    i++;
  }

  if (idp >= i)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  v[idp].stock -= qtd;
  if (v[idp].stock < 0)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    v[idp].stock += qtd;
    return;
  }
  else
  {
    
  }

}

void rem_prodorder(product o[500][10000], product v[], int ide_count)
{
  int idp;
  int ide;
  int i = 0;
  formats_input();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_count)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  while (v[i].peso > 0)
  {
    i++;
  }

  if (idp >= i)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  v[idp].stock += o[ide][idp].stock;
  o[ide][idp].stock = 0;
}

void order_cost(product o[500][10000], product v[], int ide_count)
{
  int ide;
  int total_cost = 0;
  int i = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_count)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    total_cost += v[i].preco * o[ide][i].stock;
  }

  printf("Custo da encomenda %d %d.\n", ide, total_cost);
}

void change_price(product v[])
{
  int i = 0;
  int idp;
  int price = 0;
  formats_input();
  idp = new_sym_var(sizeof(int) * 8);
  price = new_sym_var(sizeof(int) * 8);
  while (v[i].peso > 0)
  {
    i++;
  }

  if (i <= idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  v[idp].preco = price;
}

void prod_order(product v[], product o[500][10000], int ide_count)
{
  int idp;
  int ide;
  int i = 0;
  formats_input();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_count)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  while (v[i].peso > 0)
  {
    i++;
  }

  if (idp >= i)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  printf("%s %ld.\n", v[idp].descricao, o[ide][idp].stock);
}

void max_prod(product o[500][10000], product v[], int ide_count)
{
  int idp;
  int ide;
  int i = 0;
  int i2 = 0;
  int maior = 0;
  idp = new_sym_var(sizeof(int) * 8);
  while (v[i].peso > 0)
  {
    i++;
  }

  if (idp >= i)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i2 = 0; i2 <= ide_count; i2++)
  {
    if (o[i2][idp].stock > maior)
    {
      maior = o[i2][idp].stock;
      ide = i2;
    }
    else
    {
      
    }

  }

  if (maior > 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, ide, maior);
  }
  else
  {
    
  }

}

void merge_sort(int sort[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  merge_sort(sort, l, m);
  merge_sort(sort, m + 1, r);
  merge(sort, l, m, r);
}

void merge(int sort[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = sort[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = sort[j + 1];

  for (k = left; k <= right; k++)
    if ((aux[j] < aux[i]) || (i > m))
  {
    sort[k] = aux[j--];
  }
  else
  {
    sort[k] = aux[i++];
  }


}

void merge_prices(product v[])
{
  int i = 0;
  int prices[10000];
  int i2 = 0;
  int i3 = 0;
  while (v[i].preco > 0)
  {
    prices[i] = v[i].preco;
    i++;
  }

  merge_sort(prices, 0, i - 1);
  printf("Produtos\n");
  for (i2 = 0; i2 <= i; i2++)
  {
    for (i3 = 0; i3 < i; i3++)
    {
      if ((v[i3].preco == prices[i2]) && (v[i3].preco != prices[i2 - 1]))
      {
        printf("* %s %ld %ld\n", v[i3].descricao, v[i3].preco, v[i3].stock);
      }
      else
      {
        
      }

    }

  }

}

void merge_description(product o[500][10000], product v[], int ide_count)
{
  int ide;
  int products[10000];
  int i;
  int i2 = 1;
  int i3;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_count)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.", ide);
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    if (o[ide][i].stock > 0)
    {
      products[i] = v[i].descricao[0];
    }
    else
    {
      
    }

  }

  while (o[ide][i2].stock > 0)
  {
    i2++;
  }

  merge_sort(products, 0, i2);
  i2 = 0;
  while (o[ide][i2].stock > 0)
  {
    i2++;
  }

  printf("Encomenda %d.\n", ide);
  for (i3 = 0; i3 < (i2 - 1); i3++)
  {
    if (products[i3] != 0)
    {
      printf("%s %ld %ld na %d\n", v[i3].descricao, v[i3].preco, o[ide][i3].stock, ide);
    }
    else
    {
      
    }

  }

}

