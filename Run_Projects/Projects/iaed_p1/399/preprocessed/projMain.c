/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>
#include "defines_and_functions.h"


uint g_total_packages = 0;
uint g_total_products = 0;
package g_array_packages[500] = {0};
product g_array_product[10000] = {0};
int main()
{
  return CommandProcess();
}

int CommandProcess()
{
  while (1)
  {
    char io_buf[1512];
    char cmd = '\0';
    char desc[64] = "";
    int filled;
    uint weight;
    uint price;
    uint qty;
    uint id_encom;
    uint id_prod = 0;
    fgets(io_buf, 1512, stdin);
    filled = 1;
    cmd = new_sym_var(sizeof(char) * 8);
    if (filled)
    {
      switch (cmd)
      {
        case 'a':
          cmd = new_sym_var(sizeof(char) * 8);
          for (int desc_index = 0; desc_index < 10; desc_index++)
        {
          desc[desc_index] = new_sym_var(sizeof(char) * 8);
        }

          desc[10 - 1] = '\0';
          price = new_sym_var(sizeof(uint) * 8);
          weight = new_sym_var(sizeof(uint) * 8);
          qty = new_sym_var(sizeof(uint) * 8);
          CreateProd(desc, price, weight, qty);
          break;

        case 'q':
          cmd = new_sym_var(sizeof(char) * 8);
          id_prod = new_sym_var(sizeof(uint) * 8);
          qty = new_sym_var(sizeof(uint) * 8);
          AddStock(id_prod, qty);
          break;

        case 'N':
          CreateEncomenda();
          break;

        case 'A':
          cmd = new_sym_var(sizeof(char) * 8);
          id_encom = new_sym_var(sizeof(uint) * 8);
          id_prod = new_sym_var(sizeof(uint) * 8);
          qty = new_sym_var(sizeof(uint) * 8);
          AddProd(id_encom, id_prod, qty);
          break;

        case 'r':
          cmd = new_sym_var(sizeof(char) * 8);
          id_prod = new_sym_var(sizeof(uint) * 8);
          qty = new_sym_var(sizeof(uint) * 8);
          RemoveStock(id_prod, qty);
          break;

        case 'R':
          cmd = new_sym_var(sizeof(char) * 8);
          id_encom = new_sym_var(sizeof(uint) * 8);
          id_prod = new_sym_var(sizeof(uint) * 8);
          RemoveProd(id_encom, id_prod);
          break;

        case 'C':
          cmd = new_sym_var(sizeof(char) * 8);
          id_encom = new_sym_var(sizeof(uint) * 8);
          ListEncomTotalPrice(id_encom);
          break;

        case 'p':
          cmd = new_sym_var(sizeof(char) * 8);
          id_prod = new_sym_var(sizeof(uint) * 8);
          price = new_sym_var(sizeof(uint) * 8);
          ProdNewPrice(id_prod, price);
          break;

        case 'E':
          cmd = new_sym_var(sizeof(char) * 8);
          id_encom = new_sym_var(sizeof(uint) * 8);
          id_prod = new_sym_var(sizeof(uint) * 8);
          ListDescPrice(id_encom, id_prod);
          break;

        case 'm':
          cmd = new_sym_var(sizeof(char) * 8);
          id_prod = new_sym_var(sizeof(uint) * 8);
          EncomMaxProd(id_prod);
          break;

        case 'l':
          ListProdByPrice();
          break;

        case 'L':
          cmd = new_sym_var(sizeof(char) * 8);
          id_encom = new_sym_var(sizeof(uint) * 8);
          ListEncomProdByDesc(id_encom);
          break;

        case 'x':
          return 0;

        default:
          printf("Invalid command!\n");
          break;

      }

    }
    else
    {
      
    }

  }

}

void GetProdDesc(uint id, char *buffer)
{
  strcpy(buffer, g_array_product[id].desc);
  return;
}

char *GetProdDescPtr(uint id)
{
  return (char *) g_array_product[id].desc;
}

uint GetProdPeso(uint id)
{
  return g_array_product[id].weight;
}

uint GetProdPrice(uint id)
{
  return g_array_product[id].price;
}

uint GetProdutoQty(uint id)
{
  return g_array_product[id].qty;
}

uint GetEncomQtyProd(uint id_encom, uint id_prod)
{
  return g_array_packages[id_encom].products[id_prod][0];
}

void SetProdDesc(uint id, char *desc)
{
  strcpy(g_array_product[id].desc, desc);
  return;
}

void SetProdPrice(uint id, uint price)
{
  g_array_product[id].price = price;
  return;
}

void SetProdPeso(uint id, uint weight)
{
  g_array_product[id].weight = weight;
  return;
}

void SetProdQty(uint id, uint qty)
{
  g_array_product[id].qty = qty;
  return;
}

void SetEncomQtyProd(uint id_encom, uint id_prod, uint qty)
{
  g_array_packages[id_encom].products[id_prod][0] = qty;
  return;
}

uint GetEncomPeso(uint id_encom)
{
  uint total_weight = 0;
  uint id_prod = 0;
  uint qty_prod = 0;
  for (id_prod = 0; id_prod < g_total_products; id_prod++)
  {
    qty_prod = GetEncomQtyProd(id_encom, id_prod);
    if (qty_prod > 0)
    {
      total_weight += GetProdPeso(id_prod) * qty_prod;
    }
    else
    {
      
    }

  }

  return total_weight;
}

void CreateProd(char desc[64], uint price, uint weight, uint qty)
{
  SetProdDesc(g_total_products, desc);
  SetProdPeso(g_total_products, weight);
  SetProdPrice(g_total_products, price);
  SetProdQty(g_total_products, qty);
  printf("Novo produto %d.\n", g_total_products);
  g_total_products++;
  return;
}

void AddStock(uint id, uint qty)
{
  if (id >= g_total_products)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
    return;
  }
  else
  {
    
  }

  SetProdQty(id, GetProdutoQty(id) + qty);
  return;
}

void RemoveStock(uint id, uint qty_rem)
{
  uint qty_prod;
  if (id >= g_total_products)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id);
    return;
  }
  else
  {
    
  }

  qty_prod = GetProdutoQty(id);
  if (qty_prod < qty_rem)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qty_rem, id);
    return;
  }
  else
  {
    
  }

  SetProdQty(id, qty_prod - qty_rem);
  return;
}

void CreateEncomenda()
{
  printf("Nova encomenda %d.\n", g_total_packages);
  g_total_packages++;
  return;
}

void AddProd(uint id_encom, uint id_prod, uint qty)
{
  int encom_pre_weight;
  int prod_weight = 0;
  if (id_encom >= g_total_packages)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id_prod, id_encom);
    return;
  }
  else
  {
    if (id_prod >= g_total_products)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id_prod, id_encom);
      return;
    }
    else
    {
      if (GetProdutoQty(id_prod) < qty)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_prod, id_encom);
        return;
      }
      else
      {
        
      }

    }

  }

  encom_pre_weight = GetEncomPeso(id_encom);
  prod_weight = GetProdPeso(id_prod) * qty;
  if ((encom_pre_weight + prod_weight) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_prod, id_encom);
    return;
  }
  else
  {
    
  }

  RemoveStock(id_prod, qty);
  SetEncomQtyProd(id_encom, id_prod, GetEncomQtyProd(id_encom, id_prod) + qty);
  return;
}

void RemoveProd(uint id_encom, uint id_prod)
{
  int qty = 0;
  if (id_encom >= g_total_packages)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id_prod, id_encom);
    return;
  }
  else
  {
    if (id_prod >= g_total_products)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_prod, id_encom);
      return;
    }
    else
    {
      
    }

  }

  qty = GetEncomQtyProd(id_encom, id_prod);
  SetProdQty(id_prod, GetProdutoQty(id_prod) + qty);
  SetEncomQtyProd(id_encom, id_prod, 0);
  return;
}

void ListEncomTotalPrice(uint id)
{
  uint total = 0;
  uint id_prod = 0;
  if (id >= g_total_packages)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", id);
    return;
  }
  else
  {
    
  }

  for (id_prod = 0; id_prod < g_total_products; id_prod++)
  {
    total += GetEncomQtyProd(id, id_prod) * GetProdPrice(id_prod);
  }

  printf("Custo da encomenda %u %u.\n", id, total);
  return;
}

void ProdNewPrice(uint id, uint price)
{
  if (id >= g_total_products)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id);
    return;
  }
  else
  {
    
  }

  SetProdPrice(id, price);
  return;
}

void ListDescPrice(uint id_encom, uint id_prod)
{
  char *desc;
  if (id_encom >= g_total_packages)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_encom);
    return;
  }
  else
  {
    if (id_prod >= g_total_products)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", id_prod);
      return;
    }
    else
    {
      
    }

  }

  desc = GetProdDescPtr(id_prod);
  printf("%s %d.\n", desc, GetEncomQtyProd(id_encom, id_prod));
  return;
}

void EncomMaxProd(uint id_prod)
{
  int id_encom = -1;
  uint max_amount;
  uint i;
  uint encom_prod_qty;
  max_amount = 0;
  if (id_prod >= g_total_products)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id_prod);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < g_total_packages; i++)
  {
    encom_prod_qty = GetEncomQtyProd(i, id_prod);
    if (encom_prod_qty > max_amount)
    {
      max_amount = encom_prod_qty;
      id_encom = i;
    }
    else
    {
      
    }

  }

  if (id_encom == (-1))
  {
    return;
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", id_prod, id_encom, max_amount);
  return;
}

void MergeSortOrder(int arr[], int arr_aux[], uint l_bound, uint mid_index, uint r_bound, int (*p_less_key_func)(int, int))
{
  uint left_ptr;
  uint right_ptr;
  uint index;
  for (left_ptr = mid_index + 1; left_ptr > l_bound; left_ptr--)
  {
    arr_aux[left_ptr - 1] = arr[left_ptr - 1];
  }

  for (right_ptr = mid_index; right_ptr < r_bound; right_ptr++)
  {
    arr_aux[(r_bound + mid_index) - right_ptr] = arr[right_ptr + 1];
  }

  for (index = l_bound; index <= r_bound; index++)
  {
    if ((*p_less_key_func)(arr_aux[right_ptr], arr_aux[left_ptr]) || (left_ptr > mid_index))
    {
      arr[index] = arr_aux[right_ptr--];
    }
    else
    {
      arr[index] = arr_aux[left_ptr++];
    }

  }

  return;
}

void MergeSortRecursive(int arr[], int arr_aux[], uint l_bound, uint r_bound, int (*p_less_key_func)(int, int))
{
  int mid_index = (l_bound + r_bound) / 2;
  if (r_bound <= l_bound)
  {
    return;
  }
  else
  {
    
  }

  MergeSortRecursive(arr, arr_aux, l_bound, mid_index, *p_less_key_func);
  MergeSortRecursive(arr, arr_aux, mid_index + 1, r_bound, *p_less_key_func);
  MergeSortOrder(arr, arr_aux, l_bound, mid_index, r_bound, *p_less_key_func);
  return;
}

void MergeSort(int arr[], uint l_bound, uint r_bound, int (*p_less_key_func)(int, int))
{
  int arr_aux[10000] = {0};
  MergeSortRecursive(arr, arr_aux, l_bound, r_bound, *p_less_key_func);
  return;
}

int CompareProdPrice(int id_1, int id_2)
{
  int price_1 = GetProdPrice(id_1);
  int price_2 = GetProdPrice(id_2);
  if (price_1 < price_2)
  {
    return 1;
  }
  else
  {
    if (price_1 == price_2)
    {
      if (id_1 < id_2)
      {
        return 1;
      }
      else
      {
        return 0;
      }

    }
    else
    {
      return 0;
    }

  }

}

void ListProdByPrice()
{
  uint id;
  int array_ids[10000];
  char *desc;
  printf("Produtos\n");
  if (g_total_products == 0)
  {
    return;
  }
  else
  {
    
  }

  for (id = 0; id < g_total_products; id++)
  {
    array_ids[id] = id;
  }

  MergeSort(array_ids, 0, g_total_products - 1, &CompareProdPrice);
  for (id = 0; id < g_total_products; id++)
  {
    desc = GetProdDescPtr(array_ids[id]);
    printf("* %s %d %d\n", desc, GetProdPrice(array_ids[id]), GetProdutoQty(array_ids[id]));
  }

  return;
}

int CompareProdDesc(int id_1, int id_2)
{
  char *buf_1 = GetProdDescPtr(id_1);
  char *buf_2 = GetProdDescPtr(id_2);
  int comp = strcmp(buf_1, buf_2);
  if (comp < 0)
  {
    return 1;
  }
  else
  {
    if (comp == 0)
    {
      if (id_1 < id_2)
      {
        return 1;
      }
      else
      {
        return 0;
      }

    }
    else
    {
      return 0;
    }

  }

}

void ListEncomProdByDesc(uint id_encom)
{
  uint id;
  uint total_prod;
  uint counter;
  int array_ids[200] = {0};
  char *desc;
  int qty_prod;
  if (id_encom >= g_total_packages)
  {
    printf("Impossivel listar encomenda %u. Encomenda inexistente.\n", id_encom);
    return;
  }
  else
  {
    
  }

  printf("Encomenda %d\n", id_encom);
  counter = 0, total_prod = 0;
  for (id = 0; id < g_total_products; id++)
  {
    qty_prod = GetEncomQtyProd(id_encom, id);
    if (qty_prod > 0)
    {
      array_ids[counter] = id;
      total_prod++;
      counter++;
    }
    else
    {
      
    }

    if (counter >= 200)
    {
      break;
    }
    else
    {
      
    }

  }

  if (total_prod == 0)
  {
    return;
  }
  else
  {
    
  }

  MergeSort(array_ids, 0, total_prod - 1, &CompareProdDesc);
  for (counter = 0; counter < total_prod; counter++)
  {
    qty_prod = GetEncomQtyProd(id_encom, array_ids[counter]);
    desc = GetProdDescPtr(array_ids[counter]);
    printf("* %s %d %d\n", desc, GetProdPrice(array_ids[counter]), qty_prod);
  }

  return;
}

