/*File generated by PreProcessor.py*/


#include <stdio.h>
#include<string.h>


typedef struct produto
{
  int idp;
  char desc[64];
  int preco;
  int peso;
  int qtd;
} Produto;
typedef struct encomenda
{
  int ide;
  int n_prod;
  Produto prod_enc[200];
} Encomenda;
Produto produtos[10000];
int indice_produtos = 0;
Encomenda encomendas[500];
int indice_encomendas = 0;
Produto cria_produto()
{
  Produto a;
  a.idp = indice_produtos;
  indice_produtos++;
  for (int a_index = 0; a_index < 10; a_index++)
  {
    a.desc[a_index] = new_sym_var(sizeof(char) * 8);
  }

  a.desc[10 - 1] = '\0';
  a.preco = new_sym_var(sizeof(int) * 8);
  a.peso = new_sym_var(sizeof(int) * 8);
  a.qtd = new_sym_var(sizeof(int) * 8);
  produtos[a.idp] = a;
  printf("Novo produto %d.\n", a.idp);
  return a;
}

void edita_quantidade()
{
  int quantidade;
  int idp;
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (idp >= indice_produtos)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].qtd += quantidade;
  }

}

Encomenda cria_encomenda()
{
  Encomenda a;
  a.ide = indice_encomendas;
  indice_encomendas++;
  printf("Nova encomenda %d.\n", a.ide);
  return a;
}

int peso_Enc(Encomenda encomenda)
{
  int peso_total = 0;
  int i;
  for (i = 0; i < encomenda.n_prod; i++)
  {
    peso_total += encomenda.prod_enc[i].peso * encomenda.prod_enc[i].qtd;
  }

  return peso_total;
}

void add_produto()
{
  int quantidade;
  int i;
  int idp;
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (idp >= indice_produtos)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
  }
  else
  {
    if (ide >= indice_encomendas)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
    else
    {
      if (quantidade > produtos[idp].qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((peso_Enc(encomendas[ide]) + (produtos[idp].peso * quantidade)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          int FLAG = 0;
          for (i = 0; i < encomendas[ide].n_prod; i++)
          {
            if (encomendas[ide].prod_enc[i].idp == idp)
            {
              FLAG = 1;
              encomendas[ide].prod_enc[i].qtd += quantidade;
              produtos[idp].qtd -= quantidade;
              break;
            }
            else
            {
              
            }

          }

          if (FLAG == 0)
          {
            encomendas[ide].prod_enc[i] = produtos[idp];
            encomendas[ide].prod_enc[i].qtd = quantidade;
            encomendas[ide].n_prod++;
            produtos[idp].qtd -= quantidade;
          }
          else
          {
            
          }

        }

      }

    }

  }

}

void remove_stock()
{
  int quantidade;
  int idp;
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (idp >= indice_produtos)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if ((produtos[idp].qtd - quantidade) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantidade, idp);
    }
    else
    {
      produtos[idp].qtd -= quantidade;
    }

  }

}

int compare(Produto v_produtos_1, Produto v_produtos_2, int flag)
{
  if (flag == 1)
  {
    return strcmp(v_produtos_1.desc, v_produtos_2.desc) < 0;
  }
  else
  {
    if (v_produtos_1.preco == v_produtos_2.preco)
    {
      return v_produtos_1.idp < v_produtos_2.idp;
    }
    else
    {
      
    }

    return v_produtos_1.preco < v_produtos_2.preco;
  }

  return 0;
}

int partition(Produto v_produtos[], int l, int r, int flag)
{
  int i = l - 1;
  int j = r;
  Produto v = v_produtos[r];
  if (flag == 0)
  {
    while (i < j)
    {
      while (compare(v_produtos[++i], v, 0))
        ;

      while (compare(v, v_produtos[--j], 0))
        if (j == l)
      {
        break;
      }
      else
      {
        
      }


      if (i < j)
      {
        Produto t = v_produtos[i];
        v_produtos[i] = v_produtos[j];
        v_produtos[j] = t;
      }
      else
      {
        
      }

      ;
    }

    {
      Produto t = v_produtos[i];
      v_produtos[i] = v_produtos[r];
      v_produtos[r] = t;
    }
    ;
    return i;
  }
  else
  {
    while (i < j)
    {
      while (compare(v_produtos[++i], v, 1))
        ;

      while (compare(v, v_produtos[--j], 1))
        if (j == l)
      {
        break;
      }
      else
      {
        
      }


      if (i < j)
      {
        Produto t = v_produtos[i];
        v_produtos[i] = v_produtos[j];
        v_produtos[j] = t;
      }
      else
      {
        
      }

      ;
    }

    {
      Produto t = v_produtos[i];
      v_produtos[i] = v_produtos[r];
      v_produtos[r] = t;
    }
    ;
    return i;
  }

}

void quickSort(Produto v_produtos[], int l, int r, int flag)
{
  int i;
  if (flag == 0)
  {
    if (r <= l)
    {
      return;
    }
    else
    {
      
    }

    i = partition(v_produtos, l, r, 0);
    quickSort(v_produtos, l, i - 1, 0);
    quickSort(v_produtos, i + 1, r, 0);
  }
  else
  {
    if (r <= l)
    {
      return;
    }
    else
    {
      
    }

    i = partition(v_produtos, l, r, 1);
    quickSort(v_produtos, l, i - 1, 1);
    quickSort(v_produtos, i + 1, r, 1);
  }

}

void lista_produtos()
{
  int i;
  Produto prod_aux[10000 + 1];
  for (i = 0; i < indice_produtos; i++)
  {
    prod_aux[i] = produtos[i];
  }

  printf("Produtos\n");
  quickSort(prod_aux, 0, indice_produtos - 1, 0);
  for (i = 0; i < indice_produtos; i++)
  {
    printf("* %s %d %d\n", prod_aux[i].desc, prod_aux[i].preco, prod_aux[i].qtd);
  }

}

void remove_prod_enc()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= indice_encomendas)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= indice_produtos)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      for (i = 0; i < encomendas[ide].n_prod; i++)
      {
        if (encomendas[ide].prod_enc[i].idp == idp)
        {
          produtos[idp].qtd += encomendas[ide].prod_enc[i].qtd;
          encomendas[ide].prod_enc[i].qtd = 0;
        }
        else
        {
          
        }

      }

    }

  }

}

void calc_custo()
{
  int i;
  int ide;
  int custo_total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= indice_encomendas)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < encomendas[ide].n_prod; i++)
    {
      custo_total += encomendas[ide].prod_enc[i].preco * encomendas[ide].prod_enc[i].qtd;
    }

    printf("Custo da encomenda %d %d.\n", ide, custo_total);
  }

}

void lista_prod_enc()
{
  int e;
  int i;
  int ide;
  Produto prod_aux_enc[10000];
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= indice_encomendas)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (e = 0; e < encomendas[ide].n_prod; e++)
    {
      prod_aux_enc[e] = encomendas[ide].prod_enc[e];
    }

    quickSort(prod_aux_enc, 0, encomendas[ide].n_prod - 1, 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < encomendas[ide].n_prod; i++)
    {
      if (prod_aux_enc[i].qtd > 0)
      {
        printf("* %s %d %d\n", prod_aux_enc[i].desc, prod_aux_enc[i].preco, prod_aux_enc[i].qtd);
      }
      else
      {
        
      }

    }

  }

}

void altera_preco()
{
  int i;
  int e;
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= indice_produtos)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  produtos[idp].preco = preco;
  for (i = 0; i < indice_encomendas; i++)
  {
    for (e = 0; e < encomendas[i].n_prod; e++)
    {
      if (encomendas[i].prod_enc[e].idp == idp)
      {
        encomendas[i].prod_enc[e].preco = preco;
      }
      else
      {
        
      }

    }

  }

}

void desc_qtd()
{
  int ide;
  int idp;
  int i;
  int FLAG = 0;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= indice_encomendas)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= indice_produtos)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      for (i = 0; i < encomendas[ide].n_prod; i++)
      {
        if (encomendas[ide].prod_enc[i].idp == idp)
        {
          FLAG = 1;
          printf("%s %d.\n", encomendas[ide].prod_enc[i].desc, encomendas[ide].prod_enc[i].qtd);
        }
        else
        {
          
        }

      }

      if (FLAG == 0)
      {
        printf("%s %d.\n", produtos[idp].desc, 0);
      }
      else
      {
        
      }

    }

  }

}

void max_id_founder()
{
  int idp;
  int i;
  int j;
  int contador_ide = 0;
  int contador_qtd = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= indice_produtos)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; i < indice_encomendas; i++)
    {
      for (j = 0; j < encomendas[i].n_prod; j++)
      {
        if (encomendas[i].prod_enc[j].idp == idp)
        {
          if (encomendas[i].prod_enc[j].qtd > contador_qtd)
          {
            contador_qtd = encomendas[i].prod_enc[j].qtd;
            contador_ide = i;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    if (contador_qtd > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, contador_ide, contador_qtd);
    }
    else
    {
      
    }

  }

}

int main()
{
  int c;
  while ((c = getchar()) != 'x')
  {
    switch (c)
    {
      default:
        break;

      case 'a':
        cria_produto();
        break;

      case 'q':
        edita_quantidade();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        add_produto();
        break;

      case 'l':
        lista_produtos();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_prod_enc();
        break;

      case 'C':
        calc_custo();
        break;

      case 'p':
        altera_preco();
        break;

      case 'L':
        lista_prod_enc();
        break;

      case 'E':
        desc_qtd();
        break;

      case 'm':
        max_id_founder();
        break;

    }

  }

  return 0;
}

