/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>


int ID_products = 0;
int ID_Orders = 0;
char input[150];
char *palavra;
typedef struct Product
{
  int ID;
  char desc[64];
  int price;
  int weight;
  int quant;
  int modif;
} product;
typedef struct Order
{
  int ID_Order;
  int N_de_Prods;
  int weight_order;
  product order_products[10000];
} order;
order orders[500];
product products[10000];
int verifica_produto(int id)
{
  if ((id < ID_products) && (id >= 0))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int verifica_encomenda(int id)
{
  if ((id < ID_Orders) && (id >= 0))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

void cria_produto()
{
  int i = 0;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  while (palavra != 0)
  {
    if (i == 0)
    {
      strcpy(products[ID_products].desc, palavra);
    }
    else
    {
      if (i == 1)
      {
        products[ID_products].price = atoi(palavra);
      }
      else
      {
        if (i == 2)
        {
          products[ID_products].weight = atoi(palavra);
        }
        else
        {
          products[ID_products].quant = atoi(palavra);
        }

      }

    }

    palavra = strtok(0, ":");
    i++;
  }

  products[ID_products].ID = ID_products;
  products[ID_products].modif = 0;
  printf("Novo produto %d.\n", ID_products);
  ID_products++;
}

void adiciona_stock()
{
  int id;
  int new_qtd;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  id = atoi(palavra);
  palavra = strtok(0, ":");
  new_qtd = atoi(palavra);
  if (verifica_produto(id))
  {
    products[id].quant = products[id].quant + new_qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  }

}

void cria_encomenda()
{
  orders[ID_Orders].ID_Order = ID_Orders;
  orders[ID_Orders].N_de_Prods = 0;
  orders[ID_Orders].weight_order = 0;
  printf("Nova encomenda %d.\n", ID_Orders);
  ID_Orders++;
}

void adiciona_produto()
{
  int idp;
  int ide;
  int qtd;
  int i;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  ide = atoi(palavra);
  palavra = strtok(0, ":");
  idp = atoi(palavra);
  palavra = strtok(0, ":");
  qtd = atoi(palavra);
  if (!verifica_produto(idp))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
  }
  else
  {
    if (!verifica_encomenda(ide))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
    else
    {
      if (qtd > products[idp].quant)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((orders[ide].weight_order + (qtd * products[idp].weight)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          for (i = 0; i < orders[ide].N_de_Prods; i++)
          {
            if (orders[ide].order_products[i].ID == idp)
            {
              orders[ide].order_products[i].quant = orders[ide].order_products[i].quant + qtd;
              break;
            }
            else
            {
              
            }

          }

          if ((i == orders[ide].N_de_Prods) && (qtd != 0))
          {
            orders[ide].order_products[orders[ide].N_de_Prods] = products[idp];
            orders[ide].order_products[orders[ide].N_de_Prods].quant = qtd;
            orders[ide].N_de_Prods++;
          }
          else
          {
            
          }

          products[idp].quant = products[idp].quant - qtd;
          orders[ide].weight_order = orders[ide].weight_order + (qtd * products[idp].weight);
        }

      }

    }

  }

}

void remove_stock()
{
  int id;
  int new_qtd;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  id = atoi(palavra);
  palavra = strtok(0, ":");
  new_qtd = atoi(palavra);
  if (!verifica_produto(id))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    if (new_qtd > products[id].quant)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", new_qtd, id);
    }
    else
    {
      products[id].quant = products[id].quant - new_qtd;
    }

  }

}

void remove_produto_encomenda()
{
  int i;
  int ide;
  int idp;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  ide = atoi(palavra);
  palavra = strtok(0, ":");
  idp = atoi(palavra);
  if (!verifica_encomenda(ide))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (!verifica_produto(idp))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      for (i = 0; i < orders[ide].N_de_Prods; i++)
      {
        if (orders[ide].order_products[i].ID == idp)
        {
          products[idp].quant = products[idp].quant + orders[ide].order_products[i].quant;
          orders[ide].weight_order = orders[ide].weight_order - (orders[ide].order_products[i].quant * products[idp].weight);
          orders[ide].order_products[i].quant = 0;
          break;
        }
        else
        {
          
        }

      }

    }

  }

}

void calcula_preco()
{
  int id;
  int i;
  int soma = 0;
  int idp;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  id = atoi(palavra);
  if (!verifica_encomenda(id))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", id);
  }
  else
  {
    for (i = 0; i < orders[id].N_de_Prods; i++)
    {
      idp = orders[id].order_products[i].ID;
      if (products[idp].modif)
      {
        orders[id].order_products[i].price = products[idp].price;
      }
      else
      {
        
      }

      soma = soma + (orders[id].order_products[i].price * orders[id].order_products[i].quant);
    }

    printf("Custo da encomenda %d %d.\n", id, soma);
  }

}

void altera_preco()
{
  int id;
  int new_price;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  id = atoi(palavra);
  palavra = strtok(0, ":");
  new_price = atoi(palavra);
  if (!verifica_produto(id))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    products[id].price = new_price;
    products[id].modif = 1;
  }

}

void mostra_produto()
{
  int ide;
  int idp;
  int i;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  ide = atoi(palavra);
  palavra = strtok(0, ":");
  idp = atoi(palavra);
  if (!verifica_produto(idp))
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (!verifica_encomenda(ide))
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
    else
    {
      for (i = 0; i < orders[ide].N_de_Prods; i++)
      {
        if (orders[ide].order_products[i].ID == idp)
        {
          printf("%s %d.\n", orders[ide].order_products[i].desc, orders[ide].order_products[i].quant);
          break;
        }
        else
        {
          
        }

      }

      if (i == orders[ide].N_de_Prods)
      {
        printf("%s 0.\n", products[idp].desc);
      }
      else
      {
        
      }

    }

  }

}

void mostra_maior_n_produtos()
{
  int id;
  int i;
  int j;
  int vals[2];
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  id = atoi(palavra);
  if (!verifica_produto(id))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    vals[1] = 0;
    for (i = 0; i < ID_Orders; i++)
    {
      for (j = 0; j < orders[i].N_de_Prods; j++)
      {
        if (id == orders[i].order_products[j].ID)
        {
          if (vals[1] < orders[i].order_products[j].quant)
          {
            vals[0] = orders[i].ID_Order;
            vals[1] = orders[i].order_products[j].quant;
          }
          else
          {
            
          }

          break;
        }
        else
        {
          
        }

      }

    }

    if (vals[1] != 0)
    {
      printf("Maximo produto %d %d %d.\n", id, vals[0], vals[1]);
    }
    else
    {
      
    }

  }

}

void lista_produtos()
{
  int i;
  int finish;
  product aux;
  product *produtos;
  produtos = (product *) malloc((sizeof(product)) * ID_products);
  for (i = 0; i < ID_products; i++)
    produtos[i] = products[i];

  while (1)
  {
    finish = 1;
    for (i = 0; i < (ID_products - 1); i++)
    {
      if ((produtos[i].price > produtos[i + 1].price) || ((produtos[i].price == produtos[i + 1].price) && (produtos[i].ID > produtos[i + 1].ID)))
      {
        aux = produtos[i];
        produtos[i] = produtos[i + 1];
        produtos[i + 1] = aux;
        finish = 0;
      }
      else
      {
        
      }

    }

    if (finish)
    {
      break;
    }
    else
    {
      
    }

  }

  printf("Produtos\n");
  for (i = 0; i < ID_products; i++)
    printf("* %s %d %d\n", produtos[i].desc, produtos[i].price, produtos[i].quant);

}

void lista_produtos_encomenda()
{
  int i;
  int finish;
  int id;
  product *produtos;
  product aux;
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  palavra = strtok(input, ":");
  id = atoi(palavra);
  produtos = (product *) malloc((sizeof(product)) * orders[id].N_de_Prods);
  if (!verifica_encomenda(id))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id);
  }
  else
  {
    for (i = 0; i < orders[id].N_de_Prods; i++)
      produtos[i] = orders[id].order_products[i];

    while (1)
    {
      finish = 1;
      for (i = 0; i < (orders[id].N_de_Prods - 1); i++)
      {
        if (strcmp(produtos[i].desc, produtos[i + 1].desc) > 0)
        {
          aux = produtos[i];
          produtos[i] = produtos[i + 1];
          produtos[i + 1] = aux;
          finish = 0;
        }
        else
        {
          
        }

      }

      if (finish)
      {
        break;
      }
      else
      {
        
      }

    }

    printf("Encomenda %d\n", id);
    for (i = 0; i < orders[id].N_de_Prods; i++)
    {
      if (products[produtos[i].ID].modif)
      {
        produtos[i].price = products[produtos[i].ID].price;
      }
      else
      {
        
      }

      if (produtos[i].quant != 0)
      {
        printf("* %s %d %d\n", produtos[i].desc, produtos[i].price, produtos[i].quant);
      }
      else
      {
        
      }

    }

  }

}

int main()
{
  char comando;
  while ((comando = getchar()) && (comando != 'x'))
  {
    if (comando == 'a')
    {
      cria_produto();
    }
    else
    {
      if (comando == 'q')
      {
        adiciona_stock();
      }
      else
      {
        if (comando == 'N')
        {
          cria_encomenda();
        }
        else
        {
          if (comando == 'A')
          {
            adiciona_produto();
          }
          else
          {
            if (comando == 'r')
            {
              remove_stock();
            }
            else
            {
              if (comando == 'R')
              {
                remove_produto_encomenda();
              }
              else
              {
                if (comando == 'C')
                {
                  calcula_preco();
                }
                else
                {
                  if (comando == 'p')
                  {
                    altera_preco();
                  }
                  else
                  {
                    if (comando == 'E')
                    {
                      mostra_produto();
                    }
                    else
                    {
                      if (comando == 'm')
                      {
                        mostra_maior_n_produtos();
                      }
                      else
                      {
                        if (comando == 'l')
                        {
                          lista_produtos();
                        }
                        else
                        {
                          if (comando == 'L')
                          {
                            lista_produtos_encomenda();
                          }
                          else
                          {
                            
                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return 0;
}

