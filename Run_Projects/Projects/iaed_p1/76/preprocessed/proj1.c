/*File generated by PreProcessor.py*/


#include "proj1.h"


produto registo_prod[10000];
encomenda registo_enc[500];
int cont_produtos;
int cont_encomendas;
int aux[10000];
int main()
{
  int comando;
  while ((comando = getchar()) != 'x')
  {
    switch (comando)
    {
      case 'a':
        cria_produto();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        adiciona_produto();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_produto();
        break;

      case 'C':
        calcula_custo();
        break;

      case 'p':
        altera_preco();
        break;

      case 'E':
        descricao_produto();
        break;

      case 'm':
        encomenda_maior();
        break;

      case 'l':
        lista_produtos();
        break;

      case 'L':
        lista_produtos_encomenda();
        break;

      default:
        break;

    }

  }

  return 0;
}

int qtd_na_encomenda(int ide, int idp)
{
  return registo_enc[ide].produtos[idp];
}

int produto_existe(int idp)
{
  return registo_prod[idp].state;
}

int encomenda_existe(int ide)
{
  return registo_enc[ide].state;
}

int qtd_prod(int idp)
{
  return registo_prod[idp].qtd;
}

int peso_prod(int idp)
{
  return registo_prod[idp].peso;
}

int preco_prod(int idp)
{
  return registo_prod[idp].preco;
}

void altera_quantidade(int idp, int qtd)
{
  registo_prod[idp].qtd += qtd;
}

void remove_prod_ord(int ide, int idp)
{
  int i;
  for (i = 0; i < registo_enc[ide].n_prod; i++)
    if (registo_enc[ide].prod_ord[i] == idp)
  {
    break;
  }
  else
  {
    
  }


  registo_enc[ide].n_prod--;
  for (; i < registo_enc[ide].n_prod; i++)
    registo_enc[ide].prod_ord[i] = registo_enc[ide].prod_ord[i + 1];

}

void cria_produto()
{
  char des[64];
  produto prod;
  int i;
  int preco;
  int peso;
  int qtd;
  for (int des_index = 0; des_index < 10; des_index++)
  {
    des[des_index] = new_sym_var(sizeof(char) * 8);
  }

  des[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  i = 0;
  while ((prod.des[i] = des[i]) != '\0')
    i++;

  prod.preco = preco;
  prod.peso = peso;
  prod.qtd = qtd;
  prod.state = 1;
  registo_prod[cont_produtos] = prod;
  printf("Novo produto %d.\n", cont_produtos);
  cont_produtos++;
}

void adiciona_stock()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (produto_existe(idp))
  {
    altera_quantidade(idp, qtd);
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void cria_encomenda()
{
  registo_enc[cont_encomendas].state = 1;
  printf("Nova encomenda %d.\n", cont_encomendas);
  cont_encomendas++;
}

void adiciona_produto()
{
  int ide;
  int idp;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (!produto_existe(idp))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (qtd_prod(idp) < qtd)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if ((registo_enc[ide].peso + (qtd * peso_prod(idp))) > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (qtd_na_encomenda(ide, idp) == 0)
  {
    {
      registo_enc[ide].prod_ord[registo_enc[ide].n_prod] = idp;
      registo_enc[ide].n_prod++;
      insertion_sort(registo_enc[ide].prod_ord, registo_enc[ide].n_prod);
    }
  }
  else
  {
    
  }

  registo_enc[ide].produtos[idp] += qtd;
  registo_enc[ide].peso += peso_prod(idp) * qtd;
  altera_quantidade(idp, -qtd);
}

void remove_stock()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (!produto_existe(idp))
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  if ((qtd_prod(idp) - qtd) < 0)
  {
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
      return;
    }
  }
  else
  {
    
  }

  altera_quantidade(idp, -qtd);
}

void remove_produto()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (!produto_existe(idp))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (qtd_na_encomenda(ide, idp) > 0)
  {
    remove_prod_ord(ide, idp);
  }
  else
  {
    
  }

  altera_quantidade(idp, qtd_na_encomenda(ide, idp));
  registo_enc[ide].peso -= qtd_na_encomenda(ide, idp) * peso_prod(idp);
  registo_enc[ide].produtos[idp] = 0;
}

void calcula_custo()
{
  int i;
  int ide;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
    total += preco_prod(i) * qtd_na_encomenda(ide, i);

  printf("Custo da encomenda %d %d.\n", ide, total);
}

void altera_preco()
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (!produto_existe(idp))
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  registo_prod[idp].preco = preco;
}

void descricao_produto()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  if (!produto_existe(idp))
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  printf("%s %d.\n", registo_prod[idp].des, qtd_na_encomenda(ide, idp));
}

void encomenda_maior()
{
  int i;
  int encomenda;
  int idp;
  int maior = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (!produto_existe(idp))
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < cont_encomendas; i++)
    if (qtd_na_encomenda(i, idp) > maior)
  {
    {
      maior = qtd_na_encomenda(i, idp);
      encomenda = i;
    }
  }
  else
  {
    
  }


  if (maior > 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, encomenda, maior);
  }
  else
  {
    
  }

}

void lista_produtos()
{
  int i;
  int idp;
  int idp_prod[10000];
  for (i = 0; i < cont_produtos; i++)
    idp_prod[i] = i;

  mergesort(idp_prod, 0, cont_produtos - 1);
  printf("Produtos\n");
  for (i = 0; i < cont_produtos; i++)
  {
    idp = idp_prod[i];
    printf("* %s %d %d\n", registo_prod[idp].des, preco_prod(idp), qtd_prod(idp));
  }

}

void lista_produtos_encomenda()
{
  int i;
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  if (!encomenda_existe(ide))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  printf("Encomenda %d\n", ide);
  for (i = 0; i < registo_enc[ide].n_prod; i++)
  {
    idp = registo_enc[ide].prod_ord[i];
    printf("* %s %d %d\n", registo_prod[idp].des, preco_prod(idp), qtd_na_encomenda(ide, idp));
  }

}

void insertion_sort(int arr[], int n)
{
  int i;
  int element;
  element = arr[n - 1];
  if (n == 1)
  {
    return;
  }
  else
  {
    
  }

  for (i = n - 2; i >= 0; i--)
  {
    if (strcmp(registo_prod[element].des, registo_prod[arr[i]].des) < 0)
    {
      arr[i + 1] = arr[i];
    }
    else
    {
      {
        arr[i + 1] = element;
        break;
      }
    }

  }

  if (i == (-1))
  {
    arr[i + 1] = element;
  }
  else
  {
    
  }

}

void mergesort(int arr[], int esq, int drt)
{
  int m = (drt + esq) / 2;
  if (drt <= esq)
  {
    return;
  }
  else
  {
    
  }

  mergesort(arr, esq, m);
  mergesort(arr, m + 1, drt);
  merge(arr, esq, m, drt);
}

void merge(int arr[], int esq, int m, int drt)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > esq; i--)
    aux[i - 1] = arr[i - 1];

  for (j = m; j < drt; j++)
    aux[(drt + m) - j] = arr[j + 1];

  for (k = esq; k <= drt; k++)
  {
    if ((preco_prod(aux[j]) < preco_prod(aux[i])) || ((preco_prod(aux[j]) == preco_prod(aux[i])) && (aux[j] < aux[i])))
    {
      arr[k] = aux[j--];
    }
    else
    {
      arr[k] = aux[i++];
    }

  }

}

