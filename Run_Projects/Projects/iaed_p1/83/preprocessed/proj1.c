/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  char name[63];
  int price;
  int weight;
  int amount;
  int identifier;
} Product;
typedef struct 
{
  int identifier;
  int weight;
  int number_diff_products;
  Product shoplist[200];
} Order;
void command_a(char name[63], int price, int weight, int amount, int number_diff_products);
void command_q(int indentifier_product, int amount, int number_diff_products);
void command_N(int number_orders);
void command_A(int identifier_order, int identifier_product, int amount, int number_orders, int number_products);
void command_r(int identifier_product, int amount, int number_diff_products);
void command_R(int identifier_order, int identifier_product, int number_orders, int number_diff_products);
void command_C(int identifier_order, int number_orders);
void command_p(int identifier_product, int price, int number_orders, int number_diff_products);
void command_E(int identifier_order, int identifier_product, int number_orders, int number_diff_products);
void command_m(int identifier_product, int number_orders, int number_diff_products);
void command_l(int number_diff_products);
void command_L(int identifier_order, int number_orders);
void command_k(int number_diff_products);
void command_K(int identifier_order);
void quicksort_products(int array[10000], int inf, int sup);
int partition_products(int array[10000], int inf, int sup);
int less_products(int a, int b);
void exchange_products(int array[10000], int a, int b);
void quicksort_orders(int array[500], int inf, int sup, int identifier_order);
int partition_orders(int array[500], int inf, int sup, int identifier_order);
int less_orders(int a, int b, int identifier_order);
void exchange_orders(int array[10000], int a, int b);
Order orders_list[500];
Product store_stock[10000];
int main()
{
  char command_type;
  char name[63];
  int price;
  int weight;
  int amount;
  int identifier_product;
  int identifier_order;
  int number_diff_products = 0;
  int number_orders = 0;
  command_type = new_sym_var(sizeof(char) * 8);
  while (command_type != 'x')
  {
    switch (command_type)
    {
      case 'a':
        for (int name_index = 0; name_index < 10; name_index++)
      {
        name[name_index] = new_sym_var(sizeof(char) * 8);
      }

        name[10 - 1] = '\0';
        price = new_sym_var(sizeof(int) * 8);
        weight = new_sym_var(sizeof(int) * 8);
        amount = new_sym_var(sizeof(int) * 8);
        command_a(name, price, weight, amount, number_diff_products);
        number_diff_products++;
        break;

      case 'q':
        identifier_product = new_sym_var(sizeof(int) * 8);
        amount = new_sym_var(sizeof(int) * 8);
        command_q(identifier_product, amount, number_diff_products);
        break;

      case 'N':
        command_N(number_orders);
        number_orders++;
        break;

      case 'A':
        identifier_order = new_sym_var(sizeof(int) * 8);
        identifier_product = new_sym_var(sizeof(int) * 8);
        amount = new_sym_var(sizeof(int) * 8);
        command_A(identifier_order, identifier_product, amount, number_orders, number_diff_products);
        break;

      case 'r':
        identifier_product = new_sym_var(sizeof(int) * 8);
        amount = new_sym_var(sizeof(int) * 8);
        command_r(identifier_product, amount, number_diff_products);
        break;

      case 'R':
        identifier_order = new_sym_var(sizeof(int) * 8);
        identifier_product = new_sym_var(sizeof(int) * 8);
        command_R(identifier_order, identifier_product, number_orders, number_diff_products);
        break;

      case 'C':
        identifier_order = new_sym_var(sizeof(int) * 8);
        command_C(identifier_order, number_orders);
        break;

      case 'p':
        identifier_product = new_sym_var(sizeof(int) * 8);
        price = new_sym_var(sizeof(int) * 8);
        command_p(identifier_product, price, number_orders, number_diff_products);
        break;

      case 'E':
        identifier_order = new_sym_var(sizeof(int) * 8);
        identifier_product = new_sym_var(sizeof(int) * 8);
        command_E(identifier_order, identifier_product, number_orders, number_diff_products);
        break;

      case 'm':
        identifier_product = new_sym_var(sizeof(int) * 8);
        command_m(identifier_product, number_orders, number_diff_products);
        break;

      case 'l':
        command_l(number_diff_products);
        break;

      case 'L':
        identifier_order = new_sym_var(sizeof(int) * 8);
        command_L(identifier_order, number_orders);
        break;

      case 'k':
        command_k(number_diff_products);
        break;

      case 'K':
        identifier_order = new_sym_var(sizeof(int) * 8);
        command_K(identifier_order);
        break;

      default:
        break;

    }

    command_type = new_sym_var(sizeof(char) * 8);
  }

  return 0;
}

void command_a(char name[63], int price, int weight, int amount, int number_diff_products)
{
  int i;
  store_stock[number_diff_products].price = price;
  store_stock[number_diff_products].amount = amount;
  store_stock[number_diff_products].weight = weight;
  store_stock[number_diff_products].identifier = number_diff_products;
  for (i = 0; name[i] != '\0'; i++)
  {
    store_stock[number_diff_products].name[i] = name[i];
  }

  store_stock[number_diff_products].name[i] = '\0';
  printf("Novo produto %d.\n", number_diff_products);
}

void command_q(int indentifier_product, int amount, int number_diff_products)
{
  if (indentifier_product < number_diff_products)
  {
    store_stock[indentifier_product].amount += amount;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", indentifier_product);
  }

}

void command_N(int number_orders)
{
  orders_list[number_orders].identifier = number_orders;
  orders_list[number_orders].weight = 0;
  orders_list[number_orders].number_diff_products = 0;
  printf("Nova encomenda %d.\n", number_orders);
}

void command_A(int identifier_order, int identifier_product, int amount, int number_orders, int number_products)
{
  Product newProduct;
  if (!(identifier_order < number_orders))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", identifier_product, identifier_order);
  }
  else
  {
    if (!(identifier_product < number_products))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", identifier_product, identifier_order);
    }
    else
    {
      if (amount > store_stock[identifier_product].amount)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", identifier_product, identifier_order);
      }
      else
      {
        if ((orders_list[identifier_order].weight + (amount * store_stock[identifier_product].weight)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", identifier_product, identifier_order);
        }
        else
        {
          int position = orders_list[identifier_order].number_diff_products;
          int i;
          for (i = 0; i < orders_list[identifier_order].number_diff_products; i++)
          {
            if (orders_list[identifier_order].shoplist[i].identifier == identifier_product)
            {
              orders_list[identifier_order].shoplist[i].amount += amount;
              orders_list[identifier_order].weight += orders_list[identifier_order].shoplist[i].weight * amount;
              store_stock[identifier_product].amount -= amount;
              return;
            }
            else
            {
              
            }

          }

          newProduct.identifier = identifier_product;
          newProduct.amount = amount;
          newProduct.price = store_stock[identifier_product].price;
          newProduct.weight = store_stock[identifier_product].weight;
          strcpy(newProduct.name, store_stock[identifier_product].name);
          orders_list[identifier_order].shoplist[position] = newProduct;
          orders_list[identifier_order].weight += amount * store_stock[identifier_product].weight;
          orders_list[identifier_order].number_diff_products += 1;
          store_stock[identifier_product].amount -= amount;
        }

      }

    }

  }

}

void command_r(int identifier_product, int amount, int number_diff_products)
{
  if (!(identifier_product < number_diff_products))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", identifier_product);
  }
  else
  {
    if (amount > store_stock[identifier_product].amount)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", amount, identifier_product);
    }
    else
    {
      store_stock[identifier_product].amount -= amount;
    }

  }

}

void command_R(int identifier_order, int identifier_product, int number_orders, int number_diff_products)
{
  if (!(identifier_order < number_orders))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", identifier_product, identifier_order);
  }
  else
  {
    if (!(identifier_product < number_diff_products))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", identifier_product, identifier_order);
    }
    else
    {
      int i;
      int returnAmount;
      for (i = 0; i < orders_list[identifier_order].number_diff_products; i++)
      {
        if (orders_list[identifier_order].shoplist[i].identifier == identifier_product)
        {
          returnAmount = orders_list[identifier_order].shoplist[i].amount;
          orders_list[identifier_order].shoplist[i].amount = 0;
          store_stock[identifier_product].amount += returnAmount;
          orders_list[identifier_order].weight -= returnAmount * orders_list[identifier_order].shoplist[i].weight;
          return;
        }
        else
        {
          
        }

      }

    }

  }

}

void command_C(int identifier_order, int number_orders)
{
  if (!(identifier_order < number_orders))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", identifier_order);
  }
  else
  {
    int i;
    int cost = 0;
    for (i = 0; i < orders_list[identifier_order].number_diff_products; i++)
    {
      cost += orders_list[identifier_order].shoplist[i].amount * orders_list[identifier_order].shoplist[i].price;
    }

    printf("Custo da encomenda %d %d.\n", identifier_order, cost);
  }

}

void command_p(int identifier_product, int price, int number_orders, int number_diff_products)
{
  if (!(identifier_product < number_diff_products))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", identifier_product);
  }
  else
  {
    int i;
    int j;
    store_stock[identifier_product].price = price;
    for (i = 0; i < number_orders; i++)
    {
      for (j = 0; j < orders_list[i].number_diff_products; j++)
      {
        if (orders_list[i].shoplist[j].identifier == identifier_product)
        {
          orders_list[i].shoplist[j].price = price;
          break;
        }
        else
        {
          
        }

      }

    }

  }

}

void command_E(int identifier_order, int identifier_product, int number_orders, int number_diff_products)
{
  if (!(identifier_order < number_orders))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", identifier_order);
  }
  else
  {
    if (!(identifier_product < number_diff_products))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", identifier_product);
    }
    else
    {
      int i;
      for (i = 0; i < orders_list[identifier_order].number_diff_products; i++)
      {
        if (identifier_product == orders_list[identifier_order].shoplist[i].identifier)
        {
          printf("%s %d.\n", store_stock[identifier_product].name, orders_list[identifier_order].shoplist[i].amount);
          return;
        }
        else
        {
          
        }

      }

      printf("%s 0.\n", store_stock[identifier_product].name);
    }

  }

}

void command_m(int identifier_product, int number_orders, int number_diff_products)
{
  if (!(identifier_product < number_diff_products))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", identifier_product);
  }
  else
  {
    int i;
    int j;
    int max_index = 0;
    int max_amount = 0;
    int state = 0;
    for (i = 0; i < number_orders; i++)
    {
      for (j = 0; j < orders_list[i].number_diff_products; j++)
      {
        if ((identifier_product == orders_list[i].shoplist[j].identifier) && (max_amount < orders_list[i].shoplist[j].amount))
        {
          max_amount = orders_list[i].shoplist[j].amount;
          max_index = i;
          state = 1;
        }
        else
        {
          
        }

      }

    }

    if (state)
    {
      printf("Maximo produto %d %d %d.\n", identifier_product, max_index, max_amount);
    }
    else
    {
      
    }

  }

}

void command_l(int number_diff_products)
{
  printf("Produtos\n");
  if (number_diff_products > 0)
  {
    int i;
    int ordered_products[10000];
    for (i = 0; i < number_diff_products; i++)
      ordered_products[i] = i;

    quicksort_products(ordered_products, 0, number_diff_products - 1);
    for (i = 0; i < number_diff_products; i++)
      printf("* %s %d %d\n", store_stock[ordered_products[i]].name, store_stock[ordered_products[i]].price, store_stock[ordered_products[i]].amount);

  }
  else
  {
    
  }

}

void command_L(int identifier_order, int number_orders)
{
  if (!(identifier_order < number_orders))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", identifier_order);
  }
  else
  {
    int i;
    int ordered_products[200];
    printf("Encomenda %d\n", identifier_order);
    for (i = 0; i < orders_list[identifier_order].number_diff_products; i++)
      ordered_products[i] = i;

    quicksort_orders(ordered_products, 0, orders_list[identifier_order].number_diff_products - 1, identifier_order);
    for (i = 0; i < orders_list[identifier_order].number_diff_products; i++)
      if (orders_list[identifier_order].shoplist[ordered_products[i]].amount > 0)
    {
      printf("* %s %d %d\n", orders_list[identifier_order].shoplist[ordered_products[i]].name, orders_list[identifier_order].shoplist[ordered_products[i]].price, orders_list[identifier_order].shoplist[ordered_products[i]].amount);
    }
    else
    {
      
    }


  }

}

void command_k(int number_diff_products)
{
  int i;
  printf("Produtos\n");
  for (i = 0; i < number_diff_products; i++)
  {
    printf("* %s %d %d\n", store_stock[i].name, store_stock[i].price, store_stock[i].amount);
  }

}

void command_K(int identifier_order)
{
  int i;
  printf("Encomenda %d\n", identifier_order);
  for (i = 0; i < orders_list[identifier_order].number_diff_products; i++)
  {
    printf("* %s %d %d\n", orders_list[identifier_order].shoplist[i].name, orders_list[identifier_order].shoplist[i].price, orders_list[identifier_order].shoplist[i].amount);
  }

}

void quicksort_products(int array[10000], int inf, int sup)
{
  int middle;
  if (sup <= inf)
  {
    return;
  }
  else
  {
    
  }

  middle = partition_products(array, inf, sup);
  quicksort_products(array, inf, middle - 1);
  quicksort_products(array, middle + 1, sup);
}

int partition_products(int array[10000], int inf, int sup)
{
  int i = inf - 1;
  int j = sup;
  while (i < j)
  {
    while (less_products(array[++i], array[sup]))
      ;

    while (less_products(array[sup], array[--j]))
    {
      if (j == inf)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      exchange_products(array, i, j);
    }
    else
    {
      
    }

  }

  exchange_products(array, i, sup);
  return i;
}

int less_products(int a, int b)
{
  if (store_stock[a].price < store_stock[b].price)
  {
    return 1;
  }
  else
  {
    if ((store_stock[a].price == store_stock[b].price) && (a < b))
    {
      return 1;
    }
    else
    {
      return 0;
    }

  }

}

void exchange_products(int array[10000], int a, int b)
{
  int aux;
  aux = array[a];
  array[a] = array[b];
  array[b] = aux;
}

void quicksort_orders(int array[500], int inf, int sup, int identifier_order)
{
  int middle;
  if (sup <= inf)
  {
    return;
  }
  else
  {
    
  }

  middle = partition_orders(array, inf, sup, identifier_order);
  quicksort_orders(array, inf, middle - 1, identifier_order);
  quicksort_orders(array, middle + 1, sup, identifier_order);
}

int partition_orders(int array[500], int inf, int sup, int identifier_order)
{
  int i = inf - 1;
  int j = sup;
  while (i < j)
  {
    while (less_orders(array[++i], array[sup], identifier_order))
      ;

    while (less_orders(array[sup], array[--j], identifier_order))
    {
      if (j == inf)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      exchange_orders(array, i, j);
    }
    else
    {
      
    }

  }

  exchange_orders(array, i, sup);
  return i;
}

int less_orders(int a, int b, int identifier_order)
{
  if (strcmp(orders_list[identifier_order].shoplist[a].name, orders_list[identifier_order].shoplist[b].name) < 0)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

void exchange_orders(int array[10000], int a, int b)
{
  int aux;
  aux = array[a];
  array[a] = array[b];
  array[b] = aux;
}

