/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct produto
{
  int identificador;
  char descricao[63];
  int preco;
  int peso;
  int quantidade;
} Produto;
typedef struct encomenda
{
  int identificador;
  int peso_total;
  int custo;
} Encomenda;
typedef struct detalhes_encomenda
{
  int identificador_encomenda;
  int identificador_produto;
  int quantidade_produto;
} Detalhes_encomenda;
typedef struct encomenda_temp
{
  char descricao[63];
  int preco;
  int quantidade;
} Temp_enc;
Produto lista_prod[10001];
Encomenda lista_enc[50];
Detalhes_encomenda lista_det_enc[100000];
Produto lista_prod_temp[10001];
Temp_enc lista_enc_temp[100000];
Temp_enc aux[100000];
int total_produtos = 0;
int total_encomendas = -1;
int total_detalhes = 0;
int total_temp = 0;
void func_a();
void func_q();
void func_N();
void func_A();
void func_r();
void func_R();
void func_C();
void func_p();
void func_E();
void func_m();
void func_l();
void func_L();
int procura_encomenda(int);
int procura_produto(int);
int encomenda_contem_produto(int, int);
void k();
void K(int);
void merge_sort_prod(Produto [], int, int);
void merge_prod(Produto [], int, int, int);
void merge_sort_enc(Temp_enc [], int, int);
void merge_enc(Temp_enc [], int, int, int);
int main()
{
  char command;
  while (1)
  {
    command = getchar();
    switch (command)
    {
      case 'a':
        func_a();
        break;

      case 'q':
        func_q();
        break;

      case 'N':
        func_N();
        break;

      case 'A':
        func_A();
        break;

      case 'r':
        func_r();
        break;

      case 'R':
        func_R();
        break;

      case 'C':
        func_C();
        break;

      case 'p':
        func_p();
        break;

      case 'E':
        func_E();
        break;

      case 'm':
        func_m();
        break;

      case 'l':
        func_l();
        break;

      case 'L':
        func_L();
        break;

      case 'x':
        return 0;

      default:
        printf("ERRO: Comando desconhecido\n");

    }

    getchar();
  }

  return 1;
}

void func_a()
{
  char input[10000];
  char *tok;
  int i = 0;
  char *array[4];
  if (total_produtos < 10001)
  {
    for (int input_index = 0; input_index < 10; input_index++)
    {
      input[input_index] = new_sym_var(sizeof(char) * 8);
    }

    input[10 - 1] = '\0';
    tok = strtok(input, ":");
    while (tok != 0)
    {
      array[i] = tok;
      tok = strtok(0, ":");
      i++;
    }

  }
  else
  {
    
  }

  lista_prod[total_produtos].identificador = total_produtos;
  strcpy(lista_prod[total_produtos].descricao, array[0]);
  lista_prod[total_produtos].preco = atoi(array[1]);
  lista_prod[total_produtos].peso = atoi(array[2]);
  lista_prod[total_produtos].quantidade = atoi(array[3]);
  printf("Novo produto %d.\n", lista_prod[total_produtos].identificador);
  total_produtos++;
}

void func_q()
{
  char input[10000];
  char *tok;
  int i = 0;
  int prod = -1;
  char *array[2];
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  tok = strtok(input, ":");
  while (tok != 0)
  {
    array[i] = tok;
    tok = strtok(0, ":");
    i++;
  }

  prod = procura_produto(atoi(array[0]));
  if (prod == (-1))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", atoi(array[0]));
  }
  else
  {
    lista_prod[prod].quantidade += atoi(array[1]);
  }

}

void func_N()
{
  lista_enc[total_encomendas + 1].identificador = total_encomendas + 1;
  lista_enc[total_encomendas + 1].peso_total = 0;
  lista_enc[total_encomendas + 1].custo = 0;
  printf("Nova encomenda %d.\n", total_encomendas + 1);
  total_encomendas++;
}

void func_A()
{
  char input[10000];
  char *tok;
  int i = 0;
  int j = 0;
  int enc = -1;
  int prod = -1;
  int peso_enc;
  int peso_prod;
  int preco_prod;
  int quant_prod;
  char *array[3];
  if (total_produtos < 10001)
  {
    for (int input_index = 0; input_index < 10; input_index++)
    {
      input[input_index] = new_sym_var(sizeof(char) * 8);
    }

    input[10 - 1] = '\0';
    tok = strtok(input, ":");
    while (tok != 0)
    {
      array[i] = tok;
      tok = strtok(0, ":");
      i++;
    }

  }
  else
  {
    
  }

  if (total_encomendas == (-1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", atoi(array[1]), atoi(array[0]));
  }
  else
  {
    enc = procura_encomenda(atoi(array[0]));
    prod = procura_produto(atoi(array[1]));
    if (enc == (-1))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", atoi(array[1]), atoi(array[0]));
    }
    else
    {
      if (prod == (-1))
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", atoi(array[1]), atoi(array[0]));
      }
      else
      {
        quant_prod = lista_prod[prod].quantidade;
        peso_prod = lista_prod[prod].peso;
        peso_enc = lista_enc[enc].peso_total;
        if (quant_prod < atoi(array[2]))
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", atoi(array[1]), atoi(array[0]));
        }
        else
        {
          if ((peso_enc + (atoi(array[2]) * peso_prod)) > 200)
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de %d.\n", atoi(array[1]), atoi(array[0]), 200);
          }
          else
          {
            preco_prod = lista_prod[prod].preco;
            j = encomenda_contem_produto(atoi(array[0]), atoi(array[1]));
            if (j != (-1))
            {
              lista_det_enc[j].quantidade_produto += atoi(array[2]);
              lista_enc[enc].peso_total += atoi(array[2]) * peso_prod;
              lista_enc[enc].custo += atoi(array[2]) * preco_prod;
              lista_prod[prod].quantidade -= atoi(array[2]);
            }
            else
            {
              lista_det_enc[total_detalhes].identificador_encomenda = atoi(array[0]);
              lista_det_enc[total_detalhes].identificador_produto = atoi(array[1]);
              lista_det_enc[total_detalhes].quantidade_produto = atoi(array[2]);
              total_detalhes++;
              lista_enc[enc].peso_total += atoi(array[2]) * peso_prod;
              lista_enc[enc].custo += atoi(array[2]) * preco_prod;
              lista_prod[prod].quantidade -= atoi(array[2]);
            }

          }

        }

      }

    }

  }

}

void func_r()
{
  char input[10000];
  char *tok;
  int i = 0;
  int prod = -1;
  char *array[2];
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  tok = strtok(input, ":");
  while (tok != 0)
  {
    array[i] = tok;
    tok = strtok(0, ":");
    i++;
  }

  prod = procura_produto(atoi(array[0]));
  if (prod == (-1))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", atoi(array[0]));
  }
  else
  {
    if ((lista_prod[prod].quantidade <= 0) || ((lista_prod[prod].quantidade - atoi(array[1])) < 0))
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", atoi(array[1]), atoi(array[0]));
    }
    else
    {
      lista_prod[prod].quantidade -= atoi(array[1]);
    }

  }

}

void func_R()
{
  char input[10000];
  char *tok;
  int i = 0;
  int j = 0;
  int prod = -1;
  int enc = -1;
  int quantidade_restante = 0;
  char *array[2];
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  tok = strtok(input, ":");
  while (tok != 0)
  {
    array[i] = tok;
    tok = strtok(0, ":");
    i++;
  }

  enc = procura_encomenda(atoi(array[0]));
  prod = procura_produto(atoi(array[1]));
  if (enc == (-1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", atoi(array[1]), atoi(array[0]));
  }
  else
  {
    if (prod == (-1))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", atoi(array[1]), atoi(array[0]));
    }
    else
    {
      for (j = 0; j < total_detalhes; j++)
      {
        if ((lista_det_enc[j].identificador_encomenda == atoi(array[0])) && (lista_det_enc[j].identificador_produto == atoi(array[1])))
        {
          quantidade_restante = lista_det_enc[j].quantidade_produto;
          lista_enc[enc].custo -= quantidade_restante * lista_prod[prod].preco;
          lista_enc[enc].peso_total -= quantidade_restante * lista_prod[prod].peso;
          lista_prod[prod].quantidade += quantidade_restante;
          lista_det_enc[j].quantidade_produto = 0;
        }
        else
        {
          
        }

      }

    }

  }

}

void func_C()
{
  int input = 0;
  int enc = -1;
  input = new_sym_var(sizeof(int) * 8);
  enc = procura_encomenda(input);
  if (enc == (-1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", input);
  }
  else
  {
    printf("Custo da encomenda %d %d.\n", lista_enc[enc].identificador, lista_enc[enc].custo);
  }

}

void func_p()
{
  char input[10000];
  char *tok;
  int i = 0;
  int j = 0;
  int prod = -1;
  int enc = 0;
  int novo_preco = 0;
  int velho_preco = 0;
  int dif = 0;
  int quantidade = 0;
  char *array[2];
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  tok = strtok(input, ":");
  while (tok != 0)
  {
    array[i] = tok;
    tok = strtok(0, ":");
    i++;
  }

  prod = procura_produto(atoi(array[0]));
  if (prod == (-1))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", atoi(array[0]));
  }
  else
  {
    velho_preco = lista_prod[prod].preco;
    novo_preco = atoi(array[1]);
    lista_prod[prod].preco = novo_preco;
    for (j = 0; j < total_detalhes; j++)
    {
      if (lista_det_enc[j].identificador_produto == atoi(array[0]))
      {
        quantidade = lista_det_enc[j].quantidade_produto;
        dif = quantidade * (novo_preco - velho_preco);
        enc = procura_encomenda(lista_det_enc[j].identificador_encomenda);
        lista_enc[enc].custo += dif;
      }
      else
      {
        
      }

    }

  }

}

void func_E()
{
  char input[10000];
  char *tok;
  int i = 0;
  int j = 0;
  int enc = -1;
  int prod = -1;
  char *array[2];
  for (int input_index = 0; input_index < 10; input_index++)
  {
    input[input_index] = new_sym_var(sizeof(char) * 8);
  }

  input[10 - 1] = '\0';
  tok = strtok(input, ":");
  while (tok != 0)
  {
    array[i] = tok;
    tok = strtok(0, ":");
    i++;
  }

  enc = procura_encomenda(atoi(array[0]));
  prod = procura_produto(atoi(array[1]));
  j = encomenda_contem_produto(atoi(array[0]), atoi(array[1]));
  if (enc == (-1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", atoi(array[0]));
  }
  else
  {
    if (prod == (-1))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", atoi(array[1]));
    }
    else
    {
      if (j == (-1))
      {
        printf("%s %d.\n", lista_prod[prod].descricao, 0);
      }
      else
      {
        for (i = 0; i <= total_detalhes; i++)
        {
          if (((lista_det_enc[i].identificador_encomenda == atoi(array[0])) && (lista_det_enc[i].identificador_produto == atoi(array[1]))) && (lista_det_enc[i].quantidade_produto >= 0))
          {
            printf("%s %d.\n", lista_prod[prod].descricao, lista_det_enc[i].quantidade_produto);
            i = total_detalhes;
          }
          else
          {
            
          }

        }

      }

    }

  }

}

void func_m()
{
  int i = 0;
  int input = 0;
  int prod = -1;
  int ide_out = -1;
  int qtd_max_out = -1;
  input = new_sym_var(sizeof(int) * 8);
  prod = procura_produto(input);
  if (prod == (-1))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", input);
  }
  else
  {
    for (i = 0; i < total_detalhes; i++)
    {
      if (lista_det_enc[i].identificador_produto == input)
      {
        if (lista_det_enc[i].quantidade_produto == qtd_max_out)
        {
          if (lista_det_enc[i].identificador_encomenda < ide_out)
          {
            ide_out = lista_det_enc[i].identificador_encomenda;
          }
          else
          {
            
          }

        }
        else
        {
          if (lista_det_enc[i].quantidade_produto > qtd_max_out)
          {
            qtd_max_out = lista_det_enc[i].quantidade_produto;
            ide_out = lista_det_enc[i].identificador_encomenda;
          }
          else
          {
            
          }

        }

      }
      else
      {
        
      }

    }

    if ((ide_out != (-1)) && (qtd_max_out > 0))
    {
      printf("Maximo produto %d %d %d.\n", input, ide_out, qtd_max_out);
    }
    else
    {
      
    }

  }

}

void func_l()
{
  if (total_produtos > 0)
  {
    merge_sort_prod(lista_prod, 0, total_produtos - 1);
  }
  else
  {
    
  }

  k();
}

void func_L()
{
  int input = 0;
  int enc = -1;
  int i = 0;
  int id_prod = 0;
  int count = -1;
  for (i = 0; i < total_detalhes; i++)
  {
    strcpy(lista_enc_temp[i].descricao, "");
    lista_enc_temp[i].preco = 0;
    lista_enc_temp[i].quantidade = 0;
  }

  input = new_sym_var(sizeof(int) * 8);
  enc = procura_encomenda(input);
  if (enc == (-1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", input);
  }
  else
  {
    printf("Encomenda %d\n", input);
    for (i = 0; i < total_detalhes; i++)
    {
      if ((lista_det_enc[i].identificador_encomenda == input) && (lista_det_enc[i].quantidade_produto > 0))
      {
        ++count;
        id_prod = procura_produto(lista_det_enc[i].identificador_produto);
        strcpy(lista_enc_temp[count].descricao, lista_prod[id_prod].descricao);
        lista_enc_temp[count].preco = lista_prod[id_prod].preco;
        lista_enc_temp[count].quantidade = lista_det_enc[i].quantidade_produto;
      }
      else
      {
        
      }

    }

    if ((count == 0) || (count == 1))
    {
      for (i = 0; i < (count + 1); i++)
      {
        if ((lista_enc_temp[i].preco != 0) && (lista_enc_temp[i].quantidade != 0))
        {
          merge_sort_enc(lista_enc_temp, 0, count);
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (count > 1)
      {
        merge_sort_enc(lista_enc_temp, 0, count);
      }
      else
      {
        
      }

    }

    K(count);
  }

}

int procura_encomenda(int id)
{
  int i = 0;
  int enc = -1;
  for (i = 0; i <= total_encomendas; i++)
  {
    if (lista_enc[i].identificador == id)
    {
      enc = i;
    }
    else
    {
      
    }

  }

  return enc;
}

int procura_produto(int id)
{
  int i = 0;
  int prod = -1;
  for (i = 0; i < total_produtos; i++)
  {
    if (lista_prod[i].identificador == id)
    {
      prod = i;
    }
    else
    {
      
    }

  }

  return prod;
}

int encomenda_contem_produto(int n1, int n2)
{
  int j = 0;
  for (j = 0; j < total_detalhes; j++)
  {
    if ((lista_det_enc[j].identificador_encomenda == n1) && (lista_det_enc[j].identificador_produto == n2))
    {
      return j;
    }
    else
    {
      
    }

  }

  return -1;
}

void k()
{
  int i = 0;
  printf("Produtos\n");
  for (i = 0; i < total_produtos; i++)
  {
    printf("* %s %d %d\n", lista_prod[i].descricao, lista_prod[i].preco, lista_prod[i].quantidade);
  }

}

void K(int number)
{
  int i = 0;
  for (i = 0; i <= number; i++)
  {
    if ((lista_enc_temp[i].preco != 0) && (lista_enc_temp[i].quantidade != 0))
    {
      printf("* %s %d %d\n", lista_enc_temp[i].descricao, lista_enc_temp[i].preco, lista_enc_temp[i].quantidade);
    }
    else
    {
      
    }

  }

}

void merge_sort_prod(Produto a[], int low, int high)
{
  int mid = 0;
  if (low == high)
  {
    return;
  }
  else
  {
    mid = (low + high) / 2;
    merge_sort_prod(a, low, mid);
    merge_sort_prod(a, mid + 1, high);
    merge_prod(a, low, mid, high);
  }

}

void merge_prod(Produto a[], int low, int mid, int high)
{
  int i = 0;
  int left_index = low;
  int right_index = mid + 1;
  int combined_index = low;
  Produto tempA[10001];
  while ((left_index <= mid) && (right_index <= high))
  {
    if (a[left_index].preco < a[right_index].preco)
    {
      tempA[combined_index++] = a[left_index++];
    }
    else
    {
      if (a[left_index].preco > a[right_index].preco)
      {
        tempA[combined_index++] = a[right_index++];
      }
      else
      {
        if (a[left_index].identificador < a[right_index].identificador)
        {
          tempA[combined_index++] = a[left_index++];
        }
        else
        {
          tempA[combined_index++] = a[right_index++];
        }

      }

    }

  }

  if (left_index == (mid + 1))
  {
    while (right_index <= high)
    {
      tempA[combined_index++] = a[right_index++];
    }

  }
  else
  {
    while (left_index <= mid)
    {
      tempA[combined_index++] = a[left_index++];
    }

  }

  for (i = low; i <= high; i++)
  {
    a[i] = tempA[i];
  }

}

void merge_sort_enc(Temp_enc a[], int low, int high)
{
  int mid = 0;
  if (low == high)
  {
    return;
  }
  else
  {
    mid = (low + high) / 2;
    merge_sort_enc(a, low, mid);
    merge_sort_enc(a, mid + 1, high);
    merge_enc(a, low, mid, high);
  }

}

void merge_enc(Temp_enc a[], int low, int mid, int high)
{
  int i = 0;
  int left_index = low;
  int right_index = mid + 1;
  int combined_index = low;
  Temp_enc tempA[50];
  while ((left_index <= mid) && (right_index <= high))
  {
    if (strcmp(a[left_index].descricao, a[right_index].descricao) < 0)
    {
      tempA[combined_index++] = a[left_index++];
    }
    else
    {
      tempA[combined_index++] = a[right_index++];
    }

  }

  if (left_index == (mid + 1))
  {
    while (right_index <= high)
    {
      tempA[combined_index++] = a[right_index++];
    }

  }
  else
  {
    while (left_index <= mid)
    {
      tempA[combined_index++] = a[left_index++];
    }

  }

  for (i = low; i <= high; i++)
  {
    a[i] = tempA[i];
  }

}

