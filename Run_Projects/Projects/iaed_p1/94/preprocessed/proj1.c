/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int idp;
  int preco;
  int peso;
  int qtd;
  char des[64];
} produto;
typedef struct 
{
  int count;
  int produtos[200][2];
} encomenda;
int prod_count;
int enc_count;
produto vet_produtos[10000];
encomenda vet_encomendas[500];
void copia_vetores_int(int vetor_1[], int vetor_2[], int size)
{
  int i;
  for (i = 0; i < size; ++i)
    vetor_1[i] = vetor_2[i];

}

void copia_vetores_prod(produto vetor_1[], produto vetor_2[], int size)
{
  int i;
  for (i = 0; i < size; ++i)
    vetor_1[i] = vetor_2[i];

}

int idp_na_encomenda(int ide, int idp)
{
  int i;
  for (i = 0; i < vet_encomendas[ide].count; ++i)
  {
    if (idp == vet_encomendas[ide].produtos[i][0])
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

long peso_encomenda(int ide)
{
  int i;
  long total = 0;
  for (i = 0; i < vet_encomendas[ide].count; ++i)
    total += vet_produtos[vet_encomendas[ide].produtos[i][0]].peso * vet_encomendas[ide].produtos[i][1];

  return total;
}

void merge_prod(produto a[10000], int left, int m, int right)
{
  int i;
  int j;
  int l;
  produto aux[10000];
  for (i = m + 1; i > left; --i)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; ++j)
    aux[(right + m) - j] = a[j + 1];

  for (l = left; l <= right; ++l)
  {
    if (aux[j].preco < aux[i].preco)
    {
      a[l] = aux[j--];
    }
    else
    {
      if (aux[j].preco > aux[i].preco)
      {
        a[l] = aux[i++];
      }
      else
      {
        if (aux[j].idp < aux[i].idp)
        {
          a[l] = aux[j--];
        }
        else
        {
          a[l] = aux[i++];
        }

      }

    }

  }

}

void merge_sort_prod(produto a[10000], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  merge_sort_prod(a, left, m);
  merge_sort_prod(a, m + 1, right);
  merge_prod(a, left, m, right);
}

void merge_enc(int a[199][2], int left, int m, int right)
{
  int i;
  int j;
  int l;
  int aux[199][2];
  for (i = m + 1; i > left; --i)
    copia_vetores_int(aux[i - 1], a[i - 1], 2);

  for (j = m; j < right; ++j)
    copia_vetores_int(aux[(right + m) - j], a[j + 1], 2);

  for (l = left; l <= right; ++l)
  {
    if (strcmp(vet_produtos[aux[i][0]].des, vet_produtos[aux[j][0]].des) > 0)
    {
      {
        copia_vetores_int(a[l], aux[j], 2);
        --j;
      }
    }
    else
    {
      {
        copia_vetores_int(a[l], aux[i], 2);
        ++i;
      }
    }

  }

}

void merge_sort_enc(int a[199][2], int left, int right)
{
  int m = (left + right) / 2;
  if (left >= right)
  {
    return;
  }
  else
  {
    
  }

  merge_sort_enc(a, left, m);
  merge_sort_enc(a, m + 1, right);
  merge_enc(a, left, m, right);
}

void a()
{
  produto prod;
  getchar();
  for (int prod_index = 0; prod_index < 10; prod_index++)
  {
    prod.des[prod_index] = new_sym_var(sizeof(char) * 8);
  }

  prod.des[10 - 1] = '\0';
  prod.preco = new_sym_var(sizeof(int) * 8);
  prod.peso = new_sym_var(sizeof(int) * 8);
  prod.qtd = new_sym_var(sizeof(int) * 8);
  prod.idp = prod_count;
  vet_produtos[prod_count] = prod;
  printf("Novo produto %d.\n", prod_count);
  ++prod_count;
}

void q()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= prod_count)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    vet_produtos[idp].qtd += qtd;
  }

}

void N()
{
  printf("Nova encomenda %d.\n", enc_count);
  ++enc_count;
}

void A()
{
  int ide;
  int idp;
  int qtd;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= enc_count)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= prod_count)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (vet_produtos[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((peso_encomenda(ide) + (vet_produtos[idp].peso * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          {
            if ((i = idp_na_encomenda(ide, idp)) != (-1))
            {
              vet_encomendas[ide].produtos[i][1] += qtd;
            }
            else
            {
              {
                vet_encomendas[ide].produtos[vet_encomendas[ide].count][0] = idp;
                vet_encomendas[ide].produtos[vet_encomendas[ide].count][1] = qtd;
                ++vet_encomendas[ide].count;
              }
            }

            vet_produtos[idp].qtd -= qtd;
          }
        }

      }

    }

  }

}

void r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= prod_count)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (qtd > vet_produtos[idp].qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      vet_produtos[idp].qtd -= qtd;
    }

  }

}

void R()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= enc_count)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= prod_count)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if ((i = idp_na_encomenda(ide, idp)) != (-1))
      {
        {
          vet_produtos[idp].qtd += vet_encomendas[ide].produtos[i][1];
          for (; i < vet_encomendas[ide].count; ++i)
            copia_vetores_int(vet_encomendas[ide].produtos[i], vet_encomendas[ide].produtos[i + 1], 2);

          --vet_encomendas[ide].count;
        }
      }
      else
      {
        
      }

    }

  }

}

void C()
{
  int ide;
  int i;
  long preco = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= enc_count)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (i = 0; i < vet_encomendas[ide].count; ++i)
        preco += vet_encomendas[ide].produtos[i][1] * vet_produtos[vet_encomendas[ide].produtos[i][0]].preco;

      printf("Custo da encomenda %d %ld.\n", ide, preco);
    }
  }

}

void p()
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= prod_count)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    vet_produtos[idp].preco = preco;
  }

}

void E()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= enc_count)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= prod_count)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      {
        if ((i = idp_na_encomenda(ide, idp)) != (-1))
        {
          printf("%s %d.\n", vet_produtos[idp].des, vet_encomendas[ide].produtos[i][1]);
        }
        else
        {
          printf("%s 0.\n", vet_produtos[idp].des);
        }

      }
    }

  }

}

void m()
{
  int idp;
  int maior = 0;
  int ide = -1;
  int i;
  int j;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= prod_count)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      for (i = 0; i < enc_count; ++i)
        if (((j = idp_na_encomenda(i, idp)) != (-1)) && (vet_encomendas[i].produtos[j][1] > maior))
      {
        {
          maior = vet_encomendas[i].produtos[j][1];
          ide = i;
        }
      }
      else
      {
        
      }


      if (ide != (-1))
      {
        printf("Maximo produto %d %d %d.\n", idp, ide, maior);
      }
      else
      {
        
      }

    }
  }

}

void l()
{
  int i;
  produto vet_prod_copia[10000];
  copia_vetores_prod(vet_prod_copia, vet_produtos, prod_count);
  merge_sort_prod(vet_prod_copia, 0, prod_count - 1);
  printf("Produtos\n");
  for (i = 0; i < prod_count; ++i)
  {
    printf("* %s %d %d\n", vet_prod_copia[i].des, vet_prod_copia[i].preco, vet_prod_copia[i].qtd);
  }

}

void L()
{
  int ide;
  int i;
  int copia_enc[199][2];
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= enc_count)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (i = 0; i < vet_encomendas[ide].count; ++i)
      {
        copia_enc[i][0] = vet_encomendas[ide].produtos[i][0];
        copia_enc[i][1] = vet_encomendas[ide].produtos[i][1];
      }

      merge_sort_enc(copia_enc, 0, vet_encomendas[ide].count - 1);
      printf("Encomenda %d\n", ide);
      for (i = 0; i < vet_encomendas[ide].count; ++i)
      {
        printf("* %s %d %d\n", vet_produtos[copia_enc[i][0]].des, vet_produtos[copia_enc[i][0]].preco, copia_enc[i][1]);
      }

    }
  }

}

int main()
{
  int c;
  while ((c = getchar()) != 'x')
  {
    switch (c)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

    }

  }

  return 0;
}

