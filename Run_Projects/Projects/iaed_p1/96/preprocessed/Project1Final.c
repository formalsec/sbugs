/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int id;
  char descrip[63];
  int price;
  int weight;
  int stock;
} Product;
typedef struct 
{
  int nrProd;
  int products[200][2];
} Order;
int scanCommand();
void command_a();
void command_q();
void command_N();
void command_A();
void command_r();
void command_R();
void command_C();
void command_p();
void command_E();
void command_m();
void command_l();
void command_L();
void command_k();
void command_K();
int orderWeight(int idO);
int orderCost(int idO);
void mergeSort(int ids[], int left, int right, int type);
void merge(int ids[], int left, int m, int right, int type);
int nrIds;
int nrOIds;
Product warehouse[10000];
Order orders[500];
int main()
{
  int running = 1;
  while (running)
  {
    running = scanCommand();
  }

  return 0;
}

int scanCommand()
{
  char c;
  c = getchar();
  switch (c)
  {
    case 'a':
      command_a();
      break;

    case 'q':
      command_q();
      break;

    case 'N':
      command_N();
      break;

    case 'A':
      command_A();
      break;

    case 'r':
      command_r();
      break;

    case 'R':
      command_R();
      break;

    case 'C':
      command_C();
      break;

    case 'p':
      command_p();
      break;

    case 'E':
      command_E();
      break;

    case 'm':
      command_m();
      break;

    case 'l':
      command_l();
      break;

    case 'L':
      command_L();
      break;

    case 'x':
      return 0;
      break;

    default:
      break;

  }

  return 1;
}

void command_a()
{
  Product newP;
  newP.id = nrIds;
  for (int newP_index = 0; newP_index < 10; newP_index++)
  {
    newP.descrip[newP_index] = new_sym_var(sizeof(char) * 8);
  }

  newP.descrip[10 - 1] = '\0';
  newP.price = new_sym_var(sizeof(int) * 8);
  newP.weight = new_sym_var(sizeof(int) * 8);
  newP.stock = new_sym_var(sizeof(int) * 8);
  warehouse[nrIds] = newP;
  printf("Novo produto %d.\n", nrIds);
  nrIds++;
}

void command_q()
{
  int id;
  int qtd;
  id = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (nrIds > id)
  {
    warehouse[id].stock += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  }

}

void command_N()
{
  Order newOrder;
  newOrder.nrProd = 0;
  orders[nrOIds] = newOrder;
  printf("Nova encomenda %d.\n", nrOIds);
  nrOIds += 1;
}

void command_A()
{
  int idO;
  int idP;
  int qtd;
  int i;
  int nrProd;
  idO = new_sym_var(sizeof(int) * 8);
  idP = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idO >= nrOIds)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idP, idO);
  }
  else
  {
    if (idP >= nrIds)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idP, idO);
    }
    else
    {
      if (qtd > warehouse[idP].stock)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idP, idO);
      }
      else
      {
        if ((orderWeight(idO) + (qtd * warehouse[idP].weight)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idP, idO);
        }
        else
        {
          for (i = 0; i < orders[idO].nrProd; i++)
          {
            if (orders[idO].products[i][0] == idP)
            {
              orders[idO].products[i][1] += qtd;
              warehouse[idP].stock -= qtd;
              return;
            }
            else
            {
              
            }

          }

          nrProd = orders[idO].nrProd;
          orders[idO].products[nrProd][0] = idP;
          orders[idO].products[nrProd][1] = qtd;
          warehouse[idP].stock -= qtd;
          orders[idO].nrProd++;
        }

      }

    }

  }

}

void command_r()
{
  int idP;
  int qtd;
  idP = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idP >= nrIds)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idP);
  }
  else
  {
    if (warehouse[idP].stock < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idP);
    }
    else
    {
      warehouse[idP].stock -= qtd;
    }

  }

}

void command_R()
{
  int idP;
  int idO;
  int i;
  int troca = 0;
  idO = new_sym_var(sizeof(int) * 8);
  idP = new_sym_var(sizeof(int) * 8);
  if (idO >= nrOIds)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idP, idO);
  }
  else
  {
    if (idP >= nrIds)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idP, idO);
    }
    else
    {
      for (i = 0; i < orders[idO].nrProd; i++)
      {
        if (troca)
        {
          orders[idO].products[i - 1][0] = orders[idO].products[i][0];
          orders[idO].products[i - 1][1] = orders[idO].products[i][1];
        }
        else
        {
          
        }

        if ((idP == orders[idO].products[i][0]) && (!troca))
        {
          warehouse[idP].stock += orders[idO].products[i][1];
          troca = 1;
        }
        else
        {
          
        }

      }

      if (troca)
      {
        orders[idO].nrProd -= 1;
      }
      else
      {
        
      }

    }

  }

}

void command_C()
{
  int idO;
  idO = new_sym_var(sizeof(int) * 8);
  if (idO >= nrOIds)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", idO);
  }
  else
  {
    printf("Custo da encomenda %d %d.\n", idO, orderCost(idO));
  }

}

void command_p()
{
  int idP;
  int newPrice;
  idP = new_sym_var(sizeof(int) * 8);
  newPrice = new_sym_var(sizeof(int) * 8);
  if (idP >= nrIds)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idP);
  }
  else
  {
    warehouse[idP].price = newPrice;
  }

}

void command_E()
{
  int idP;
  int idO;
  int i;
  idO = new_sym_var(sizeof(int) * 8);
  idP = new_sym_var(sizeof(int) * 8);
  if (idO >= nrOIds)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idO);
  }
  else
  {
    if (idP >= nrIds)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idP);
    }
    else
    {
      for (i = 0; i < orders[idO].nrProd; i++)
      {
        if (idP == orders[idO].products[i][0])
        {
          printf("%s %d.\n", warehouse[idP].descrip, orders[idO].products[i][1]);
          return;
        }
        else
        {
          
        }

      }

      printf("%s %d.\n", warehouse[idP].descrip, 0);
    }

  }

}

void command_m()
{
  int idP;
  int qtd = 0;
  int idO;
  int i;
  int j;
  idP = new_sym_var(sizeof(int) * 8);
  if (idP >= nrIds)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idP);
  }
  else
  {
    for (i = 0; i < nrOIds; i++)
    {
      for (j = 0; j < orders[i].nrProd; j++)
      {
        if (idP == orders[i].products[j][0])
        {
          if (qtd < orders[i].products[j][1])
          {
            qtd = orders[i].products[j][1];
            idO = i;
            break;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    if (qtd != 0)
    {
      printf("Maximo produto %d %d %d.\n", idP, idO, qtd);
    }
    else
    {
      
    }

  }

}

void command_l()
{
  int i;
  int ids[10000];
  for (i = 0; i < nrIds; i++)
  {
    ids[i] = i;
  }

  mergeSort(ids, 0, nrIds - 1, 1);
  printf("Produtos\n");
  for (i = 0; i < nrIds; i++)
  {
    printf("* %s %d %d\n", warehouse[ids[i]].descrip, warehouse[ids[i]].price, warehouse[ids[i]].stock);
  }

}

void command_L()
{
  int i;
  int idO;
  int ids[200];
  int qtds[10000];
  idO = new_sym_var(sizeof(int) * 8);
  if (idO >= nrOIds)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idO);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < orders[idO].nrProd; i++)
  {
    ids[i] = orders[idO].products[i][0];
    qtds[ids[i]] = orders[idO].products[i][1];
  }

  mergeSort(ids, 0, orders[idO].nrProd - 1, 0);
  printf("Encomenda %d\n", idO);
  for (i = 0; i < orders[idO].nrProd; i++)
  {
    printf("* %s %d %d\n", warehouse[ids[i]].descrip, warehouse[ids[i]].price, qtds[ids[i]]);
  }

}

int orderWeight(int idO)
{
  int i;
  int wt = 0;
  for (i = 0; i < orders[idO].nrProd; i++)
  {
    wt += orders[idO].products[i][1] * warehouse[orders[idO].products[i][0]].weight;
  }

  return wt;
}

int orderCost(int idO)
{
  int i;
  int cost = 0;
  for (i = 0; i < orders[idO].nrProd; i++)
  {
    cost += orders[idO].products[i][1] * warehouse[orders[idO].products[i][0]].price;
  }

  return cost;
}

void mergeSort(int ids[], int left, int right, int type)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergeSort(ids, left, m, type);
  mergeSort(ids, m + 1, right, type);
  merge(ids, left, m, right, type);
}

int aux[10000];
void merge(int ids[], int left, int m, int right, int type)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = ids[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = ids[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if (type)
    {
      if (warehouse[aux[j]].price < warehouse[aux[i]].price)
      {
        ids[k] = aux[j--];
      }
      else
      {
        if (warehouse[aux[j]].price > warehouse[aux[i]].price)
        {
          ids[k] = aux[i++];
        }
        else
        {
          if (aux[j] > aux[i])
          {
            ids[k] = aux[i++];
          }
          else
          {
            ids[k] = aux[j--];
          }

        }

      }

    }
    else
    {
      if (strcmp(warehouse[aux[i]].descrip, warehouse[aux[j]].descrip) > 0)
      {
        ids[k] = aux[j--];
      }
      else
      {
        ids[k] = aux[i++];
      }

    }

  }

}

