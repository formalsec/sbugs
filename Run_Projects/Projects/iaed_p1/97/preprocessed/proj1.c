/*File generated by PreProcessor.py*/


#include <stdio.h>


int contador_produto = 0;
int contador_encomenda = 0;
typedef struct 
{
  char descricao[200];
  int preco;
  int peso;
  int qtd;
} produto;
typedef struct 
{
  int idp;
  int qtd;
} produto_enc;
typedef struct 
{
  int qntprods;
  produto_enc produto[200];
} encomenda;
void add_prod(produto sistema[]);
void add_stock(produto sistema[]);
void nova_encom(encomenda encomenda[]);
int peso(produto sistema[], encomenda encomendas[], int ide);
int encontra_idp_local(encomenda encomendas[], int ide, int idp);
void add_prod_encom(produto sistema[], encomenda encomendas[]);
void remo_stock(produto sistema[]);
void remo_prod_encom(produto sistema[], encomenda encomendas[]);
void custo_encom(produto sistema[], encomenda encomendas[]);
void alt_preco(produto sistema[]);
void lista_prod_encom(produto sistema[], encomenda encomendas[]);
void lista_prodfreq_encom(encomenda encomendas[]);
void merge(produto sistema[], int copia[], int aux[], int esq, int m, int dir);
void mergesort(produto sistema[], int copia[], int esq, int dir);
void ordena_preco_prods(produto sistema[]);
void merge_encom(produto sistema[], encomenda encomendas[], int ide, produto_enc aux[], int esq, int m, int dir);
void mergesort_encom(produto sistema[], encomenda encomendas[], int ide, int esq, int dir);
void ordena_descr_encom(produto sistema[], encomenda encomendas[]);
int main()
{
  produto sistema[10000];
  encomenda encomendas[500];
  int estado = 1;
  char comando;
  while (estado)
  {
    comando = getchar();
    switch (comando)
    {
      case 'a':
        add_prod(sistema);
        break;

      case 'q':
        add_stock(sistema);
        break;

      case 'N':
        nova_encom(encomendas);
        break;

      case 'A':
        add_prod_encom(sistema, encomendas);
        break;

      case 'r':
        remo_stock(sistema);
        break;

      case 'R':
        remo_prod_encom(sistema, encomendas);
        break;

      case 'C':
        custo_encom(sistema, encomendas);
        break;

      case 'p':
        alt_preco(sistema);
        break;

      case 'E':
        lista_prod_encom(sistema, encomendas);
        break;

      case 'm':
        lista_prodfreq_encom(encomendas);
        break;

      case 'l':
        ordena_preco_prods(sistema);
        break;

      case 'L':
        ordena_descr_encom(sistema, encomendas);
        break;

      case 'x':
        estado = 0;

    }

  }

  return 0;
}

void add_prod(produto sistema[])
{
  produto prod;
  for (int prod_index = 0; prod_index < 10; prod_index++)
  {
    prod.descricao[prod_index] = new_sym_var(sizeof(char) * 8);
  }

  prod.descricao[10 - 1] = '\0';
  prod.preco = new_sym_var(sizeof(int) * 8);
  prod.peso = new_sym_var(sizeof(int) * 8);
  prod.qtd = new_sym_var(sizeof(int) * 8);
  sistema[contador_produto] = prod;
  printf("Novo produto %d.\n", contador_produto);
  contador_produto++;
}

void add_stock(produto sistema[])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= contador_produto)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  sistema[idp].qtd += qtd;
}

void nova_encom(encomenda encomenda[])
{
  encomenda[contador_encomenda].qntprods = 0;
  printf("Nova encomenda %d.\n", contador_encomenda);
  contador_encomenda++;
}

int peso(produto sistema[], encomenda encomendas[], int ide)
{
  int i;
  int nrprodutos;
  int idp;
  int peso = 0;
  nrprodutos = encomendas[ide].qntprods;
  for (i = 0; i < nrprodutos; i++)
  {
    idp = encomendas[ide].produto[i].idp;
    peso += sistema[idp].peso * encomendas[ide].produto[i].qtd;
  }

  return peso;
}

int encontra_idp_local(encomenda encomendas[], int ide, int idp)
{
  int i;
  int nrprodutos;
  nrprodutos = encomendas[ide].qntprods;
  for (i = 0; i < nrprodutos; i++)
  {
    if (encomendas[ide].produto[i].idp == idp)
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return -1;
}

void add_prod_encom(produto sistema[], encomenda encomendas[])
{
  int ide;
  int idp;
  int qtd;
  int nrprodutos;
  int idp_local;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_encomenda)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (idp >= contador_produto)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (sistema[idp].qtd < qtd)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if ((peso(sistema, encomendas, ide) + (sistema[idp].peso * qtd)) > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  nrprodutos = encomendas[ide].qntprods;
  idp_local = encontra_idp_local(encomendas, ide, idp);
  if (idp_local >= 0)
  {
    {
      encomendas[ide].produto[idp_local].qtd += qtd;
      sistema[idp].qtd -= qtd;
    }
  }
  else
  {
    {
      encomendas[ide].produto[nrprodutos].idp = idp;
      encomendas[ide].produto[nrprodutos].qtd = qtd;
      encomendas[ide].qntprods++;
      sistema[idp].qtd -= qtd;
    }
  }

}

void remo_stock(produto sistema[])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= contador_produto)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  if (sistema[idp].qtd < qtd)
  {
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
      return;
    }
  }
  else
  {
    
  }

  sistema[idp].qtd -= qtd;
}

void remo_prod_encom(produto sistema[], encomenda encomendas[])
{
  int i;
  int ide;
  int idp;
  int nrproduto;
  int idp_local;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_encomenda)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (idp >= contador_produto)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  idp_local = encontra_idp_local(encomendas, ide, idp);
  nrproduto = encomendas[ide].qntprods;
  if (idp_local >= 0)
  {
    {
      sistema[idp].qtd += encomendas[ide].produto[idp_local].qtd;
      for (i = idp_local; i < (nrproduto - 1); i++)
      {
        encomendas[ide].produto[i].idp = encomendas[ide].produto[i + 1].idp;
        encomendas[ide].produto[i].qtd = encomendas[ide].produto[i + 1].qtd;
      }

      encomendas[ide].qntprods--;
    }
  }
  else
  {
    
  }

}

void custo_encom(produto sistema[], encomenda encomendas[])
{
  int i;
  int ide;
  int nrprodutos;
  int custo = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_encomenda)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  nrprodutos = encomendas[ide].qntprods;
  for (i = 0; i < nrprodutos; i++)
  {
    custo += sistema[encomendas[ide].produto[i].idp].preco * encomendas[ide].produto[i].qtd;
  }

  printf("Custo da encomenda %d %d.\n", ide, custo);
}

void alt_preco(produto sistema[])
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= contador_produto)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  sistema[idp].preco = preco;
}

void lista_prod_encom(produto sistema[], encomenda encomendas[])
{
  int ide;
  int idp;
  int idp_local;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_encomenda)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  if (idp >= contador_produto)
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  idp_local = encontra_idp_local(encomendas, ide, idp);
  if (idp_local >= 0)
  {
    {
      printf("%s %d.\n", sistema[idp].descricao, encomendas[ide].produto[idp_local].qtd);
    }
  }
  else
  {
    {
      printf("%s 0.\n", sistema[idp].descricao);
    }
  }

}

void lista_prodfreq_encom(encomenda encomendas[])
{
  int i;
  int j;
  int idp;
  int ide;
  int nrprodutos;
  int maior = 0;
  int existe_em_encomenda = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= contador_produto)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < contador_encomenda; i++)
  {
    nrprodutos = encomendas[i].qntprods;
    for (j = 0; j < nrprodutos; j++)
    {
      if ((encomendas[i].produto[j].qtd > maior) && (encomendas[i].produto[j].idp == idp))
      {
        {
          ide = i;
          maior = encomendas[i].produto[j].qtd;
          existe_em_encomenda = 1;
        }
      }
      else
      {
        
      }

    }

  }

  if ((contador_encomenda != 0) && existe_em_encomenda)
  {
    {
      printf("Maximo produto %d %d %d.\n", idp, ide, maior);
    }
  }
  else
  {
    
  }

}

void mergesort(produto sistema[], int copia[], int esq, int dir)
{
  int m = (dir + esq) / 2;
  int aux[10000];
  if (dir <= esq)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  mergesort(sistema, copia, esq, m);
  mergesort(sistema, copia, m + 1, dir);
  merge(sistema, copia, aux, esq, m, dir);
}

void merge(produto sistema[], int copia[], int aux[], int esq, int m, int dir)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > esq; i--)
  {
    aux[i - 1] = copia[i - 1];
  }

  for (j = m; j < dir; j++)
  {
    aux[(dir + m) - j] = copia[j + 1];
  }

  for (k = esq; k <= dir; k++)
  {
    if (sistema[aux[j]].preco < sistema[aux[i]].preco)
    {
      {
        copia[k] = aux[j--];
      }
    }
    else
    {
      if (sistema[aux[j]].preco == sistema[aux[i]].preco)
      {
        {
          if (aux[j] < aux[i])
          {
            {
              copia[k] = aux[j--];
            }
          }
          else
          {
            {
              copia[k] = aux[i++];
            }
          }

        }
      }
      else
      {
        {
          copia[k] = aux[i++];
        }
      }

    }

  }

}

void ordena_preco_prods(produto sistema[])
{
  int i;
  int copia[10000];
  for (i = 0; i < contador_produto; i++)
  {
    copia[i] = i;
  }

  mergesort(sistema, copia, 0, contador_produto - 1);
  printf("Produtos\n");
  for (i = 0; i < contador_produto; i++)
  {
    printf("* %s %d %d\n", sistema[copia[i]].descricao, sistema[copia[i]].preco, sistema[copia[i]].qtd);
  }

}

void mergesort_encom(produto sistema[], encomenda encomendas[], int ide, int esq, int dir)
{
  int m = (dir + esq) / 2;
  produto_enc aux[200];
  if (dir <= esq)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  mergesort_encom(sistema, encomendas, ide, esq, m);
  mergesort_encom(sistema, encomendas, ide, m + 1, dir);
  merge_encom(sistema, encomendas, ide, aux, esq, m, dir);
}

void merge_encom(produto sistema[], encomenda encomendas[], int ide, produto_enc aux[], int esq, int m, int dir)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > esq; i--)
  {
    aux[i - 1] = encomendas[ide].produto[i - 1];
  }

  for (j = m; j < dir; j++)
  {
    aux[(dir + m) - j] = encomendas[ide].produto[j + 1];
  }

  for (k = esq; k <= dir; k++)
  {
    if (strcmp(sistema[aux[j].idp].descricao, sistema[aux[i].idp].descricao) < 0)
    {
      {
        encomendas[ide].produto[k] = aux[j--];
      }
    }
    else
    {
      {
        encomendas[ide].produto[k] = aux[i++];
      }
    }

  }

}

void ordena_descr_encom(produto sistema[], encomenda encomendas[])
{
  int i;
  int ide;
  int nrprodutos;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_encomenda)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  nrprodutos = encomendas[ide].qntprods;
  mergesort_encom(sistema, encomendas, ide, 0, nrprodutos - 1);
  printf("Encomenda %d\n", ide);
  for (i = 0; i < nrprodutos; i++)
  {
    if (encomendas[ide].produto[i].qtd > 0)
    {
      {
        printf("* %s %d %d\n", sistema[encomendas[ide].produto[i].idp].descricao, sistema[encomendas[ide].produto[i].idp].preco, encomendas[ide].produto[i].qtd);
      }
    }
    else
    {
      
    }

  }

}

