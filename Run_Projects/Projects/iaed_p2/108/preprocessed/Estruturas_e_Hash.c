/*File generated by PreProcessor.py*/


#include "Estruturas_e_Hash.h"


int hash(char *nome, int max)
{
  int soma = 0;
  size_t i;
  int a = 1;
  for (i = 0; i < strlen(nome); i++)
  {
    soma += nome[i];
    a = ((a * 1023) + soma) % max;
  }

  return a % max;
}

void Equipainit(int *max_equipas, int m, p_equipa **p_tab_e)
{
  int i;
  *max_equipas = m;
  *p_tab_e = malloc((*max_equipas) * (sizeof(p_equipa)));
  for (i = 0; i < (*max_equipas); i++)
  {
    (*p_tab_e)[i] = 0;
  }

}

void Equipaexpande(int *max_equipas, int *n_equipas, p_equipa **p_tab_e);
void EquipaInsere(int *max_equipas, int *n_equipas, p_equipa equipa, p_equipa **p_tab_e)
{
  int i = hash(equipa->nome, *max_equipas);
  while ((*p_tab_e)[i] != 0)
  {
    i = (i + 1) % (*max_equipas);
  }

  (*p_tab_e)[i] = equipa;
  if (((*n_equipas)++) > ((*max_equipas) / 2))
  {
    Equipaexpande(max_equipas, n_equipas, p_tab_e);
  }
  else
  {
    
  }

}

void Equipaexpande(int *max_equipas, int *n_equipas, p_equipa **p_tab_e)
{
  int i;
  p_equipa *t = *p_tab_e;
  Equipainit(max_equipas, (*max_equipas) + (*max_equipas), p_tab_e);
  for (i = 0; i < ((*max_equipas) / 2); i++)
  {
    if (t[i] != 0)
    {
      *n_equipas = (*n_equipas) - 1;
      EquipaInsere(max_equipas, n_equipas, t[i], p_tab_e);
    }
    else
    {
      
    }

  }

  free(t);
}

p_equipa EquipaProcura(int *max_equipas, char *nome, p_equipa **p_tab_e)
{
  int key = hash(nome, *max_equipas);
  while ((*p_tab_e)[key] != 0)
  {
    if (strcmp((*p_tab_e)[key]->nome, nome) == 0)
    {
      return (*p_tab_e)[key];
    }
    else
    {
      key = (key + 1) % (*max_equipas);
    }

  }

  return 0;
}

void Jogoinit(int *max_jogos, int m, p_jogo **p_tab_j)
{
  int i;
  *max_jogos = m;
  *p_tab_j = malloc((*max_jogos) * (sizeof(p_jogo)));
  for (i = 0; i < (*max_jogos); i++)
  {
    (*p_tab_j)[i] = 0;
  }

}

void Jogoexpande(int *max_jogos, int *n_jogos, p_jogo **p_tab_j);
void JogoInsereHash(int *max_jogos, int *n_jogos, p_jogo jogo, p_jogo **p_tab_j)
{
  int i = hash(jogo->nome_j, *max_jogos);
  while ((*p_tab_j)[i] != 0)
  {
    i = (i + 1) % (*max_jogos);
  }

  (*p_tab_j)[i] = jogo;
  if (((*n_jogos)++) > ((*max_jogos) / 2))
  {
    Jogoexpande(max_jogos, n_jogos, p_tab_j);
  }
  else
  {
    
  }

}

void Jogoexpande(int *max_jogos, int *n_jogos, p_jogo **p_tab_j)
{
  int i;
  p_jogo *t = *p_tab_j;
  Jogoinit(max_jogos, (*max_jogos) + (*max_jogos), p_tab_j);
  for (i = 0; i < ((*max_jogos) / 2); i++)
  {
    if (t[i] != 0)
    {
      *n_jogos = (*n_jogos) - 1;
      JogoInsereHash(max_jogos, n_jogos, t[i], p_tab_j);
    }
    else
    {
      
    }

  }

  free(t);
}

p_jogo JogoProcura(int *max_jogos, char *nome, p_jogo **p_tab_j)
{
  int key = hash(nome, *max_jogos);
  while ((*p_tab_j)[key] != 0)
  {
    if (strcmp((*p_tab_j)[key]->nome_j, nome) == 0)
    {
      return (*p_tab_j)[key];
    }
    else
    {
      key = (key + 1) % (*max_jogos);
    }

  }

  return 0;
}

void JogoInsereLista(p_jogo jogo, link *head, link *tail)
{
  link new;
  if ((*head) == 0)
  {
    *head = malloc(sizeof(struct node));
    (*head)->next = 0;
    (*head)->prev = 0;
    (*head)->jogo = jogo;
  }
  else
  {
    if ((*tail) == 0)
    {
      *tail = malloc(sizeof(struct node));
      (*tail)->jogo = jogo;
      (*tail)->next = 0;
      (*tail)->prev = *head;
      (*head)->next = *tail;
    }
    else
    {
      new = malloc(sizeof(struct node));
      new->jogo = jogo;
      new->prev = *tail;
      new->next = 0;
      (*tail)->next = new;
      *tail = new;
    }

  }

}

void JogoApagaHash(p_jogo jogo, int *max_jogos, int *n_jogos, p_jogo **p_tab_j)
{
  int i;
  int key;
  p_jogo v;
  key = hash(jogo->nome_j, *max_jogos);
  while ((*p_tab_j)[key] != 0)
  {
    if ((*p_tab_j)[key] == jogo)
    {
      break;
    }
    else
    {
      key = (key + 1) % (*max_jogos);
    }

  }

  (*n_jogos)--;
  (*p_tab_j)[key] = 0;
  for (i = (key + 1) % (*max_jogos); (*p_tab_j)[i] != 0; i = (i + 1) % (*max_jogos), (*n_jogos)--)
  {
    v = (*p_tab_j)[i];
    (*p_tab_j)[i] = 0;
    JogoInsereHash(max_jogos, n_jogos, v, p_tab_j);
  }

}

void JogoApagaLista(p_jogo jogo, link *head, link *tail)
{
  link aux;
  if ((*head)->jogo == jogo)
  {
    aux = (*head)->next;
    free((*head)->jogo->nome_j);
    free((*head)->jogo);
    free(*head);
    *head = aux;
  }
  else
  {
    if ((*tail)->jogo == jogo)
    {
      aux = (*tail)->prev;
      free((*tail)->jogo->nome_j);
      free((*tail)->jogo);
      free(*tail);
      aux->next = 0;
      *tail = aux;
    }
    else
    {
      link t;
      t = *head;
      while (t->jogo != jogo)
      {
        t = t->next;
      }

      t->prev->next = t->next;
      t->next->prev = t->prev;
      free(t->jogo->nome_j);
      free(t->jogo);
      free(t);
    }

  }

}

