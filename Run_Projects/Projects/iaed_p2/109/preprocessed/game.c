/*File generated by PreProcessor.py*/


#include "game.h"


Game newGame(char *name, Team team1, Team team2, int score1, int score2)
{
  Game new = (Game) malloc(sizeof(struct game));
  new->name = strDup(name);
  new->team1 = team1;
  new->team2 = team2;
  new->score1 = score1;
  new->score2 = score2;
  return new;
}

GameLink newGameLink(Game game)
{
  GameLink new = (GameLink) malloc(sizeof(struct gameNode));
  new->game = game;
  new->prev = (new->next = 0);
  return new;
}

GameLink insertGameList(GameLink head, Game game)
{
  GameLink new = newGameLink(game);
  GameLink last;
  if (!head)
  {
    new->next = (new->prev = new);
    return new;
  }
  else
  {
    
  }

  last = head->prev;
  new->next = head;
  new->prev = last;
  last->next = (head->prev = new);
  return new;
}

GameLink removeGameList(GameLink head, char *name)
{
  GameLink aux = head;
  GameLink prev = 0;
  GameLink temp;
  while (strcmp(aux->game->name, name) != 0)
  {
    prev = aux;
    aux = aux->next;
  }

  if ((aux->next == head) && (!prev))
  {
    head = 0;
    freeGameNode(aux);
    return 0;
  }
  else
  {
    
  }

  if (aux == head)
  {
    prev = head->prev;
    head = head->next;
    prev->next = head;
    head->prev = prev;
  }
  else
  {
    if (aux->next == head)
    {
      prev->next = head;
      head->prev = prev;
    }
    else
    {
      temp = aux->next;
      prev->next = temp;
      temp->prev = prev;
    }

  }

  freeGameNode(aux);
  return head;
}

void freeGameNode(GameLink link)
{
  freeGame(link->game);
  free(link);
}

HashGame gHashInit(int max)
{
  int i;
  HashGame table = (HashGame) malloc(sizeof(struct hashGame));
  table->N = 0;
  table->M = max;
  table->games = (Game *) malloc(table->M * (sizeof(struct game)));
  for (i = 0; i < table->M; i++)
  {
    table->games[i] = 0;
  }

  return table;
}

HashGame gHashInsert(HashGame *table, Game game)
{
  int i = hash(game->name, (*table)->M);
  HashGame newtable;
  while ((*table)->games[i])
  {
    i = (i + 1) % (*table)->M;
  }

  (*table)->games[i] = game;
  (*table)->N++;
  if ((*table)->N >= ((*table)->M / 2))
  {
    newtable = gHashExpand(*table);
    return newtable;
  }
  else
  {
    
  }

  return *table;
}

HashGame gHashExpand(HashGame table)
{
  int i;
  HashGame newtable = gHashInit(table->M * 2);
  for (i = 0; i < table->M; i++)
  {
    if (table->games[i])
    {
      gHashInsert(&newtable, table->games[i]);
    }
    else
    {
      
    }

  }

  free(table->games);
  free(table);
  return newtable;
}

Game gHashSearch(HashGame table, char *name)
{
  int i = hash(name, table->M);
  while (table->games[i])
    if (strcmp(name, table->games[i]->name) == 0)
  {
    return table->games[i];
  }
  else
  {
    i = (i + 1) % table->M;
  }


  return 0;
}

void gHashDelete(HashGame table, char *name)
{
  int j;
  int i = hash(name, table->M);
  Game aux;
  while (table->games[i])
  {
    if (strcmp(name, table->games[i]->name) == 0)
    {
      break;
    }
    else
    {
      i = (i + 1) % table->M;
    }

  }

  if (!table->games[i])
  {
    return;
  }
  else
  {
    
  }

  table->games[i] = 0;
  table->N--;
  for (j = (i + 1) % table->M; table->games[j]; j = (j + 1) % table->M)
  {
    table->N--;
    aux = table->games[j];
    table->games[j] = 0;
    gHashInsert(&table, aux);
  }

}

void printGame(Game game)
{
  printf("%s %s %s %d %d\n", game->name, game->team1->name, game->team2->name, game->score1, game->score2);
}

void freeGame(Game game)
{
  free(game->name);
  free(game);
}

void gHashFree(HashGame table)
{
  int i;
  for (i = 0; i < table->M; i++)
  {
    if (table->games[i])
    {
      freeGame(table->games[i]);
    }
    else
    {
      
    }

  }

  free(table->games);
  free(table);
}

void gListFree(GameLink head)
{
  GameLink current = head;
  GameLink next;
  if (head)
  {
    do
    {
      next = current->next;
      free(current);
      current = next;
    }
    while (current != head);
  }
  else
  {
    
  }

}

