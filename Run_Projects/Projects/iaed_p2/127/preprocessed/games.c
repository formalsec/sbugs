/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "games.h"


game *create_game(char *name, char *t1, char *t2, int sc1, int sc2)
{
  game *new_game;
  new_game = malloc(sizeof(game));
  new_game->score_t1 = sc1;
  new_game->score_t2 = sc2;
  new_game->name = malloc((sizeof(char)) * (strlen(name) + 1));
  new_game->team1 = t1;
  new_game->team2 = t2;
  strcpy(new_game->name, name);
  return new_game;
}

link push(link *borders, game *g)
{
  link new_node;
  new_node = malloc(sizeof(struct node));
  new_node->game = g;
  new_node->next = *borders;
  new_node->prev = 0;
  if ((*borders) == 0)
  {
    *(borders + 1) = new_node;
  }
  else
  {
    (*borders)->prev = new_node;
  }

  *borders = new_node;
  return new_node;
}

void delete_el(link *borders, link g)
{
  if (g == (*borders))
  {
    if (g == (*(borders + 1)))
    {
      *borders = 0;
      *(borders + 1) = 0;
    }
    else
    {
      *borders = g->next;
      (*borders)->prev = 0;
    }

  }
  else
  {
    if (g == (*(borders + 1)))
    {
      *(borders + 1) = g->prev;
      (*(borders + 1))->next = 0;
    }
    else
    {
      g->prev->next = g->next;
      g->next->prev = g->prev;
    }

  }

  free(g->game->name);
  free(g->game);
  free(g);
}

long int table_hash(char *name, long int m)
{
  long int hash;
  long int n1 = 26453;
  long int n2 = 12532;
  for (hash = 0; (*name) != '\0'; name++, n1 = (n1 * n2) % (m - 1))
  {
    hash = ((n1 * hash) + (*name)) % m;
  }

  return hash;
}

void table_g_init(link *game_t, long int m)
{
  long int i;
  for (i = 0; i < m; i++)
    *(game_t + i) = 0;

}

link *expand_g(link *game_tab, long int *max_len)
{
  long int i;
  long int old_m;
  link *new_tab = malloc(((sizeof(link)) * (*max_len)) * 2);
  old_m = *max_len;
  *max_len = (*max_len) * 2;
  table_g_init(new_tab, *max_len);
  for (i = 0; i < old_m; i++)
    if ((*(game_tab + i)) != 0)
  {
    add_game_to_table(new_tab, *(game_tab + i), max_len);
    (*(max_len + 1))--;
  }
  else
  {
    
  }


  free(game_tab);
  return new_tab;
}

link *add_game_to_table(link *game_t, link g, long int *max_len)
{
  long int m = *max_len;
  long int hash;
  hash = table_hash(g->game->name, m);
  while ((*(game_t + hash)) != 0)
    hash = (hash + 1) % m;

  *(game_t + hash) = g;
  (*(max_len + 1))++;
  if ((*(max_len + 1)) > (m / 2))
  {
    return expand_g(game_t, max_len);
  }
  else
  {
    return game_t;
  }

}

void rearrange_tab_g(link *game_tab, long int pointer, long int *max_len)
{
  long int i;
  long int m = *max_len;
  link aux;
  for (i = (pointer + 1) % m; (*(game_tab + i)) != 0; i = (i + 1) % m)
  {
    aux = *(game_tab + i);
    *(game_tab + i) = 0;
    add_game_to_table(game_tab, aux, max_len);
    (*(max_len + 1))--;
  }

}

long int search_aux(char *game_name, link *game_tab, long int m)
{
  long int i = table_hash(game_name, m);
  while ((*(game_tab + i)) != 0)
  {
    if (strcmp(game_name, (*(game_tab + i))->game->name) == 0)
    {
      return i;
    }
    else
    {
      i = (i + 1) % m;
    }

  }

  return -1;
}

link search_g(char *game_name, link *game_tab, long int m)
{
  long int node_ptr;
  node_ptr = search_aux(game_name, game_tab, m);
  if (node_ptr != (-1))
  {
    return *(game_tab + node_ptr);
  }
  else
  {
    return 0;
  }

}

void destroy_game_st(link *borders)
{
  link t = *borders;
  link aux;
  while (t != 0)
  {
    aux = t->next;
    free(t->game->name);
    free(t->game);
    free(t);
    t = aux;
  }

}

