/*File generated by PreProcessor.py*/


#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct entry_e
{
  char *nome;
  int vitorias;
  struct entry_e *next;
} entry_e;
typedef struct entry_j
{
  char *nome;
  char *equipa1;
  char *equipa2;
  int score1;
  int score2;
  unsigned long jogo_id;
  struct entry_j *next;
} entry_j;
typedef struct 
{
  entry_e **entries;
} ht_e;
typedef struct 
{
  entry_j **entries;
} ht_j;
unsigned int hash(const char *key);
static int myCompare(const void *a, const void *b);
void sort(char *arr[], int n);
entry_j *ht_pair_j(const char *nome, const char *equipa1, const char *equipa2, const int score1, const int score2, unsigned long jogo_id);
entry_e *ht_pair_e(const char *equipa, const int vitorias);
ht_j *ht_create_j(void);
ht_e *ht_create_e(void);
void ht_set_j(ht_j *hashtable, const char *nome, const char *equipa1, const char *equipa2, const int score1, const int score2, unsigned long jogo_id, int rnl);
void ht_set_e(ht_e *hashtable, const char *nome, const int vitorias, int rnl);
entry_j *ht_get_j(ht_j *hashtable, const char *nome);
entry_e *ht_get_e(ht_e *hashtable, const char *nome);
void ht_del_j(ht_j *hashtable, const char *nome);
void ht_del_e(ht_e *hashtable, const char *nome);
void ht_dump_j(ht_j *hashtable, int rnl);
void delete_all_j(ht_j *hashtable);
void delete_all_e(ht_e *hashtable);
unsigned int hash(const char *key)
{
  unsigned long int value = 0;
  unsigned int i = 0;
  unsigned int key_len = strlen(key);
  for (; i < key_len; ++i)
  {
    value = (value * 37) + key[i];
  }

  value = value % 10000;
  return value;
}

static int myCompare(const void *a, const void *b)
{
  return strcmp(*((const char **) a), *((const char **) b));
}

void sort(char *arr[], int n)
{
  qsort(arr, n, sizeof(const char *), myCompare);
}

entry_j *ht_pair_j(const char *nome, const char *equipa1, const char *equipa2, const int score1, const int score2, unsigned long jogo_id)
{
  entry_j *entry = malloc((sizeof(entry_j)) * 1);
  entry->nome = malloc(strlen(nome) + 1);
  entry->equipa1 = malloc(strlen(equipa1) + 1);
  entry->equipa2 = malloc(strlen(equipa2) + 1);
  entry->jogo_id = jogo_id;
  strcpy(entry->nome, nome);
  strcpy(entry->equipa1, equipa1);
  strcpy(entry->equipa2, equipa2);
  entry->score1 = score1;
  entry->score2 = score2;
  entry->next = 0;
  return entry;
}

entry_e *ht_pair_e(const char *equipa, const int vitorias)
{
  entry_e *entry = malloc((sizeof(entry_e)) * 1);
  entry->nome = malloc(strlen(equipa) + 1);
  entry->vitorias = vitorias;
  strcpy(entry->nome, equipa);
  entry->next = 0;
  return entry;
}

ht_j *ht_create_j(void)
{
  int i = 0;
  ht_j *hashtable = malloc((sizeof(ht_j)) * 1);
  hashtable->entries = malloc((sizeof(entry_j *)) * 10000);
  for (; i < 10000; ++i)
  {
    hashtable->entries[i] = 0;
  }

  return hashtable;
}

ht_e *ht_create_e(void)
{
  int i = 0;
  ht_e *hashtable = malloc((sizeof(ht_e)) * 1);
  hashtable->entries = malloc((sizeof(entry_e *)) * 10000);
  for (; i < 10000; ++i)
  {
    hashtable->entries[i] = 0;
  }

  return hashtable;
}

void ht_set_j(ht_j *hashtable, const char *nome, const char *equipa1, const char *equipa2, const int score1, const int score2, unsigned long jogo_id, int rnl)
{
  unsigned int slot = hash(nome);
  entry_j *entry = hashtable->entries[slot];
  entry_j *prev;
  if (entry == 0)
  {
    hashtable->entries[slot] = ht_pair_j(nome, equipa1, equipa2, score1, score2, jogo_id);
    return;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->nome, nome) == 0)
    {
      printf("%d Jogo existente.\n", rnl);
      return;
    }
    else
    {
      
    }

    prev = entry;
    entry = prev->next;
  }

  prev->next = ht_pair_j(nome, equipa1, equipa2, score1, score2, jogo_id);
}

void ht_set_e(ht_e *hashtable, const char *nome, const int vitorias, int rnl)
{
  unsigned int slot = hash(nome);
  entry_e *entry = hashtable->entries[slot];
  entry_e *prev;
  if (entry == 0)
  {
    hashtable->entries[slot] = ht_pair_e(nome, vitorias);
    return;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->nome, nome) == 0)
    {
      printf("%d Equipa existente.\n", rnl);
      return;
    }
    else
    {
      
    }

    prev = entry;
    entry = prev->next;
  }

  prev->next = ht_pair_e(nome, vitorias);
}

entry_j *ht_get_j(ht_j *hashtable, const char *nome)
{
  unsigned int slot = hash(nome);
  entry_j *entry = hashtable->entries[slot];
  if (entry == 0)
  {
    return 0;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->nome, nome) == 0)
    {
      return entry;
    }
    else
    {
      
    }

    entry = entry->next;
  }

  return 0;
}

entry_e *ht_get_e(ht_e *hashtable, const char *nome)
{
  unsigned int slot = hash(nome);
  entry_e *entry = hashtable->entries[slot];
  if (entry == 0)
  {
    return 0;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->nome, nome) == 0)
    {
      return entry;
    }
    else
    {
      
    }

    entry = entry->next;
  }

  return 0;
}

void ht_del_j(ht_j *hashtable, const char *nome)
{
  unsigned int bucket = hash(nome);
  entry_j *entry = hashtable->entries[bucket];
  entry_j *prev;
  int idx = 0;
  if (entry == 0)
  {
    return;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->nome, nome) == 0)
    {
      if ((entry->next == 0) && (idx == 0))
      {
        hashtable->entries[bucket] = 0;
      }
      else
      {
        
      }

      if ((entry->next != 0) && (idx == 0))
      {
        hashtable->entries[bucket] = entry->next;
      }
      else
      {
        
      }

      if ((entry->next == 0) && (idx != 0))
      {
        prev->next = 0;
      }
      else
      {
        
      }

      if ((entry->next != 0) && (idx != 0))
      {
        prev->next = entry->next;
      }
      else
      {
        
      }

      free(entry->nome);
      free(entry->equipa1);
      free(entry->equipa2);
      free(entry);
      return;
    }
    else
    {
      
    }

    prev = entry;
    entry = prev->next;
    ++idx;
  }

}

void ht_del_e(ht_e *hashtable, const char *nome)
{
  unsigned int bucket = hash(nome);
  entry_e *entry = hashtable->entries[bucket];
  entry_e *prev;
  int idx = 0;
  if (entry == 0)
  {
    return;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->nome, nome) == 0)
    {
      if ((entry->next == 0) && (idx == 0))
      {
        hashtable->entries[bucket] = 0;
      }
      else
      {
        
      }

      if ((entry->next != 0) && (idx == 0))
      {
        hashtable->entries[bucket] = entry->next;
      }
      else
      {
        
      }

      if ((entry->next == 0) && (idx != 0))
      {
        prev->next = 0;
      }
      else
      {
        
      }

      if ((entry->next != 0) && (idx != 0))
      {
        prev->next = entry->next;
      }
      else
      {
        
      }

      free(entry->nome);
      free(entry);
      return;
    }
    else
    {
      
    }

    prev = entry;
    entry = prev->next;
    ++idx;
  }

}

void ht_dump_j(ht_j *hashtable, int rnl)
{
  int i;
  int d;
  struct entry_j **lista_jogos;
  struct entry_j *swap;
  struct entry_j *entry;
  int total_jogos = 0;
  int index = 0;
  for (i = 0; i < 10000; ++i)
  {
    entry = hashtable->entries[i];
    if (entry == 0)
    {
      continue;
    }
    else
    {
      
    }

    for (;;)
    {
      total_jogos++;
      if (entry->next == 0)
      {
        break;
      }
      else
      {
        
      }

      entry = entry->next;
    }

  }

  lista_jogos = malloc((total_jogos + 1) * (sizeof(struct entry_j *)));
  for (i = 0; i < 10000; ++i)
  {
    entry = hashtable->entries[i];
    if (entry == 0)
    {
      continue;
    }
    else
    {
      
    }

    for (;;)
    {
      lista_jogos[index] = (entry_j *) malloc(sizeof(entry_j));
      lista_jogos[index]->equipa1 = (char *) malloc((strlen(entry->equipa1) + 1) * (sizeof(char)));
      lista_jogos[index]->equipa2 = (char *) malloc((strlen(entry->equipa2) + 1) * (sizeof(char)));
      lista_jogos[index]->nome = (char *) malloc((strlen(entry->nome) + 1) * (sizeof(char)));
      strcpy((char *) lista_jogos[index]->nome, entry->nome);
      strcpy((char *) lista_jogos[index]->equipa1, entry->equipa1);
      strcpy((char *) lista_jogos[index]->equipa2, entry->equipa2);
      lista_jogos[index]->score1 = entry->score1;
      lista_jogos[index]->score2 = entry->score2;
      lista_jogos[index]->jogo_id = entry->jogo_id;
      index++;
      if (entry->next == 0)
      {
        break;
      }
      else
      {
        
      }

      entry = entry->next;
    }

  }

  for (i = 0; i < (total_jogos - 1); i++)
  {
    for (d = 0; d < ((total_jogos - i) - 1); d++)
    {
      if (lista_jogos[d]->jogo_id > lista_jogos[d + 1]->jogo_id)
      {
        swap = lista_jogos[d];
        lista_jogos[d] = lista_jogos[d + 1];
        lista_jogos[d + 1] = swap;
      }
      else
      {
        
      }

    }

  }

  for (i = 0; i < total_jogos; i++)
  {
    printf("%d %s %s %s %d %d\n", rnl, lista_jogos[i]->nome, lista_jogos[i]->equipa1, lista_jogos[i]->equipa2, lista_jogos[i]->score1, lista_jogos[i]->score2);
    free(lista_jogos[i]->equipa1);
    free(lista_jogos[i]->equipa2);
    free(lista_jogos[i]->nome);
    free(lista_jogos[i]);
  }

  free(lista_jogos);
  return;
}

void delete_all_j(ht_j *hashtable)
{
  int i;
  entry_j *current;
  for (i = 0; i < 10000; ++i)
  {
    entry_j *entry = hashtable->entries[i];
    if (entry == 0)
    {
      continue;
    }
    else
    {
      
    }

    for (;;)
    {
      current = entry;
      entry = entry->next;
      free(current->nome);
      free(current->equipa1);
      free(current->equipa2);
      free(current);
      if (entry == 0)
      {
        break;
      }
      else
      {
        
      }

    }

  }

}

void delete_all_e(ht_e *hashtable)
{
  int i;
  entry_e *current;
  for (i = 0; i < 10000; ++i)
  {
    entry_e *entry = hashtable->entries[i];
    if (entry == 0)
    {
      continue;
    }
    else
    {
      
    }

    for (;;)
    {
      current = entry;
      entry = entry->next;
      free(current->nome);
      free(current);
      if (entry == 0)
      {
        break;
      }
      else
      {
        
      }

    }

  }

}

int main()
{
  ht_j *htj = ht_create_j();
  ht_e *hte = ht_create_e();
  int trabalha = 1;
  int rnl = 0;
  int c;
  int i;
  int index;
  int n_equipas;
  char **strings = 0;
  char b[1024];
  char h[1024];
  char j[1024];
  int score1 = 0;
  int score2 = 0;
  unsigned long jogo_id = 0;
  entry_e *current_e;
  entry_e *entry_equipa;
  entry_j *current_j;
  while (trabalha)
  {
    switch (c = getchar())
    {
      case 'a':
        rnl++;
        for (int b_index = 0; b_index < 10; b_index++)
      {
        b[b_index] = new_sym_var(sizeof(char) * 8);
      }

        b[10 - 1] = '\0';
        for (int h_index = 0; h_index < 10; h_index++)
      {
        h[h_index] = new_sym_var(sizeof(char) * 8);
      }

        h[10 - 1] = '\0';
        for (int j_index = 0; j_index < 10; j_index++)
      {
        j[j_index] = new_sym_var(sizeof(char) * 8);
      }

        j[10 - 1] = '\0';
        score1 = new_sym_var(sizeof(int) * 8);
        score2 = new_sym_var(sizeof(int) * 8);
        if (ht_get_j(htj, b) == 0)
      {
        if ((ht_get_e(hte, h) != 0) && (ht_get_e(hte, j) != 0))
        {
          ht_set_j(htj, b, h, j, score1, score2, jogo_id, rnl);
          jogo_id++;
          if (score1 > score2)
          {
            current_e = ht_get_e(hte, h);
            current_e->vitorias++;
          }
          else
          {
            
          }

          if (score1 < score2)
          {
            current_e = ht_get_e(hte, j);
            current_e->vitorias++;
          }
          else
          {
            
          }

          break;
        }
        else
        {
          printf("%d Equipa inexistente.\n", rnl);
        }

      }
      else
      {
        printf("%d Jogo existente.\n", rnl);
      }

        break;

      case 'A':
        rnl++;
        for (int b_index = 0; b_index < 10; b_index++)
      {
        b[b_index] = new_sym_var(sizeof(char) * 8);
      }

        b[10 - 1] = '\0';
        if (ht_get_e(hte, b) == 0)
      {
        ht_set_e(hte, b, 0, rnl);
        break;
      }
      else
      {
        printf("%d Equipa existente.\n", rnl);
      }

        break;

      case 'l':
        rnl++;
        ht_dump_j(htj, rnl);
        break;

      case 'p':
        rnl++;
        for (int b_index = 0; b_index < 10; b_index++)
      {
        b[b_index] = new_sym_var(sizeof(char) * 8);
      }

        b[10 - 1] = '\0';
        current_j = ht_get_j(htj, b);
        if (current_j != 0)
      {
        printf("%d %s %s %s %d %d\n", rnl, current_j->nome, current_j->equipa1, current_j->equipa2, current_j->score1, current_j->score2);
      }
      else
      {
        printf("%d Jogo inexistente.\n", rnl);
      }

        break;

      case 'r':
        rnl++;
        for (int b_index = 0; b_index < 10; b_index++)
      {
        b[b_index] = new_sym_var(sizeof(char) * 8);
      }

        b[10 - 1] = '\0';
        current_j = ht_get_j(htj, b);
        if (current_j != 0)
      {
        if (current_j->score1 > current_j->score2)
        {
          current_e = ht_get_e(hte, current_j->equipa1);
          current_e->vitorias--;
        }
        else
        {
          
        }

        if (current_j->score1 < current_j->score2)
        {
          current_e = ht_get_e(hte, current_j->equipa2);
          current_e->vitorias--;
        }
        else
        {
          
        }

        ht_del_j(htj, b);
        break;
      }
      else
      {
        printf("%d Jogo inexistente.\n", rnl);
      }

        break;

      case 's':
        rnl++;
        for (int b_index = 0; b_index < 10; b_index++)
      {
        b[b_index] = new_sym_var(sizeof(char) * 8);
      }

        b[10 - 1] = '\0';
        score1 = new_sym_var(sizeof(int) * 8);
        score2 = new_sym_var(sizeof(int) * 8);
        current_j = ht_get_j(htj, b);
        if (current_j != 0)
      {
        if (current_j->score1 > current_j->score2)
        {
          current_e = ht_get_e(hte, current_j->equipa1);
          current_e->vitorias--;
        }
        else
        {
          
        }

        if (current_j->score1 < current_j->score2)
        {
          current_e = ht_get_e(hte, current_j->equipa2);
          current_e->vitorias--;
        }
        else
        {
          
        }

        current_j->score1 = score1;
        current_j->score2 = score2;
        if (current_j->score1 > current_j->score2)
        {
          current_e = ht_get_e(hte, current_j->equipa1);
          current_e->vitorias++;
        }
        else
        {
          
        }

        if (current_j->score1 < current_j->score2)
        {
          current_e = ht_get_e(hte, current_j->equipa2);
          current_e->vitorias++;
        }
        else
        {
          
        }

        break;
      }
      else
      {
        printf("%d Jogo inexistente.\n", rnl);
      }

        break;

      case 'P':
        rnl++;
        for (int b_index = 0; b_index < 10; b_index++)
      {
        b[b_index] = new_sym_var(sizeof(char) * 8);
      }

        b[10 - 1] = '\0';
        current_e = ht_get_e(hte, b);
        if (current_e != 0)
      {
        printf("%d %s %d\n", rnl, current_e->nome, current_e->vitorias);
      }
      else
      {
        printf("%d Equipa inexistente.\n", rnl);
      }

        break;

      case 'g':
        rnl++;
        c = 0;
        index = 0;
        n_equipas = 0;
        for (i = 0; i < 10000; ++i)
      {
        entry_equipa = hte->entries[i];
        if (entry_equipa == 0)
        {
          continue;
        }
        else
        {
          
        }

        for (;;)
        {
          if (entry_equipa->vitorias > c)
          {
            c = entry_equipa->vitorias;
            n_equipas = 1;
          }
          else
          {
            if (entry_equipa->vitorias == c)
            {
              n_equipas++;
            }
            else
            {
              
            }

          }

          if (entry_equipa->next == 0)
          {
            break;
          }
          else
          {
            
          }

          entry_equipa = entry_equipa->next;
        }

      }

        if (n_equipas == 0)
      {
        break;
      }
      else
      {
        
      }

        printf("%d Melhores %d\n", rnl, c);
        strings = malloc((n_equipas + 1) * (sizeof(char *)));
        for (i = 0; i < 10000; ++i)
      {
        entry_equipa = hte->entries[i];
        if (entry_equipa == 0)
        {
          continue;
        }
        else
        {
          
        }

        for (;;)
        {
          if (entry_equipa->vitorias == c)
          {
            strings[index] = (char *) malloc((strlen(entry_equipa->nome) + 1) * (sizeof(char)));
            strcpy((char *) strings[index], entry_equipa->nome);
            index++;
          }
          else
          {
            
          }

          if (entry_equipa->next == 0)
          {
            break;
          }
          else
          {
            
          }

          entry_equipa = entry_equipa->next;
        }

      }

        sort(strings, n_equipas);
        for (i = 0; i < index; i++)
      {
        printf("%d * %s \n", rnl, strings[i]);
        free(strings[i]);
      }

        free(strings);
        break;

      case 'x':
        trabalha = 0;
        break;

      default:
        break;

    }

  }

  delete_all_e(hte);
  delete_all_j(htj);
  free(hte->entries);
  free(htj->entries);
  free(htj);
  free(hte);
  return 0;
}

