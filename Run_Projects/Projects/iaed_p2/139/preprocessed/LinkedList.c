/*File generated by PreProcessor.py*/


#include "LinkedList.h"


LinkedList list_init()
{
  LinkedList lista;
  lista = malloc(sizeof(struct MasterNode));
  lista->load = 0;
  lista->head = 0;
  lista->tail = 0;
  return lista;
}

Link add_node_before(Link next, Item item)
{
  Link new;
  new = malloc(sizeof(struct Node));
  new->item = item;
  new->next = next;
  return new;
}

Link add_node_after(Link ant, Item item)
{
  Link new;
  Link aux;
  if (ant == 0)
  {
    return add_node_before(ant, item);
  }
  else
  {
    
  }

  new = malloc(sizeof(struct Node));
  new->item = item;
  aux = ant->next;
  new->next = aux;
  ant->next = new;
  return new;
}

void delete_node(Link node)
{
  deleteItem(get_item(node));
  free(node);
}

int is_empty(LinkedList lista)
{
  return lista->load == 0;
}

Item get_item(Link node)
{
  if (node != 0)
  {
    return node->item;
  }
  else
  {
    
  }

  return 0;
}

Item get_first_item(LinkedList lista)
{
  return get_item(lista->head);
}

Link search_list(LinkedList lista, Key key)
{
  Link current;
  for (current = lista->head; current; current = current->next)
  {
    if (strcmp(get_item(current)->value, key) == 0)
    {
      return current;
    }
    else
    {
      
    }

  }

  return 0;
}

void push(LinkedList lista, Item i)
{
  Link newNode;
  newNode = add_node_before(lista->head, i);
  lista->head = newNode;
  if (lista->tail == 0)
  {
    lista->tail = newNode;
  }
  else
  {
    
  }

  lista->load++;
}

void append(LinkedList lista, Item i)
{
  Link newNode;
  newNode = add_node_after(lista->tail, i);
  lista->tail = newNode;
  if (lista->head == 0)
  {
    lista->head = newNode;
  }
  else
  {
    
  }

  lista->load++;
}

void insertInOrder(LinkedList lista, Item i)
{
  Link current;
  Link new;
  Link prev;
  if (is_empty(lista))
  {
    append(lista, i);
    return;
  }
  else
  {
    
  }

  for (current = lista->head, prev = 0; current && (strcmp(get_item(current)->value, i->value) < 0); prev = current, current = current->next)
    ;

  if (current == 0)
  {
    append(lista, i);
    return;
  }
  else
  {
    
  }

  new = malloc(sizeof(struct Node));
  new->item = i;
  new->next = current;
  if (prev)
  {
    prev->next = new;
  }
  else
  {
    lista->head = new;
  }

  lista->load++;
}

void pop(LinkedList lista)
{
  Link aux;
  if ((lista->head == 0) || is_empty(lista))
  {
    return;
  }
  else
  {
    
  }

  aux = lista->head;
  lista->head = aux->next;
  delete_node(aux);
  lista->load--;
}

void remove_element(LinkedList lista, Key k)
{
  Link current;
  Link prev;
  for (current = lista->head, prev = 0; current; prev = current, current = current->next)
  {
    if (strcmp(k, current->item->value) == 0)
    {
      if (current == lista->head)
      {
        lista->head = current->next;
      }
      else
      {
        prev->next = current->next;
      }

      delete_node(current);
      lista->load--;
      break;
    }
    else
    {
      
    }

  }

}

void destroy_list_nodes(LinkedList lista)
{
  Link current;
  Link aux;
  if (!lista)
  {
    return;
  }
  else
  {
    
  }

  if (!is_empty(lista))
  {
    for (current = lista->head, aux = lista->head->next; current; aux = current->next, free(current), current = aux)
      ;

  }
  else
  {
    
  }

  free(lista);
}

void destroy_list_node(LinkedList lista, Key nome)
{
  Link current;
  Link prev;
  for (current = lista->head, prev = 0; current; prev = current, current = current->next)
  {
    if (strcmp(nome, current->item->value) == 0)
    {
      if (current == lista->head)
      {
        lista->head = current->next;
      }
      else
      {
        prev->next = current->next;
      }

      free(current);
      lista->load--;
      if (current == lista->tail)
      {
        lista->tail = lista->head;
      }
      else
      {
        
      }

      break;
    }
    else
    {
      
    }

  }

}

void destroy_list(LinkedList lista)
{
  Link current;
  Link aux;
  if (lista == 0)
  {
    return;
  }
  else
  {
    
  }

  if (lista->load != 0)
  {
    for (current = lista->head, aux = lista->head->next; current; aux = current->next, delete_node(current), current = aux)
      ;

  }
  else
  {
    
  }

  free(lista);
}

