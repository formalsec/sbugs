/*File generated by PreProcessor.py*/

#ifndef FUNCOES_H
#define FUNCOES_H

#include "hash_tables.h"


void executa_A(hash_table_equipa *hash_table_equipa_p, lista *Equipa_lista, int NL)
{
  char buffer[1023];
  str_node *Test;
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  Test = hash_table_lookup_equipa(hash_table_equipa_p, buffer);
  if (Test == 0)
  {
    struct str_node *Temp = 0;
    Temp = (struct str_node *) malloc(sizeof(struct str_node));
    Temp->equipa.nome = (char *) malloc((sizeof(char)) * (strlen(buffer) + 1));
    strcpy(Temp->equipa.nome, buffer);
    if (Equipa_lista->head == 0)
    {
      Temp->previous = 0;
      Equipa_lista->last = Temp;
    }
    else
    {
      Equipa_lista->head->next = Temp;
      Temp->previous = Equipa_lista->head;
    }

    Temp->next = 0;
    Temp->equipa.score = 0;
    Equipa_lista->head = Temp;
    hash_table_equipa_insert(hash_table_equipa_p, Temp, Equipa_lista);
  }
  else
  {
    printf("%d Equipa existente.\n", NL);
  }

}

void executa_P(hash_table_equipa *hash_table_equipa_p, int NL)
{
  char buffer[1023];
  str_node *Test;
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  Test = hash_table_lookup_equipa(hash_table_equipa_p, buffer);
  if (Test != 0)
  {
    printf("%d %s %d\n", NL, Test->equipa.nome, Test->equipa.score);
  }
  else
  {
    printf("%d Equipa inexistente.\n", NL);
  }

}

void executa_a(hash_table_equipa *hash_table_equipa_p, hash_table_jogo *hash_table_jogo_p, lista2 *Jogos_lista_pointer, int NL)
{
  char buffer_nome[1023];
  char buffer_equipa1[1023];
  char buffer_equipa2[1023];
  int score1;
  int score2;
  str_node_jogo *Test1;
  str_node *point1;
  str_node *point2;
  for (int buffer_nome_index = 0; buffer_nome_index < 10; buffer_nome_index++)
  {
    buffer_nome[buffer_nome_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer_nome[10 - 1] = '\0';
  for (int buffer_equipa1_index = 0; buffer_equipa1_index < 10; buffer_equipa1_index++)
  {
    buffer_equipa1[buffer_equipa1_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer_equipa1[10 - 1] = '\0';
  for (int buffer_equipa2_index = 0; buffer_equipa2_index < 10; buffer_equipa2_index++)
  {
    buffer_equipa2[buffer_equipa2_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer_equipa2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  Test1 = hash_table_jogo_lookup(hash_table_jogo_p, buffer_nome);
  point1 = hash_table_lookup_equipa(hash_table_equipa_p, buffer_equipa1);
  point2 = hash_table_lookup_equipa(hash_table_equipa_p, buffer_equipa2);
  if (Test1 == 0)
  {
    if ((point1 != 0) && (point2 != 0))
    {
      struct str_node_jogo *Temp = 0;
      Temp = (struct str_node_jogo *) malloc(sizeof(struct str_node_jogo));
      Temp->jogo.nome = (char *) malloc((sizeof(char)) * (strlen(buffer_nome) + 1));
      strcpy(Temp->jogo.nome, buffer_nome);
      Temp->jogo.equipa1 = point1;
      Temp->jogo.equipa2 = point2;
      if ((score1 - score2) < 0)
      {
        point2->equipa.score = point2->equipa.score + 1;
      }
      else
      {
        if ((score1 - score2) > 0)
        {
          point1->equipa.score = point1->equipa.score + 1;
        }
        else
        {
          
        }

      }

      Temp->jogo.score[0] = score1;
      Temp->jogo.score[1] = score2;
      if (Jogos_lista_pointer->last == 0)
      {
        Temp->previous = 0;
        Jogos_lista_pointer->last = Temp;
      }
      else
      {
        Jogos_lista_pointer->head->next = Temp;
        Temp->previous = Jogos_lista_pointer->head;
      }

      Temp->next = 0;
      Jogos_lista_pointer->head = Temp;
      hash_table_jogo_insert(hash_table_jogo_p, Temp, Jogos_lista_pointer);
    }
    else
    {
      printf("%d Equipa inexistente.\n", NL);
    }

  }
  else
  {
    printf("%d Jogo existente.\n", NL);
  }

}

void executa_p(hash_table_jogo *hash_table_jogo_p, int NL)
{
  char buffer[1023];
  str_node_jogo *Test;
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  Test = hash_table_jogo_lookup(hash_table_jogo_p, buffer);
  if (Test != 0)
  {
    printf("%d %s %s %s %d %d\n", NL, Test->jogo.nome, Test->jogo.equipa1->equipa.nome, Test->jogo.equipa2->equipa.nome, Test->jogo.score[0], Test->jogo.score[1]);
  }
  else
  {
    printf("%d Jogo inexistente.\n", NL);
  }

}

void executa_l(lista2 *Jogos_lista_pointer, int NL)
{
  str_node_jogo *Temp;
  Temp = Jogos_lista_pointer->last;
  while (Temp != 0)
  {
    printf("%d %s %s %s %d %d\n", NL, Temp->jogo.nome, Temp->jogo.equipa1->equipa.nome, Temp->jogo.equipa2->equipa.nome, Temp->jogo.score[0], Temp->jogo.score[1]);
    Temp = Temp->next;
  }

}

void executa_s(hash_table_jogo *hash_table_jogo_p, int NL)
{
  char buffer[1023];
  int novo_scor1;
  int novo_scor2;
  str_node_jogo *Temp;
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  novo_scor1 = new_sym_var(sizeof(int) * 8);
  novo_scor2 = new_sym_var(sizeof(int) * 8);
  Temp = hash_table_jogo_lookup(hash_table_jogo_p, buffer);
  if (Temp != 0)
  {
    if ((Temp->jogo.score[0] - Temp->jogo.score[1]) < 0)
    {
      Temp->jogo.equipa2->equipa.score = Temp->jogo.equipa2->equipa.score - 1;
    }
    else
    {
      if ((Temp->jogo.score[0] - Temp->jogo.score[1]) > 0)
      {
        Temp->jogo.equipa1->equipa.score = Temp->jogo.equipa1->equipa.score - 1;
      }
      else
      {
        
      }

    }

    if ((novo_scor1 - novo_scor2) < 0)
    {
      Temp->jogo.equipa2->equipa.score = Temp->jogo.equipa2->equipa.score + 1;
    }
    else
    {
      if ((novo_scor1 - novo_scor2) > 0)
      {
        Temp->jogo.equipa1->equipa.score = Temp->jogo.equipa1->equipa.score + 1;
      }
      else
      {
        
      }

    }

    Temp->jogo.score[0] = novo_scor1;
    Temp->jogo.score[1] = novo_scor2;
  }
  else
  {
    printf("%d Jogo inexistente.\n", NL);
  }

}

void executa_r(hash_table_jogo *hash_table_jogo_p, lista2 *Jogos_lista, int NL)
{
  char buffer[1023];
  int headd = 0;
  int lastt = 0;
  str_node_jogo *Temp;
  str_node_jogo *prev = 0;
  str_node_jogo *other = 0;
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  Temp = hash_table_jogo_lookup(hash_table_jogo_p, buffer);
  if (Temp != 0)
  {
    int index;
    index = hash(buffer, hash_table_jogo_p->M);
    other = hash_table_jogo_p->entries[index];
    while (strcmp(other->jogo.nome, buffer) != 0)
    {
      prev = other;
      other = other->jogo.next;
    }

    if (prev == 0)
    {
      hash_table_jogo_p->entries[index] = Temp->jogo.next;
    }
    else
    {
      prev->jogo.next = Temp->jogo.next;
    }

    if (Temp->next != 0)
    {
      Temp->next->previous = Temp->previous;
      lastt = 1;
    }
    else
    {
      
    }

    if (Temp->previous != 0)
    {
      Temp->previous->next = Temp->next;
      headd = 1;
    }
    else
    {
      
    }

    if ((lastt == 0) && (headd == 0))
    {
      Jogos_lista->head = 0, Jogos_lista->last = 0;
    }
    else
    {
      if (headd == 0)
      {
        Jogos_lista->last = Temp->next;
      }
      else
      {
        if (lastt == 0)
        {
          Jogos_lista->head = Temp->previous;
        }
        else
        {
          
        }

      }

    }

    if ((Temp->jogo.score[0] - Temp->jogo.score[1]) < 0)
    {
      Temp->jogo.equipa2->equipa.score = Temp->jogo.equipa2->equipa.score - 1;
    }
    else
    {
      if ((Temp->jogo.score[0] - Temp->jogo.score[1]) > 0)
      {
        Temp->jogo.equipa1->equipa.score = Temp->jogo.equipa1->equipa.score - 1;
      }
      else
      {
        
      }

    }

    free(Temp->jogo.nome);
    free(Temp);
  }
  else
  {
    printf("%d Jogo inexistente.\n", NL);
  }

}

int comparador(const void *a, const void *b)
{
  equipa *equipaA = (equipa *) a;
  equipa *equipaB = (equipa *) b;
  return strcmp(equipaA->nome, equipaB->nome);
}

void executa_g(lista *Equipa_lista, int NL)
{
  str_node *Temp;
  int maior = 0;
  int i = 0;
  int e;
  struct equipa vencedores[1023];
  Temp = Equipa_lista->last;
  while (Temp != 0)
  {
    if (Temp->equipa.score > maior)
    {
      memset(vencedores, 0, i);
      i = 1;
      maior = Temp->equipa.score;
      vencedores[0] = Temp->equipa;
    }
    else
    {
      if (Temp->equipa.score == maior)
      {
        vencedores[i] = Temp->equipa;
        i = i + 1;
      }
      else
      {
        
      }

    }

    Temp = Temp->next;
  }

  if (i != 0)
  {
    printf("%d Melhores %d\n", NL, maior);
    qsort(vencedores, i, sizeof(vencedores[0]), comparador);
    for (e = 0; e < i; e++)
    {
      printf("%d * %s\n", NL, vencedores[e].nome);
    }

  }
  else
  {
    
  }

}

void liberta_espacos(lista *Equipa_lista, lista2 *Jogos_lista, hash_table_equipa *hash_table_equipa_p, hash_table_jogo *hash_table_jogo_p)
{
  str_node *current = Equipa_lista->last;
  str_node *tmp;
  str_node_jogo *current2 = Jogos_lista->last;
  str_node_jogo *tmp2;
  while (current != 0)
  {
    tmp = current;
    current = current->next;
    free(tmp->equipa.nome);
    free(tmp);
  }

  while (current2 != 0)
  {
    tmp2 = current2;
    current2 = current2->next;
    free(tmp2->jogo.nome);
    free(tmp2);
  }

  free(hash_table_equipa_p->entries);
  free(hash_table_equipa_p);
  free(hash_table_jogo_p->entries);
  free(hash_table_jogo_p);
}

#endif