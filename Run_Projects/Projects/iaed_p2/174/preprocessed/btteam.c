/*File generated by PreProcessor.py*/


#include "btteam.h"


BTTeam *newBTTeamNode(Team *team, BTTeam *left, BTTeam *right)
{
  BTTeam *node = (BTTeam *) malloc(sizeof(BTTeam));
  node->team = team;
  node->left = left;
  node->right = right;
  node->height = 1;
  return node;
}

void freeBTTeamNode(BTTeam *node)
{
  free(node);
}

BTTeam *newBTTeam()
{
  return 0;
}

void freeBTTeam(BTTeam *node)
{
  if (node != 0)
  {
    {
      freeBTTeam(node->left);
      freeBTTeam(node->right);
      freeTeam(node->team);
      freeBTTeamNode(node);
    }
  }
  else
  {
    
  }

}

int countBTTeam(BTTeam *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return (1 + countBTTeam(node->left)) + countBTTeam(node->right);
}

Team *searchBTTeam(BTTeam *node, char *name)
{
  int cmp;
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  cmp = teamKeyOrder(name, node->team);
  if (cmp == 0)
  {
    return node->team;
  }
  else
  {
    if (cmp < 0)
    {
      return searchBTTeam(node->left, name);
    }
    else
    {
      return searchBTTeam(node->right, name);
    }

  }

}

int existsBTTeam(BTTeam *node, char *name)
{
  return searchBTTeam(node, name) != 0;
}

int heightBBTeam(BTTeam *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return node->height;
}

BTTeam *rotLBTTeam(BTTeam *node)
{
  int hleft;
  int hright;
  int xleft;
  int xright;
  BTTeam *x = node->right;
  node->right = x->left;
  x->left = node;
  hleft = heightBBTeam(node->left);
  hright = heightBBTeam(node->right);
  node->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
  xleft = heightBBTeam(x->left);
  xright = heightBBTeam(x->right);
  x->height = (xleft > xright) ? (xleft + 1) : (xright + 1);
  return x;
}

BTTeam *rotRBTTeam(BTTeam *node)
{
  int hleft;
  int hright;
  int xleft;
  int xright;
  BTTeam *x = node->left;
  node->left = x->right;
  x->right = node;
  hleft = heightBBTeam(node->left);
  hright = heightBBTeam(node->right);
  node->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
  xleft = heightBBTeam(x->left);
  xright = heightBBTeam(x->right);
  x->height = (xleft > xright) ? (xleft + 1) : (xright + 1);
  return x;
}

BTTeam *rotLRBTTeam(BTTeam *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  node->left = rotLBTTeam(node->left);
  return rotRBTTeam(node);
}

BTTeam *rotRLBTTeam(BTTeam *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  node->right = rotRBTTeam(node->right);
  return rotLBTTeam(node);
}

int balanceBBTeam(BTTeam *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return heightBBTeam(node->left) - heightBBTeam(node->right);
}

BTTeam *AVLbalanceBBTeam(BTTeam *node)
{
  int balanceFactor;
  int hleft;
  int hright;
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  balanceFactor = balanceBBTeam(node);
  if (balanceFactor > 1)
  {
    {
      if (balanceBBTeam(node->left) >= 0)
      {
        node = rotRBTTeam(node);
      }
      else
      {
        node = rotLRBTTeam(node);
      }

    }
  }
  else
  {
    if (balanceFactor < (-1))
    {
      {
        if (balanceBBTeam(node->right) <= 0)
        {
          node = rotLBTTeam(node);
        }
        else
        {
          node = rotRLBTTeam(node);
        }

      }
    }
    else
    {
      {
        hleft = heightBBTeam(node->left);
        hright = heightBBTeam(node->right);
        node->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
      }
    }

  }

  return node;
}

BTTeam *insertBTTeamAux(BTTeam *node, Team *team)
{
  int cmp;
  if (node == 0)
  {
    return newBTTeamNode(team, 0, 0);
  }
  else
  {
    
  }

  cmp = teamsOrder(team, node->team);
  if (cmp < 0)
  {
    node->left = insertBTTeamAux(node->left, team);
  }
  else
  {
    node->right = insertBTTeamAux(node->right, team);
  }

  return AVLbalanceBBTeam(node);
}

void insertBTTeam(BTTeam **node, Team *team)
{
  *node = insertBTTeamAux(*node, team);
}

BTTeam *maxBBTeam(BTTeam *node)
{
  if ((node == 0) || (node->right == 0))
  {
    return node;
  }
  else
  {
    
  }

  return maxBBTeam(node->right);
}

BTTeam *deleteRBTTeam(BTTeam *node, char *name)
{
  BTTeam *aux;
  Team *x;
  int cmp;
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  cmp = teamKeyOrder(name, node->team);
  if (cmp < 0)
  {
    node->left = deleteRBTTeam(node->left, name);
  }
  else
  {
    if (cmp > 0)
    {
      node->right = deleteRBTTeam(node->right, name);
    }
    else
    {
      if ((node->left != 0) && (node->right != 0))
      {
        {
          aux = maxBBTeam(node->left);
          x = node->team;
          node->team = aux->team;
          aux->team = x;
          node->left = deleteRBTTeam(node->left, name);
        }
      }
      else
      {
        {
          aux = node;
          if ((node->left == 0) && (node->right == 0))
          {
            node = 0;
          }
          else
          {
            if (node->left == 0)
            {
              node = node->right;
            }
            else
            {
              node = node->left;
            }

          }

          freeTeam(aux->team);
          freeBTTeamNode(aux);
        }
      }

    }

  }

  return AVLbalanceBBTeam(node);
}

void deleteBTTeam(BTTeam **node, char *name)
{
  *node = deleteRBTTeam(*node, name);
}

void findBestTeams(TeamList **result, BTTeam *node, int *best)
{
  int wins;
  if (node != 0)
  {
    {
      findBestTeams(result, node->right, best);
      wins = getTeamWins(node->team);
      if (wins == (*best))
      {
        {
          shiftTeamList(result, node->team);
        }
      }
      else
      {
        if (wins > (*best))
        {
          {
            clearTeamList(result);
            shiftTeamList(result, node->team);
            *best = wins;
          }
        }
        else
        {
          
        }

      }

      findBestTeams(result, node->left, best);
    }
  }
  else
  {
    
  }

}

TeamList *bestBTTeam(BTTeam *node)
{
  TeamList *result = newTeamList();
  int best = 0;
  findBestTeams(&result, node, &best);
  return result;
}

