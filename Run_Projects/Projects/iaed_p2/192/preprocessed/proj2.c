/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct stru_node_equipa
{
  struct stru_node_equipa *next;
  char *nome;
  int vitorias;
} *node_equipa;
typedef struct stru_node_jogo
{
  struct stru_node_jogo *next;
  char *name;
  node_equipa equipa1;
  node_equipa equipa2;
  int golos_casa;
  int golos_fora;
} *node_jogo;
typedef struct node_queue
{
  node_jogo jogo;
  struct node_queue *prev;
  struct node_queue *next;
} *Q;
typedef struct stru_list
{
  Q head;
  Q tail;
} *list;
void init_teamhash(int m, node_equipa *equipas)
{
  int j;
  for (j = 0; j < m; j++)
    equipas[j] = 0;

}

void init_gamehash(int n, node_jogo *jogos)
{
  int j;
  for (j = 0; j < n; j++)
    jogos[j] = 0;

}

Q init_node_queue()
{
  node_jogo aux;
  Q q;
  Q auxiliar;
  auxiliar = (Q) malloc(sizeof(struct node_queue));
  q = auxiliar;
  aux = (node_jogo) malloc(sizeof(struct stru_node_jogo));
  q->jogo = aux;
  auxiliar = (Q) malloc(sizeof(struct node_queue));
  q->prev = auxiliar;
  free(auxiliar);
  auxiliar = (Q) malloc(sizeof(struct node_queue));
  q->next = auxiliar;
  free(auxiliar);
  q->prev = 0;
  q->next = 0;
  return q;
}

list init_list()
{
  Q auxiliar;
  list q;
  q = (list) malloc(sizeof(struct stru_list));
  auxiliar = (Q) malloc(sizeof(struct node_queue));
  q->head = auxiliar;
  free(auxiliar);
  auxiliar = (Q) malloc(sizeof(struct node_queue));
  q->tail = auxiliar;
  free(auxiliar);
  q->head = (q->tail = 0);
  return q;
}

int hash_str(char *v, int M)
{
  int h;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*v) != '\0'; v++, a = (a * b) % (M - 1))
    h = ((a * h) + (*v)) % M;

  return h;
}

node_equipa insere_equipa(node_equipa equipas, char *nome)
{
  node_equipa team;
  team = (node_equipa) malloc(sizeof(struct stru_node_equipa));
  team->nome = malloc(strlen(nome) + 1);
  team->vitorias = 0;
  strcpy(team->nome, nome);
  team->next = equipas;
  return team;
}

int search_game(node_jogo head, char *nome_do_jogo)
{
  node_jogo x;
  for (x = head; x != 0; x = x->next)
  {
    if (strcmp(x->name, nome_do_jogo) == 0)
    {
      return 1;
      break;
    }
    else
    {
      
    }

  }

  return 0;
}

int search_team(node_equipa head_equipa, char *team)
{
  node_equipa x;
  for (x = head_equipa; x != 0; x = x->next)
  {
    if (strcmp(x->nome, team) == 0)
    {
      return 1;
      break;
    }
    else
    {
      
    }

  }

  return 0;
}

void insert(int input, node_equipa *equipas, int m)
{
  int i;
  char nome[1024];
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  i = hash_str(nome, m);
  if (search_team(equipas[i], nome) == 1)
  {
    printf("%d Equipa existente.\n", input);
  }
  else
  {
    equipas[i] = insere_equipa(equipas[i], nome);
  }

}

Q novo_no(char *nome_do_jogo, int m, char *team1, char *team2, int golos_casa, int golos_fora, node_equipa *equipas, Q next)
{
  int i = hash_str(team1, m);
  int j = hash_str(team2, m);
  Q new;
  Q aux_next;
  Q aux_prev;
  node_equipa h;
  node_equipa aux;
  new = (Q) malloc(sizeof(struct node_queue));
  aux_next = (Q) malloc(sizeof(struct node_queue));
  new->next = aux_next;
  free(aux_next);
  aux_prev = (Q) malloc(sizeof(struct node_queue));
  new->prev = aux_prev;
  free(aux_prev);
  new->jogo = (node_jogo) malloc(sizeof(struct stru_node_jogo));
  new->jogo->name = (char *) malloc(strlen(nome_do_jogo) + 1);
  strcpy(new->jogo->name, nome_do_jogo);
  for (h = equipas[i]; h != 0; h = h->next)
  {
    if (strcmp(h->nome, team1) == 0)
    {
      aux = (node_equipa) malloc(sizeof(struct stru_node_equipa));
      new->jogo->equipa1 = aux;
      free(aux);
      new->jogo->equipa1 = h;
      break;
    }
    else
    {
      
    }

  }

  for (h = equipas[j]; h != 0; h = h->next)
  {
    if (strcmp(h->nome, team2) == 0)
    {
      aux = (node_equipa) malloc(sizeof(struct stru_node_equipa));
      new->jogo->equipa2 = aux;
      free(aux);
      new->jogo->equipa2 = h;
      break;
    }
    else
    {
      
    }

  }

  new->jogo->golos_casa = golos_casa;
  new->jogo->golos_fora = golos_fora;
  new->prev = next;
  new->next = 0;
  return new;
}

node_jogo insere_jogo(char *nome_do_jogo, int m, int n, char *team1, char *team2, int golos_casa, int golos_fora, node_jogo *jogos, node_equipa *equipas, list l)
{
  int i = hash_str(team1, m);
  int j = hash_str(team2, m);
  int k = hash_str(nome_do_jogo, n);
  int winner;
  node_jogo novo_jogo;
  node_equipa h;
  node_equipa aux;
  if (golos_casa > golos_fora)
  {
    winner = 1;
  }
  else
  {
    if (golos_casa < golos_fora)
    {
      winner = 2;
    }
    else
    {
      if (golos_casa == golos_fora)
      {
        winner = 0;
      }
      else
      {
        
      }

    }

  }

  novo_jogo = (node_jogo) malloc(sizeof(struct stru_node_jogo));
  novo_jogo->name = (char *) malloc(strlen(nome_do_jogo) + 1);
  novo_jogo->golos_casa = golos_casa;
  novo_jogo->golos_fora = golos_fora;
  strcpy(novo_jogo->name, nome_do_jogo);
  for (h = equipas[i]; h != 0; h = h->next)
  {
    if (strcmp(h->nome, team1) == 0)
    {
      aux = (node_equipa) malloc(sizeof(struct stru_node_equipa));
      novo_jogo->equipa1 = aux;
      novo_jogo->equipa1 = h;
      free(aux);
      break;
    }
    else
    {
      
    }

  }

  for (h = equipas[j]; h != 0; h = h->next)
  {
    if (strcmp(h->nome, team2) == 0)
    {
      aux = (node_equipa) malloc(sizeof(struct stru_node_equipa));
      novo_jogo->equipa2 = aux;
      novo_jogo->equipa2 = h;
      free(aux);
      break;
    }
    else
    {
      
    }

  }

  for (h = equipas[i]; h != 0; h = h->next)
  {
    if ((strcmp(h->nome, team1) == 0) && (winner == 1))
    {
      h->vitorias++;
    }
    else
    {
      
    }

  }

  for (h = equipas[j]; h != 0; h = h->next)
  {
    if ((strcmp(h->nome, team2) == 0) && (winner == 2))
    {
      h->vitorias++;
    }
    else
    {
      
    }

  }

  novo_jogo->next = jogos[k];
  if (!l->head)
  {
    l->head = (l->tail = novo_no(nome_do_jogo, m, team1, team2, golos_casa, golos_fora, equipas, l->head));
    return novo_jogo;
  }
  else
  {
    l->tail->next = novo_no(nome_do_jogo, m, team1, team2, golos_casa, golos_fora, equipas, l->tail);
    l->tail = l->tail->next;
    return novo_jogo;
  }

  return 0;
}

void adiciona_jogo(int inp, int m, int n, node_jogo *jogos, node_equipa *equipas, list l)
{
  int i;
  int j;
  int k;
  int a;
  int b;
  char nome[1024];
  char e1[1024];
  char e2[1024];
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  for (int e1_index = 0; e1_index < 10; e1_index++)
  {
    e1[e1_index] = new_sym_var(sizeof(char) * 8);
  }

  e1[10 - 1] = '\0';
  for (int e2_index = 0; e2_index < 10; e2_index++)
  {
    e2[e2_index] = new_sym_var(sizeof(char) * 8);
  }

  e2[10 - 1] = '\0';
  a = new_sym_var(sizeof(int) * 8);
  b = new_sym_var(sizeof(int) * 8);
  i = hash_str(e1, m);
  j = hash_str(e2, m);
  k = hash_str(nome, n);
  if (search_game(jogos[k], nome) == 1)
  {
    printf("%d Jogo existente.\n", inp);
  }
  else
  {
    if (search_team(equipas[i], e1) == 0)
    {
      printf("%d Equipa inexistente.\n", inp);
    }
    else
    {
      if (search_team(equipas[j], e2) == 0)
      {
        printf("%d Equipa inexistente.\n", inp);
      }
      else
      {
        jogos[k] = insere_jogo(nome, m, n, e1, e2, a, b, jogos, equipas, l);
      }

    }

  }

}

void print_ordenada(int inp, list l)
{
  Q x;
  for (x = l->head; x != 0; x = x->next)
  {
    printf("%d %s %s %s %d %d\n", inp, x->jogo->name, x->jogo->equipa1->nome, x->jogo->equipa2->nome, x->jogo->golos_casa, x->jogo->golos_fora);
  }

}

int check_game(int inp, node_jogo *jogos, int n)
{
  int i;
  node_jogo x;
  char nome[1024];
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  i = hash_str(nome, n);
  for (x = jogos[i]; x != 0; x = x->next)
  {
    if (strcmp(x->name, nome) == 0)
    {
      printf("%d %s %s %s %d %d\n", inp, x->name, x->equipa1->nome, x->equipa2->nome, x->golos_casa, x->golos_fora);
      return 0;
    }
    else
    {
      
    }

  }

  printf("%d Jogo inexistente.\n", inp);
  return 0;
}

int delete_game(int inp, node_jogo *jogos, node_equipa *equipas, int m, int n, list l)
{
  node_jogo aux;
  node_jogo temp;
  node_jogo prev;
  Q x;
  Q aux_queue;
  node_equipa equipa_com_menos_vitoria;
  char *vencedor;
  char nome[1024];
  int i;
  int j;
  int existe = 0;
  int tie = 0;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  i = hash_str(nome, n);
  aux = jogos[i];
  if (aux != 0)
  {
    for (temp = jogos[i], prev = 0; temp != 0; prev = temp, temp = temp->next)
    {
      if (strcmp(temp->name, nome) == 0)
      {
        if (temp == jogos[i])
        {
          if (temp->golos_casa > temp->golos_fora)
          {
            vencedor = (char *) malloc((sizeof(char)) * (strlen(temp->equipa1->nome) + 1));
            existe = 1;
            strcpy(vencedor, temp->equipa1->nome);
            jogos[i] = temp->next;
            free(temp->name);
            free(temp);
            break;
          }
          else
          {
            if (temp->golos_fora > temp->golos_casa)
            {
              existe = 1;
              vencedor = (char *) malloc((sizeof(char)) * (strlen(temp->equipa2->nome) + 1));
              strcpy(vencedor, temp->equipa2->nome);
              jogos[i] = temp->next;
              free(temp->name);
              free(temp);
              break;
            }
            else
            {
              if (temp->golos_fora == temp->golos_casa)
              {
                tie = 1;
                jogos[i] = temp->next;
                free(temp->name);
                free(temp);
                break;
              }
              else
              {
                
              }

            }

          }

        }
        else
        {
          if (temp->golos_casa > temp->golos_fora)
          {
            existe = 1;
            vencedor = (char *) malloc((sizeof(char)) * (strlen(temp->equipa1->nome) + 1));
            strcpy(vencedor, temp->equipa1->nome);
            prev->next = temp->next;
            free(temp->name);
            free(temp);
            break;
          }
          else
          {
            if (temp->golos_fora > temp->golos_casa)
            {
              existe = 1;
              vencedor = (char *) malloc((sizeof(char)) * (strlen(temp->equipa2->nome) + 1));
              strcpy(vencedor, temp->equipa2->nome);
              prev->next = temp->next;
              free(temp->name);
              free(temp);
              break;
            }
            else
            {
              if (temp->golos_fora == temp->golos_casa)
              {
                tie = 1;
                prev->next = temp->next;
                free(temp->name);
                free(temp);
                break;
              }
              else
              {
                
              }

            }

          }

        }

      }
      else
      {
        
      }

    }

    for (x = l->head; x != 0; x = x->next)
    {
      if (strcmp(x->jogo->name, nome) == 0)
      {
        if (x == l->head)
        {
          l->head = x->next;
          free(x->jogo->name);
          free(x);
          break;
        }
        else
        {
          if (x->next != 0)
          {
            aux_queue = x;
            x->next->prev = x->prev;
            x->prev->next = x->next;
            free(aux_queue->jogo->name);
            free(aux_queue);
            break;
          }
          else
          {
            if (x->prev != 0)
            {
              x->prev->next = x->next;
              free(x->jogo->name);
              free(x);
              break;
            }
            else
            {
              
            }

          }

        }

      }
      else
      {
        
      }

    }

    if (existe == 1)
    {
      j = hash_str(vencedor, m);
      for (equipa_com_menos_vitoria = equipas[j]; equipa_com_menos_vitoria != 0; equipa_com_menos_vitoria = equipa_com_menos_vitoria->next)
      {
        if (strcmp(equipa_com_menos_vitoria->nome, vencedor) == 0)
        {
          equipa_com_menos_vitoria->vitorias--;
          free(vencedor);
          return 0;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (tie == 1)
      {
        return 0;
      }
      else
      {
        if (search_game(jogos[i], nome) == 0)
        {
          printf("%d Jogo inexistente.\n", inp);
          return 0;
        }
        else
        {
          
        }

      }

    }

  }
  else
  {
    printf("%d Jogo inexistente.\n", inp);
  }

  return 0;
}

int change_game(int inp, node_jogo *jogos, int n, list l)
{
  char nome[1024];
  int a;
  int b;
  int i;
  int winner;
  node_jogo x;
  Q t;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  a = new_sym_var(sizeof(int) * 8);
  b = new_sym_var(sizeof(int) * 8);
  i = hash_str(nome, n);
  if (a > b)
  {
    winner = 1;
  }
  else
  {
    if (a < b)
    {
      winner = 2;
    }
    else
    {
      if (a == b)
      {
        winner = 0;
      }
      else
      {
        
      }

    }

  }

  if (search_game(jogos[i], nome) == 1)
  {
    for (x = jogos[i]; x != 0; x = x->next)
    {
      if (((strcmp(x->name, nome) == 0) && (winner == 1)) && (x->golos_casa < x->golos_fora))
      {
        x->equipa1->vitorias++;
        x->equipa2->vitorias--;
        x->golos_casa = a;
        x->golos_fora = b;
        break;
      }
      else
      {
        if (((winner == 2) && (x->golos_casa > x->golos_fora)) && (strcmp(x->name, nome) == 0))
        {
          x->equipa1->vitorias--;
          x->equipa2->vitorias++;
          x->golos_casa = a;
          x->golos_fora = b;
          break;
        }
        else
        {
          if (((winner == 1) && (x->golos_casa > x->golos_fora)) && (strcmp(x->name, nome) == 0))
          {
            x->golos_casa = a;
            x->golos_fora = b;
            break;
          }
          else
          {
            if (((winner == 2) && (x->golos_casa < x->golos_fora)) && (strcmp(x->name, nome) == 0))
            {
              x->golos_casa = a;
              x->golos_fora = b;
              break;
            }
            else
            {
              if (((strcmp(x->name, nome) == 0) && (winner == 0)) && (x->golos_casa < x->golos_fora))
              {
                x->equipa2->vitorias--;
                x->golos_casa = a;
                x->golos_fora = b;
                break;
              }
              else
              {
                if (((strcmp(x->name, nome) == 0) && (winner == 0)) && (x->golos_casa > x->golos_fora))
                {
                  x->equipa1->vitorias--;
                  x->golos_casa = a;
                  x->golos_fora = b;
                  break;
                }
                else
                {
                  if (((strcmp(x->name, nome) == 0) && (winner == 1)) && (x->golos_casa == x->golos_fora))
                  {
                    x->equipa1->vitorias++;
                    x->golos_casa = a;
                    x->golos_fora = b;
                    break;
                  }
                  else
                  {
                    if (((strcmp(x->name, nome) == 0) && (winner == 2)) && (x->golos_casa == x->golos_fora))
                    {
                      x->equipa2->vitorias++;
                      x->golos_casa = a;
                      x->golos_fora = b;
                      break;
                    }
                    else
                    {
                      if (((strcmp(x->name, nome) == 0) && (winner == 0)) && (x->golos_casa == x->golos_fora))
                      {
                        x->golos_casa = a;
                        x->golos_fora = b;
                        break;
                      }
                      else
                      {
                        
                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

    for (t = l->head; t != 0; t = t->next)
    {
      if (strcmp(t->jogo->name, nome) == 0)
      {
        t->jogo->golos_casa = a;
        t->jogo->golos_fora = b;
      }
      else
      {
        
      }

    }

  }
  else
  {
    printf("%d Jogo inexistente.\n", inp);
  }

  return 0;
}

int check_team(int inp, node_equipa *equipas, int m)
{
  char nome[1024];
  int i;
  node_equipa x;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  i = hash_str(nome, m);
  for (x = equipas[i]; x != 0; x = x->next)
  {
    if (strcmp(x->nome, nome) == 0)
    {
      printf("%d %s %d\n", inp, x->nome, x->vitorias);
      return 0;
    }
    else
    {
      
    }

  }

  printf("%d Equipa inexistente.\n", inp);
  return 0;
}

int cmpstr(const void *a, const void *b)
{
  const struct stru_node_equipa *elemento1 = *((struct stru_node_equipa **) a);
  const struct stru_node_equipa *elemento2 = *((struct stru_node_equipa **) b);
  int rtn;
  rtn = strcmp(elemento1->nome, elemento2->nome);
  return rtn;
}

void sort_teams(int inp, node_equipa *equipas)
{
  int i;
  int j;
  int n = 1161;
  int maximo = 0;
  int capacity = 5;
  int existe;
  int used = 0;
  node_equipa x;
  for (j = 0; j < n; j++)
  {
    for (x = equipas[j]; x != 0; x = x->next)
    {
      if (x->vitorias >= maximo)
      {
        maximo = x->vitorias;
      }
      else
      {
        
      }

      existe = 1;
    }

  }

  if (existe == 1)
  {
    node_equipa *array = malloc((sizeof(struct stru_node_equipa)) * capacity);
    for (j = 0; j < n; j++)
    {
      for (x = equipas[j]; x != 0; x = x->next)
      {
        if ((used >= capacity) && (x->vitorias == maximo))
        {
          capacity *= 2;
          array = (node_equipa *) realloc(array, (sizeof(struct stru_node_equipa)) * capacity);
          array[used] = (node_equipa) malloc(sizeof(struct stru_node_equipa));
          array[used]->nome = (char *) malloc(strlen(x->nome) + 1);
          strcpy(array[used]->nome, x->nome);
          used++;
        }
        else
        {
          if (x->vitorias == maximo)
          {
            array[used] = (node_equipa) malloc(sizeof(struct stru_node_equipa));
            array[used]->nome = (char *) malloc(strlen(x->nome) + 1);
            strcpy(array[used]->nome, x->nome);
            used++;
          }
          else
          {
            
          }

        }

      }

    }

    qsort(array, used, sizeof(struct equipa_a *), cmpstr);
    printf("%d Melhores %d\n", inp, maximo);
    for (i = 0; i < used; i++)
    {
      printf("%d * %s\n", inp, array[i]->nome);
      free(array[i]->nome);
      free(array[i]);
    }

    free(array);
  }
  else
  {
    
  }

}

void free_game(node_jogo *jogos, int n)
{
  node_jogo x;
  node_jogo temp;
  int i;
  for (i = 0; i < n; i++)
  {
    x = jogos[i];
    while (x != 0)
    {
      temp = x->next;
      free(x->name);
      free(x);
      x = temp;
    }

  }

}

void free_team(node_equipa *equipas, int n)
{
  node_equipa x;
  node_equipa temp;
  int i;
  for (i = 0; i < n; i++)
  {
    x = equipas[i];
    while (x != 0)
    {
      temp = x->next;
      free(x->nome);
      free(x);
      x = temp;
    }

  }

}

void remove_queue(list l)
{
  while (l->head != 0)
  {
    Q temp = l->head;
    l->head = temp->next;
    free(temp->jogo->name);
    free(temp->jogo);
    free(temp);
  }

  free(l);
}

int main()
{
  int c;
  int inp = 1;
  node_equipa *equipas;
  node_jogo *jogos;
  list l;
  int m = 1161;
  int n = 1161;
  equipas = (node_equipa *) malloc(m * (sizeof(struct stru_node_equipa)));
  jogos = (node_jogo *) malloc(n * (sizeof(struct stru_node_jogo)));
  l = init_list();
  init_teamhash(m, equipas);
  init_gamehash(n, jogos);
  while (((c = getchar()) != EOF) && (c != 'x'))
  {
    switch (c)
    {
      case 'a':
      {
        adiciona_jogo(inp, m, n, jogos, equipas, l);
        inp++;
        break;
      }

      case 'A':
      {
        insert(inp, equipas, m);
        inp++;
        break;
      }

      case 'l':
      {
        print_ordenada(inp, l);
        inp++;
        break;
      }

      case 'p':
      {
        check_game(inp, jogos, n);
        inp++;
        break;
      }

      case 'r':
      {
        delete_game(inp, jogos, equipas, m, n, l);
        inp++;
        break;
      }

      case 's':
      {
        change_game(inp, jogos, n, l);
        inp++;
        break;
      }

      case 'P':
      {
        check_team(inp, equipas, n);
        inp++;
        break;
      }

      case 'g':
      {
        sort_teams(inp, equipas);
        inp++;
        break;
      }

    }

  }

  remove_queue(l);
  free_game(jogos, n);
  free(jogos);
  free_team(equipas, n);
  free(equipas);
  return 0;
}

