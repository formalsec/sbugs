/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int NL = 0;
typedef struct _team
{
  char *name;
  int wins;
} *Team;
typedef struct node_team
{
  Team t;
  struct node_team *next;
} *Link_team;
typedef struct _game
{
  char *name;
  Team t1;
  Team t2;
  int score_t1;
  int score_t2;
} *Game;
typedef struct node_game
{
  Game g;
  struct node_game *next;
} *Link_game;
typedef struct 
{
  int hash_index;
  char game[3082];
  char team1[3082];
  char team2[3082];
  int score1;
  int score2;
  int input_index;
} Instruction;
typedef struct _winners
{
  int max_wins;
  int how_many_teams;
  struct node_team *teams;
} Winners;
int hash(char input[3082]);
Link_team insert_team(Link_team head, char input[3082]);
Team add_new_team(char input[3082]);
void list_teams(Link_team head);
int does_team_exist(char input[1024], Link_team head);
Link_team locate_team(char input[1024], Link_team head);
Instruction get_name_hash(char input[3082], int i);
Winners create_game(char input[3082], Link_team *heads_teams, Link_game *heads_games, Game *list_games, Winners winners);
Instruction get_score(char input[3082], Instruction reader);
Link_game store_game(Link_game head, Game new_game, Game *list_games);
int does_game_exist(char input[1024], Link_game head);
void list_games_order(Game *list_games);
Link_game locate_game(char input[1024], Link_game head);
Link_game delete_game(char input[1024], Link_game head, Game *list_games);
void rectify_score(char input[1024], Link_game *heads_games, int i);
Winners are_they_winners(int wins, Instruction reader, Link_team *heads_teams, Winners winners);
void list_winners(Winners winners);
int main()
{
  char input[3082];
  Link_team *heads_teams;
  Link_game *heads_games;
  int i;
  Link_team aux_team = 0;
  Link_game aux_game = 0;
  Game *list_games;
  Winners winners;
  winners.max_wins = 0;
  winners.how_many_teams = 0;
  winners.teams = 0;
  list_games = malloc(9999 * (sizeof(Game)));
  for (i = 0; i < 9999; i++)
    list_games[i] = 0;

  heads_teams = malloc(23 * (sizeof(Link_team)));
  for (i = 0; i < 23; i++)
    heads_teams[i] = 0;

  heads_games = malloc(23 * (sizeof(Link_game)));
  for (i = 0; i < 23; i++)
    heads_games[i] = 0;

  do
  {
    fgets(input, 3082, stdin);
    NL++;
    strtok(input, "\n");
    switch (input[0])
    {
      case 'a':
        i = strlen(input);
        input[i] = '\n';
        winners = create_game(input, heads_teams, heads_games, list_games, winners);
        break;

      case 'l':
        list_games_order(list_games);
        break;

      case 'p':
        i = hash(input + 2);
        if (does_game_exist(input + 2, heads_games[i]))
      {
        aux_game = locate_game(input + 2, heads_games[i]);
        printf("%d %s %s %s %d %d\n", NL, aux_game->g->name, aux_game->g->t1->name, aux_game->g->t2->name, aux_game->g->score_t1, aux_game->g->score_t2);
      }
      else
      {
        printf("%d Jogo inexistente.\n", NL);
      }

        break;

      case 'r':
        i = hash(input + 2);
        if (does_game_exist(input + 2, heads_games[i]))
      {
        heads_games[i] = delete_game(input + 2, heads_games[i], list_games);
      }
      else
      {
        printf("%d Jogo inexistente.\n", NL);
      }

        break;

      case 's':
        rectify_score(input, heads_games, 2);
        break;

      case 'A':
        i = hash(input + 2);
        heads_teams[i] = insert_team(heads_teams[i], input + 2);
        break;

      case 'K':
        i = (*(input + 2)) - '0';
        list_teams(heads_teams[i]);
        break;

      case 'P':
        i = hash(input + 2);
        if (does_team_exist(input + 2, heads_teams[i]))
      {
        aux_team = locate_team(input + 2, heads_teams[i]);
        printf("%d %s %d\n", NL, aux_team->t->name, aux_team->t->wins);
      }
      else
      {
        printf("%d Equipa inexistente.\n", NL);
      }

        break;

      case 'w':
        list_winners(winners);
        break;

    }

  }
  while (input[0] != 'x');
  for (i = 0; i < 9999; i++)
    free(list_games[i]);

  free(list_games);
  for (i = 0; i < 23; i++)
    free(heads_teams[i]);

  free(heads_teams);
  for (i = 0; i < 23; i++)
    free(heads_games[i]);

  free(heads_games);
  return 0;
}

int hash(char input[3082])
{
  int index = 0;
  int aux = 127;
  int i = 0;
  for (; input[i] != '\0'; i++)
    index = ((aux * index) + input[i]) % 23;

  return index;
}

Link_team insert_team(Link_team head, char input[3082])
{
  Link_team temp = malloc(sizeof(struct node_team));
  if (does_team_exist(input, head))
  {
    printf("%d Equipa existente.\n", NL);
    return head;
  }
  else
  {
    
  }

  temp->t = add_new_team(input);
  temp->next = head;
  return temp;
}

Team add_new_team(char input[3082])
{
  Team temp = malloc(sizeof(struct _team));
  temp->name = malloc((sizeof(char)) * (strlen(input) + 1));
  strcpy(temp->name, input);
  temp->wins = 0;
  return temp;
}

void list_teams(Link_team head)
{
  Link_team temp;
  for (temp = head; temp != 0; temp = temp->next)
    printf("%s\n", temp->t->name);

}

int does_team_exist(char input[1024], Link_team head)
{
  Link_team temp;
  for (temp = head; temp != 0; temp = temp->next)
    if (!strcmp(input, temp->t->name))
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

Link_team locate_team(char input[1024], Link_team head)
{
  Link_team temp;
  for (temp = head; temp != 0; temp = temp->next)
    if (!strcmp(input, temp->t->name))
  {
    return temp;
  }
  else
  {
    
  }


  temp = 0;
  return temp;
}

Instruction get_game_info(char input[3082], int i)
{
  int j;
  int k;
  char *temp;
  Instruction reader;
  reader.input_index = i;
  reader.score1 = -1;
  for (j = 0; (input[i] != ':') && (input[i] != '\n'); i++, j++)
    ;

  temp = malloc((j + 1) * (sizeof(char)));
  k = j;
  for (j = 0; k > 0; j++, reader.input_index++, k--)
    temp[j] = input[reader.input_index];

  temp[j] = '\0';
  reader.hash_index = hash(temp);
  strcpy(reader.game, temp);
  reader.input_index = i + 1;
  i = reader.input_index;
  for (j = 0; (input[i] != ':') && (input[i] != '\n'); i++, j++)
    ;

  temp = realloc(temp, (j + 1) * (sizeof(char)));
  k = j;
  for (j = 0; k > 0; j++, reader.input_index++, k--)
    temp[j] = input[reader.input_index];

  temp[j] = '\0';
  strcpy(reader.team1, temp);
  reader.input_index = i + 1;
  i = reader.input_index;
  for (j = 0; (input[i] != ':') && (input[i] != '\n'); i++, j++)
    ;

  temp = realloc(temp, (j + 1) * (sizeof(char)));
  k = j;
  for (j = 0; k > 0; j++, reader.input_index++, k--)
    temp[j] = input[reader.input_index];

  temp[j] = '\0';
  strcpy(reader.team2, temp);
  reader.input_index = i + 1;
  i = reader.input_index;
  reader = get_score(input, reader);
  reader = get_score(input, reader);
  return reader;
}

Instruction get_score(char input[3082], Instruction reader)
{
  int i = reader.input_index;
  int n = 0;
  while ((input[i] != ':') && (input[i] != '\n'))
  {
    n = ((n * 10) + input[i]) - '0';
    i++;
  }

  if (reader.score1 == (-1))
  {
    reader.score1 = n;
    reader.input_index = i + 1;
  }
  else
  {
    reader.score2 = n;
  }

  return reader;
}

Winners create_game(char input[3082], Link_team *heads_teams, Link_game *heads_games, Game *list_games, Winners winners)
{
  Instruction reader;
  Game new_game = malloc(sizeof(struct _game));
  reader.input_index = 2;
  reader = get_game_info(input, reader.input_index);
  if (does_game_exist(reader.game, heads_games[reader.hash_index]))
  {
    printf("%d Jogo existente.\n", NL);
    free(new_game);
    return winners;
  }
  else
  {
    
  }

  if (!does_team_exist(reader.team1, heads_teams[hash(reader.team1)]))
  {
    printf("%d Equipa inexistente.\n", NL);
    free(new_game);
    return winners;
  }
  else
  {
    
  }

  if (!does_team_exist(reader.team2, heads_teams[hash(reader.team2)]))
  {
    printf("%d Equipa inexistente.\n", NL);
    free(new_game);
    return winners;
  }
  else
  {
    
  }

  new_game->name = malloc((sizeof(char)) * (strlen(reader.game) + 1));
  strcpy(new_game->name, reader.game);
  new_game->t1 = locate_team(reader.team1, heads_teams[hash(reader.team1)])->t;
  new_game->t2 = locate_team(reader.team2, heads_teams[hash(reader.team2)])->t;
  new_game->score_t1 = reader.score1;
  new_game->score_t2 = reader.score2;
  if (new_game->score_t1 > new_game->score_t2)
  {
    new_game->t1->wins++;
    winners = are_they_winners(new_game->t1->wins, reader, heads_teams, winners);
  }
  else
  {
    if (new_game->score_t2 > new_game->score_t1)
    {
      new_game->t2->wins++;
      winners = are_they_winners(new_game->t2->wins, reader, heads_teams, winners);
    }
    else
    {
      
    }

  }

  heads_games[reader.hash_index] = store_game(heads_games[reader.hash_index], new_game, list_games);
  return winners;
}

Link_game store_game(Link_game head, Game new_game, Game *list_games)
{
  Link_game temp = malloc(sizeof(struct node_game));
  int i;
  temp->g = new_game;
  temp->next = head;
  for (i = 0; list_games[i] != 0; i++)
    ;

  list_games[i] = new_game;
  return temp;
}

int does_game_exist(char input[1024], Link_game head)
{
  Link_game temp;
  for (temp = head; temp != 0; temp = temp->next)
    if (!strcmp(input, temp->g->name))
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

void list_games_order(Game *list_games)
{
  int i;
  for (i = 0; list_games[i] != 0; i++)
    printf("%d %s %s %s %d %d\n", NL, list_games[i]->name, list_games[i]->t1->name, list_games[i]->t2->name, list_games[i]->score_t1, list_games[i]->score_t2);

}

Link_game locate_game(char input[1024], Link_game head)
{
  Link_game temp;
  for (temp = head; temp != 0; temp = temp->next)
    if (!strcmp(input, temp->g->name))
  {
    return temp;
  }
  else
  {
    
  }


  temp = 0;
  return temp;
}

Link_game delete_game(char input[1024], Link_game head, Game *list_games)
{
  Link_game temp;
  Link_game prev;
  int i;
  for (temp = head, prev = 0; temp != 0; prev = temp, temp = temp->next)
  {
    if (strcmp(temp->g->name, input) == 0)
    {
      if (temp == head)
      {
        head = temp->next;
      }
      else
      {
        prev->next = temp->next;
      }

      for (i = 0; list_games[i] != 0; i++)
        if (strcmp(list_games[i]->name, input) == 0)
      {
        for (; list_games[i] != 0; i++)
          list_games[i] = list_games[i + 1];

        list_games[i] = 0;
      }
      else
      {
        
      }


      if (temp->g->score_t1 > temp->g->score_t2)
      {
        temp->g->t1->wins--;
      }
      else
      {
        if (temp->g->score_t1 < temp->g->score_t2)
        {
          temp->g->t2->wins--;
        }
        else
        {
          
        }

      }

      free(temp->g->name);
      free(temp->g);
      free(temp);
    }
    else
    {
      
    }

  }

  return head;
}

void rectify_score(char input[1024], Link_game *heads_games, int i)
{
  int j;
  int k;
  int hash_temp;
  int len;
  char *temp;
  Link_game temp_game;
  Instruction reader;
  reader.score1 = -1;
  reader.score2 = 0;
  for (j = 0; input[i] != ':'; i++, j++)
    ;

  temp = malloc((j + 1) * (sizeof(char)));
  k = j;
  reader.input_index = i + 1;
  for (i = 2, j = 0; k > 0; j++, i++, k--)
    temp[j] = input[i];

  temp[j] = '\0';
  hash_temp = hash(temp);
  temp_game = locate_game(temp, heads_games[hash_temp]);
  if (!does_game_exist(temp_game->g->name, heads_games[hash_temp]))
  {
    printf("%d Jogo inexistente.\n", NL);
    return;
  }
  else
  {
    
  }

  reader = get_score(input, reader);
  j = reader.input_index;
  len = strlen(input);
  while ((input[j] != ':') && (j < len))
  {
    reader.score2 = ((reader.score2 * 10) + input[j]) - '0';
    j++;
  }

  if (temp_game->g->score_t1 > temp_game->g->score_t2)
  {
    if (reader.score1 < reader.score2)
    {
      temp_game->g->t1->wins--;
      temp_game->g->t2->wins++;
    }
    else
    {
      if (reader.score1 == reader.score2)
      {
        temp_game->g->t1->wins--;
      }
      else
      {
        
      }

    }

  }
  else
  {
    if (temp_game->g->score_t1 < temp_game->g->score_t2)
    {
      if (reader.score1 > reader.score2)
      {
        temp_game->g->t1->wins++;
        temp_game->g->t2->wins--;
      }
      else
      {
        if (reader.score1 == reader.score2)
        {
          temp_game->g->t2->wins--;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (reader.score1 > reader.score2)
      {
        temp_game->g->t1->wins++;
      }
      else
      {
        if (reader.score1 < reader.score2)
        {
          temp_game->g->t2->wins++;
        }
        else
        {
          
        }

      }

    }

  }

  temp_game->g->score_t1 = reader.score1;
  temp_game->g->score_t2 = reader.score2;
}

Winners are_they_winners(int wins, Instruction reader, Link_team *heads_teams, Winners winners)
{
  Link_team temp_head;
  if (wins == winners.max_wins)
  {
    ;
    temp_head = winners.teams;
    winners.teams = locate_team(reader.team1, heads_teams[hash(reader.team1)]);
    winners.teams->next = temp_head;
    winners.how_many_teams++;
  }
  else
  {
    if (wins > winners.max_wins)
    {
      ;
      free(winners.teams);
      winners.teams = locate_team(reader.team1, heads_teams[hash(reader.team1)]);
      winners.teams->next = 0;
      winners.max_wins = wins;
      winners.how_many_teams = 1;
    }
    else
    {
      
    }

  }

  return winners;
}

void list_winners(Winners winners)
{
  Link_team temp;
  for (temp = winners.teams; temp != 0; temp = temp->next)
  {
    printf("%s\n", temp->t->name);
  }

}

