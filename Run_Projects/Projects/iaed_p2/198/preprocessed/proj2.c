/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>


int count;
typedef struct stru_nodeT
{
  struct stru_nodeT *next;
  struct stru_nodeT *previous;
  char *name;
  int *victories;
} nodeT;
typedef struct 
{
  nodeT *head;
  nodeT *last;
} listT;
typedef struct stru_nodeG
{
  struct stru_nodeG *next;
  struct stru_nodeG *previous;
  char *name;
  char *team1;
  char *team2;
  int *score1;
  int *score2;
} nodeG;
typedef struct 
{
  nodeG *head;
  nodeG *last;
} listG;
listT *mk_listT()
{
  listT *l = malloc(sizeof(listT));
  l->head = (l->last = 0);
  return l;
}

listG *mk_listG()
{
  listG *l = malloc(sizeof(listG));
  l->head = (l->last = 0);
  return l;
}

void free_nodeT(nodeT *n)
{
  free(n->victories);
  free(n->name);
  free(n);
}

void free_nodeG(nodeG *n)
{
  free(n->name);
  free(n->team1);
  free(n->team2);
  free(n->score1);
  free(n->score2);
  free(n);
}

void free_listT(listT *l)
{
  while (l->head != 0)
  {
    nodeT *tmp = l->head->next;
    free_nodeT(l->head);
    l->head = tmp;
  }

  free(l);
}

void free_listG(listG *l)
{
  while (l->head != 0)
  {
    nodeG *tmp = l->head->next;
    free_nodeG(l->head);
    l->head = tmp;
  }

  free(l);
}

void rm_nodeG(listG *l, nodeG *n)
{
  if (n->previous == 0)
  {
    {
      l->head = n->next;
    }
  }
  else
  {
    {
      n->previous->next = n->next;
    }
  }

  if (n->next == 0)
  {
    {
      l->last = n->previous;
    }
  }
  else
  {
    {
      n->next->previous = n->previous;
    }
  }

  free_nodeG(n);
}

void add_lastT(listT *l, const char *n)
{
  nodeT *nn = malloc(sizeof(nodeT));
  nn->previous = l->last;
  nn->next = 0;
  nn->name = malloc((sizeof(char)) * (strlen(n) + 1));
  nn->victories = malloc(sizeof(int));
  strcpy(nn->name, n);
  *nn->victories = 0;
  if (l->last)
  {
    {
      l->last->next = nn;
    }
  }
  else
  {
    {
      l->head = nn;
    }
  }

  l->last = nn;
}

void add_lastG(listG *l, const char *n, const char *T1, const char *T2, int *s1, int *s2)
{
  nodeG *nn = malloc(sizeof(nodeG));
  nn->previous = l->last;
  nn->next = 0;
  nn->name = malloc((sizeof(char)) * (strlen(n) + 1));
  nn->team1 = malloc((sizeof(char)) * (strlen(T1) + 1));
  nn->team2 = malloc((sizeof(char)) * (strlen(T2) + 1));
  nn->score1 = malloc(sizeof(int));
  nn->score2 = malloc(sizeof(int));
  strcpy(nn->name, n);
  strcpy(nn->team1, T1);
  strcpy(nn->team2, T2);
  *nn->score1 = *s1;
  *nn->score2 = *s2;
  if (l->last)
  {
    {
      l->last->next = nn;
    }
  }
  else
  {
    {
      l->head = nn;
    }
  }

  l->last = nn;
}

char *scan_and_allocate()
{
  char *buffer = malloc(1024);
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  return buffer;
}

int *scan_int()
{
  int *s = malloc(sizeof(int));
  for (int s_index = 0; s_index < 10; s_index++)
  {
    s[s_index] = new_sym_var(sizeof(int) * 8);
  }

  return s;
}

bool checkGame(listG *games, char *name)
{
  nodeG *tmp;
  for (tmp = games->head; tmp; tmp = tmp->next)
  {
    if (strcmp(tmp->name, name) == 0)
    {
      {
        return 1;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

bool checkTeam(listT *teams, char *name)
{
  nodeT *tmp;
  for (tmp = teams->head; tmp; tmp = tmp->next)
  {
    if (strcmp(tmp->name, name) == 0)
    {
      {
        return 1;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

void addTeam(listT *teams)
{
  char *name = scan_and_allocate();
  if (!checkTeam(teams, name))
  {
    {
      add_lastT(teams, name);
    }
  }
  else
  {
    {
      printf("%d Equipa existente.\n", count);
    }
  }

  free(name);
}

void victory(listT *teams, char *T1, char *T2, int *s1, int *s2)
{
  char *name;
  nodeT *tmp;
  if ((*s1) > (*s2))
  {
    {
      name = T1;
    }
  }
  else
  {
    if ((*s1) < (*s2))
    {
      {
        name = T2;
      }
    }
    else
    {
      {
        return;
      }
    }

  }

  for (tmp = teams->head; tmp; tmp = tmp->next)
  {
    if (strcmp(tmp->name, name) == 0)
    {
      {
        tmp->victories++;
      }
    }
    else
    {
      
    }

  }

}

void addGame(listG *games, listT *teams)
{
  char *name;
  char *team1;
  char *team2;
  int *s1;
  int *s2;
  name = scan_and_allocate();
  team1 = scan_and_allocate();
  team2 = scan_and_allocate();
  s1 = scan_int();
  s2 = scan_int();
  if (!checkGame(games, name))
  {
    {
      if (checkTeam(teams, team1) && checkTeam(teams, team2))
      {
        {
          add_lastG(games, name, team1, team2, s1, s2);
          victory(teams, team1, team2, s1, s2);
        }
      }
      else
      {
        {
          printf("%d Equipa inexistente.\n", count);
        }
      }

    }
  }
  else
  {
    {
      printf("%d Jogo existente.\n", count);
    }
  }

  free(s2);
  free(s1);
  free(team2);
  free(team1);
  free(name);
}

void listGames(listG *games)
{
  nodeG *tmp;
  for (tmp = games->head; tmp; tmp = tmp->next)
  {
    printf("%d %s %s %s %d %d\n", count, tmp->name, tmp->team1, tmp->team2, *tmp->score1, *tmp->score2);
  }

}

void removeGame(listG *games)
{
  char *name = scan_and_allocate();
  if (checkGame(games, name))
  {
    {
      nodeG *tmp;
      for (tmp = games->head; tmp; tmp = tmp->next)
      {
        if (strcmp(tmp->name, name) == 0)
        {
          {
            rm_nodeG(games, tmp);
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    {
      printf("%d Jogo inexistente.\n", count);
    }
  }

  free(name);
}

void changeScore(listG *games)
{
  char *name = scan_and_allocate();
  int *s1 = scan_int();
  int *s2 = scan_int();
  if (checkGame(games, name))
  {
    {
      nodeG *tmp;
      for (tmp = games->head; tmp; tmp = tmp->next)
      {
        if (strcmp(tmp->name, name) == 0)
        {
          {
            *tmp->score1 = *s1;
            *tmp->score2 = *s2;
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    {
      printf("%d Jogo inexistente.\n", count);
    }
  }

  free(name);
}

void searchGame(listG *games)
{
  char *name = scan_and_allocate();
  if (checkGame(games, name))
  {
    {
      nodeG *tmp;
      for (tmp = games->head; tmp; tmp = tmp->next)
      {
        if (strcmp(tmp->name, name) == 0)
        {
          {
            printf("%d %s %s %s %d %d\n", count, tmp->name, tmp->team1, tmp->team2, *tmp->score1, *tmp->score2);
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    {
      printf("%d Jogo inexistente.\n", count);
    }
  }

  free(name);
}

void searchTeam(listT *teams)
{
  char *name = scan_and_allocate();
  if (checkTeam(teams, name))
  {
    {
      nodeT *tmp;
      for (tmp = teams->head; tmp; tmp = tmp->next)
      {
        if (strcmp(tmp->name, name) == 0)
        {
          {
            printf("%d %s %d\n", count, tmp->name, *tmp->victories);
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    {
      printf("%d Equipa inexistente.\n", count);
    }
  }

  free(name);
}

int main()
{
  listT *teams = mk_listT();
  listG *games = mk_listG();
  count = 0;
  while (1)
  {
    char c = getchar();
    switch (c)
    {
      case 'x':
        free_listT(teams);
        free_listG(games);
        exit(0);

      case 'a':
        count++;
        getchar();
        addGame(games, teams);
        break;

      case 'l':
        count++;
        listGames(games);
        break;

      case 'p':
        count++;
        getchar();
        searchGame(games);
        break;

      case 'r':
        count++;
        getchar();
        removeGame(games);
        break;

      case 's':
        count++;
        getchar();
        changeScore(games);
        break;

      case 'A':
        count++;
        getchar();
        addTeam(teams);
        break;

      case 'P':
        count++;
        getchar();
        searchTeam(teams);
        break;

      case 'g':
        count++;
        break;

    }

  }

  return 0;
}

