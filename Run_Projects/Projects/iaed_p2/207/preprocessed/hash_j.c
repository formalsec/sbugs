/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include "funcoes.h"


char *strdup(const char *src)
{
  char *dst = malloc(strlen(src) + 1);
  if (dst == 0)
  {
    return 0;
  }
  else
  {
    
  }

  strcpy(dst, src);
  return dst;
}

int hashCode(char *str, int tamanho)
{
  int i;
  int l;
  int len = strlen(str);
  int valor = 0;
  for (i = 0; i < len; i++)
  {
    l = str[i];
    valor += l;
  }

  return valor % tamanho;
}

int procura_jogo(char *jogo_nome, PRINCIPAL p)
{
  int hashIndex = hashCode(jogo_nome, p->cap_jogos);
  while (p->hashJogo[hashIndex] != 0)
  {
    if (strcmp(p->hashJogo[hashIndex]->nome, jogo_nome) == 0)
    {
      {
        return hashIndex;
      }
    }
    else
    {
      
    }

    ++hashIndex;
    hashIndex %= p->cap_jogos;
  }

  return -1;
}

int insert_jogo(JOGO j, PRINCIPAL p)
{
  int i;
  if (p->tamanho_jogos >= (p->cap_jogos * 0.7))
  {
    {
      p->cap_jogos += 20;
      p->hashJogo = (JOGO *) realloc(p->hashJogo, (sizeof(JOGO)) * p->cap_jogos);
    }
  }
  else
  {
    
  }

  i = hashCode(j->nome, p->cap_jogos);
  while (p->hashJogo[i] != 0)
  {
    ++i;
    i %= p->cap_jogos;
  }

  p->hashJogo[i] = (JOGO) malloc(sizeof(struct jogo));
  p->hashJogo[i]->nome = strdup(j->nome);
  p->hashJogo[i]->equipa1 = strdup(j->equipa1);
  p->hashJogo[i]->equipa2 = strdup(j->equipa2);
  p->hashJogo[i]->score1 = j->score1;
  p->hashJogo[i]->score2 = j->score2;
  p->tamanho_jogos++;
  return 0;
}

void delete_jogo(char *jogo_nome, PRINCIPAL p)
{
  JOGO jogo;
  int i;
  int j;
  i = hashCode(jogo_nome, p->cap_jogos);
  while (p->hashJogo[i] != 0)
  {
    if (strcmp(p->hashJogo[i]->nome, jogo_nome) == 0)
    {
      break;
    }
    else
    {
      i = (i + 1) % p->cap_jogos;
    }

  }

  if (p->hashJogo[i] == 0)
  {
    return;
  }
  else
  {
    
  }

  free(p->hashJogo[i]->nome);
  free(p->hashJogo[i]->equipa1);
  free(p->hashJogo[i]->equipa2);
  free(p->hashJogo[i]);
  p->hashJogo[i] = 0;
  for (j = (i + 1) % p->cap_jogos; p->hashJogo[j] != 0; j = (j + 1) % p->cap_jogos)
  {
    jogo = copia_jogo(jogo, p->hashJogo[j]);
    free_jogo(p->hashJogo[j]);
    p->hashJogo[j] = 0;
    insert_jogo(jogo, p);
    free_jogo(jogo);
    p->tamanho_jogos--;
  }

  p->tamanho_jogos--;
}

void display_jogo(PRINCIPAL p)
{
  int i = 0;
  for (i = 0; i < p->cap_jogos; i++)
  {
    if (p->hashJogo[i] != 0)
    {
      printf("(%s, %s, %s, %d, %d)\n", p->hashJogo[i]->nome, p->hashJogo[i]->equipa1, p->hashJogo[i]->equipa2, p->hashJogo[i]->score1, p->hashJogo[i]->score2);
    }
    else
    {
      printf("~~\n");
    }

  }

  printf("\n");
}

JOGO copia_jogo(JOGO jogo1, JOGO jogo2)
{
  jogo1 = (JOGO) malloc(sizeof(struct jogo));
  jogo1->nome = strdup(jogo2->nome);
  jogo1->equipa1 = strdup(jogo2->equipa1);
  jogo1->equipa2 = strdup(jogo2->equipa2);
  jogo1->score1 = jogo2->score1;
  jogo1->score2 = jogo2->score2;
  return jogo1;
}

void free_jogo(JOGO jogo)
{
  free(jogo->nome);
  free(jogo->equipa1);
  free(jogo->equipa2);
  free(jogo);
  jogo = 0;
}

