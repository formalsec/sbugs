/*File generated by PreProcessor.py*/


#include "TEAMHTABLE.h"
#include "TEAM.h"


int hashT(char *v)
{
  int h = v[0] % 257;
  return h;
}

void teamInit()
{
  int i;
  teamHeads = (teamNode *) malloc(257 * (sizeof(teamNode)));
  for (i = 0; i < 257; i++)
  {
    teamHeads[i] = 0;
  }

}

void teamInsert(Team team)
{
  int i = hashT(team->name);
  if (teamHeads[i] == 0)
  {
    {
      teamHeads[i] = (teamNode) malloc(sizeof(struct teamnode));
      teamHeads[i]->team = team;
      teamHeads[i]->next = 0;
    }
  }
  else
  {
    {
      teamNode newNode = (teamNode) malloc(sizeof(struct teamnode));
      teamNode t;
      teamNode prev;
      newNode->team = team;
      for (t = teamHeads[i], prev = 0; t != 0; prev = t, t = t->next)
      {
        if (strcmp(t->team->name, team->name) > 0)
        {
          {
            if (t == teamHeads[i])
            {
              {
                newNode->next = teamHeads[i];
                teamHeads[i] = newNode;
                break;
              }
            }
            else
            {
              {
                newNode->next = t;
                prev->next = newNode;
                break;
              }
            }

          }
        }
        else
        {
          {
            if (t->next == 0)
            {
              {
                newNode->next = 0;
                t->next = newNode;
                break;
              }
            }
            else
            {
              
            }

          }
        }

      }

    }
  }

}

void teamDelete(Team team)
{
  int i = hashT(team->name);
  teamNode t;
  teamNode prev;
  for (t = teamHeads[i], prev = 0; t != 0; prev = t, t = t->next)
  {
    if (strcmp(t->team->name, team->name) == 0)
    {
      {
        if (t == teamHeads[i])
        {
          {
            teamHeads[i] = t->next;
          }
        }
        else
        {
          if (t->next == 0)
          {
            {
              prev->next = 0;
            }
          }
          else
          {
            {
              prev->next = t->next;
            }
          }

        }

        free(t->team);
        free(t);
        break;
      }
    }
    else
    {
      
    }

  }

}

teamNode teamSearch(char *name)
{
  int i = hashT(name);
  teamNode aux;
  for (aux = teamHeads[i]; aux != 0; aux = aux->next)
  {
    if (strcmp(aux->team->name, name) == 0)
    {
      {
        return aux;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

void teamHashListFREE(teamNode t)
{
  if (t != 0)
  {
    {
      freeTeam(t->team);
      teamHashListFREE(t->next);
      free(t);
    }
  }
  else
  {
    
  }

}

void teamHashFREE()
{
  int i;
  for (i = 0; i < 257; i++)
  {
    teamHashListFREE(teamHeads[i]);
  }

}

void TlistInit()
{
  THeadList = 0;
}

teamNode newTeamNode(Team t, teamNode next)
{
  teamNode x = (teamNode) malloc(sizeof(struct teamnode));
  x->team = t;
  x->next = next;
  return x;
}

void addTeamNodeList(Team t)
{
  if (THeadList == 0)
  {
    {
      THeadList = newTeamNode(t, THeadList);
    }
  }
  else
  {
    {
      teamNode aux;
      aux = THeadList;
      while (aux->next != 0)
      {
        aux = aux->next;
      }

      aux->next = newTeamNode(t, 0);
    }
  }

}

void TfreeHead(teamNode node)
{
  if (node != 0)
  {
    {
      TfreeHead(node->next);
      free(node);
    }
  }
  else
  {
    
  }

}

