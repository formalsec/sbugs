/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "main.h"
#include "struct.h"
#include "add.h"
#include "list.h"
#include "search.h"
#include "remove.h"
#include "change.h"
#include "champs.h"


hashTable games[1999];
hashTable teams[1999];
int counter = 0;
hashTable *startHash(hashTable *hash)
{
  int i;
  for (i = 0; i < 1999; i++)
  {
    hash[i].head = 0;
  }

  return hash;
}

list *startList()
{
  list *ls;
  ls = malloc(sizeof(list));
  ls->head = (ls->end = 0);
  return ls;
}

int getHashKey(char name[1024])
{
  int i;
  int res = 0;
  int len = strlen(name);
  for (i = 0; i < len; i++)
  {
    res += name[i];
  }

  return res % 1999;
}

hashNode *getNodeGames(char n_name[1024])
{
  int i = getHashKey(n_name);
  hashNode *aux = games[i].head;
  while (aux != 0)
  {
    if (strcmp(n_name, aux->point->name) == 0)
    {
      {
        return aux;
      }
    }
    else
    {
      
    }

    aux = aux->next;
  }

  return 0;
}

hashNode *getNodeTeams(char n_name[1024])
{
  int i = getHashKey(n_name);
  hashNode *aux = teams[i].head;
  while (aux != 0)
  {
    if (strcmp(n_name, aux->point->name) == 0)
    {
      {
        return aux;
      }
    }
    else
    {
      
    }

    aux = aux->next;
  }

  return 0;
}

void deleteList(list *ls, int flag)
{
  int i;
  for (i = 0; i < 1999; i++)
  {
    switch (flag)
    {
      case 0:
        while (games[i].head != 0)
      {
        eraseGames(ls, games[i].head->point->name);
        i++;
      }

        break;

      case 1:
        while (teams[i].head != 0)
      {
        eraseTeams(ls, teams[i].head->point->name);
        i++;
      }

        break;

    }

  }

}

int main()
{
  list *lGames;
  list *lTeams;
  char cmd = '\0';
  lGames = startList();
  lTeams = startList();
  startHash(games);
  startHash(teams);
  while (cmd != 'x')
  {
    cmd = getchar();
    switch (cmd)
    {
      case 'a':
        counter++;
        addGame(lGames, lTeams);
        break;

      case 'A':
        counter++;
        addTeam(lTeams);
        break;

      case 'l':
        counter++;
        listGames(lGames);
        break;

      case 'p':
        counter++;
        searchGame();
        break;

      case 'P':
        counter++;
        searchTeam();
        break;

      case 'r':
        counter++;
        removeGame(lGames, lTeams);
        break;

      case 's':
        counter++;
        changeScore(lGames, lTeams);
        break;

      case 'g':
        counter++;
        findChamps(lTeams);
        break;

    }

  }

  deleteList(lGames, 0);
  deleteList(lTeams, 1);
  free(lGames);
  free(lTeams);
  return 0;
}

