/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct Game
{
  char *name;
  char *team_one;
  char *team_two;
  int score[2];
  struct Game *next;
} game;
typedef struct node_t
{
  game *game;
  struct node_t *next;
} Node;
typedef struct Team
{
  char *team_name;
  int wins;
  struct Team *next;
} team;
int teams_counter = 0;
int command_count = 0;
static team *teams[619] = {0};
static game *hashtable[619] = {0};
static Node *head = 0;
static Node *tail = 0;
static team *team_head = 0;
static team *team_tail = 0;
void initializeHashTables()
{
  int i;
  for (i = 0; i < 619; i++)
  {
    hashtable[i] = 0;
    teams[i] = 0;
  }

}

void insertTeamList(team *t)
{
  team *temp;
  temp = t;
  temp->next = 0;
  if (team_head == 0)
  {
    {
      team_head = temp;
      team_tail = temp;
    }
  }
  else
  {
    {
      team_tail->next = temp;
      team_tail = temp;
    }
  }

}

void insertList(game *g)
{
  Node *temp = (Node *) malloc(sizeof(Node));
  temp->game = g;
  temp->next = 0;
  if (head == 0)
  {
    {
      head = temp;
      tail = temp;
    }
  }
  else
  {
    {
      tail->next = temp;
      tail = temp;
    }
  }

}

void insertHashTeam(team *t, unsigned long key)
{
  team *temp;
  if (!teams[key])
  {
    {
      teams[key] = t;
    }
  }
  else
  {
    {
      for (temp = teams[key]; temp->next != 0; temp = temp->next)
        ;

      temp->next = t;
    }
  }

}

void insertHashName(game *g, unsigned long key)
{
  game *temp;
  if (!hashtable[key])
  {
    {
      hashtable[key] = g;
    }
  }
  else
  {
    {
      for (temp = hashtable[key]; temp->next != 0; temp = temp->next)
        ;

      temp->next = g;
    }
  }

}

game *read_game()
{
  game *inputPtr;
  char name[3080];
  char team_one[3080];
  char team_two[3080];
  int score_one;
  int score_two;
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  for (int team_one_index = 0; team_one_index < 10; team_one_index++)
  {
    team_one[team_one_index] = new_sym_var(sizeof(char) * 8);
  }

  team_one[10 - 1] = '\0';
  for (int team_two_index = 0; team_two_index < 10; team_two_index++)
  {
    team_two[team_two_index] = new_sym_var(sizeof(char) * 8);
  }

  team_two[10 - 1] = '\0';
  score_one = new_sym_var(sizeof(int) * 8);
  score_two = new_sym_var(sizeof(int) * 8);
  inputPtr = (game *) malloc(sizeof(game));
  inputPtr->name = malloc((sizeof(char)) * (strlen(name) + 1));
  inputPtr->team_one = malloc((sizeof(char)) * (strlen(team_one) + 1));
  inputPtr->team_two = malloc((sizeof(char)) * (strlen(team_two) + 1));
  inputPtr->score[0] = score_one;
  inputPtr->score[1] = score_two;
  strcpy(inputPtr->name, name);
  strcpy(inputPtr->team_one, team_one);
  strcpy(inputPtr->team_two, team_two);
  return inputPtr;
}

unsigned long getKey(char name[1023])
{
  unsigned int i;
  unsigned long car;
  unsigned long string = 0;
  for (i = 0; i < strlen(name); i++)
  {
    car = name[i];
    string += car * i;
  }

  return string % 619;
}

void deleteHash(char *name, char *team_one, char *team_two, unsigned long key)
{
  game *t;
  game *prev;
  for (t = hashtable[key], prev = 0; t != 0; prev = t, t = t->next)
  {
    if (((strcmp(t->name, name) == 0) && (strcmp(t->team_one, team_one) == 0)) && (strcmp(t->team_two, team_two) == 0))
    {
      {
        if (t == hashtable[key])
        {
          hashtable[key] = t->next;
        }
        else
        {
          prev->next = t->next;
        }

      }
    }
    else
    {
      
    }

  }

}

void deleteList(char *name, char *team_one, char *team_two)
{
  Node *t;
  Node *prev;
  for (t = head, prev = 0; t != 0; prev = t, t = t->next)
  {
    if (((strcmp(t->game->name, name) == 0) && (strcmp(t->game->team_one, team_one) == 0)) && (strcmp(t->game->team_two, team_two) == 0))
    {
      {
        if (t == head)
        {
          head = t->next;
        }
        else
        {
          if (t == tail)
          {
            {
              tail = prev;
              prev->next = t->next;
            }
          }
          else
          {
            prev->next = t->next;
          }

        }

      }
    }
    else
    {
      
    }

  }

}

int team_error(char name[1023], unsigned long key)
{
  team *node;
  for (node = teams[key]; node != 0; node = node->next)
    if (strcmp(node->team_name, name) == 0)
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

int game_error(char name[1023], unsigned long key)
{
  game *node;
  for (node = hashtable[key]; node != 0; node = node->next)
    if (strcmp(node->name, name) == 0)
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

void increment_win(game *g, unsigned long key1, unsigned long key2)
{
  team *node;
  if (g->score[0] > g->score[1])
  {
    {
      for (node = teams[key1]; node != 0; node = node->next)
        if (strcmp(node->team_name, g->team_one) == 0)
      {
        {
          node->wins++;
          return;
        }
      }
      else
      {
        
      }


    }
  }
  else
  {
    if (g->score[0] < g->score[1])
    {
      {
        for (node = teams[key2]; node != 0; node = node->next)
          if (strcmp(node->team_name, g->team_two) == 0)
        {
          {
            node->wins++;
            return;
          }
        }
        else
        {
          
        }


      }
    }
    else
    {
      
    }

  }

}

void command_a()
{
  game *inputPtr;
  unsigned long key;
  inputPtr = read_game();
  inputPtr->next = 0;
  key = getKey(inputPtr->name);
  if (game_error(inputPtr->name, key) != 0)
  {
    {
      printf("%d Jogo existente.\n", command_count);
    }
  }
  else
  {
    if ((team_error(inputPtr->team_one, getKey(inputPtr->team_one)) == 0) || (team_error(inputPtr->team_two, getKey(inputPtr->team_two)) == 0))
    {
      {
        printf("%d Equipa inexistente.\n", command_count);
      }
    }
    else
    {
      {
        insertHashName(inputPtr, key);
        insertList(inputPtr);
        increment_win(inputPtr, getKey(inputPtr->team_one), getKey(inputPtr->team_two));
      }
    }

  }

}

void command_p()
{
  game *node;
  unsigned long key;
  char name[1023];
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  key = getKey(name);
  for (node = hashtable[key]; node != 0; node = node->next)
    if (strcmp(node->name, name) == 0)
  {
    {
      printf("%d %s %s %s %d %d\n", command_count, node->name, node->team_one, node->team_two, node->score[0], node->score[1]);
      return;
    }
  }
  else
  {
    
  }


  printf("%d Jogo inexistente.\n", command_count);
}

void command_r()
{
  game *t;
  unsigned long key;
  char name[1023];
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  key = getKey(name);
  for (t = hashtable[key]; t != 0; t = t->next)
  {
    if (strcmp(t->name, name) == 0)
    {
      {
        deleteList(t->name, t->team_one, t->team_two);
        deleteHash(t->name, t->team_one, t->team_two, key);
        return;
      }
    }
    else
    {
      
    }

  }

  printf("%d Jogo inexistente.\n", command_count);
}

void command_s()
{
  game *node;
  unsigned long key;
  char name[3080];
  int score_one = 0;
  int score_two = 0;
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  score_one = new_sym_var(sizeof(int) * 8);
  score_two = new_sym_var(sizeof(int) * 8);
  key = getKey(name);
  for (node = hashtable[key]; node != 0; node = node->next)
    if (strcmp(node->name, name) == 0)
  {
    {
      node->score[0] = score_one;
      node->score[1] = score_two;
      return;
    }
  }
  else
  {
    
  }


  printf("%d Jogo inexistente.\n", command_count);
}

void command_l()
{
  Node *node = head;
  for (; node != 0; node = node->next)
  {
    printf("%d %s %s %s %d %d\n", command_count, node->game->name, node->game->team_one, node->game->team_two, node->game->score[0], node->game->score[1]);
  }

}

void command_A()
{
  team *inputPtr = malloc(sizeof(team));
  unsigned long key;
  char name[1023];
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  key = getKey(name);
  inputPtr->team_name = malloc((sizeof(char)) * (strlen(name) + 1));
  strcpy(inputPtr->team_name, name);
  inputPtr->next = 0;
  if (team_error(inputPtr->team_name, key) != 0)
  {
    {
      printf("%d Equipa existente.\n", command_count);
    }
  }
  else
  {
    {
      insertHashTeam(inputPtr, key);
      insertTeamList(inputPtr);
      teams_counter++;
    }
  }

}

void command_P()
{
  team *node = 0;
  unsigned long key;
  char name[1023] = {0};
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  key = getKey(name);
  for (node = teams[key]; node != 0; node = node->next)
    if (strcmp(node->team_name, name) == 0)
  {
    {
      printf("%d %s %d\n", command_count, node->team_name, node->wins);
      return;
    }
  }
  else
  {
    
  }


  printf("%d Equipa inexistente.\n", command_count);
}

void command_g()
{
  team *node = team_head;
  int max_wins = 0;
  int count = 0;
  char **max_wins_teams;
  char temp[1023] = {0};
  int i;
  int j;
  if (teams_counter == 0)
  {
    return;
  }
  else
  {
    
  }

  max_wins_teams = malloc(teams_counter * (sizeof(char *)));
  for (i = 0; i < teams_counter; i++)
    max_wins_teams[i] = malloc(1023 + 1);

  for (; node != 0; node = node->next)
  {
    if (node->wins > max_wins)
    {
      max_wins = node->wins;
    }
    else
    {
      
    }

    teams_counter++;
  }

  for (node = team_head, i = 0; node != 0; node = node->next, i++)
    if (node->wins == max_wins)
  {
    {
      strcpy(max_wins_teams[i], node->team_name);
      count++;
    }
  }
  else
  {
    
  }


  for (i = 0; i < count; ++i)
  {
    for (j = i + 1; j < count; ++j)
    {
      if (strcmp(max_wins_teams[i], max_wins_teams[j]) > 0)
      {
        {
          strcpy(temp, max_wins_teams[i]);
          strcpy(max_wins_teams[i], max_wins_teams[j]);
          strcpy(max_wins_teams[j], temp);
        }
      }
      else
      {
        
      }

    }

  }

  printf("%d Melhores %d\n", command_count, max_wins);
  for (i = 0; i < count; ++i)
    printf("%d * %s\n", command_count, max_wins_teams[i]);

}

void freeList()
{
  Node *temp;
  team *temp_t;
  while (head != 0)
  {
    temp = head;
    head = head->next;
    free(temp->game->name);
    free(temp->game->team_one);
    free(temp->game->team_two);
    free(temp->game);
    free(temp);
  }

  while (team_head != 0)
  {
    temp_t = team_head;
    team_head = team_head->next;
    free(temp_t->team_name);
    free(temp_t);
  }

}

void freeHash()
{
  game *temp;
  team *temp_t;
  int i;
  for (i = 0; i < 619; i++)
  {
    while (hashtable[i] != 0)
    {
      temp = hashtable[i];
      hashtable[i] = hashtable[i]->next;
      if (temp->name)
      {
        free(temp->name);
      }
      else
      {
        
      }

      if (temp->team_two)
      {
        free(temp->team_two);
      }
      else
      {
        
      }

      if (temp->team_one)
      {
        free(temp->team_one);
      }
      else
      {
        
      }

      free(temp);
    }

    while (teams[i] != 0)
    {
      temp_t = teams[i];
      teams[i] = teams[i]->next;
      if (temp_t->team_name)
      {
        free(temp_t->team_name);
      }
      else
      {
        
      }

      free(temp_t);
    }

  }

}

int main()
{
  initializeHashTables();
  for (;;)
  {
    switch (getchar())
    {
      case 'a':
        getchar();
        command_count++;
        command_a();
        break;

      case 'l':
        getchar();
        command_count++;
        command_l();
        break;

      case 'p':
        getchar();
        command_count++;
        command_p();
        break;

      case 'r':
        getchar();
        command_count++;
        command_r();
        break;

      case 's':
        getchar();
        command_count++;
        command_s();
        break;

      case 'A':
        getchar();
        command_count++;
        command_A();
        break;

      case 'P':
        getchar();
        command_count++;
        command_P();
        break;

      case 'g':
        getchar();
        command_count++;
        command_g();
        break;

      case 'x':
        freeList();
        return 0;

      default:
        break;

    }

  }

}

