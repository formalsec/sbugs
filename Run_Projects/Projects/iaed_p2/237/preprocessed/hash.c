/*File generated by PreProcessor.py*/


#include "hash.h"


unsigned int hash(const char *key)
{
  unsigned long int value = 0;
  unsigned int i = 0;
  unsigned int key_len = strlen(key);
  for (; i < key_len; i++)
  {
    value = (value * 37) + key[i];
  }

  value = value % 5000;
  return value;
}

ht *hash_init()
{
  int i;
  ht *hashtable = malloc(sizeof(ht));
  hashtable->entries = malloc((sizeof(entry *)) * 5000);
  i = 0;
  for (; i < 5000; i++)
  {
    hashtable->entries[i] = 0;
  }

  return hashtable;
}

entry *ht_pair_team(unsigned int key, char *buffer)
{
  entry *entrie = malloc(sizeof(entry));
  entrie->t = malloc(sizeof(Team));
  entrie->t->nome = malloc((sizeof(char)) * (strlen(buffer) + 1));
  entrie->t->wins = 0;
  strcpy(entrie->t->nome, buffer);
  entrie->key = key;
  entrie->next = 0;
  return entrie;
}

entry *ht_pair_game(unsigned int key, char *buffer, Team *t1, Team *t2, int score1, int score2, int *maxWins)
{
  entry *entrie = malloc(sizeof(entry));
  entrie->game = malloc(sizeof(Game));
  entrie->game->gameName = malloc((sizeof(char)) * (strlen(buffer) + 1));
  entrie->game->t1 = t1;
  entrie->game->t2 = t2;
  entrie->game->score1 = score1;
  entrie->game->score2 = score2;
  strcpy(entrie->game->gameName, buffer);
  entrie->key = key;
  entrie->next = 0;
  if (score1 > score2)
  {
    {
      t1->wins++;
      if (t1->wins > (*maxWins))
      {
        *maxWins = t1->wins;
      }
      else
      {
        
      }

    }
  }
  else
  {
    if (score2 > score1)
    {
      {
        t2->wins++;
        if (t2->wins > (*maxWins))
        {
          *maxWins = t2->wins;
        }
        else
        {
          
        }

      }
    }
    else
    {
      
    }

  }

  return entrie;
}

Team *addTeam(ht *hashtable, int cmd_count)
{
  char teamname[1023];
  entry *entrie;
  entry *prev;
  unsigned int key;
  for (int teamname_index = 0; teamname_index < 10; teamname_index++)
  {
    teamname[teamname_index] = new_sym_var(sizeof(char) * 8);
  }

  teamname[10 - 1] = '\0';
  key = hash(teamname);
  entrie = hashtable->entries[key];
  if (entrie == 0)
  {
    {
      hashtable->entries[key] = ht_pair_team(key, teamname);
      return hashtable->entries[key]->t;
    }
  }
  else
  {
    
  }

  while (entrie != 0)
  {
    if ((strcmp(entrie->t->nome, teamname) != 0) && (entrie->next == 0))
    {
      {
        entrie->next = ht_pair_team(key, teamname);
        return entrie->next->t;
      }
    }
    else
    {
      if (strcmp(entrie->t->nome, teamname) == 0)
      {
        {
          printf("%d Equipa existente.\n", cmd_count);
          return 0;
        }
      }
      else
      {
        
      }

    }

    prev = entrie;
    entrie = prev->next;
  }

  prev->next = ht_pair_team(key, teamname);
  return prev->next->t;
}

Team *teamSearch(ht *hashtable, char *name)
{
  entry *entrie;
  unsigned int key;
  key = hash(name);
  entrie = hashtable->entries[key];
  if (entrie == 0)
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  while (entrie != 0)
  {
    if (strcmp(entrie->t->nome, name) == 0)
    {
      {
        return entrie->t;
      }
    }
    else
    {
      
    }

    entrie = entrie->next;
  }

  return 0;
}

void getTeam(ht *hashtable, int cmd_count)
{
  char name[1023];
  Team *team;
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  team = teamSearch(hashtable, name);
  if (team == 0)
  {
    {
      printf("%d Equipa inexistente.\n", cmd_count);
    }
  }
  else
  {
    {
      printf("%d %s %d\n", cmd_count, team->nome, team->wins);
    }
  }

}

int searchGame(entry *entrie, char *buffer)
{
  entry *aux = entrie;
  if (aux == 0)
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  if (aux->game != 0)
  {
    {
      while (strcmp(aux->game->gameName, buffer) != 0)
      {
        if (aux->next == 0)
        {
          {
            return 0;
          }
        }
        else
        {
          
        }

        aux = aux->next;
      }

      return 1;
    }
  }
  else
  {
    return 0;
  }

}

void getGame(ht *game_ht, int cmd_count)
{
  char name[1023];
  entry *entrie;
  int key;
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  key = hash(name);
  entrie = game_ht->entries[key];
  if (!searchGame(entrie, name))
  {
    {
      printf("%d Jogo inexistente.\n", cmd_count);
    }
  }
  else
  {
    {
      while ((entrie->game != 0) && (strcmp(entrie->game->gameName, name) != 0))
      {
        entrie = entrie->next;
      }

      printf("%d %s %s %s %d %d\n", cmd_count, entrie->game->gameName, entrie->game->t1->nome, entrie->game->t2->nome, entrie->game->score1, entrie->game->score2);
    }
  }

}

Game *addGame(ht *hashtable, ht *game_ht, int cmd_count, int *game_count, int *maxWins)
{
  char gameName[1023];
  char t1_name[1023];
  char t2_name[1023];
  int score1;
  int score2;
  Team *t1;
  Team *t2;
  entry *entrie;
  entry *prev;
  unsigned int key;
  for (int gameName_index = 0; gameName_index < 10; gameName_index++)
  {
    gameName[gameName_index] = new_sym_var(sizeof(char) * 8);
  }

  gameName[10 - 1] = '\0';
  for (int t1_name_index = 0; t1_name_index < 10; t1_name_index++)
  {
    t1_name[t1_name_index] = new_sym_var(sizeof(char) * 8);
  }

  t1_name[10 - 1] = '\0';
  for (int t2_name_index = 0; t2_name_index < 10; t2_name_index++)
  {
    t2_name[t2_name_index] = new_sym_var(sizeof(char) * 8);
  }

  t2_name[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  t1 = teamSearch(hashtable, t1_name);
  t2 = teamSearch(hashtable, t2_name);
  key = hash(gameName);
  entrie = game_ht->entries[key];
  if (entrie == 0)
  {
    {
      if ((t1 == 0) || (t2 == 0))
      {
        {
          printf("%d Equipa inexistente.\n", cmd_count);
          return 0;
        }
      }
      else
      {
        
      }

      game_ht->entries[key] = ht_pair_game(key, gameName, t1, t2, score1, score2, maxWins);
      (*game_count)++;
      return game_ht->entries[key]->game;
    }
  }
  else
  {
    
  }

  while (entrie != 0)
  {
    if (((((strcmp(entrie->game->gameName, gameName) != 0) && (entrie->next == 0)) && (entrie->game != 0)) && (t1 != 0)) && (t2 != 0))
    {
      {
        entrie->next = ht_pair_game(key, gameName, t1, t2, score1, score2, maxWins);
        (*game_count)++;
        return entrie->next->game;
      }
    }
    else
    {
      if (strcmp(entrie->game->gameName, gameName) == 0)
      {
        {
          printf("%d Jogo existente.\n", cmd_count);
          return 0;
        }
      }
      else
      {
        
      }

    }

    prev = entrie;
    entrie = prev->next;
  }

  if ((t1 == 0) || (t2 == 0))
  {
    {
      printf("%d Equipa inexistente.\n", cmd_count);
      return 0;
    }
  }
  else
  {
    
  }

  prev->next = ht_pair_game(key, gameName, t1, t2, score1, score2, maxWins);
  (*game_count)++;
  return prev->next->game;
}

void changeScore(ht *game_ht, int cmd_count)
{
  char buffer[1023];
  entry *entrie;
  int key;
  int score1;
  int score2;
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  key = hash(buffer);
  entrie = game_ht->entries[key];
  if (!searchGame(entrie, buffer))
  {
    {
      printf("%d Jogo inexistente.\n", cmd_count);
      return;
    }
  }
  else
  {
    
  }

  while (strcmp(entrie->game->gameName, buffer) != 0)
  {
    entrie = entrie->next;
  }

  if (entrie->game->score1 > entrie->game->score2)
  {
    {
      entrie->game->t1->wins--;
    }
  }
  else
  {
    if (entrie->game->score2 > entrie->game->score1)
    {
      {
        entrie->game->t2->wins--;
      }
    }
    else
    {
      
    }

  }

  if (score1 > score2)
  {
    {
      entrie->game->t1->wins++;
    }
  }
  else
  {
    if (score2 > score1)
    {
      {
        entrie->game->t2->wins++;
      }
    }
    else
    {
      
    }

  }

  entrie->game->score1 = score1;
  entrie->game->score2 = score2;
}

entry *destroyTeamEntry(entry *head)
{
  entry *new = head;
  while (new != 0)
  {
    entry *aux = new->next;
    free(new->t->nome);
    free(new->t);
    free(new);
    new = aux;
  }

  return 0;
}

entry *destroyGameEntry(entry *head)
{
  entry *new = head;
  while (new != 0)
  {
    entry *aux = new->next;
    free(new->game->gameName);
    free(new->game);
    free(new);
    new = aux;
  }

  return 0;
}

void destroyTeam(ht *hashtable)
{
  int i;
  for (i = 0; i < 5000; i++)
  {
    if (hashtable->entries[i] == 0)
    {
      {
        continue;
      }
    }
    else
    {
      {
        destroyTeamEntry(hashtable->entries[i]);
      }
    }

  }

  free(hashtable->entries);
  free(hashtable);
}

void destroyGame(ht *hashtable)
{
  int i;
  for (i = 0; i < 5000; i++)
  {
    if (hashtable->entries[i] == 0)
    {
      {
        continue;
      }
    }
    else
    {
      {
        destroyGameEntry(hashtable->entries[i]);
      }
    }

  }

  free(hashtable->entries);
  free(hashtable);
}

