/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "proj2_h.h"


int main()
{
  list_j *ls_j = mk_list_j();
  list_e *ls_e = mk_list_e();
  char command;
  char n[1024];
  char e1[1024];
  char e2[1024];
  int s1;
  int s2;
  int count = 1;
  Init_hash_j(107);
  Init_hash_e(107);
  do
  {
    switch (command = getchar())
    {
      case 'a':
      {
        link_e eq1;
        link_e eq2;
        link_e venc;
        getchar();
        for (int n_index = 0; n_index < 10; n_index++)
        {
          n[n_index] = new_sym_var(sizeof(char) * 8);
        }

        n[10 - 1] = '\0';
        for (int e1_index = 0; e1_index < 10; e1_index++)
        {
          e1[e1_index] = new_sym_var(sizeof(char) * 8);
        }

        e1[10 - 1] = '\0';
        for (int e2_index = 0; e2_index < 10; e2_index++)
        {
          e2[e2_index] = new_sym_var(sizeof(char) * 8);
        }

        e2[10 - 1] = '\0';
        s1 = new_sym_var(sizeof(int) * 8);
        s2 = new_sym_var(sizeof(int) * 8);
        eq1 = lookup_e(e1);
        eq2 = lookup_e(e2);
        if (lookup_j(n) == 0)
        {
          {
            if ((eq1 != 0) && (eq2 != 0))
            {
              {
                insertEnd_j(ls_j, n, eq1, eq2, s1, s2);
                insert_h_j(ls_j->last);
                if (s1 != s2)
                {
                  {
                    if (s1 > s2)
                    {
                      venc = eq1;
                    }
                    else
                    {
                      if (s1 < s2)
                      {
                        venc = eq2;
                      }
                      else
                      {
                        
                      }

                    }

                    venc->jogos_ganhos += 1;
                  }
                }
                else
                {
                  
                }

              }
            }
            else
            {
              printf("%d Equipa inexistente.\n", count);
            }

          }
        }
        else
        {
          printf("%d Jogo existente.\n", count);
        }

        break;
      }

      case 'A':
      {
        getchar();
        for (int n_index = 0; n_index < 10; n_index++)
        {
          n[n_index] = new_sym_var(sizeof(char) * 8);
        }

        n[10 - 1] = '\0';
        if (lookup_e(n) == 0)
        {
          {
            insertEnd_e(ls_e, n);
            insert_h_e(ls_e->last);
          }
        }
        else
        {
          printf("%d Equipa existente.\n", count);
        }

        break;
      }

      case 'l':
      {
        link_j t;
        for (t = ls_j->head; t != 0; t = t->next)
          printf("%d %s %s %s %d %d\n", count, t->nome, t->equ1->nome, t->equ2->nome, t->sco1, t->sco2);

        break;
      }

      case 'p':
      {
        link_j t;
        getchar();
        for (int n_index = 0; n_index < 10; n_index++)
        {
          n[n_index] = new_sym_var(sizeof(char) * 8);
        }

        n[10 - 1] = '\0';
        t = lookup_j(n);
        if (t != 0)
        {
          {
            printf("%d %s %s %s %d %d\n", count, t->nome, t->equ1->nome, t->equ2->nome, t->sco1, t->sco2);
          }
        }
        else
        {
          printf("%d Jogo inexistente.\n", count);
        }

        break;
      }

      case 'P':
      {
        link_e t;
        getchar();
        for (int n_index = 0; n_index < 10; n_index++)
        {
          n[n_index] = new_sym_var(sizeof(char) * 8);
        }

        n[10 - 1] = '\0';
        t = lookup_e(n);
        if (t != 0)
        {
          printf("%d %s %d\n", count, t->nome, t->jogos_ganhos);
        }
        else
        {
          printf("%d Equipa inexistente.\n", count);
        }

        break;
      }

      case 'r':
      {
        link_j j;
        getchar();
        for (int n_index = 0; n_index < 10; n_index++)
        {
          n[n_index] = new_sym_var(sizeof(char) * 8);
        }

        n[10 - 1] = '\0';
        j = lookup_j(n);
        if (j != 0)
        {
          {
            s1 = j->sco1;
            s2 = j->sco2;
            if (s1 != s2)
            {
              {
                if (s1 > s2)
                {
                  j->equ1->jogos_ganhos -= 1;
                }
                else
                {
                  if (s1 < s2)
                  {
                    j->equ2->jogos_ganhos -= 1;
                  }
                  else
                  {
                    
                  }

                }

              }
            }
            else
            {
              
            }

            delete_h_j(j);
            delete_j(ls_j, j);
          }
        }
        else
        {
          printf("%d Jogo inexistente.\n", count);
        }

        break;
      }

      case 's':
      {
        link_j t;
        getchar();
        for (int n_index = 0; n_index < 10; n_index++)
        {
          n[n_index] = new_sym_var(sizeof(char) * 8);
        }

        n[10 - 1] = '\0';
        s1 = new_sym_var(sizeof(int) * 8);
        s2 = new_sym_var(sizeof(int) * 8);
        t = lookup_j(n);
        if (t != 0)
        {
          {
            if ((t->sco1 == t->sco2) && (s1 > s2))
            {
              t->equ1->jogos_ganhos++;
            }
            else
            {
              if ((t->sco1 == t->sco2) && (s1 < s2))
              {
                t->equ2->jogos_ganhos++;
              }
              else
              {
                if ((t->sco1 > t->sco2) && (s1 == s2))
                {
                  t->equ1->jogos_ganhos--;
                }
                else
                {
                  if ((t->sco1 > t->sco2) && (s1 < s2))
                  {
                    {
                      t->equ1->jogos_ganhos--;
                      t->equ2->jogos_ganhos++;
                    }
                  }
                  else
                  {
                    if ((t->sco1 < t->sco2) && (s1 == s2))
                    {
                      t->equ2->jogos_ganhos--;
                    }
                    else
                    {
                      if ((t->sco1 < t->sco2) && (s1 > s2))
                      {
                        {
                          t->equ1->jogos_ganhos++;
                          t->equ2->jogos_ganhos--;
                        }
                      }
                      else
                      {
                        
                      }

                    }

                  }

                }

              }

            }

            t->sco1 = s1;
            t->sco2 = s2;
          }
        }
        else
        {
          printf("%d Jogo inexistente.\n", count);
        }

        break;
      }

      case 'g':
      {
        link_e t;
        list_e *ls_v = mk_list_e();
        int i;
        int i1;
        int maior;
        char **arr;
        i1 = 0;
        maior = get_higher_score(ls_e, ls_v);
        for (t = ls_v->head; t; t = t->next)
          i1++;

        arr = malloc((sizeof(char *)) * (i1 + 1));
        for (i = 0, t = ls_v->head; t; i++, t = t->next)
        {
          arr[i] = malloc((sizeof(char)) * (strlen(t->nome) + 1));
          strcpy(arr[i], t->nome);
        }

        qsort(arr, i, sizeof(char *), cstring_cmp);
        for (i = 0; i != i1; i++)
        {
          if (i == 0)
          {
            printf("%d Melhores %d\n", count, maior);
          }
          else
          {
            
          }

          printf("%d * %s\n", count, arr[i]);
        }

        for (i = 0; i != i1; i++)
        {
          free(arr[i]);
        }

        for (t = ls_v->head; t; t = ls_v->head)
          delete_e(ls_v, t);

        free(ls_v);
        free(arr);
        break;
      }

      case 'x':
      {
        link_j t;
        link_e t1;
        for (t = ls_j->head; t; t = ls_j->head)
        {
          delete_h_j(t);
          delete_j(ls_j, t);
        }

        for (t1 = ls_e->head; t1; t1 = ls_e->head)
        {
          delete_h_e(t1);
          delete_e(ls_e, t1);
        }

        free(ls_j);
        free(ls_e);
        free(head_h_e);
        free(head_h_j);
        break;
      }

    }

    getchar();
    count++;
  }
  while (command != 'x');
  return 0;
}

