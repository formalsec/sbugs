/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <string.h>
#include "tabela_jogos.h"


size_t hash_j(const char *s, size_t max)
{
  size_t h = 0;
  size_t a = 31415;
  size_t b = 27183;
  for (; (*s) != '\0'; s++, a = (a * b) % (max - 1))
    h = ((a * h) + (*s)) % max;

  return h;
}

jogos *inic_jogos(size_t max)
{
  jogos *t = malloc(sizeof(jogos));
  t->capacidade = max;
  t->sz = 0;
  t->tb = calloc(t->capacidade, sizeof(jogos));
  return t;
}

char *insere_str(const char *s)
{
  char *esp = malloc((strlen(s) + 1) * (sizeof(char)));
  strcpy(esp, s);
  return esp;
}

jogo *make_jogo(const char *nome, const char *neq1, const char *neq2, size_t s1, size_t s2)
{
  jogo *new_j = malloc(sizeof(jogo));
  new_j->nome = insere_str(nome);
  new_j->equipa1 = insere_str(neq1);
  new_j->equipa2 = insere_str(neq2);
  new_j->score1 = s1;
  new_j->score2 = s2;
  return new_j;
}

int procura_j(const char *nome, jogos *tb_j)
{
  size_t h = hash_j(nome, tb_j->capacidade);
  while (tb_j->tb[h])
  {
    if (strcmp(tb_j->tb[h]->nome, nome) == 0)
    {
      return h;
    }
    else
    {
      h = (h + 1) % tb_j->capacidade;
    }

  }

  return -1;
}

void free_jogo(jogo *j)
{
  free(j->nome);
  free(j->equipa1);
  free(j->equipa2);
  free(j);
}

jogos *expand_j(jogos *tb_j)
{
  size_t i;
  jogos *old = tb_j;
  tb_j->capacidade *= 2;
  tb_j = inic_jogos(tb_j->capacidade);
  for (i = 0; i < (tb_j->capacidade / 2); i++)
  {
    if (old->tb[i])
    {
      tb_j = insere_j(old->tb[i], tb_j);
    }
    else
    {
      
    }

  }

  free(old->tb);
  free(old);
  return tb_j;
}

jogos *insere_j(jogo *j, jogos *tb_j)
{
  size_t h = hash_j(j->nome, tb_j->capacidade);
  while (tb_j->tb[h])
    h = (h + 1) % tb_j->capacidade;

  tb_j->tb[h] = j;
  if ((tb_j->sz++) > (tb_j->capacidade / 2))
  {
    tb_j = expand_j(tb_j);
  }
  else
  {
    
  }

  return tb_j;
}

void reinsere_seguintes(size_t hash, jogos *tb_j)
{
  size_t i;
  size_t tam = tb_j->capacidade;
  jogo *tmp;
  for (i = (hash + 1) % tam; tb_j->tb[i]; i = (i + 1) % tam)
  {
    tmp = tb_j->tb[i];
    tb_j->tb[i] = 0;
    tb_j->sz--;
    tb_j = insere_j(tmp, tb_j);
  }

}

void remove_jogo(size_t hash, jogos *tb_j)
{
  free_jogo(tb_j->tb[hash]);
  tb_j->tb[hash] = 0;
  tb_j->sz--;
  reinsere_seguintes(hash, tb_j);
}

void free_jogos(jogos *tb_j)
{
  size_t i;
  for (i = 0; i < tb_j->capacidade; i++)
    if (tb_j->tb[i])
  {
    free_jogo(tb_j->tb[i]);
  }
  else
  {
    
  }


  free(tb_j->tb);
  free(tb_j);
}

