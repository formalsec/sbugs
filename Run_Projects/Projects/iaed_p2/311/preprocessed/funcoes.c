/*File generated by PreProcessor.py*/


#include "jogo.h"
#include "equipa.h"
#include "hash.h"
#include "funcoes.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


void addJ(hashJ hash, hashE teams, link_J *jogos, int count, int *wins, int *flag, Equipa *new)
{
  Jogo x;
  link_E node1;
  link_E node2;
  Equipa equipa = 0;
  char nome[1024];
  char equipa1[1024];
  char equipa2[1024];
  int score1;
  int score2;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  for (int equipa1_index = 0; equipa1_index < 10; equipa1_index++)
  {
    equipa1[equipa1_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa1[10 - 1] = '\0';
  for (int equipa2_index = 0; equipa2_index < 10; equipa2_index++)
  {
    equipa2[equipa2_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  if (procura_hash_jogo(hash, nome, 1013) != 0)
  {
    {
      printf("%d Jogo existente.\n", count);
      return;
    }
  }
  else
  {
    
  }

  node1 = procura_hash_equipa(teams, equipa1, 1013);
  node2 = procura_hash_equipa(teams, equipa2, 1013);
  if ((node1 == 0) || (node2 == 0))
  {
    {
      printf("%d Equipa inexistente.\n", count);
      return;
    }
  }
  else
  {
    
  }

  if (score1 > score2)
  {
    {
      equipa = node1->equipa;
    }
  }
  else
  {
    if (score2 > score1)
    {
      {
        equipa = node2->equipa;
      }
    }
    else
    {
      
    }

  }

  if (equipa != 0)
  {
    {
      if ((++equipa->wins) > (*wins))
      {
        {
          (*wins)++;
          *flag = 2;
          *new = equipa;
        }
      }
      else
      {
        if (equipa->wins == (*wins))
        {
          {
            *flag = 1;
            *new = equipa;
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    
  }

  x = inicializa_jogo(nome, equipa1, equipa2, score1, score2);
  hash = insere_hash_jogo(hash, x, 1013);
  *jogos = insertBeginJ(*jogos, x);
  return;
}

void print_lista_jogos(link_J head, int contador)
{
  print_inverso(head, contador);
  return;
}

void procura_jogo(hashJ jogos, int contador)
{
  char nome[1024];
  link_J jogo;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  jogo = procura_hash_jogo(jogos, nome, 1013);
  if (jogo == 0)
  {
    printf("%d Jogo inexistente.\n", contador);
  }
  else
  {
    {
      printf("%d ", contador);
      printNodeJ(jogo);
    }
  }

  return;
}

void apaga_jogo(hashJ jogos, hashE equipas, link_J *lista, link_E *winners, int contador, int *flag)
{
  link_J node;
  Equipa equipa = 0;
  char nome[1024];
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  node = procura_hash_jogo(jogos, nome, 1013);
  if (node == 0)
  {
    {
      printf("%d Jogo inexistente.\n", contador);
      return;
    }
  }
  else
  {
    
  }

  if (node->jogo->score1 > node->jogo->score2)
  {
    {
      equipa = procura_hash_equipa(equipas, node->jogo->equipa1, 1013)->equipa;
    }
  }
  else
  {
    if (node->jogo->score2 > node->jogo->score1)
    {
      {
        equipa = procura_hash_equipa(equipas, node->jogo->equipa2, 1013)->equipa;
      }
    }
    else
    {
      
    }

  }

  if (equipa != 0)
  {
    {
      *winners = deleteE(*winners, equipa->nome);
      equipa->wins--;
    }
  }
  else
  {
    
  }

  if ((*winners) == 0)
  {
    *flag = 3;
  }
  else
  {
    
  }

  jogos = retira_hash_jogo(jogos, nome, 1013);
  *lista = deleteJ(*lista);
  return;
}

void alt_score(hashJ jogos, hashE equipas, link_E *winners, Equipa *new, int count, int *flag, int *wins)
{
  int score1;
  int score2;
  char nome[1024];
  link_J node;
  Equipa equipa1;
  Equipa equipa2;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  node = procura_hash_jogo(jogos, nome, 1013);
  if (node == 0)
  {
    {
      printf("%d Jogo inexistente.\n", count);
      return;
    }
  }
  else
  {
    {
      equipa1 = procura_hash_equipa(equipas, node->jogo->equipa1, 1013)->equipa;
      equipa2 = procura_hash_equipa(equipas, node->jogo->equipa2, 1013)->equipa;
      if ((score1 > score2) && (node->jogo->score1 <= node->jogo->score2))
      {
        {
          if (node->jogo->score1 < node->jogo->score2)
          {
            {
              equipa2->wins--;
              *winners = deleteE(*winners, equipa2->nome);
            }
          }
          else
          {
            
          }

          if ((++equipa1->wins) > (*wins))
          {
            {
              (*wins)++;
              *flag = 2;
              *new = equipa1;
            }
          }
          else
          {
            if (equipa1->wins == (*wins))
            {
              {
                *flag = 1;
                *new = equipa1;
              }
            }
            else
            {
              
            }

          }

        }
      }
      else
      {
        if ((score2 > score1) && (node->jogo->score2 <= node->jogo->score1))
        {
          {
            if (node->jogo->score2 < node->jogo->score1)
            {
              {
                *winners = deleteE(*winners, equipa1->nome);
                equipa1->wins--;
              }
            }
            else
            {
              
            }

            if ((++equipa2->wins) > (*wins))
            {
              {
                (*wins)++;
                *flag = 2;
                *new = equipa2;
              }
            }
            else
            {
              if (equipa2->wins == (*wins))
              {
                {
                  *flag = 1;
                  *new = equipa2;
                }
              }
              else
              {
                
              }

            }

          }
        }
        else
        {
          if (score1 == score2)
          {
            {
              if (node->jogo->score1 > node->jogo->score2)
              {
                {
                  *winners = deleteE(*winners, equipa1->nome);
                  equipa1->wins--;
                }
              }
              else
              {
                if (node->jogo->score2 > node->jogo->score1)
                {
                  {
                    *winners = deleteE(*winners, equipa2->nome);
                    equipa2->wins--;
                  }
                }
                else
                {
                  
                }

              }

            }
          }
          else
          {
            
          }

        }

      }

      node->jogo->score1 = score1;
      node->jogo->score2 = score2;
      if (((*winners) == 0) && ((*flag) == 0))
      {
        *flag = 3;
      }
      else
      {
        
      }

    }
  }

  return;
}

void add_equipa(hashE equipas, Equipa *new_winner, int wins, int *flag, int contador)
{
  Equipa x;
  char nome[1024];
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  if (procura_hash_equipa(equipas, nome, 1013) != 0)
  {
    {
      printf("%d Equipa existente.\n", contador);
      return;
    }
  }
  else
  {
    
  }

  x = malloc(sizeof(struct equipa));
  x->nome = malloc((sizeof(char)) * (strlen(nome) + 1));
  strcpy(x->nome, nome);
  x->wins = 0;
  if (wins == 0)
  {
    {
      *flag = 1;
      *new_winner = x;
    }
  }
  else
  {
    
  }

  equipas = insere_hash_equipa(equipas, x, 1013);
  return;
}

void procura_equipa(hashE equipas, int contador)
{
  char nome[1024];
  link_E equipa;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  equipa = procura_hash_equipa(equipas, nome, 1013);
  if (equipa == 0)
  {
    printf("%d Equipa inexistente.\n", contador);
  }
  else
  {
    {
      printf("%d ", contador);
      printNodeE(equipa);
    }
  }

  return;
}

void champions(link_E equipas, int wins, int contador)
{
  int n;
  int i;
  char **array;
  link_E temp;
  n = lengthE(equipas);
  array = malloc((sizeof(char *)) * n);
  temp = equipas;
  for (i = 0; i < n; i++)
  {
    array[i] = malloc((sizeof(char)) * (strlen(temp->equipa->nome) + 1));
    strcpy(array[i], temp->equipa->nome);
    temp = temp->next;
  }

  qsort(array, n, sizeof(char *), compara);
  if (n != 0)
  {
    printf("%d Melhores %d\n", contador, wins);
  }
  else
  {
    
  }

  for (i = 0; i < n; i++)
    printf("%d * %s\n", contador, array[i]);

  for (i = 0; i < n; i++)
    free(array[i]);

  free(array);
  return;
}

void atualiza_winner(hashE equipas, link_E *winners, Equipa winner, int flag, int *wins)
{
  int i;
  int max = 0;
  link_E head;
  link_E temp;
  if (flag != 0)
  {
    {
      if (flag == 1)
      {
        {
          *winners = insertBeginE(*winners, winner);
        }
      }
      else
      {
        if (flag == 2)
        {
          {
            free_nodesE(*winners);
            *winners = 0;
            *winners = insertBeginE(*winners, winner);
          }
        }
        else
        {
          if (flag == 3)
          {
            {
              (*wins)--;
              for (i = 0; i < 1013; i++)
              {
                head = equipas[i];
                while (head != 0)
                {
                  if (head->equipa->wins == max)
                  {
                    {
                      *winners = insertBeginE(*winners, head->equipa);
                    }
                  }
                  else
                  {
                    if (head->equipa->wins > max)
                    {
                      {
                        max = head->equipa->wins;
                        while ((*winners) != 0)
                        {
                          temp = *winners;
                          *winners = (*winners)->next;
                          free(temp);
                        }

                        *winners = insertBeginE(*winners, head->equipa);
                      }
                    }
                    else
                    {
                      
                    }

                  }

                  head = head->next;
                }

              }

            }
          }
          else
          {
            
          }

        }

      }

    }
  }
  else
  {
    
  }

}

void print_hash_equipas(hashE equipas, int wins)
{
  link_E head;
  int i;
  printf("%d\n", wins);
  for (i = 0; i < 1013; i++)
  {
    for (head = equipas[i]; head != 0; head = head->next)
    {
      printf("%d ", i);
      printNodeE(head);
    }

  }

  return;
}

void print_hash_jogos(hashJ jogos)
{
  link_J head;
  int i;
  for (i = 0; i < 1013; i++)
  {
    for (head = jogos[i]; head != 0; head = head->next)
    {
      printf("%d ", i);
      printNodeJ(head);
    }

  }

  return;
}

