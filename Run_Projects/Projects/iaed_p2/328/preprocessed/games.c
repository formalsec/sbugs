/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "games.h"


h_t_ordered_list *init_list()
{
  h_t_ordered_list *lst = malloc(sizeof(h_t_ordered_list));
  lst->head = 0;
  lst->tail = 0;
  return lst;
}

hash_table_games *create_ht_game(int size)
{
  int i;
  hash_table_games *new;
  if (size < 1)
  {
    return 0;
  }
  else
  {
    
  }

  if ((new = malloc(sizeof(hash_table_games))) == 0)
  {
    return 0;
  }
  else
  {
    
  }

  if ((new->table = malloc((sizeof(list_games *)) * size)) == 0)
  {
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < size; i++)
    new->table[i] = 0;

  new->size = size;
  return new;
}

int hash_games(hash_table_games *game_ht, char *v)
{
  int h;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*v) != '\0'; v++, a = (a * b) % (game_ht->size - 1))
  {
    h = ((a * h) + (*v)) % game_ht->size;
  }

  return h;
}

void insertEnd_list(h_t_ordered_list *lst, list_games *g)
{
  ordered_list_g y;
  ordered_list_g z;
  if (lst->head == 0)
  {
    y = malloc(sizeof(struct OL_G));
    y->game = g;
    y->next = 0;
    y->prev = 0;
    lst->head = y;
    lst->tail = y;
    return;
  }
  else
  {
    
  }

  z = malloc(sizeof(struct OL_G));
  z->game = g;
  z->next = 0;
  z->prev = lst->tail;
  lst->tail->next = z;
  lst->tail = z;
}

void remove_list(h_t_ordered_list *lst, char *token)
{
  ordered_list_g head_aux = lst->head;
  while (head_aux != 0)
  {
    if (strcmp(head_aux->game->name, token) == 0)
    {
      if ((head_aux == lst->head) && (head_aux == lst->tail))
      {
        free(head_aux);
        lst->head = 0;
        lst->tail = 0;
        return;
      }
      else
      {
        
      }

      if (head_aux == lst->head)
      {
        lst->head->next->prev = 0;
        lst->head = head_aux->next;
        free(head_aux);
        return;
      }
      else
      {
        
      }

      if (head_aux == lst->tail)
      {
        lst->tail->prev->next = 0;
        lst->tail = head_aux->prev;
        free(head_aux);
        return;
      }
      else
      {
        
      }

      head_aux->prev->next = head_aux->next;
      head_aux->next->prev = head_aux->prev;
      free(head_aux);
      return;
    }
    else
    {
      
    }

    head_aux = head_aux->next;
  }

}

void print_list(h_t_ordered_list *lst, int NL)
{
  ordered_list_g t;
  for (t = lst->head; t != 0; t = t->next)
    printf("%d %s %s %s %d %d\n", NL, t->game->name, t->game->team1, t->game->team2, t->game->score1, t->game->score2);

}

list_games *insertBegin_games(hash_table_games *game_ht, char *name, char *team1, char *team2, int score1, int score2)
{
  list_games *new;
  int i = hash_games(game_ht, name);
  new = malloc(sizeof(list_games));
  new->name = malloc((sizeof(char)) * (strlen(name) + 1));
  new->team1 = malloc((sizeof(char)) * (strlen(team1) + 1));
  new->team2 = malloc((sizeof(char)) * (strlen(team2) + 1));
  strcpy(new->name, name);
  strcpy(new->team1, team1);
  strcpy(new->team2, team2);
  new->score1 = score1;
  new->score2 = score2;
  new->next = game_ht->table[i];
  game_ht->table[i] = new;
  return new;
}

list_games *search_game_aux(hash_table_games *game_ht, char *v)
{
  list_games *g;
  int i = hash_games(game_ht, v);
  for (g = game_ht->table[i]; g != 0; g = g->next)
  {
    if (strcmp(v, g->name) == 0)
    {
      return g;
    }
    else
    {
      
    }

  }

  return 0;
}

void delete_game_aux(hash_table_games *game_ht, char *token)
{
  int h = hash_games(game_ht, token);
  int i = 0;
  list_games *temp = game_ht->table[h];
  list_games *aux;
  while (temp != 0)
  {
    if (strcmp(temp->name, token) == 0)
    {
      if ((i == 0) && (temp->next == 0))
      {
        game_ht->table[h] = 0;
      }
      else
      {
        
      }

      if ((i == 0) && (temp->next != 0))
      {
        game_ht->table[h] = temp->next;
      }
      else
      {
        
      }

      if ((i != 0) && (temp->next == 0))
      {
        aux->next = 0;
      }
      else
      {
        
      }

      if ((i != 0) && (temp->next != 0))
      {
        aux->next = temp->next;
      }
      else
      {
        
      }

      free(temp->name);
      free(temp->team1);
      free(temp->team2);
      free(temp);
      return;
    }
    else
    {
      
    }

    i++;
    aux = temp;
    temp = aux->next;
  }

}

void change_score_aux(list_games *g, hash_table_teams *team_ht, int score1, int score2)
{
  int old_score1;
  int old_score2;
  list_teams *t1;
  list_teams *t2;
  old_score1 = g->score1;
  old_score2 = g->score2;
  g->score1 = score1;
  g->score2 = score2;
  t1 = search_team_aux(team_ht, g->team1);
  t2 = search_team_aux(team_ht, g->team2);
  if ((score1 > score2) && (old_score1 < old_score2))
  {
    t1->victories++;
    t2->victories--;
    return;
  }
  else
  {
    
  }

  if ((score1 < score2) && (old_score1 > old_score2))
  {
    t1->victories--;
    t2->victories++;
    return;
  }
  else
  {
    
  }

  if ((score1 == score2) && (old_score1 > old_score2))
  {
    t1->victories--;
    return;
  }
  else
  {
    
  }

  if ((score1 == score2) && (old_score1 < old_score2))
  {
    t2->victories--;
    return;
  }
  else
  {
    
  }

  if ((score1 > score2) && (old_score1 == old_score2))
  {
    t1->victories++;
    return;
  }
  else
  {
    
  }

  if ((score1 < score2) && (old_score1 == old_score2))
  {
    t2->victories++;
  }
  else
  {
    
  }

}

