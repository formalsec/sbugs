/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "teams_struct.h"


t_node *push_team(t_node *head, char *team)
{
  t_node *new_node = malloc(sizeof(t_node));
  new_node->next = head;
  new_node->team_name = malloc((sizeof(char)) * (strlen(team) + 1));
  strcpy(new_node->team_name, team);
  new_node->wins = 0;
  return new_node;
}

t_node *pop_team(t_node *head)
{
  t_node *node = head->next;
  free(head->team_name);
  free(head);
  return node;
}

void destroy_pile(t_node *head)
{
  while (head)
  {
    head = pop_team(head);
  }

}

link_t **init_hash_teams()
{
  int i;
  link_t **hash_teams;
  hash_teams = malloc((sizeof(link_t)) * 10000);
  for (i = 0; i < 10000; i++)
  {
    hash_teams[i] = 0;
  }

  return hash_teams;
}

int hashU(char *v, int M)
{
  int h;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*v) != '\0'; v++, a = (a * b) % (M - 1))
    h = ((a * h) + (*v)) % M;

  return h;
}

link_t *insert_beguin_hash_team(link_t *head, t_node *team)
{
  link_t *new_head = malloc(sizeof(link_t));
  new_head->link_team = team;
  new_head->next_link = head;
  return new_head;
}

void insert_hash_team(link_t **List_links, t_node *Team)
{
  int key = hashU(Team->team_name, 10000);
  link_t *new_head = insert_beguin_hash_team(List_links[key], Team);
  List_links[key] = new_head;
}

t_node *search_team(link_t **List_links, char *name)
{
  int key = hashU(name, 10000);
  t_node *team = 0;
  link_t *head = List_links[key];
  while (List_links[key])
  {
    if (!strcmp(List_links[key]->link_team->team_name, name))
    {
      team = List_links[key]->link_team;
      break;
    }
    else
    {
      List_links[key] = List_links[key]->next_link;
    }

  }

  List_links[key] = head;
  return team;
}

int less(t_node *team_one, t_node *team_two)
{
  int i;
  int booleano = -1;
  for (i = 0; booleano == (-1); i++)
  {
    if ((team_one->team_name[i] > team_two->team_name[i]) || (team_two->team_name[i] == '\0'))
    {
      booleano = 0;
      break;
    }
    else
    {
      if ((team_one->team_name[i] < team_two->team_name[i]) || (team_one->team_name[i] == '\0'))
      {
        booleano = 1;
        break;
      }
      else
      {
        
      }

    }

  }

  return booleano;
}

void merge(t_node **array, int head, int midle, int last)
{
  int i;
  int j;
  int k;
  t_node *aux[10000];
  for (i = midle + 1; i > head; i--)
    aux[i - 1] = array[i - 1];

  for (j = midle; j < last; j++)
    aux[(last + midle) - j] = array[j + 1];

  for (k = head; k <= last; k++)
  {
    if (less(aux[j], aux[i]))
    {
      array[k] = aux[j--];
    }
    else
    {
      array[k] = aux[i++];
    }

  }

}

void mergesort(t_node **array, int head, int last)
{
  int midle = (last + head) / 2;
  if (last <= head)
  {
    return;
  }
  else
  {
    
  }

  mergesort(array, head, midle);
  mergesort(array, midle + 1, last);
  merge(array, head, midle, last);
}

t_node *sort_teams_pile(t_node *head, int size)
{
  int i;
  t_node *teams_list[10000];
  t_node *first_head = head;
  t_node *sorted_pile = 0;
  for (i = 0; i < size; i++)
  {
    teams_list[i] = head;
    head = head->next;
  }

  mergesort(teams_list, 0, size - 1);
  for (i = size - 1; i >= 0; i--)
    sorted_pile = push_team(sorted_pile, teams_list[i]->team_name);

  destroy_pile(first_head);
  return sorted_pile;
}

void destroy_hash_teams(link_t **List_links)
{
  link_t *new_head;
  int i;
  for (i = 0; i < 10000; i++)
  {
    while (List_links[i])
    {
      new_head = List_links[i]->next_link;
      free(List_links[i]);
      List_links[i] = new_head;
    }

  }

  free(List_links);
}

