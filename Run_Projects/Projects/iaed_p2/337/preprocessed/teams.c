/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "hash.h"
#include "teams.h"
#include "games.h"


Teams *init_Tlist()
{
  Teams *list = malloc(sizeof(Teams));
  list->head = 0;
  list->tail = 0;
  return list;
}

void destroy_Tlist(Teams *teams)
{
  team *team_aux;
  while (teams->head)
  {
    team_aux = teams->head->next;
    free_team_node(teams->head);
    teams->head = team_aux;
  }

  free(teams);
}

void free_team_node(team *team_x)
{
  free(team_x->name);
  free(team_x);
}

void new_team(Teams *teams, HashTeams *hashtable, int NL)
{
  char team_name[1024];
  for (int team_name_index = 0; team_name_index < 10; team_name_index++)
  {
    team_name[team_name_index] = new_sym_var(sizeof(char) * 8);
  }

  team_name[10 - 1] = '\0';
  if (hash_lookfor_team(hashtable, team_name) != 0)
  {
    printf("%d Equipa existente.\n", NL);
  }
  else
  {
    team *new_team = alloc_team(team_name);
    add_last_team(teams, new_team);
    add_team_to_hash(new_team, hashtable);
  }

}

team *alloc_team(char team_name[1024])
{
  team *new_team = malloc(sizeof(team));
  new_team->next = 0;
  new_team->previous = 0;
  new_team->name = malloc(((sizeof(char)) * strlen(team_name)) + 1);
  strcpy(new_team->name, team_name);
  new_team->wins = 0;
  return new_team;
}

void add_last_team(Teams *teams, team *new_team)
{
  if (teams->tail)
  {
    teams->tail->next = new_team;
  }
  else
  {
    teams->head = new_team;
  }

  new_team->previous = teams->tail;
  new_team->next = 0;
  teams->tail = new_team;
}

void lookfor_team(HashTeams *hashtable, int NL)
{
  char team_name[1024];
  team *team_x;
  for (int team_name_index = 0; team_name_index < 10; team_name_index++)
  {
    team_name[team_name_index] = new_sym_var(sizeof(char) * 8);
  }

  team_name[10 - 1] = '\0';
  team_x = hash_lookfor_team(hashtable, team_name);
  if (team_x != 0)
  {
    printf("%d %s %d\n", NL, team_x->name, team_x->wins);
  }
  else
  {
    printf("%d Equipa inexistente.\n", NL);
  }

}

void find_most_winning_teams(Teams *teams, int NL)
{
  team *team_x;
  int max_wins = 0;
  int init_size = 100;
  int i = 0;
  team **W_teams = malloc((sizeof(team *)) * init_size);
  for (team_x = teams->head; team_x != 0; team_x = team_x->next)
  {
    if (team_x->wins > max_wins)
    {
      max_wins = team_x->wins;
      clean_winning_teams(W_teams, i);
      i = 0;
      W_teams[i] = team_x;
      i++;
    }
    else
    {
      if (team_x->wins == max_wins)
      {
        W_teams[i] = team_x;
        i++;
      }
      else
      {
        
      }

    }

  }

  quicksort_teams(W_teams, 0, i - 1);
  print_winning_teams(W_teams, i, NL, max_wins);
  free(W_teams);
}

void quicksort_teams(team **W_teams, int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition(W_teams, l, r);
  quicksort_teams(W_teams, l, i - 1);
  quicksort_teams(W_teams, i + 1, r);
}

int partition(team **W_teams, int l, int r)
{
  int i = l - 1;
  int j = r;
  team *v = W_teams[r];
  while (i < j)
  {
    while (strcmp(W_teams[++i]->name, v->name) < 0)
      ;

    while (strcmp(v->name, W_teams[--j]->name) < 0)
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      team *t = W_teams[i];
      W_teams[i] = W_teams[j];
      W_teams[j] = t;
    }
    else
    {
      
    }

    ;
  }

  {
    team *t = W_teams[i];
    W_teams[i] = W_teams[r];
    W_teams[r] = t;
  }
  ;
  return i;
}

void clean_winning_teams(team **W_teams, int i)
{
  int aux;
  for (aux = 0; aux < i; aux++)
    W_teams[aux] = 0;

}

void print_winning_teams(team **W_teams, int i, int NL, int max_wins)
{
  int aux;
  if (i > 0)
  {
    printf("%d Melhores %d\n", NL, max_wins);
    for (aux = 0; aux < i; aux++)
      printf("%d * %s\n", NL, W_teams[aux]->name);

  }
  else
  {
    
  }

}

void remove_team_win(HashTeams *hashtable_teams, char *winner)
{
  team *team_x = hash_lookfor_team(hashtable_teams, winner);
  team_x->wins -= 1;
}

void add_team_win(HashTeams *hashtable_teams, char *new_winner)
{
  team *team_x = hash_lookfor_team(hashtable_teams, new_winner);
  team_x->wins += 1;
}

HashTeams *init_HTtable(int size)
{
  int i;
  HashTeams *hashtable = malloc(sizeof(HashTeams));
  hashtable->slots = malloc((sizeof(team *)) * size);
  hashtable->size = 0;
  hashtable->cap = size;
  for (i = 0; i < hashtable->cap; i++)
    hashtable->slots[i] = 0;

  return hashtable;
}

void destroy_HTtable(HashTeams *hashtable)
{
  free(hashtable->slots);
  free(hashtable);
}

void add_team_to_hash(team *team_x, HashTeams *hashtable)
{
  int h = hash(team_x->name, hashtable->cap);
  int inc = (1 + (3 * h)) % hashtable->cap;
  if (inc == 0)
  {
    inc++;
  }
  else
  {
    
  }

  while (hashtable->slots[h] != 0)
    h = (h + inc) % hashtable->cap;

  hashtable->slots[h] = team_x;
  hashtable->size++;
  if (hashtable->size > (hashtable->cap / 2))
  {
    resize_hashtable_teams(hashtable);
  }
  else
  {
    
  }

}

team *hash_lookfor_team(HashTeams *hashtable, char *name)
{
  int h = hash(name, hashtable->cap);
  int inc = (1 + (3 * h)) % hashtable->cap;
  if (inc == 0)
  {
    inc++;
  }
  else
  {
    
  }

  while (hashtable->slots[h] != 0)
  {
    if (strcmp(hashtable->slots[h]->name, name) == 0)
    {
      return hashtable->slots[h];
    }
    else
    {
      h = (h + inc) % hashtable->cap;
    }

  }

  return 0;
}

void resize_hashtable_teams(HashTeams *hashtable)
{
  int new_cap;
  team **new_slots;
  team **old_slots = hashtable->slots;
  new_cap = hashtable->cap * 2;
  while (eh_primo(new_cap) != 1)
    new_cap++;

  new_slots = malloc((sizeof(team *)) * new_cap);
  init_new_team_slots(new_slots, new_cap);
  rehash_teams(hashtable, new_slots, old_slots, new_cap);
  hashtable->slots = new_slots;
  hashtable->cap = new_cap;
  free(old_slots);
}

void init_new_team_slots(team **new_slots, int new_cap)
{
  int i;
  for (i = 0; i < new_cap; i++)
    new_slots[i] = 0;

}

void rehash_teams(HashTeams *hashtable, team **new_slots, team **old_slots, int new_cap)
{
  int i;
  int inc;
  int h;
  for (i = 0; i < hashtable->cap; i++)
  {
    if (old_slots[i] != 0)
    {
      h = hash(old_slots[i]->name, new_cap);
      inc = (1 + (3 * h)) % new_cap;
      if (inc == 0)
      {
        inc++;
      }
      else
      {
        
      }

      while (new_slots[h] != 0)
        h = (h + inc) % new_cap;

      new_slots[h] = old_slots[i];
    }
    else
    {
      
    }

  }

}

