/*File generated by PreProcessor.py*/


#include "hash.h"


int hashU_JOGOS(char *v, Hashtable_JOGOS HT)
{
  int h = 0;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*v) != '\0'; v++, a = (a * b) % (HT->M - 1))
    h = ((a * h) + (*v)) % HT->M;

  return h;
}

Hashtable_JOGOS HashtableInit_JOGOS(int M)
{
  int i = 0;
  Hashtable_JOGOS HT = malloc(sizeof(struct hashtable_jogos));
  HT->M = M;
  HT->adj = malloc(M * (sizeof(linkPJogo)));
  for (i = 0; i < M; i++)
    HT->adj[i] = 0;

  return HT;
}

void HashtableInsert_JOGOS(Hashtable_JOGOS HT, linkJogo j)
{
  linkPJogo a = (linkPJogo) malloc(sizeof(struct nodePJogo));
  int key = hashU_JOGOS(j->j.nome, HT);
  linkPJogo last = HT->adj[key];
  a->j = j;
  a->next = 0;
  if (HT->adj[key] == 0)
  {
    HT->adj[key] = a;
    return;
  }
  else
  {
    
  }

  while (last->next != 0)
    last = last->next;

  last->next = a;
  return;
}

int HashtableSearch_JOGOS(char *v, Hashtable_JOGOS HT)
{
  linkPJogo j;
  int key = hashU_JOGOS(v, HT);
  for (j = HT->adj[key]; j != 0; j = j->next)
    if (!strcmp(j->j->j.nome, v))
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

void HashtableDelete_JOGOS(char *v, struct nodeJogo **head, Hashtable_JOGOS HT)
{
  linkPJogo p;
  int key = hashU_JOGOS(v, HT);
  struct nodePJogo *temp = HT->adj[key];
  struct nodePJogo *prev;
  for (p = HT->adj[key]; p != 0; p = p->next)
  {
    if (!strcmp(p->j->j.nome, v))
    {
      if ((temp != 0) && (!strcmp(temp->j->j.nome, v)))
      {
        HT->adj[key] = temp->next;
        deleteNodeJogo(head, temp->j->j);
        free(temp);
        return;
      }
      else
      {
        
      }

      while ((temp != 0) && strcmp(temp->j->j.nome, v))
      {
        prev = temp;
        temp = temp->next;
      }

      if (temp == 0)
      {
        return;
      }
      else
      {
        
      }

      prev->next = temp->next;
      deleteNodeJogo(head, temp->j->j);
      free(temp);
    }
    else
    {
      
    }

  }

}

void HashtableDeleteAll_JOGOS(Hashtable_JOGOS HT, linkJogo *head)
{
  int i = 0;
  linkPJogo temp;
  linkPJogo first;
  for (i = 0; i < HT->M; i++)
  {
    first = HT->adj[i];
    while (first != 0)
    {
      temp = first;
      first = first->next;
      free(temp);
    }

  }

  HT->adj[i] = 0;
  deleteListJogo(head);
}

int hashU_EQUIPAS(char *v, Hashtable_EQUIPAS HT)
{
  int h = 0;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*v) != '\0'; v++, a = (a * b) % (HT->M - 1))
    h = ((a * h) + (*v)) % HT->M;

  return h;
}

Hashtable_EQUIPAS HashtableInit_EQUIPAS(int M)
{
  int i = 0;
  Hashtable_EQUIPAS HT = malloc(sizeof(struct hashtable_jogos));
  HT->M = M;
  HT->adj = malloc(M * (sizeof(linkPEquipa)));
  for (i = 0; i < M; i++)
    HT->adj[i] = 0;

  return HT;
}

void HashtableInsert_EQUIPAS(Hashtable_EQUIPAS HT, linkEquipa e)
{
  linkPEquipa a = (linkPEquipa) malloc(sizeof(struct nodePEquipa));
  int key = hashU_EQUIPAS(e->e.nome, HT);
  linkPEquipa last = HT->adj[key];
  a->e = e;
  a->next = 0;
  if (HT->adj[key] == 0)
  {
    HT->adj[key] = a;
    return;
  }
  else
  {
    
  }

  while (last->next != 0)
    last = last->next;

  last->next = a;
  return;
}

int HashtableSearch_EQUIPAS(char *v, Hashtable_EQUIPAS HT)
{
  linkPEquipa p;
  int key = hashU_EQUIPAS(v, HT);
  for (p = HT->adj[key]; p != 0; p = p->next)
    if (!strcmp(p->e->e.nome, v))
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

void HashtableDelete_EQUIPAS(char *v, struct nodeEquipa **head, Hashtable_EQUIPAS HT)
{
  linkPEquipa p;
  int key = hashU_EQUIPAS(v, HT);
  struct nodePEquipa *temp = HT->adj[key];
  struct nodePEquipa *prev;
  for (p = HT->adj[key]; p != 0; p = p->next)
  {
    if (!strcmp(p->e->e.nome, v))
    {
      if ((temp != 0) && (!strcmp(temp->e->e.nome, v)))
      {
        HT->adj[key] = temp->next;
        deleteNodeEquipa(head, temp->e->e);
        free(temp);
        return;
      }
      else
      {
        
      }

      while ((temp != 0) && strcmp(temp->e->e.nome, v))
      {
        prev = temp;
        temp = temp->next;
      }

      if (temp == 0)
      {
        return;
      }
      else
      {
        
      }

      prev->next = temp->next;
      deleteNodeEquipa(head, temp->e->e);
      free(temp);
    }
    else
    {
      
    }

  }

}

void HashtableDeleteAll_EQUIPAS(Hashtable_EQUIPAS HT, linkEquipa *head)
{
  int i = 0;
  linkPEquipa temp;
  linkPEquipa first;
  for (i = 0; i < HT->M; i++)
  {
    first = HT->adj[i];
    while (first != 0)
    {
      temp = first;
      first = first->next;
      free(temp);
    }

  }

  HT->adj[i] = 0;
  deleteListEquipa(head);
}

