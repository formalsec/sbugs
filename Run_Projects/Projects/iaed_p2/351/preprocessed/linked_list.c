/*File generated by PreProcessor.py*/


#include "linked_list.h"
#include <stdlib.h>


l_list *create_l_list()
{
  l_list *list = calloc(1, sizeof(l_list));
  return list;
}

l_node *create_l_node()
{
  l_node *ptr = calloc(1, sizeof(l_node));
  return ptr;
}

void l_list_add_node_end(l_list *list, l_node *node)
{
  if (list->head == 0)
  {
    {
      list->head = (list->last = node);
    }
  }
  else
  {
    {
      list->last->next = node;
      list->last = node;
      node->next = 0;
    }
  }

  list->n_elems++;
  return;
}

void l_list_remove_node_only(l_list *list, l_node *node)
{
  l_node *prev;
  l_node *curr;
  if (list->head == node)
  {
    {
      if (node->next == 0)
      {
        {
          list->head = 0;
          list->last = 0;
          free(node);
          list->n_elems--;
          return;
        }
      }
      else
      {
        {
          list->head = node->next;
          free(node);
          list->n_elems--;
          return;
        }
      }

    }
  }
  else
  {
    
  }

  for (prev = list->head, curr = list->head->next; curr != 0; prev = curr, curr = curr->next)
  {
    if (curr == node)
    {
      {
        prev->next = node->next;
        if (list->last == node)
        {
          list->last = prev;
        }
        else
        {
          
        }

        free(node);
        list->n_elems--;
        return;
      }
    }
    else
    {
      
    }

  }

  return;
}

void l_list_remove_node(l_list *list, l_node *node, void (*func)(void *))
{
  l_node *prev;
  l_node *curr;
  if (list->head == node)
  {
    {
      if (node->next == 0)
      {
        {
          list->head = 0;
          list->last = 0;
          func(node->info_struct);
          free(node);
          list->n_elems--;
          return;
        }
      }
      else
      {
        {
          list->head = node->next;
          func(node->info_struct);
          free(node);
          list->n_elems--;
          return;
        }
      }

    }
  }
  else
  {
    
  }

  for (prev = list->head, curr = list->head->next; curr != 0; prev = curr, curr = curr->next)
  {
    if (curr == node)
    {
      {
        prev->next = node->next;
        if (list->last == node)
        {
          list->last = prev;
        }
        else
        {
          
        }

        func(node->info_struct);
        free(node);
        list->n_elems--;
        return;
      }
    }
    else
    {
      
    }

  }

  return;
}

void free_l_list_and_node_only(l_list *list)
{
  l_node *curr;
  l_node *next;
  if (list == 0)
  {
    return;
  }
  else
  {
    
  }

  for (curr = list->head; curr != 0; curr = next)
  {
    next = curr->next;
    l_list_remove_node_only(list, curr);
  }

  free(list);
  return;
}

void free_l_list(l_list *list, void (*func)(void *))
{
  l_node *curr;
  l_node *next;
  if (list == 0)
  {
    return;
  }
  else
  {
    
  }

  for (curr = list->head; curr != 0; curr = next)
  {
    next = curr->next;
    l_list_remove_node(list, curr, func);
  }

  free(list);
  return;
}

