/*File generated by PreProcessor.py*/


#include "game.h"


Game_ptr NewGame(char *name, Team_ptr team1, Team_ptr team2, int score1, int score2)
{
  Game_ptr new_game = (Game_ptr) malloc(sizeof(struct Game));
  new_game->name = StringDup(name);
  new_game->team1 = team1;
  new_game->team2 = team2;
  new_game->score.score1 = score1;
  new_game->score.score2 = score2;
  return new_game;
}

void PrintGame(Game_ptr game)
{
  int score1;
  int score2;
  score1 = game->score.score1;
  score2 = game->score.score2;
  printf("%s %s %s %d %d\n", game->name, game->team1->name, game->team2->name, score1, score2);
}

Team_ptr game_winner(Game_ptr game)
{
  if (game->score.score1 > game->score.score2)
  {
    return game->team1;
  }
  else
  {
    
  }

  if (game->score.score2 > game->score.score1)
  {
    return game->team2;
  }
  else
  {
    
  }

  return 0;
}

void FreeGame(Game_ptr game)
{
  free(game->name);
  free(game);
}

Game_link NewGameLink(Game_ptr game_ptr)
{
  Game_link new_link = (Game_link) malloc(sizeof(struct GameNode));
  new_link->game = game_ptr;
  new_link->prev = 0;
  new_link->next = 0;
  return new_link;
}

Game_link InsertGameBeginList(Game_link head, Game_ptr game_ptr)
{
  Game_link new_link = NewGameLink(game_ptr);
  Game_link last;
  if (head == 0)
  {
    new_link->next = (new_link->prev = new_link);
    return new_link;
  }
  else
  {
    
  }

  last = head->prev;
  new_link->next = head;
  new_link->prev = last;
  last->next = (head->prev = new_link);
  return new_link;
}

Game_link RemoveGameList(Game_link head, char *name)
{
  Game_link link_to_remove = head;
  Game_link prev = 0;
  while (strcmp(link_to_remove->game->name, name) != 0)
  {
    prev = link_to_remove;
    link_to_remove = link_to_remove->next;
  }

  if ((link_to_remove->next == head) && (prev == 0))
  {
    FreeGameNode(link_to_remove);
    return 0;
  }
  else
  {
    
  }

  if (link_to_remove == head)
  {
    prev = head->prev;
    head = head->next;
    prev->next = head;
    head->prev = prev;
    FreeGameNode(link_to_remove);
  }
  else
  {
    if (link_to_remove->next == head)
    {
      prev->next = head;
      head->prev = prev;
      FreeGameNode(link_to_remove);
    }
    else
    {
      Game_link aux = link_to_remove->next;
      prev->next = aux;
      aux->prev = prev;
      FreeGameNode(link_to_remove);
    }

  }

  return head;
}

void FreeGameNode(Game_link game_link)
{
  FreeGame(game_link->game);
  free(game_link);
}

GameHash_ptr GameHashInit(int max)
{
  int i;
  GameHash_ptr game_hash = (GameHash_ptr) malloc(sizeof(struct GameHash));
  game_hash->N = 0;
  game_hash->M = max;
  game_hash->hash_table = (Game_ptr *) malloc(game_hash->M * (sizeof(Game_ptr)));
  for (i = 0; i < game_hash->M; i++)
    game_hash->hash_table[i] = 0;

  return game_hash;
}

GameHash_ptr GameHashInsert(GameHash_ptr game_hash, Game_ptr game)
{
  int i = HashU(game->name, game_hash->M);
  while (game_hash->hash_table[i] != 0)
    i = (i + 1) % game_hash->M;

  game_hash->hash_table[i] = game;
  game_hash->N++;
  if (game_hash->N >= (game_hash->M / 2))
  {
    GameHash_ptr new_hash = GameHashExpand(game_hash);
    return new_hash;
  }
  else
  {
    
  }

  return game_hash;
}

GameHash_ptr GameHashExpand(GameHash_ptr game_hash)
{
  int i;
  Game_ptr *aux = game_hash->hash_table;
  GameHash_ptr new_hash = GameHashInit(game_hash->M * 2);
  for (i = 0; i < game_hash->M; i++)
    if (game_hash->hash_table[i] != 0)
  {
    GameHashInsert(new_hash, game_hash->hash_table[i]);
  }
  else
  {
    
  }


  free(aux);
  free(game_hash);
  return new_hash;
}

Game_ptr GameHashSearch(GameHash_ptr game_hash, char *name)
{
  int i = HashU(name, game_hash->M);
  while (game_hash->hash_table[i] != 0)
    if (strcmp(name, game_hash->hash_table[i]->name) == 0)
  {
    return game_hash->hash_table[i];
  }
  else
  {
    i = (i + 1) % game_hash->M;
  }


  return 0;
}

void GameHashRemove(GameHash_ptr game_hash, char *name)
{
  int j;
  int i = HashU(name, game_hash->M);
  Game_ptr aux;
  while (game_hash->hash_table[i] != 0)
    if (strcmp(name, game_hash->hash_table[i]->name) == 0)
  {
    break;
  }
  else
  {
    i = (i + 1) % game_hash->M;
  }


  game_hash->hash_table[i] = 0;
  game_hash->N--;
  for (j = (i + 1) % game_hash->M; game_hash->hash_table[j] != 0; j = (j + 1) % game_hash->M, game_hash->N--)
  {
    aux = game_hash->hash_table[j];
    game_hash->hash_table[j] = 0;
    GameHashInsert(game_hash, aux);
  }

}

void DeleteGameHash(GameHash_ptr game_hash)
{
  int i;
  for (i = 0; i < game_hash->M; i++)
    if (game_hash->hash_table[i] != 0)
  {
    FreeGame(game_hash->hash_table[i]);
  }
  else
  {
    
  }


  free(game_hash->hash_table);
  free(game_hash);
}

void DeleteGameList(Game_link head)
{
  Game_link current = head;
  Game_link next;
  if (head != 0)
  {
    do
    {
      next = current->next;
      free(current);
      current = next;
    }
    while (current != head);
  }
  else
  {
    
  }

}

