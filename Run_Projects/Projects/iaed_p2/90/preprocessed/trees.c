/*File generated by PreProcessor.py*/


#include "trees.h"


t_node *new_node(void *value)
{
  t_node *new;
  new = (t_node *) malloc(sizeof(t_node));
  new->value = value;
  new->left = (new->right = 0);
  new->height = 1;
  return new;
}

short height(t_node *target)
{
  if (target == 0)
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  return target->height;
}

t_node *right_rotate(t_node *y)
{
  t_node *x = y->left;
  y->left = x->right;
  x->right = y;
  y->height = ((height(y->left) > height(y->right)) ? (height(y->left)) : (height(y->right))) + 1;
  x->height = ((height(x->left) > height(x->right)) ? (height(x->left)) : (height(x->right))) + 1;
  return x;
}

t_node *left_rotate(t_node *y)
{
  t_node *x = y->right;
  y->right = x->left;
  x->left = y;
  y->height = ((height(y->left) > height(y->right)) ? (height(y->left)) : (height(y->right))) + 1;
  x->height = ((height(x->left) > height(x->right)) ? (height(x->left)) : (height(x->right))) + 1;
  return x;
}

t_node *l_r_rotate(t_node *root)
{
  if (root == 0)
  {
    {
      return root;
    }
  }
  else
  {
    
  }

  root->left = left_rotate(root->left);
  return right_rotate(root);
}

t_node *r_l_rotate(t_node *root)
{
  if (root == 0)
  {
    {
      return root;
    }
  }
  else
  {
    
  }

  root->right = right_rotate(root->right);
  return left_rotate(root);
}

short get_balance(t_node *node)
{
  if (node == 0)
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  return height(node->left) - height(node->right);
}

void *tree_lookup(t_node *root, int (*cmp)(void *val, void *nd), void *value)
{
  t_node *cursor = root;
  short dif;
  while ((cursor != 0) && ((dif = cmp(value, cursor->value)) != 0))
  {
    if (dif < 0)
    {
      cursor = cursor->left;
    }
    else
    {
      cursor = cursor->right;
    }

  }

  return (cursor) ? (cursor->value) : (0);
}

t_node *min_node(t_node *root)
{
  t_node *current = root;
  while (current->left != 0)
  {
    current = current->left;
  }

  return current;
}

t_node *max_node(t_node *root)
{
  t_node *current = root;
  while (current->right != 0)
  {
    current = current->right;
  }

  return current;
}

t_node *tree_insert(t_node *root, int (*cmp)(void *val, void *nod), void *value)
{
  if (root == 0)
  {
    {
      return new_node(value);
    }
  }
  else
  {
    
  }

  if (cmp(value, root->value) < 0)
  {
    root->left = tree_insert(root->left, cmp, value);
  }
  else
  {
    root->right = tree_insert(root->right, cmp, value);
  }

  root = fix_balance(root);
  return root;
}

t_node *tree_remove(t_node *root, int (*cmp)(void *val, void *nd), void *value)
{
  t_node *temp;
  t_node *aux;
  if (root == 0)
  {
    return root;
  }
  else
  {
    
  }

  if (cmp(value, root->value) < 0)
  {
    root->left = tree_remove(root->left, cmp, value);
  }
  else
  {
    if (cmp(value, root->value) > 0)
    {
      root->right = tree_remove(root->right, cmp, value);
    }
    else
    {
      {
        if ((root->left == 0) || (root->right == 0))
        {
          {
            temp = root;
            root = (root->left) ? (root->left) : (root->right);
            free(temp);
          }
        }
        else
        {
          {
            temp = min_node(root->right);
            aux = root->value;
            root->value = temp->value;
            temp->value = aux;
            root->right = tree_remove(root->right, cmp, temp->value);
          }
        }

      }
    }

  }

  if (root == 0)
  {
    return root;
  }
  else
  {
    
  }

  root = fix_balance(root);
  return root;
}

t_node *fix_balance(t_node *root)
{
  short bal;
  if (root == 0)
  {
    {
      return root;
    }
  }
  else
  {
    
  }

  bal = get_balance(root);
  if (bal > 1)
  {
    {
      if (get_balance(root->left) >= 0)
      {
        root = right_rotate(root);
      }
      else
      {
        root = l_r_rotate(root);
      }

    }
  }
  else
  {
    if (bal < (-1))
    {
      {
        if (get_balance(root->right) <= 0)
        {
          root = left_rotate(root);
        }
        else
        {
          root = r_l_rotate(root);
        }

      }
    }
    else
    {
      {
        root->height = ((height(root->left) > height(root->right)) ? (height(root->left)) : (height(root->right))) + 1;
      }
    }

  }

  return root;
}

void destroy_tree(t_node *root, void (*del)(void *nd))
{
  if (root == 0)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  destroy_tree(root->left, del);
  destroy_tree(root->right, del);
  del(root->value);
  free(root);
  return;
}

void free_tree(t_node *root)
{
  if (root == 0)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  free_tree(root->left);
  free_tree(root->right);
  free(root);
  return;
}

