/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


enum 
{
  TRUE = 1,
  FALSE = 0
};
typedef char bool_t;
typedef struct AdjNode
{
  unsigned long vertex;
  struct AdjNode *next;
} AdjNode;
typedef struct Graph
{
  unsigned long numVertices;
  unsigned long articulationPoints;
  AdjNode **adjLists;
} Graph;
AdjNode *createAdjNode(unsigned long n)
{
  AdjNode *newNode = (AdjNode *) malloc(sizeof(AdjNode));
  newNode->vertex = n;
  newNode->next = 0;
  return newNode;
}

Graph *createGraph(unsigned long n)
{
  Graph *graph = (Graph *) malloc(sizeof(Graph));
  unsigned long i;
  graph->numVertices = n;
  graph->adjLists = (AdjNode **) malloc((sizeof(AdjNode *)) * n);
  graph->articulationPoints = 0;
  for (i = 0; i < n; i++)
    graph->adjLists[i] = 0;

  return graph;
}

Graph *addEdge(Graph *graph, unsigned long v1, unsigned long v2)
{
  AdjNode *newNode1 = createAdjNode(v1);
  AdjNode *newNode2 = createAdjNode(v2);
  AdjNode *current;
  current = graph->adjLists[v1 - 1];
  if (current != 0)
  {
    while (current->next != 0)
    {
      current = current->next;
    }

    current->next = newNode2;
  }
  else
  {
    graph->adjLists[v1 - 1] = newNode2;
  }

  current = graph->adjLists[v2 - 1];
  if (current != 0)
  {
    while (current->next != 0)
    {
      current = current->next;
    }

    current->next = newNode1;
  }
  else
  {
    graph->adjLists[v2 - 1] = newNode1;
  }

  return graph;
}

void freeList(AdjNode *head)
{
  AdjNode *current;
  if (head != 0)
  {
    while (head->next != 0)
    {
      current = head->next;
      head->next = current->next;
      free(current);
    }

  }
  else
  {
    
  }

  free(head);
}

void freeGraph(Graph *graph)
{
  unsigned long i;
  unsigned long n = graph->numVertices;
  for (i = 0; i < n; i++)
    freeList(graph->adjLists[i]);

  free(graph->adjLists);
  free(graph);
}

unsigned long DFS_visit(Graph *graph, unsigned long vertex, bool_t visited[], bool_t ap[])
{
  AdjNode *current;
  unsigned long netSize = 0;
  visited[vertex - 1] = TRUE;
  for (current = graph->adjLists[vertex - 1]; current != 0; current = current->next)
  {
    if ((visited[current->vertex - 1] == FALSE) && (ap[current->vertex - 1] == FALSE))
    {
      netSize += DFS_visit(graph, current->vertex, visited, ap);
    }
    else
    {
      
    }

  }

  return netSize + 1;
}

unsigned long DFS(Graph *graph, bool_t visited[], bool_t ap[])
{
  unsigned long i;
  unsigned long n = graph->numVertices;
  unsigned long netSize = 0;
  unsigned long maxNetSize = 0;
  for (i = 0; i < n; i++)
    visited[i] = FALSE;

  for (i = 0; i < n; i++)
    if ((visited[i] == FALSE) && (ap[i] == FALSE))
  {
    netSize = DFS_visit(graph, i + 1, visited, ap);
    maxNetSize = (netSize > maxNetSize) ? (netSize) : (maxNetSize);
  }
  else
  {
    
  }


  return maxNetSize;
}

unsigned long tarjanVisit(Graph *graph, unsigned long vertex, unsigned long *d, unsigned long *low, unsigned long *parent, bool_t visited[], bool_t ap[])
{
  AdjNode *current;
  static unsigned long time;
  unsigned long children = 0;
  unsigned long currentIndex = 0;
  unsigned long maxIndex = vertex;
  visited[vertex - 1] = TRUE;
  d[vertex - 1] = ++time;
  low[vertex - 1] = d[vertex - 1];
  for (current = graph->adjLists[vertex - 1]; current != 0; current = current->next)
  {
    if (visited[current->vertex - 1] == FALSE)
    {
      children++;
      parent[current->vertex - 1] = vertex;
      currentIndex = tarjanVisit(graph, current->vertex, d, low, parent, visited, ap);
      maxIndex = (maxIndex > currentIndex) ? (maxIndex) : (currentIndex);
      low[vertex - 1] = (low[vertex - 1] < low[current->vertex - 1]) ? (low[vertex - 1]) : (low[current->vertex - 1]);
      if (((parent[vertex - 1] == 0) && (children > 1)) || ((parent[vertex - 1] != 0) && (low[current->vertex - 1] >= d[vertex - 1])))
      {
        if (ap[vertex - 1] == FALSE)
        {
          graph->articulationPoints++;
          ap[vertex - 1] = TRUE;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }
    else
    {
      if (current->vertex != parent[vertex - 1])
      {
        low[vertex - 1] = (low[vertex - 1] < d[current->vertex - 1]) ? (low[vertex - 1]) : (d[current->vertex - 1]);
      }
      else
      {
        
      }

    }

  }

  return maxIndex;
}

unsigned long tarjan(Graph *graph, bool_t maxIndexes[], unsigned long *d, unsigned long *low, unsigned long *parent, bool_t visited[], bool_t ap[])
{
  unsigned long i;
  unsigned long maxIndex;
  unsigned long n = graph->numVertices;
  unsigned long subNetCount = 0;
  for (i = 0; i < n; i++)
  {
    visited[i] = FALSE;
    parent[i] = 0;
    ap[i] = FALSE;
    maxIndexes[i] = FALSE;
  }

  for (i = 0; i < n; i++)
    if (visited[i] == FALSE)
  {
    maxIndex = tarjanVisit(graph, i + 1, d, low, parent, visited, ap);
    maxIndexes[maxIndex - 1] = TRUE;
    subNetCount++;
  }
  else
  {
    
  }


  return subNetCount;
}

int main()
{
  Graph *graph;
  unsigned long n;
  unsigned long e;
  unsigned long v1;
  unsigned long v2;
  unsigned long i;
  unsigned long j;
  unsigned long subNetworks;
  n = new_sym_var(sizeof(unsigned long) * 8);
  e = new_sym_var(sizeof(unsigned long) * 8);
  unsigned long *d = (unsigned long *) malloc((sizeof(unsigned long)) * n);
  unsigned long *low = (unsigned long *) malloc((sizeof(unsigned long)) * n);
  unsigned long *parent = (unsigned long *) malloc((sizeof(unsigned long)) * n);
  bool_t maxIndexes[n];
  bool_t visited[n];
  bool_t ap[n];
  graph = createGraph(n);
  for (i = 0; i < e; i++)
  {
    v1 = new_sym_var(sizeof(unsigned long) * 8);
    v2 = new_sym_var(sizeof(unsigned long) * 8);
    addEdge(graph, v1, v2);
  }

  subNetworks = tarjan(graph, maxIndexes, d, low, parent, visited, ap);
  printf("%lu\n", subNetworks);
  for (i = 0; i < n; i++)
    if (maxIndexes[i] == TRUE)
  {
    printf("%lu", i + 1);
    break;
  }
  else
  {
    
  }


  for (j = i + 1; j < n; j++)
    if (maxIndexes[j] == TRUE)
  {
    printf(" %lu", j + 1);
  }
  else
  {
    
  }


  printf("\n%lu\n%lu\n", graph->articulationPoints, DFS(graph, visited, ap));
  free(d);
  free(low);
  free(parent);
  freeGraph(graph);
  return 0;
}

