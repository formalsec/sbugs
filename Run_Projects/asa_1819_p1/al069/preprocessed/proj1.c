/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct lista Lista;
typedef struct no No;
struct lista
{
  No *inicio;
  No *fim;
};
struct no
{
  int vertice;
  No *prox;
};
int nrouters = 0;
int *low;
int n_scc = 0;
int *maxscc;
int descTemp = 1;
int *d;
int *parente;
int n_ptoart = 0;
int max_aux = 0;
int max_art = 0;
bool *ptoart;
Lista *adj;
No *Novo(int vertice)
{
  No *x = (No *) malloc(sizeof(struct no));
  x->vertice = vertice;
  x->prox = 0;
  return x;
}

No *insereFim(No *fim, int vertice, No **inicio)
{
  if (fim == 0)
  {
    *inicio = Novo(vertice);
    return *inicio;
  }
  else
  {
    
  }

  fim->prox = Novo(vertice);
  fim = fim->prox;
  return fim;
}

void eliminartudo()
{
  int i;
  No *t;
  No *aux;
  for (i = 0; i < nrouters; i++)
  {
    for (t = adj[i].inicio; t != 0;)
    {
      adj[i].inicio = t->prox;
      aux = t;
      t = t->prox;
      free(aux);
    }

    adj[i].fim = adj[i].inicio;
  }

  free(adj);
  free(maxscc);
  free(d);
  free(low);
  free(parente);
  free(ptoart);
}

void mergesort(int a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int *aux;
  aux = (int *) malloc((sizeof(int)) * n_scc);
  for (i = m + 1; i > l; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < r; j++)
    aux[(r + m) - j] = a[j + 1];

  for (k = l; k <= r; k++)
    if (aux[j] < aux[i])
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


  free(aux);
}

void merge(int a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  merge(a, l, m);
  merge(a, m + 1, r);
  mergesort(a, l, m, r);
}

void Inicializacoes(int flag)
{
  int i;
  for (i = 0; i < nrouters; i++)
  {
    d[i] = -1;
    low[i] = 0;
    parente[i] = 0;
    if (flag == 1)
    {
      adj[i].inicio = 0;
      adj[i].fim = 0;
      ptoart[i] = false;
    }
    else
    {
      
    }

  }

}

int min(int atual, int posterior)
{
  if (atual < posterior)
  {
    return atual;
  }
  else
  {
    
  }

  return posterior;
}

void tarjan(int atual, int flag)
{
  No *i;
  int filhos = 0;
  if (((!ptoart[atual]) && (flag == 2)) || (flag == 1))
  {
    if (d[atual] == (-1))
    {
      if (flag == 2)
      {
        max_aux++;
      }
      else
      {
        
      }

      d[atual] = (low[atual] = descTemp++);
      if ((max_aux < (atual + 1)) && (flag == 1))
      {
        max_aux = atual + 1;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    for (i = adj[atual].inicio; i != 0; i = i->prox)
    {
      if (d[i->vertice - 1] == (-1))
      {
        filhos++;
        parente[i->vertice - 1] = atual + 1;
        tarjan(i->vertice - 1, flag);
        low[atual] = min(low[atual], low[i->vertice - 1]);
        if (((flag == 1) && (ptoart[atual] == false)) && (((parente[atual] == 0) && (filhos > 1)) || ((parente[atual] != 0) && (low[i->vertice - 1] >= d[atual]))))
        {
          ptoart[atual] = true;
          n_ptoart++;
        }
        else
        {
          
        }

      }
      else
      {
        if (i->vertice != parente[atual])
        {
          low[atual] = min(low[atual], d[i->vertice - 1]);
        }
        else
        {
          
        }

      }

    }

  }
  else
  {
    
  }

}

int main()
{
  int nligacoes = 0;
  int i;
  int origem;
  int destino;
  if (!1)
  {
    printf("Tem de colocar um número de routers e tem de ser igual ou");
    printf(" superior a 2\n");
    exit(1);
  }
  else
  {
    nrouters = new_sym_var(sizeof(int) * 8);
    
  }

  if (!1)
  {
    printf("Tem de colocar um número de ligações e tem de ser igual ou");
    printf(" superior a 1\n");
    exit(1);
  }
  else
  {
    nligacoes = new_sym_var(sizeof(int) * 8);
    
  }

  adj = (Lista *) malloc((sizeof(Lista)) * nrouters);
  low = (int *) malloc((sizeof(int)) * nrouters);
  d = (int *) malloc((sizeof(int)) * nrouters);
  maxscc = (int *) malloc((sizeof(int)) * nrouters);
  parente = (int *) malloc((sizeof(int)) * nrouters);
  ptoart = (bool *) malloc((sizeof(bool)) * nrouters);
  Inicializacoes(1);
  for (i = 0; i < nligacoes; i++)
  {
    if (((((!2) || (origem < 1)) || (origem > nrouters)) || (destino < 1)) || (destino > nrouters))
    {
      printf("O identificador do router tem de estar entre 1 e %d", nrouters);
      exit(1);
    }
    else
    {
      origem = new_sym_var(sizeof(int) * 8);
      destino = new_sym_var(sizeof(int) * 8);
      
    }

    adj[origem - 1].fim = insereFim(adj[origem - 1].fim, destino, &adj[origem - 1].inicio);
    adj[destino - 1].fim = insereFim(adj[destino - 1].fim, origem, &adj[destino - 1].inicio);
  }

  for (i = 0; i < nrouters; i++)
  {
    if (d[i] == (-1))
    {
      max_aux = 0;
      n_scc++;
      tarjan(i, 1);
      maxscc[n_scc - 1] = max_aux;
    }
    else
    {
      
    }

  }

  Inicializacoes(2);
  for (i = 0; i < nrouters; i++)
  {
    if (d[i] == (-1))
    {
      max_aux = 0;
      tarjan(i, 2);
      if (max_aux > max_art)
      {
        max_art = max_aux;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  merge(maxscc, 0, n_scc - 1);
  printf("%d\n", n_scc);
  for (i = 0; i < (n_scc - 1); i++)
    printf("%d ", maxscc[i]);

  printf("%d\n", maxscc[n_scc - 1]);
  printf("%d\n", n_ptoart);
  printf("%d\n", max_art);
  eliminartudo();
  return 0;
}

