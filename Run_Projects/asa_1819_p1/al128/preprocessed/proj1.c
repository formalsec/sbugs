/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct router
{
  unsigned long id;
  bool ap;
  struct link *connect;
} router;
typedef struct link
{
  struct router *content;
  struct link *next;
} link;
void addLink(link **list, link *toAdd)
{
  if ((*list) == 0)
  {
    *list = toAdd;
  }
  else
  {
    link *temp = *list;
    while (temp->next != 0)
    {
      temp = temp->next;
    }

    temp->next = toAdd;
  }

}

void addNode(unsigned long router1, unsigned long router2, router *vertices)
{
  link *oneToTwo = (link *) malloc(sizeof(link));
  link *twoToOne = (link *) malloc(sizeof(link));
  oneToTwo->content = &vertices[router2 - 1];
  twoToOne->content = &vertices[router1 - 1];
  oneToTwo->next = 0;
  twoToOne->next = 0;
  addLink(&vertices[router1 - 1].connect, oneToTwo);
  addLink(&vertices[router2 - 1].connect, twoToOne);
}

void freeList(link *list)
{
  link *temp = list;
  link *oldTemp;
  while (temp != 0)
  {
    oldTemp = temp;
    temp = temp->next;
    free(oldTemp);
  }

}

unsigned long listSize(link *list)
{
  if (list == 0)
  {
    return 0;
  }
  else
  {
    unsigned long size = 1;
    link *temp = list;
    while (temp->next != 0)
    {
      temp = temp->next;
      size++;
    }

    return size;
  }

}

void startVertices(unsigned long number, router *vertices)
{
  unsigned long i;
  for (i = 0; i < number; i++)
  {
    vertices[i].id = i + 1;
    vertices[i].ap = 0;
    vertices[i].connect = 0;
  }

}

void freeGraph(router *vertices, unsigned long verticeNum)
{
  unsigned long i;
  for (i = 0; i < verticeNum; i++)
  {
    freeList(vertices[i].connect);
  }

  free(vertices);
}

unsigned long min(unsigned long a, unsigned long b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

unsigned long dfsVisit(router *node, unsigned long *time, unsigned long *discovery, unsigned long *predecessor, unsigned long *low, bool *seen)
{
  unsigned long biggestId = node->id;
  unsigned long tempId;
  unsigned long children = 0;
  seen[node->id - 1] = 1;
  discovery[node->id - 1] = *time;
  low[node->id - 1] = *time;
  (*time)++;
  link *l = node->connect;
  while (l != 0)
  {
    if (seen[l->content->id - 1] == 0)
    {
      predecessor[l->content->id - 1] = node->id;
      children++;
      tempId = dfsVisit(l->content, time, discovery, predecessor, low, seen);
      if (tempId > biggestId)
      {
        biggestId = tempId;
      }
      else
      {
        
      }

      low[node->id - 1] = min(low[node->id - 1], low[l->content->id - 1]);
      if ((predecessor[node->id - 1] == 0) && (children > 1))
      {
        node->ap = 1;
      }
      else
      {
        
      }

      if ((predecessor[node->id - 1] != 0) && (low[l->content->id - 1] >= discovery[node->id - 1]))
      {
        node->ap = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (l->content->id != predecessor[node->id - 1])
      {
        low[node->id - 1] = min(low[node->id - 1], discovery[l->content->id - 1]);
      }
      else
      {
        
      }

    }

    l = l->next;
  }

  return biggestId;
}

void dfs(router *vertices, unsigned long verticeNum)
{
  unsigned long i;
  unsigned long time = 1;
  unsigned long biggestNode;
  unsigned long *dfsDiscovery = (unsigned long *) malloc((sizeof(unsigned long)) * verticeNum);
  unsigned long *dfsPredecessor = (unsigned long *) malloc((sizeof(unsigned long)) * verticeNum);
  unsigned long *dfsLow = (unsigned long *) malloc((sizeof(unsigned long)) * verticeNum);
  bool *dfsSubtree = (bool *) malloc((sizeof(bool)) * verticeNum);
  bool *dfsSeen = (bool *) malloc((sizeof(bool)) * verticeNum);
  for (i = 0; i < verticeNum; i++)
  {
    dfsDiscovery[i] = 0;
    dfsPredecessor[i] = 0;
    dfsLow[i] = 0;
    dfsSeen[i] = 0;
    dfsSubtree[i] = 0;
  }

  for (i = 0; i < verticeNum; i++)
  {
    if (dfsSeen[i] == 0)
    {
      biggestNode = dfsVisit(&vertices[i], &time, dfsDiscovery, dfsPredecessor, dfsLow, dfsSeen);
      dfsSubtree[biggestNode - 1] = 1;
    }
    else
    {
      
    }

  }

  unsigned long subR = 0;
  unsigned long ap = 0;
  for (i = 0; i < verticeNum; i++)
  {
    if (dfsSubtree[i] == 1)
    {
      subR++;
    }
    else
    {
      
    }

    if (vertices[i].ap == 1)
    {
      ap++;
    }
    else
    {
      
    }

  }

  printf("%lu\n", subR);
  for (i = 0; i < verticeNum; i++)
  {
    if (dfsSubtree[i] == 1)
    {
      printf("%lu", vertices[i].id);
      if (subR > 1)
      {
        putchar(' ');
        subR--;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  printf("\n%lu\n", ap);
  free(dfsDiscovery);
  free(dfsPredecessor);
  free(dfsLow);
  free(dfsSubtree);
  free(dfsSeen);
}

void simpleDfsVisit(router *node, unsigned long *time, bool *seen)
{
  seen[node->id - 1] = 1;
  (*time)++;
  link *l = node->connect;
  while (l != 0)
  {
    if ((seen[l->content->id - 1] == 0) && (l->content->ap == 0))
    {
      simpleDfsVisit(l->content, time, seen);
    }
    else
    {
      
    }

    l = l->next;
  }

}

void simpleDfsCounter(router *vertices, unsigned long verticeNum)
{
  unsigned long i;
  unsigned long time = 0;
  unsigned long timeHigh = 0;
  bool *dfsSeen = (bool *) malloc((sizeof(bool)) * verticeNum);
  for (i = 0; i < verticeNum; i++)
  {
    dfsSeen[i] = 0;
  }

  for (i = 0; i < verticeNum; i++)
  {
    if ((dfsSeen[i] == 0) && (vertices[i].ap == 0))
    {
      simpleDfsVisit(&vertices[i], &time, dfsSeen);
    }
    else
    {
      
    }

    if (timeHigh < time)
    {
      timeHigh = time;
    }
    else
    {
      
    }

    time = 0;
  }

  printf("%lu\n", timeHigh);
  free(dfsSeen);
}

int main()
{
  unsigned long i;
  unsigned long verticeNum;
  unsigned long edgeNum;
  unsigned long r1;
  unsigned long r2;
  if (1 != 1)
  {
    return 1;
  }
  else
  {
    verticeNum = new_sym_var(sizeof(unsigned long) * 8);
    
  }

  if (1 != 1)
  {
    return 1;
  }
  else
  {
    edgeNum = new_sym_var(sizeof(unsigned long) * 8);
    
  }

  router *vertices = (router *) malloc((sizeof(router)) * verticeNum);
  startVertices(verticeNum, vertices);
  for (i = 0; i < edgeNum; i++)
  {
    if (2 != 2)
    {
      return 1;
    }
    else
    {
      r1 = new_sym_var(sizeof(unsigned long) * 8);
      r2 = new_sym_var(sizeof(unsigned long) * 8);
      
    }

    addNode(r1, r2, vertices);
  }

  dfs(vertices, verticeNum);
  simpleDfsCounter(vertices, verticeNum);
  freeGraph(vertices, verticeNum);
  return 0;
}

