/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct node *Link;
struct node
{
  int id;
  Link next;
};
Link insertL(Link head, int id);
void freeL(Link head);
struct graph
{
  int V;
  int E;
  Link *adjacencies;
};
struct audit
{
  int numSubNets;
  int netID;
  int *subNetIDs;
  int numCutV;
  char *cutV;
  int maxNetSize;
};
struct dfsState
{
  char *color;
  int *d;
  char *root;
  int *low;
};
typedef struct graph *Graph;
typedef struct audit *Audit;
typedef struct dfsState dfsState_t;
enum dfs_colors
{
  WHITE = 0,
  GRAY = 1,
  BLACK = 2
};
Graph initG(int V);
void insertEdgeG(Graph G, int u, int v);
void doDFS_G(Graph G, Audit output);
void doTarjanSearchG(Graph G, Audit output);
void freeG(Graph G);
Audit initAudit(Graph G);
void printAudit(Graph G, Audit output);
void freeAudit(Audit a);
int main()
{
  int V;
  int E;
  Graph G;
  int u;
  int v;
  Audit output;
  int i;
  if (!1)
  {
    printf("Invalid number of routers!\n");
    exit(1);
  }
  else
  {
    V = new_sym_var(sizeof(int) * 8);
    
  }

  if (!1)
  {
    printf("Invalid number of connections!\n");
    exit(1);
  }
  else
  {
    E = new_sym_var(sizeof(int) * 8);
    
  }

  G = initG(V);
  for (i = 0; i < E; i++)
  {
    u = new_sym_var(sizeof(int) * 8);
    v = new_sym_var(sizeof(int) * 8);
    insertEdgeG(G, u, v);
  }

  output = initAudit(G);
  doTarjanSearchG(G, output);
  doDFS_G(G, output);
  printAudit(G, output);
  freeG(G);
  freeAudit(output);
  return 0;
}

Audit initAudit(Graph G)
{
  Audit new = (Audit) malloc(sizeof(struct audit));
  new->numSubNets = 0;
  new->netID = 0;
  new->subNetIDs = (int *) malloc((sizeof(int)) * G->V);
  new->numCutV = 0;
  new->cutV = (char *) malloc((sizeof(char)) * G->V);
  new->maxNetSize = 0;
  return new;
}

void printAudit(Graph G, Audit output)
{
  int i;
  int flag = 0;
  printf("%d\n", output->numSubNets);
  for (i = 0; i < G->V; i++)
  {
    if (output->subNetIDs[i] != (-1))
    {
      if (!flag)
      {
        printf("%d", output->subNetIDs[i]);
        flag = 1;
      }
      else
      {
        printf(" %d", output->subNetIDs[i]);
      }

    }
    else
    {
      
    }

  }

  printf("\n%d\n", output->numCutV);
  printf("%d\n", output->maxNetSize);
}

void freeAudit(Audit a)
{
  free(a->subNetIDs);
  free(a->cutV);
  free(a);
}

Graph initG(int V)
{
  int i;
  Graph new = (Graph) malloc(sizeof(struct graph));
  new->V = V;
  new->E = 0;
  new->adjacencies = (Link *) malloc((sizeof(Link)) * V);
  for (i = 0; i < V; i++)
  {
    new->adjacencies[i] = 0;
  }

  return new;
}

void insertEdgeG(Graph G, int u, int v)
{
  G->adjacencies[u - 1] = insertL(G->adjacencies[u - 1], v);
  G->adjacencies[v - 1] = insertL(G->adjacencies[v - 1], u);
  G->E++;
}

static int tarjanVisitG(Graph G, int u, void *args, int count, Audit output)
{
  Link v;
  dfsState_t *state = (dfsState_t *) args;
  state->color[u - 1] = GRAY;
  state->d[u - 1] = count;
  state->low[u - 1] = count++;
  int numChildren = 0;
  for (v = G->adjacencies[u - 1]; v; v = v->next)
  {
    if (state->color[v->id - 1] == WHITE)
    {
      numChildren++;
      state->root[v->id - 1] = 0;
      output->netID = (output->netID > v->id) ? (output->netID) : (v->id);
      count = tarjanVisitG(G, v->id, (void *) state, count, output);
      state->low[u - 1] = (state->low[u - 1] < state->low[v->id - 1]) ? (state->low[u - 1]) : (state->low[v->id - 1]);
      if (((!state->root[u - 1]) && (state->low[v->id - 1] >= state->d[u - 1])) && (!output->cutV[u - 1]))
      {
        output->numCutV++;
        output->cutV[u - 1] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    if (state->color[v->id - 1] == GRAY)
    {
      state->low[u - 1] = (state->low[u - 1] < state->d[v->id - 1]) ? (state->low[u - 1]) : (state->d[v->id - 1]);
    }
    else
    {
      
    }

  }

  if (state->root[u - 1] && (numChildren > 1))
  {
    output->numCutV++;
    output->cutV[u - 1] = 1;
  }
  else
  {
    
  }

  state->color[u - 1] = BLACK;
  return count;
}

void doTarjanSearchG(Graph G, Audit output)
{
  char *color = (char *) malloc((sizeof(char)) * G->V);
  int *d = (int *) malloc((sizeof(int)) * G->V);
  char *root = (char *) malloc((sizeof(char)) * G->V);
  int *low = (int *) malloc((sizeof(int)) * G->V);
  dfsState_t state = {color, d, root, low};
  int u;
  int count = 1;
  for (u = 1; u <= G->V; u++)
  {
    color[u - 1] = WHITE;
    d[u - 1] = -1;
    root[u - 1] = 1;
    low[u - 1] = -1;
    output->cutV[u - 1] = 0;
    output->subNetIDs[u - 1] = -1;
  }

  for (u = 1; u <= G->V; u++)
  {
    if (color[u - 1] == WHITE)
    {
      output->numSubNets++;
      output->netID = u;
      count = tarjanVisitG(G, u, (void *) (&state), count, output);
      output->subNetIDs[output->netID - 1] = output->netID;
    }
    else
    {
      
    }

  }

  free(color);
  free(d);
  free(root);
  free(low);
}

static int dfsVisitG(Graph G, int u, char *color, int numVertices, Audit output)
{
  Link v;
  color[u - 1] = GRAY;
  for (v = G->adjacencies[u - 1]; v; v = v->next)
  {
    if ((color[v->id - 1] == WHITE) && (!output->cutV[v->id - 1]))
    {
      numVertices++;
      numVertices = dfsVisitG(G, v->id, color, numVertices, output);
    }
    else
    {
      
    }

  }

  color[u - 1] = BLACK;
  return numVertices;
}

void doDFS_G(Graph G, Audit output)
{
  char *color = (char *) malloc((sizeof(char)) * G->V);
  int numVertices = 1;
  int u;
  for (u = 1; u <= G->V; u++)
  {
    color[u - 1] = WHITE;
  }

  for (u = 1; u <= G->V; u++)
  {
    if ((color[u - 1] == WHITE) && (!output->cutV[u - 1]))
    {
      numVertices = dfsVisitG(G, u, color, numVertices, output);
      output->maxNetSize = (output->maxNetSize > numVertices) ? (output->maxNetSize) : (numVertices);
      numVertices = 1;
    }
    else
    {
      
    }

  }

  free(color);
}

void freeG(Graph G)
{
  int i;
  for (i = 0; i < G->V; i++)
  {
    freeL(G->adjacencies[i]);
  }

  free(G->adjacencies);
  free(G);
}

Link insertL(Link head, int id)
{
  Link new = (Link) malloc(sizeof(struct node));
  new->id = id;
  new->next = head;
  return new;
}

void freeL(Link head)
{
  Link t;
  while (head != 0)
  {
    t = head;
    head = t->next;
    free(t);
  }

}

