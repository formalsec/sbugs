/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct arco *Arco;
typedef struct vertice *Vertice;
typedef struct ligacao *Ligacao;
struct ligacao
{
  int v;
  Ligacao next;
};
struct arco
{
  int capacity;
  Vertice v;
  Arco next;
  Arco back;
};
struct vertice
{
  int id;
  Arco a;
  Arco parent;
};
typedef struct rede
{
  int numVert;
  int numForn;
  int numAbast;
  Vertice *adjacencias;
} *Grafo;
int V;
Grafo ReadInput();
Grafo GraphInit(int f, int e);
void InsertEdge(Grafo g, int v, int w, int c);
Arco InsertBegin(Arco head, Vertice v, int c);
Arco InsertSorted(Vertice h, Vertice v, int c);
void FreeRede(Grafo g);
void FreeArcos(Grafo g);
void PrintRede(Grafo g);
void FordFulkerson(Grafo G, int s, int t);
int main(int argc, const char **argv)
{
  Grafo G = ReadInput();
  FordFulkerson(G, 1, 0);
  FreeRede(G);
  return 0;
}

Grafo ReadInput()
{
  int f;
  int e;
  int t;
  int i = 2;
  int j;
  int c;
  f = new_sym_var(sizeof(int) * 8);
  e = new_sym_var(sizeof(int) * 8);
  t = new_sym_var(sizeof(int) * 8);
  Grafo G = GraphInit(f, e);
  while (i < (f + 2))
  {
    c = new_sym_var(sizeof(int) * 8);
    InsertEdge(G, i++, 0, c);
  }

  int m = (f + e) + 2;
  while (i < m)
  {
    c = new_sym_var(sizeof(int) * 8);
    InsertEdge(G, i + e, i, c);
    i++;
  }

  while (t--)
  {
    i = new_sym_var(sizeof(int) * 8);
    j = new_sym_var(sizeof(int) * 8);
    c = new_sym_var(sizeof(int) * 8);
    if (i >= (f + 2))
    {
      InsertEdge(G, j, i + e, c);
    }
    else
    {
      InsertEdge(G, j, i, c);
    }

  }

  return G;
}

Grafo GraphInit(int f, int e)
{
  int i = 0;
  int v = (f + (2 * e)) + 2;
  Grafo G = malloc(sizeof(struct rede));
  G->numVert = v;
  G->numForn = f;
  G->numAbast = e;
  G->adjacencias = malloc(v * (sizeof(Vertice)));
  V = v;
  for (; i < v; i++)
  {
    G->adjacencias[i] = malloc(sizeof(struct vertice));
    Vertice new = G->adjacencias[i];
    new->id = i;
    new->a = 0;
    new->parent = 0;
  }

  return G;
}

void InsertEdge(Grafo g, int v, int w, int c)
{
  Arco a = InsertSorted(g->adjacencias[v], g->adjacencias[w], c);
  Arco b = InsertSorted(g->adjacencias[w], g->adjacencias[v], 0);
  a->back = b;
  b->back = a;
}

Arco InsertSorted(Vertice h, Vertice v, int c)
{
  Arco head = h->a;
  Arco x = malloc(sizeof(struct arco));
  x->v = v;
  x->capacity = c;
  x->next = 0;
  if (head == 0)
  {
    x->next = 0;
    h->a = x;
  }
  else
  {
    if (head->v->id > v->id)
    {
      x->next = head;
      h->a = x;
    }
    else
    {
      while (head->next)
      {
        if (head->next->v->id > v->id)
        {
          x->next = head->next;
          head->next = x;
          break;
        }
        else
        {
          
        }

        head = head->next;
      }

      head->next = x;
    }

  }

  return x;
}

int bfs(Grafo g, int s, int t)
{
  char visited[g->numVert];
  int i = 0;
  while (i < g->numVert)
  {
    visited[i++] = 'f';
  }

  Ligacao l = malloc(sizeof(struct ligacao));
  Ligacao aux = 0;
  Ligacao end = 0;
  l->v = s;
  l->next = 0;
  visited[s] = 't';
  end = l;
  Arco curr = 0;
  while (l)
  {
    int u = l->v;
    aux = l;
    l = l->next;
    free(aux);
    curr = g->adjacencias[u]->a;
    while (curr)
    {
      if ((visited[curr->v->id] == 'f') && (curr->capacity > 0))
      {
        curr->v->parent = curr->back;
        visited[curr->v->id] = 't';
        Ligacao new = malloc(sizeof(struct ligacao));
        new->v = curr->v->id;
        new->next = 0;
        if (l == 0)
        {
          l = new;
          end = new;
        }
        else
        {
          aux = end;
          aux->next = new;
          end = new;
        }

      }
      else
      {
        
      }

      curr = curr->next;
    }

  }

  return visited[t] == 't';
}

void dfs(Grafo g, int s, char visited[])
{
  visited[s] = 't';
  Arco curr = g->adjacencias[s]->a;
  while (curr)
  {
    if (curr->capacity && (visited[curr->v->id] == 'f'))
    {
      dfs(g, curr->v->id, visited);
    }
    else
    {
      
    }

    curr = curr->next;
  }

}

void FordFulkerson(Grafo g, int s, int t)
{
  int u;
  int V = g->numVert;
  int max_flow = 0;
  while (bfs(g, s, t))
  {
    int path_flow = 2147483647;
    Vertice v = g->adjacencias[t];
    Arco u = 0;
    while (v != g->adjacencias[s])
    {
      u = v->parent;
      path_flow = (path_flow <= u->back->capacity) ? (path_flow) : (u->back->capacity);
      v = v->parent->v;
    }

    v = g->adjacencias[t];
    u = 0;
    while (v != g->adjacencias[s])
    {
      u = v->parent;
      u->back->capacity -= path_flow;
      u->capacity += path_flow;
      v = v->parent->v;
    }

    max_flow += path_flow;
  }

  char visited[V];
  int i = 0;
  char first = 't';
  while (i < V)
    visited[i++] = 'f';

  dfs(g, s, visited);
  printf("%d\n", max_flow);
  for (u = g->numForn + 2; u < (V - g->numAbast); u++)
  {
    Arco curr = g->adjacencias[u]->a;
    while (curr)
    {
      if (curr->v->id == (u + g->numAbast))
      {
        if (((visited[u] == 'f') && (visited[curr->v->id] == 't')) && curr->capacity)
        {
          if (first == 'f')
          {
            printf(" ");
          }
          else
          {
            first = 'f';
          }

          printf("%d", u);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      curr = curr->next;
    }

  }

  puts("");
  for (u = 2; u < (g->numForn + 2); u++)
  {
    Arco curr = g->adjacencias[u]->a;
    while (curr)
    {
      if ((((curr->v->id != 0) && (visited[u] == 'f')) && (visited[curr->v->id] == 't')) && curr->capacity)
      {
        printf("%d %d\n", u, curr->v->id);
      }
      else
      {
        
      }

      curr = curr->next;
    }

  }

  for (u = g->numVert - g->numAbast; u < V; u++)
  {
    Arco curr = g->adjacencias[u]->a;
    while (curr)
    {
      if (((visited[u] == 'f') && (visited[curr->v->id] == 't')) && curr->capacity)
      {
        printf("%d %d\n", u - g->numAbast, curr->v->id);
      }
      else
      {
        
      }

      curr = curr->next;
    }

  }

}

void FreeRede(Grafo g)
{
  FreeArcos(g);
  free(g->adjacencias);
  free(g);
}

void FreeArcos(Grafo g)
{
  int numVert = g->numVert;
  int i = 0;
  for (; i < numVert; i++)
  {
    Arco prev = 0;
    Arco curr = g->adjacencias[i]->a;
    while (curr != 0)
    {
      prev = curr;
      curr = curr->next;
      free(prev);
    }

    free(g->adjacencias[i]);
  }

}

void PrintRede(Grafo g)
{
  puts("debug3:print rede");
  printf("v: %d\n", g->numVert);
  int i = 0;
  for (; i < g->numVert; i++)
  {
    Arco prev = 0;
    Arco curr = g->adjacencias[i]->a;
    printf("Adjacencias de%3d:->", g->adjacencias[i]->id);
    while (curr != 0)
    {
      prev = curr;
      curr = curr->next;
      printf("next:id:%2d,cap:%3d|| ->", prev->v->id, prev->capacity);
    }

    puts("NIL");
  }

}

