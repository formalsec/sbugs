/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


struct edge
{
  int u;
  int v;
  int cap;
  int flow;
};
typedef struct edge *Edge;
typedef struct node *Link;
struct node
{
  Edge edge;
  Edge opEdge;
  Link next;
};
Link insertL(Link head, Edge edge);
void linkOppositesL(Link t, Link u);
void freeL(Link head);
typedef struct queueNode *QueueLink;
typedef struct queue *Queue;
struct queueNode
{
  int id;
  QueueLink next;
};
struct queue
{
  int N;
  QueueLink front;
  QueueLink back;
};
Queue initQ();
void putQ(Queue Q, int u);
int getQ(Queue Q);
int isEmptyQ(Queue Q);
void freeQ(Queue Q);
struct graph
{
  int V;
  int P;
  int S;
  int E;
  Link *adj;
};
struct PR_State
{
  int *h;
  int *e;
  char *active;
  int *gap;
};
typedef struct graph *Graph;
typedef struct PR_State PR_State_t;
struct audit
{
  int maxFlow;
  char *minCutS;
  Edge *minCutE;
  int idx;
};
typedef struct audit *NetAudit;
Graph initG(int V, int P, int S);
void insertWeightedEdgeG(Graph G, int u, int v, int c);
void pushRelabelFIFO(Graph G, NetAudit output);
void freeG(Graph G);
NetAudit initNetAudit(Graph G);
void printNetAudit(Graph G, NetAudit out);
void freeAudit(NetAudit a);
int cmpfunc(const void *a, const void *b)
{
  if ((*((Edge *) a))->u - (*((Edge *) b))->u)
  {
    return (*((Edge *) a))->u - (*((Edge *) b))->u;
  }
  else
  {
    
  }

  return (*((Edge *) a))->v - (*((Edge *) b))->v;
}

int main()
{
  int P;
  int S;
  int T;
  int V;
  Graph Net;
  int u;
  int v;
  int cap;
  int i;
  if ((((!scanf("%d %d %d", &P, &S, &T)) || (P < 1)) || (S < 0)) || (T < 0))
  {
    printf("Invalid input!\n");
    exit(1);
  }
  else
  {
    
  }

  V = (P + (2 * S)) + 2;
  Net = initG(V, P, S);
  for (i = 2; i < (P + 2); i++)
  {
    cap = new_sym_var(sizeof(int) * 8);
    insertWeightedEdgeG(Net, i, 0, cap);
  }

  for (i = P + 2; i < (S + (P + 2)); i++)
  {
    cap = new_sym_var(sizeof(int) * 8);
    insertWeightedEdgeG(Net, i + S, i, cap);
  }

  for (i = 0; i < T; i++)
  {
    if ((((!scanf("%d %d %d", &u, &v, &cap)) || (u < 2)) || (v < 1)) || (cap < 1))
    {
      printf("Invalid input!\n");
      exit(1);
    }
    else
    {
      
    }

    if (u > (P + 1))
    {
      u = u + S;
    }
    else
    {
      
    }

    insertWeightedEdgeG(Net, v, u, cap);
  }

  NetAudit out = initNetAudit(Net);
  pushRelabelFIFO(Net, out);
  printNetAudit(Net, out);
  freeG(Net);
  freeAudit(out);
  return 0;
}

NetAudit initNetAudit(Graph G)
{
  NetAudit new = (NetAudit) malloc(sizeof(struct audit));
  new->maxFlow = 0;
  new->minCutS = (char *) calloc(G->V, sizeof(char));
  new->minCutE = (Edge *) calloc(G->E, sizeof(Edge));
  new->idx = 0;
  return new;
}

void printNetAudit(Graph G, NetAudit out)
{
  int i;
  int flag = 0;
  printf("%d\n", out->maxFlow);
  for (i = G->P + 2; i < (G->V - G->S); i++)
  {
    if (out->minCutS[i] != 1)
    {
      continue;
    }
    else
    {
      
    }

    if (!flag)
    {
      printf("%d", i);
      flag = 1;
    }
    else
    {
      printf(" %d", i);
    }

  }

  printf("\n");
  qsort(out->minCutE, out->idx, sizeof(Edge), cmpfunc);
  for (i = 0; i < G->E; i++)
  {
    if (i == out->idx)
    {
      break;
    }
    else
    {
      
    }

    if (out->minCutE[i] == 0)
    {
      continue;
    }
    else
    {
      
    }

    if (out->minCutE[i]->u >= (G->V - G->S))
    {
      out->minCutE[i]->u -= G->S;
    }
    else
    {
      
    }

    printf("%d %d\n", out->minCutE[i]->u, out->minCutE[i]->v);
  }

}

void freeAudit(NetAudit a)
{
  free(a->minCutS);
  free(a->minCutE);
  free(a);
}

Graph initG(int V, int P, int S)
{
  int i;
  Graph new = (Graph) malloc(sizeof(struct graph));
  new->V = V;
  new->P = P;
  new->S = S;
  new->E = 0;
  new->adj = (Link *) malloc((sizeof(Link)) * V);
  for (i = 0; i < V; i++)
  {
    new->adj[i] = 0;
  }

  return new;
}

static Edge createWeightedEdgeG(int u, int v, int c)
{
  Edge new = (Edge) malloc(sizeof(struct edge));
  new->u = u;
  new->v = v;
  new->cap = c;
  new->flow = 0;
  return new;
}

void insertWeightedEdgeG(Graph G, int u, int v, int c)
{
  Edge e1 = createWeightedEdgeG(u, v, c);
  Edge e2 = createWeightedEdgeG(v, u, 0);
  G->adj[u] = insertL(G->adj[u], e1);
  G->adj[v] = insertL(G->adj[v], e2);
  linkOppositesL(G->adj[u], G->adj[v]);
  G->E++;
}

static void initializePreFLow(Graph G, Queue FIFO, PR_State_t *state, int s, int t)
{
  int u;
  int v;
  Link l;
  Edge edge;
  for (u = 0; u < G->V; u++)
  {
    state->h[u] = 0;
    state->e[u] = 0;
    state->active[u] = 0;
  }

  state->h[s] = G->V;
  state->gap[G->V] = 1;
  state->active[s] = 1;
  state->active[t] = 1;
  for (l = G->adj[s]; l; l = l->next)
  {
    edge = l->edge;
    v = l->edge->v;
    edge->flow = edge->cap;
    l->opEdge->flow = edge->flow * (-1);
    state->e[v] = edge->flow;
    state->e[s] -= edge->flow;
    state->active[v] = 1;
    putQ(FIFO, v);
  }

}

static void gapRelabel(Graph G, Queue FIFO, PR_State_t *state, int h)
{
  int u;
  for (u = 2; u < G->V; u++)
  {
    if (state->h[u] >= h)
    {
      state->gap[state->h[u]] -= 1;
      state->h[u] = (G->V > state->h[u]) ? (G->V) : (state->h[u]);
      state->gap[state->h[u]] += 1;
    }
    else
    {
      
    }

  }

}

static void relabel(Graph G, PR_State_t *state, int u)
{
  Link t;
  int min = G->V * 2;
  for (t = G->adj[u]; t; t = t->next)
  {
    if ((t->edge->cap - t->edge->flow) > 0)
    {
      min = (min < state->h[t->edge->v]) ? (min) : (state->h[t->edge->v]);
    }
    else
    {
      
    }

  }

  state->gap[state->h[u]] -= 1;
  state->h[u] = 1 + min;
  state->gap[state->h[u]] += 1;
}

static void push(PR_State_t *state, Link t, int u, int v)
{
  Edge edge = t->edge;
  int f = (state->e[u] < (edge->cap - edge->flow)) ? (state->e[u]) : (edge->cap - edge->flow);
  edge->flow += f;
  t->opEdge->flow = edge->flow * (-1);
  state->e[u] -= f;
  state->e[v] += f;
}

static void discharge(Graph G, Queue FIFO, PR_State_t *state, int u)
{
  Link t = G->adj[u];
  Edge edge;
  while (state->e[u] > 0)
  {
    if (t != 0)
    {
      edge = t->edge;
    }
    else
    {
      
    }

    if (t == 0)
    {
      if ((state->h[u] < G->V) && (state->gap[state->h[u]] == 1))
      {
        gapRelabel(G, FIFO, state, state->h[u]);
      }
      else
      {
        relabel(G, state, u);
        t = G->adj[u];
      }

    }
    else
    {
      if (((edge->cap - edge->flow) > 0) && (state->h[u] == (state->h[edge->v] + 1)))
      {
        push(state, t, u, edge->v);
        if (!state->active[edge->v])
        {
          state->active[edge->v] = 1;
          putQ(FIFO, edge->v);
        }
        else
        {
          
        }

      }
      else
      {
        t = t->next;
      }

    }

  }

  if (state->e[u] == 0)
  {
    state->active[u] = 0;
  }
  else
  {
    
  }

}

static void getMinCut(Graph G, PR_State_t *state, NetAudit output, int s)
{
  int u;
  int h;
  Link l;
  for (h = 2; h < G->V; h++)
  {
    if (state->gap[h] == 0)
    {
      break;
    }
    else
    {
      
    }

  }

  for (u = 0; u < G->V; u++)
  {
    if (state->h[u] < h)
    {
      continue;
    }
    else
    {
      
    }

    for (l = G->adj[u]; l; l = l->next)
    {
      if (state->h[l->edge->v] > h)
      {
        continue;
      }
      else
      {
        
      }

      if (u >= (G->V - G->S))
      {
        output->minCutS[l->edge->v] = 1;
      }
      else
      {
        if ((u == 1) || (u > (G->P + 1)))
        {
          output->minCutE[output->idx++] = l->opEdge;
        }
        else
        {
          
        }

      }

    }

  }

}

void pushRelabelFIFO(Graph G, NetAudit output)
{
  int u;
  int *h = (int *) malloc((sizeof(int)) * G->V);
  int *e = (int *) malloc((sizeof(int)) * G->V);
  char *active = (char *) malloc((sizeof(char)) * G->V);
  int *gap = (int *) calloc(2 * G->V, sizeof(int));
  PR_State_t state = {h, e, active, gap};
  Queue FIFO = initQ();
  initializePreFLow(G, FIFO, (PR_State_t *) (&state), 1, 0);
  while (!isEmptyQ(FIFO))
  {
    u = getQ(FIFO);
    discharge(G, FIFO, (PR_State_t *) (&state), u);
  }

  output->maxFlow = state.e[0];
  getMinCut(G, (PR_State_t *) (&state), output, 0);
  free(h);
  free(e);
  free(active);
  free(gap);
  freeQ(FIFO);
}

void freeG(Graph G)
{
  int i;
  for (i = 0; i < G->V; i++)
  {
    freeL(G->adj[i]);
  }

  free(G->adj);
  free(G);
}

Queue initQ()
{
  Queue new;
  new = (Queue) malloc(sizeof(struct queue));
  new->front = 0;
  new->back = 0;
  new->N = 0;
  return new;
}

void putQ(Queue Q, int u)
{
  QueueLink new = (QueueLink) malloc(sizeof(struct queueNode));
  new->id = u;
  new->next = 0;
  if (!isEmptyQ(Q))
  {
    Q->back->next = new;
  }
  else
  {
    Q->front = new;
  }

  Q->back = new;
  Q->N++;
}

int getQ(Queue Q)
{
  QueueLink t;
  int id;
  if (!isEmptyQ(Q))
  {
    id = Q->front->id;
    t = Q->front;
    Q->front = t->next;
    free(t);
    if (isEmptyQ(Q))
    {
      Q->back = 0;
    }
    else
    {
      
    }

    Q->N--;
    return id;
  }
  else
  {
    
  }

  return 0;
}

int isEmptyQ(Queue Q)
{
  return Q->N == 0;
}

void freeQ(Queue Q)
{
  QueueLink t;
  while (Q->front != 0)
  {
    t = Q->front;
    Q->front = t->next;
    free(t);
  }

  free(Q);
}

Link insertL(Link head, Edge edge)
{
  Link new = (Link) malloc(sizeof(struct node));
  new->edge = edge;
  new->next = head;
  new->opEdge = 0;
  return new;
}

void linkOppositesL(Link t, Link u)
{
  t->opEdge = u->edge;
  u->opEdge = t->edge;
}

void freeL(Link head)
{
  Link t;
  while (head != 0)
  {
    t = head;
    head = t->next;
    free(t->edge);
    free(t);
  }

}

