/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stdio.h>


typedef struct Stack
{
  int top;
  int size;
  int *values;
  int *onStack;
} Stack;
typedef struct Node
{
  int dest;
  struct Node *next;
} Node;
typedef struct Graph
{
  Node **adjList;
  int V;
  int time;
  int SCCs;
  int *grade;
  int *d;
  int *color;
  int *low;
  int *SCCId;
  int *SCCGrades;
} Graph;
int Min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

int Max(int a, int b)
{
  return (a > b) ? (a) : (b);
}

Stack *createStack(int size)
{
  int i;
  Stack *s = malloc(sizeof(Stack));
  s->size = size;
  s->top = -1;
  s->values = malloc((sizeof(int)) * size);
  s->onStack = malloc((sizeof(int)) * (size + 1));
  for (i = 0; i < size; i++)
  {
    s->values[i] = -1;
    s->onStack[i] = 0;
  }

  s->onStack[i] = 0;
  return s;
}

void push(Stack *s, int v)
{
  s->values[++s->top] = v;
}

int pop(Stack *s)
{
  return s->values[s->top--];
}

Graph *createGraph(int V)
{
  int i;
  Graph *g = malloc(sizeof(Graph));
  g->V = V;
  g->adjList = malloc((sizeof(Node)) * (V + 1));
  g->grade = malloc((sizeof(int)) * (V + 1));
  g->low = malloc((sizeof(int)) * (V + 1));
  g->d = malloc((sizeof(int)) * (V + 1));
  g->color = malloc((sizeof(int)) * (V + 1));
  g->SCCId = malloc((sizeof(int)) * (V + 1));
  g->SCCGrades = malloc((sizeof(int)) * (V + 1));
  for (i = 1; i <= g->V; i++)
  {
    g->adjList[i] = 0;
    g->grade[i] = (g->low[i] = (g->d[i] = (g->SCCId[i] = (g->SCCGrades[i] = -1))));
  }

  g->SCCs = 1;
  return g;
}

void addEdge(Graph *g, int src, int dest)
{
  Node *newNode = malloc(sizeof(Node));
  newNode->dest = dest;
  newNode->next = g->adjList[src];
  g->adjList[src] = newNode;
}

void Tarjan_Visit(Graph *g, Stack *s, int i)
{
  Node *tmp;
  g->d[i] = (g->low[i] = ++g->time);
  push(s, i);
  s->onStack[i] = 1;
  for (tmp = g->adjList[i]; tmp != 0; tmp = tmp->next)
  {
    int v = tmp->dest;
    if ((g->d[v] == (-1)) || s->onStack[v])
    {
      if (g->d[v] == (-1))
      {
        Tarjan_Visit(g, s, v);
      }
      else
      {
        
      }

      g->low[i] = Min(g->low[v], g->low[i]);
    }
    else
    {
      
    }

  }

  if (g->low[i] == g->d[i])
  {
    int u;
    while (s->values[s->top] != i)
    {
      u = pop(s);
      s->onStack[u] = 0;
      g->SCCId[u] = g->SCCs;
      g->SCCGrades[g->SCCs] = Max(g->SCCGrades[g->SCCs], g->grade[u]);
    }

    u = pop(s);
    s->onStack[u] = 0;
    g->SCCId[u] = g->SCCs;
    g->SCCGrades[g->SCCs] = Max(g->SCCGrades[g->SCCs], g->grade[u]);
    g->SCCs++;
  }
  else
  {
    
  }

}

void SCC_Tarjan(Graph *g)
{
  int i;
  int V = g->V;
  Stack *s = createStack(V);
  g->time = 0;
  for (i = 1; i <= V; i++)
    if (g->d[i] == (-1))
  {
    Tarjan_Visit(g, s, i);
  }
  else
  {
    
  }


  free(s->onStack);
  free(s->values);
  free(s);
}

void DFSVisit(Graph *g, int v)
{
  Node *ptr;
  g->color[v] = 0;
  for (ptr = g->adjList[v]; ptr != 0; ptr = ptr->next)
  {
    if (g->color[ptr->dest] == 1)
    {
      DFSVisit(g, ptr->dest);
    }
    else
    {
      
    }

    g->grade[v] = Max(g->grade[v], g->grade[ptr->dest]);
  }

  g->color[v] = 2;
}

void DFS(Graph *g)
{
  int i;
  for (i = 1; i <= g->V; i++)
  {
    g->color[i] = 1;
  }

  for (i = 1; i <= g->V; i++)
  {
    if (g->color[i] == 1)
    {
      DFSVisit(g, i);
    }
    else
    {
      
    }

  }

}

Graph *doAlgorithm(Graph *g)
{
  SCC_Tarjan(g);
  Graph *scc = createGraph(g->SCCs);
  int v;
  for (v = 0; v < g->SCCs; v++)
    scc->grade[v] = g->SCCGrades[v];

  Node *ptr;
  for (v = 1; v <= g->V; v++)
    for (ptr = g->adjList[v]; ptr != 0; ptr = ptr->next)
  {
    if (g->SCCId[v] != g->SCCId[ptr->dest])
    {
      addEdge(scc, g->SCCId[v], g->SCCId[ptr->dest]);
    }
    else
    {
      
    }

  }


  DFS(scc);
  return scc;
}

Graph *readInput()
{
  int V;
  int numE;
  if (2 != 2)
  {
    fprintf(stderr, "Invalid input");
    exit(1);
  }
  else
  {
    V = new_sym_var(sizeof(int) * 8);
    numE = new_sym_var(sizeof(int) * 8);
    
  }

  Graph *g = createGraph(V);
  int i;
  for (i = 1; i <= V; i++)
  {
    int grade;
    if (1 != 1)
    {
      fprintf(stderr, "Invalid input");
      exit(1);
    }
    else
    {
      grade = new_sym_var(sizeof(int) * 8);
      
    }

    g->grade[i] = grade;
  }

  for (i = 0; i < numE; i++)
  {
    int src;
    int dest;
    if (2 != 2)
    {
      fprintf(stderr, "Invalid input");
      exit(1);
    }
    else
    {
      src = new_sym_var(sizeof(int) * 8);
      dest = new_sym_var(sizeof(int) * 8);
      
    }

    ;
    addEdge(g, src, dest);
  }

  return g;
}

void writeOutput(Graph *g, Graph *scc)
{
  int i;
  for (i = 1; i <= g->V; i++)
    printf("%d\n", scc->grade[g->SCCId[i]]);

}

void freeMemory(Graph *g, Graph *scc)
{
  Node *ptr;
  int i;
  for (i = 1; i <= g->V; i++)
  {
    while (g->adjList[i])
    {
      ptr = g->adjList[i];
      g->adjList[i] = g->adjList[i]->next;
      free(ptr);
    }

  }

  for (i = 1; i <= scc->V; i++)
  {
    while (scc->adjList[i])
    {
      ptr = scc->adjList[i];
      scc->adjList[i] = scc->adjList[i]->next;
      free(ptr);
    }

  }

  free(g->adjList);
  free(g->color);
  free(g->d);
  free(g->grade);
  free(g->low);
  free(g->SCCId);
  free(g->SCCGrades);
  free(g);
  free(scc->adjList);
  free(scc->color);
  free(scc->d);
  free(scc->grade);
  free(scc->low);
  free(scc->SCCId);
  free(scc->SCCGrades);
  free(scc);
}

int main()
{
  Graph *g = readInput();
  Graph *scc = doAlgorithm(g);
  writeOutput(g, scc);
  freeMemory(g, scc);
  return 0;
}

