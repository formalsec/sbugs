/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h> 
#include <string.h>


struct node
{
  int w;
  struct node *next;
};
typedef struct node *link;
struct adjList
{
  link head;
};
typedef struct adjList AdjList;
struct graph
{
  int V;
  int E;
  AdjList *adj;
};
typedef struct graph *Graph;
struct queue
{
  link head;
  link tail;
};
typedef struct queue *Queue;
int *dsc;
int *low;
int *grades;
int *onStack;
Queue queue;
Graph G;
int time = 0;
int sccCount = 0;
link newNode(int v)
{
  link a = malloc(sizeof(struct node));
  a->w = v;
  a->next = 0;
  return a;
}

Queue createQueue()
{
  Queue s = (Queue) malloc(sizeof(struct queue));
  s->head = (s->tail = 0);
  return s;
}

void pop()
{
  if (queue->head == 0)
  {
    return;
  }
  else
  {
    
  }

  link temp = queue->head;
  queue->head = queue->head->next;
  if (queue->head == 0)
  {
    queue->tail = 0;
  }
  else
  {
    
  }

  free(temp);
}

void push(int v)
{
  link temp = newNode(v);
  if (queue->tail == 0)
  {
    queue->head = (queue->tail = temp);
    return;
  }
  else
  {
    
  }

  queue->tail->next = temp;
  queue->tail = temp;
}

void newEdge(int v, int w)
{
  link new = newNode(w);
  new->next = G->adj[v].head;
  G->adj[v].head = new;
  G->E++;
}

Graph initGraph(int V)
{
  int v;
  Graph G = malloc(sizeof(struct graph));
  G->V = V;
  G->E = 0;
  G->adj = malloc(V * (sizeof(AdjList)));
  for (v = 0; v < V; v++)
    G->adj[v].head = 0;

  return G;
}

int max(int a, int b)
{
  return (a > b) ? (a) : (b);
}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

int visit(int v)
{
  link a;
  push(v);
  onStack[v] = 1;
  dsc[v] = time;
  low[v] = time;
  time++;
  int maxGrade = grades[v];
  for (a = G->adj[v].head; a != 0; a = a->next)
  {
    if (dsc[a->w] == (-1))
    {
      maxGrade = max(maxGrade, visit(a->w));
      low[v] = min(low[v], low[a->w]);
    }
    else
    {
      if (onStack[a->w] == 1)
      {
        maxGrade = max(maxGrade, grades[a->w]);
        low[v] = min(low[v], dsc[a->w]);
      }
      else
      {
        maxGrade = max(maxGrade, grades[a->w]);
      }

    }

  }

  if (dsc[v] == low[v])
  {
    for (a = queue->head; a != 0; a = a->next)
    {
      grades[a->w] = max(maxGrade, grades[a->w]);
      onStack[a->w] = 0;
      pop();
    }

    sccCount++;
  }
  else
  {
    
  }

  grades[v] = maxGrade;
  return maxGrade;
}

int main()
{
  int i = 0;
  int students;
  int friendships;
  int s1;
  int s2;
  students = new_sym_var(sizeof(int) * 8);
  friendships = new_sym_var(sizeof(int) * 8);
  G = initGraph(students);
  queue = createQueue();
  dsc = (int *) malloc(students * (sizeof(int)));
  low = (int *) malloc(students * (sizeof(int)));
  grades = (int *) malloc(students * (sizeof(int)));
  onStack = (int *) malloc(students * (sizeof(int)));
  memset(onStack, 0, students * (sizeof(int)));
  memset(dsc, -1, students * (sizeof(int)));
  memset(low, -1, students * (sizeof(int)));
  for (i = 0; i < students; i++)
  {
    grades[i] = new_sym_var(sizeof(int) * 8);
  }

  for (i = 0; i < friendships; i++)
  {
    s1 = new_sym_var(sizeof(int) * 8);
    s2 = new_sym_var(sizeof(int) * 8);
    newEdge(s1 - 1, s2 - 1);
  }

  for (i = 0; i < students; i++)
  {
    visit(i);
    printf("%d\n", grades[i]);
  }

  free(G);
  free(dsc);
  free(low);
  free(grades);
  free(onStack);
  free(queue);
  return 0;
}

