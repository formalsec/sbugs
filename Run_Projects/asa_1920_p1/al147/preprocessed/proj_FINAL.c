/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


void panic(char *msg)
{
  printf("%s\n", msg);
  exit(1);
}

typedef struct Stack
{
  int top_index;
  int *stack_list;
} Stack;
Stack *initialize_stack()
{
  Stack *new_stack = (Stack *) malloc(sizeof(Stack));
  new_stack->top_index = -1;
  return new_stack;
}

void push_stack(Stack *stack, int number)
{
  if (stack->top_index == (-1))
  {
    stack->stack_list = (int *) malloc(sizeof(int));
    if (!stack->stack_list)
    {
      panic("Failed to allocate memory for the stack.");
    }
    else
    {
      
    }

  }
  else
  {
    stack->stack_list = (int *) realloc(stack->stack_list, (sizeof(int)) * (stack->top_index + 2));
    if (!stack->stack_list)
    {
      panic("Failed to reallocate memory for the stack!");
    }
    else
    {
      
    }

  }

  stack->top_index++;
  stack->stack_list[stack->top_index] = number;
}

int pop_stack(Stack *stack)
{
  int item;
  if (stack->top_index == (-1))
  {
    item = -1;
  }
  else
  {
    if (stack->top_index == 0)
    {
      item = stack->stack_list[stack->top_index];
      stack->top_index = -1;
      free(stack->stack_list);
    }
    else
    {
      item = stack->stack_list[stack->top_index];
      stack->top_index--;
      stack->stack_list = (int *) realloc(stack->stack_list, (sizeof(int)) * (stack->top_index + 1));
      if (!stack->stack_list)
      {
        panic("Failed to reallocate memory for the stack!");
      }
      else
      {
        
      }

    }

  }

  return item;
}

void free_stack(Stack *stack)
{
  if (stack->top_index != (-1))
  {
    free(stack->stack_list);
  }
  else
  {
    
  }

  free(stack);
}

typedef struct GraphNode GraphNode;
struct GraphNode
{
  int index;
  GraphNode *next;
};
typedef struct StudentGraph
{
  int num_students;
  int *grades;
  GraphNode **nodes;
} StudentGraph;
StudentGraph *new_student_graph(int size)
{
  int i;
  StudentGraph *student_system = (StudentGraph *) malloc(sizeof(StudentGraph));
  if (!student_system)
  {
    panic("Failed to allocate memory for the student system!");
  }
  else
  {
    
  }

  student_system->num_students = size;
  student_system->grades = (int *) malloc((sizeof(int)) * size);
  if (!student_system->grades)
  {
    panic("Failed to allocate memory for the grade vector!");
  }
  else
  {
    
  }

  student_system->nodes = (GraphNode **) malloc((sizeof(GraphNode *)) * size);
  if (!student_system->nodes)
  {
    panic("Failed to allocate memory for the nodes array!");
  }
  else
  {
    
  }

  for (i = 0; i < size; i++)
  {
    student_system->nodes[i] = 0;
  }

  return student_system;
}

void add_student(StudentGraph *student_system, int grade, int index)
{
  student_system->grades[index] = grade;
}

void add_friend(StudentGraph *student_system, int student, int friend)
{
  GraphNode *new_node = (GraphNode *) malloc(sizeof(GraphNode));
  if (!new_node)
  {
    panic("Failed to allocate memory for a friend!");
  }
  else
  {
    
  }

  new_node->index = friend;
  new_node->next = 0;
  if (student_system->nodes[student] != 0)
  {
    new_node->next = student_system->nodes[student];
  }
  else
  {
    
  }

  student_system->nodes[student] = new_node;
}

void free_system(StudentGraph *student_graph)
{
  int i;
  free(student_graph->grades);
  for (i = 0; i < student_graph->num_students; i++)
  {
    if (student_graph->nodes[i] != 0)
    {
      GraphNode *current_node = student_graph->nodes[i];
      GraphNode *temp_node;
      while (current_node != 0)
      {
        temp_node = current_node;
        current_node = current_node->next;
        free(temp_node);
      }

    }
    else
    {
      
    }

  }

  free(student_graph->nodes);
  free(student_graph);
}

StudentGraph *get_input()
{
  int i;
  int n_students;
  int n_relationships;
  char line[1024];
  if (!fgets(line, 1024, stdin))
  {
    panic("Failed to get Input!");
  }
  else
  {
    
  }

  if (2 != 2)
  {
    panic("Invalid Input!");
  }
  else
  {
    n_students = new_sym_var(sizeof(int) * 8);
    n_relationships = new_sym_var(sizeof(int) * 8);
    
  }

  StudentGraph *student_graph = new_student_graph(n_students);
  int grade;
  for (i = 0; i < n_students; i++)
  {
    if (!fgets(line, 1024, stdin))
    {
      panic("Failed to get Input!");
    }
    else
    {
      
    }

    if (1 != 1)
    {
      panic("Invalid Input");
    }
    else
    {
      grade = new_sym_var(sizeof(int) * 8);
      
    }

    add_student(student_graph, grade, i);
  }

  int student;
  int friend;
  for (i = 0; i < n_relationships; i++)
  {
    if (!fgets(line, 1024, stdin))
    {
      panic("Failed to get Input!");
    }
    else
    {
      
    }

    if (2 != 2)
    {
      panic("Invalid Input!");
    }
    else
    {
      student = new_sym_var(sizeof(int) * 8);
      friend = new_sym_var(sizeof(int) * 8);
      
    }

    add_friend(student_graph, student - 1, friend - 1);
  }

  return student_graph;
}

void print_grades_formatted(StudentGraph *student_graph)
{
  int i;
  for (i = 0; i < student_graph->num_students; i++)
  {
    printf("%d\n", student_graph->grades[i]);
  }

}

typedef enum State
{
  NOT_VISITED,
  ON_STACK,
  VISITED
} State;
typedef struct AlgorithmData
{
  State *states;
  int *disc;
  int *lows;
  Stack *stack;
} AlgorithmData;
AlgorithmData *initialize_data(int num_students)
{
  AlgorithmData *new_data = (AlgorithmData *) malloc(sizeof(AlgorithmData));
  new_data->states = (State *) calloc(num_students, sizeof(int));
  new_data->disc = (int *) malloc((sizeof(int)) * num_students);
  new_data->lows = (int *) malloc((sizeof(int)) * num_students);
  new_data->stack = initialize_stack();
  return new_data;
}

void free_data(AlgorithmData *data)
{
  free(data->states);
  free(data->disc);
  free(data->lows);
  free_stack(data->stack);
  free(data);
}

void visit_maximize_grade(StudentGraph *student_graph, int node, int *time, AlgorithmData *data)
{
  (*time)++;
  data->states[node] = ON_STACK;
  data->disc[node] = *time;
  data->lows[node] = *time;
  push_stack(data->stack, node);
  GraphNode *current_node = student_graph->nodes[node];
  int friend;
  while (current_node != 0)
  {
    friend = current_node->index;
    if (data->states[friend] == NOT_VISITED)
    {
      visit_maximize_grade(student_graph, friend, time, data);
      data->lows[node] = (data->lows[node] < data->lows[current_node->index]) ? (data->lows[node]) : (data->lows[current_node->index]);
      student_graph->grades[node] = (student_graph->grades[node] > student_graph->grades[friend]) ? (student_graph->grades[node]) : (student_graph->grades[friend]);
    }
    else
    {
      if (data->states[current_node->index] == ON_STACK)
      {
        data->lows[node] = (data->lows[node] < data->lows[current_node->index]) ? (data->lows[node]) : (data->lows[current_node->index]);
        student_graph->grades[node] = (student_graph->grades[node] > student_graph->grades[friend]) ? (student_graph->grades[node]) : (student_graph->grades[friend]);
      }
      else
      {
        student_graph->grades[node] = (student_graph->grades[node] > student_graph->grades[friend]) ? (student_graph->grades[node]) : (student_graph->grades[friend]);
      }

    }

    current_node = current_node->next;
  }

  if (data->disc[node] == data->lows[node])
  {
    int popped = pop_stack(data->stack);
    data->states[popped] = VISITED;
    student_graph->grades[popped] = student_graph->grades[node];
    while (popped != node)
    {
      popped = pop_stack(data->stack);
      data->states[popped] = VISITED;
      student_graph->grades[popped] = student_graph->grades[node];
    }

  }
  else
  {
    
  }

}

void maximize_grade(StudentGraph *student_graph)
{
  int i;
  int time = 0;
  AlgorithmData *data = initialize_data(student_graph->num_students);
  for (i = 0; i < student_graph->num_students; i++)
  {
    if (data->states[i] == NOT_VISITED)
    {
      visit_maximize_grade(student_graph, i, &time, data);
    }
    else
    {
      
    }

  }

  free_data(data);
}

int main()
{
  StudentGraph *student_graph = get_input();
  maximize_grade(student_graph);
  print_grades_formatted(student_graph);
  free_system(student_graph);
  return 0;
}

