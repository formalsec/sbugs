/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int C = 0;
int S = 0;
int M = 0;
int N = 0;
int V = 0;
typedef struct queue queue;
typedef struct element element;
typedef struct node *link;
struct element
{
  int data;
  element *next;
};
struct queue
{
  int count;
  element *front;
  element *rear;
};
struct node
{
  int n;
  int flow;
  link next;
};
void initializeQueue(queue *q)
{
  q->count = 0;
  q->front = 0;
  q->rear = 0;
}

int isQueueEmpty(queue *q)
{
  return q->rear == 0;
}

void enQueue(queue *q, int value)
{
  element *tmp;
  tmp = malloc(sizeof(element));
  tmp->data = value;
  tmp->next = 0;
  if (!isQueueEmpty(q))
  {
    q->rear->next = tmp;
    q->rear = tmp;
  }
  else
  {
    q->front = tmp;
    q->rear = tmp;
  }

  q->count++;
}

int deQueue(queue *q)
{
  int n;
  element *tmp;
  n = q->front->data;
  tmp = q->front;
  q->front = q->front->next;
  q->count--;
  if (q->count == 0)
  {
    q->rear = 0;
  }
  else
  {
    
  }

  free(tmp);
  return n;
}

int getN(int av, int st)
{
  return ((av + ((st - 1) * M)) * 2) - 1;
}

void getCoords(int n, int *av, int *st)
{
  *av = ((n + 1) % (M * 2)) / 2;
  *st = (n + 1) / (M * 2);
  if ((*av) == 0)
  {
    *av = M;
  }
  else
  {
    (*st)++;
  }

}

void getNeighbours(int node, int neighbours[])
{
  int i;
  int av;
  int st;
  getCoords(node, &av, &st);
  for (i = 0; i < 4; i++)
  {
    if ((i == 0) && ((av + 1) <= M))
    {
      neighbours[i] = node + 1;
    }
    else
    {
      if ((i == 1) && ((av - 1) > 0))
      {
        neighbours[i] = node - 3;
      }
      else
      {
        if ((i == 2) && ((st + 1) <= N))
        {
          neighbours[i] = node + ((M * 2) - 1);
        }
        else
        {
          if ((i == 3) && ((st - 1) > 0))
          {
            neighbours[i] = node - ((M * 2) + 1);
          }
          else
          {
            neighbours[i] = 0;
          }

        }

      }

    }

  }

}

link createLink(int n, int flow)
{
  link l;
  l = malloc(sizeof(struct node));
  l->n = n;
  l->flow = flow;
  l->next = 0;
  return l;
}

link lastLink(link *G, int n)
{
  link m;
  m = G[n];
  while (m->next != 0)
  {
    m = m->next;
  }

  return m;
}

link findLink(link *G, int n, int find)
{
  link m;
  m = G[n];
  while ((m != 0) && (m->n != find))
  {
    m = m->next;
  }

  return m;
}

link *initializeGraph()
{
  int i;
  int j;
  int node;
  int av;
  int st;
  link *G;
  int neighbours[4];
  link m;
  link n;
  G = malloc(V * (sizeof(link)));
  for (i = 0; i < V; i++)
  {
    G[i] = malloc(sizeof(struct node));
    G[i]->n = i;
    G[i]->next = 0;
  }

  for (i = 1; i < (V - 2); i += 2)
  {
    n = malloc(sizeof(struct node));
    n->n = i + 1;
    n->flow = 1;
    n->next = 0;
    G[i]->next = n;
  }

  for (i = 2; i < (V - 1); i += 2)
  {
    getNeighbours(i, neighbours);
    m = G[i];
    for (j = 0; j < 4; j++)
    {
      if (neighbours[j] != 0)
      {
        n = malloc(sizeof(struct node));
        n->n = neighbours[j];
        n->flow = 1;
        n->next = 0;
        m->next = n;
        m = m->next;
      }
      else
      {
        
      }

    }

  }

  for (i = 0; i < S; i++)
  {
    av = new_sym_var(sizeof(int) * 8);
    st = new_sym_var(sizeof(int) * 8);
    node = getN(av, st) + 1;
    m = lastLink(G, node);
    n = malloc(sizeof(struct node));
    n->n = V - 1;
    n->flow = 1;
    n->next = 0;
    m->next = n;
  }

  for (i = 0; i < C; i++)
  {
    av = new_sym_var(sizeof(int) * 8);
    st = new_sym_var(sizeof(int) * 8);
    node = getN(av, st);
    m = lastLink(G, 0);
    n = malloc(sizeof(struct node));
    n->n = node;
    n->flow = 1;
    n->next = 0;
    m->next = n;
  }

  return G;
}

int bfs(link *G, int s, int t, int parent[])
{
  int i;
  int u;
  int *visited;
  link l;
  queue *q;
  q = malloc(sizeof(queue));
  visited = malloc(V * (sizeof(int)));
  for (i = 0; i < V; i++)
    visited[i] = 0;

  initializeQueue(q);
  enQueue(q, s);
  visited[s] = 1;
  parent[s] = -1;
  while (!isQueueEmpty(q))
  {
    u = deQueue(q);
    l = G[u]->next;
    while (l != 0)
    {
      if (((visited[l->n] == 0) && (l != 0)) && (l->flow > 0))
      {
        enQueue(q, l->n);
        parent[l->n] = u;
        visited[l->n] = 1;
      }
      else
      {
        
      }

      l = l->next;
    }

  }

  free(q);
  if (visited[t] == 1)
  {
    free(visited);
    return 1;
  }
  else
  {
    free(visited);
    return 0;
  }

}

int edmondsKarp(link *G, int s, int t)
{
  int u;
  int v;
  int maxFlow = 0;
  link l;
  link m;
  int *parent;
  parent = malloc(V * (sizeof(int)));
  while (bfs(G, s, t, parent))
  {
    for (v = t; v != s; v = parent[v])
    {
      u = parent[v];
      l = findLink(G, u, v);
      l->flow -= 1;
      l = findLink(G, v, u);
      if (l == 0)
      {
        l = createLink(u, 0);
        m = lastLink(G, v);
        m->next = l;
      }
      else
      {
        
      }

      l->flow += 1;
    }

    maxFlow += 1;
    if ((maxFlow == S) || (maxFlow == C))
    {
      return maxFlow;
    }
    else
    {
      
    }

  }

  return maxFlow;
}

int main()
{
  link *graph;
  M = new_sym_var(sizeof(int) * 8);
  N = new_sym_var(sizeof(int) * 8);
  S = new_sym_var(sizeof(int) * 8);
  C = new_sym_var(sizeof(int) * 8);
  V = (2 * (M * N)) + 2;
  graph = initializeGraph();
  printf("%d\n", edmondsKarp(graph, 0, V - 1));
  return 0;
}

