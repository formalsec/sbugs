/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct item
{
  int n;
  struct item *prox;
} Item;
struct queue
{
  int items[1000000 + 1];
  int front;
  int rear;
};
struct queue *createQ()
{
  struct queue *q = malloc(sizeof(struct queue));
  q->front = -1;
  q->rear = -1;
  return q;
}

int isEmpty(struct queue *q)
{
  if (q->rear == (-1))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

void enQ(struct queue *q, int value)
{
  if (q->front == (-1))
  {
    q->front = 0;
  }
  else
  {
    
  }

  q->rear++;
  q->items[q->rear] = value;
}

int deQ(struct queue *q)
{
  int item;
  if (isEmpty(q))
  {
    item = -1;
  }
  else
  {
    item = q->items[q->front];
    q->front++;
    if (q->front > q->rear)
    {
      q->front = (q->rear = -1);
    }
    else
    {
      
    }

  }

  return item;
}

Item list[1000000 + 1];
int M;
int N;
int nS;
int nC;
int Sup[1000000 + 1];
int Cid[1000000 + 1];
int color[1000000 + 1];
int maxC;
void addEdge(Item *list, int u, int v)
{
  Item *aux;
  Item *tmp;
  aux = (Item *) malloc((int) (sizeof(Item)));
  aux->n = v;
  aux->prox = 0;
  list[u].n++;
  if (list[u].prox == 0)
  {
    list[u].prox = aux;
  }
  else
  {
    tmp = list[u].prox;
    if (tmp->n > v)
    {
      aux->prox = tmp;
      list[u].prox = aux;
    }
    else
    {
      if (tmp->prox == 0)
      {
        aux->prox = tmp->prox;
        tmp->prox = aux;
      }
      else
      {
        while ((tmp->prox != 0) && (tmp->prox->n < v))
          tmp = tmp->prox;

        aux->prox = tmp->prox;
        tmp->prox = aux;
      }

    }

  }

}

void BFS(Item *list, int startVer)
{
  struct queue *q = createQ();
  color[startVer] = 1;
  enQ(q, startVer);
  while (!isEmpty(q))
  {
    int currentVer = deQ(q);
    color[currentVer] = 1;
    if (Sup[currentVer] == 1)
    {
      maxC++;
      break;
    }
    else
    {
      
    }

    Item *temp;
    temp = (Item *) malloc((int) (sizeof(Item)));
    temp->n = currentVer;
    temp->prox = list[currentVer].prox;
    while (temp->prox != 0)
    {
      int adjVer;
      adjVer = temp->n;
      if (color[adjVer] == 0)
      {
        color[adjVer] = 1;
        enQ(q, adjVer);
      }
      else
      {
        
      }

      temp = temp->prox;
    }

  }

}

int main(int argc, char *argv[])
{
  int i;
  int j;
  int m;
  int n;
  int v;
  int b;
  int vS;
  int vC;
  M = new_sym_var(sizeof(int) * 8);
  N = new_sym_var(sizeof(int) * 8);
  for (v = 1; v <= (M * N); v++)
  {
    addEdge(list, v, v);
    if ((v + N) <= (M * N))
    {
      addEdge(list, v, v + N);
    }
    else
    {
      
    }

    if ((v - N) > 0)
    {
      addEdge(list, v, v - N);
    }
    else
    {
      
    }

    if ((v % N) != 0)
    {
      addEdge(list, v, v + 1);
    }
    else
    {
      
    }

    if ((v % N) != 1)
    {
      addEdge(list, v, v - 1);
    }
    else
    {
      
    }

  }

  nS = new_sym_var(sizeof(int) * 8);
  nC = new_sym_var(sizeof(int) * 8);
  for (i = 1; i <= nS; i++)
  {
    m = new_sym_var(sizeof(int) * 8);
    n = new_sym_var(sizeof(int) * 8);
    vS = (m * N) - (N - n);
    Sup[vS] = 1;
  }

  for (j = 1; j <= nC; j++)
  {
    m = new_sym_var(sizeof(int) * 8);
    n = new_sym_var(sizeof(int) * 8);
    vC = (m * N) - (N - n);
    Cid[vC] = 1;
  }

  for (b = 1; b <= (M * N); b++)
  {
    if (Cid[b] == 1)
    {
      BFS(list, b);
    }
    else
    {
      
    }

  }

  printf("%d\n", maxC);
  return 0;
}

