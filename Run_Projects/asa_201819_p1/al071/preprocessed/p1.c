/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct node
{
  int destino;
  struct node *next;
} *No;
typedef struct list
{
  No head;
} *List;
typedef struct graph
{
  int vertices;
  List listas;
} *Graph;
No criaNo(int destino);
Graph criaGrafo(int vertices);
void addAresta(Graph grafo, int fonte, int destino);
void removeNo(Graph grafo, int *ap);
void DFS(Graph grafo);
int APUtil(Graph grafo, int vertice);
void DFS2(Graph grafo);
void APUtil2(Graph grafo, int vertice);
void libertar(Graph grafo);
void sort_array(int *a, size_t n);
int compare_ints(const void *p, const void *q);
int i;
int j;
int *disc;
int *parent;
int *low;
int *ap;
int *visited;
int counterSubR;
int *ListAPConca;
int *listAux;
int counterAP;
int max;
int counterApHelper;
int counterVertex;
int maxCounterVertex;
int countings;
No criaNo(int destino)
{
  No novoNo = (No) malloc(sizeof(struct node));
  novoNo->destino = destino;
  novoNo->next = 0;
  return novoNo;
}

Graph criaGrafo(int vertices)
{
  Graph novoGraph = (Graph) malloc(sizeof(struct graph));
  novoGraph->vertices = vertices;
  novoGraph->listas = (List) malloc(vertices * (sizeof(struct list)));
  for (i = 0; i < vertices; i++)
  {
    novoGraph->listas[i].head = 0;
  }

  return novoGraph;
}

void addAresta(Graph grafo, int fonte, int destino)
{
  destino--;
  No novoNo = criaNo(destino);
  fonte--;
  novoNo->next = grafo->listas[fonte].head;
  grafo->listas[fonte].head = novoNo;
}

int compare_ints(const void *p, const void *q)
{
  int x = *((const int *) p);
  int y = *((const int *) q);
  if (x < y)
  {
    return -1;
  }
  else
  {
    if (x > y)
    {
      return 1;
    }
    else
    {
      
    }

  }

  return 0;
}

void sort_array(int *a, size_t n)
{
  qsort(a, n, sizeof(*a), &compare_ints);
}

void DFS(Graph grafo)
{
  int vertices = grafo->vertices;
  countings = 0;
  counterSubR = 0;
  counterAP = 0;
  ListAPConca = (int *) malloc(vertices * (sizeof(int)));
  visited = (int *) malloc(vertices * (sizeof(int)));
  disc = (int *) malloc(vertices * (sizeof(int)));
  low = (int *) malloc(vertices * (sizeof(int)));
  parent = (int *) malloc(vertices * (sizeof(int)));
  ap = (int *) malloc(vertices * (sizeof(int)));
  listAux = (int *) malloc(vertices * (sizeof(int)));
  for (i = 0; i < vertices; i++)
  {
    parent[i] = -1;
    visited[i] = 0;
    ap[i] = 0;
  }

  for (i = 0; i < vertices; i++)
  {
    if (visited[i] == 0)
    {
      ++counterSubR;
      max = i;
      int id = APUtil(grafo, i);
      listAux[counterSubR - 1] = id;
    }
    else
    {
      
    }

  }

  if (counterSubR > 1)
  {
    sort_array(listAux, counterSubR);
  }
  else
  {
    
  }

  sort_array(ListAPConca, counterAP);
}

int APUtil(Graph grafo, int vertice)
{
  static int time = 0;
  int children = 0;
  visited[vertice] = 1;
  disc[vertice] = (low[vertice] = ++time);
  No current = grafo->listas[vertice].head;
  int destino;
  while (current != 0)
  {
    destino = current->destino;
    if (!visited[destino])
    {
      children++;
      parent[destino] = vertice;
      max = (destino > max) ? (destino) : (max);
      APUtil(grafo, destino);
      low[vertice] = (low[vertice] < low[destino]) ? (low[vertice]) : (low[destino]);
      if (((parent[vertice] == (-1)) && (children > 1)) && (ap[vertice] == 0))
      {
        ap[vertice] = 1;
        counterAP++;
        ListAPConca[countings] = vertice;
        countings++;
      }
      else
      {
        
      }

      if (((parent[vertice] != (-1)) && (low[destino] >= disc[vertice])) && (ap[vertice] == 0))
      {
        ap[vertice] = 1;
        counterAP++;
        ListAPConca[countings] = vertice;
        countings++;
      }
      else
      {
        
      }

    }
    else
    {
      if (destino != parent[vertice])
      {
        low[vertice] = (low[vertice] < disc[destino]) ? (low[vertice]) : (disc[destino]);
      }
      else
      {
        
      }

    }

    current = current->next;
  }

  return max;
}

void DFS2(Graph grafo)
{
  int vertices = grafo->vertices;
  maxCounterVertex = 0;
  visited = (int *) malloc(vertices * (sizeof(int)));
  int counter_ap_aux = 0;
  for (i = 0; i < vertices; i++)
  {
    if (ListAPConca[counter_ap_aux] == i)
    {
      visited[i] = 1;
      counter_ap_aux++;
      continue;
    }
    else
    {
      
    }

    visited[i] = 0;
  }

  for (i = 0; i < vertices; i++)
  {
    if (visited[i] == 0)
    {
      counterVertex = 0;
      APUtil2(grafo, i);
    }
    else
    {
      
    }

  }

}

void APUtil2(Graph grafo, int vertice)
{
  visited[vertice] = 1;
  No current = grafo->listas[vertice].head;
  counterVertex++;
  int destino;
  while (current != 0)
  {
    destino = current->destino;
    if (!visited[destino])
    {
      APUtil2(grafo, destino);
    }
    else
    {
      
    }

    current = current->next;
  }

  maxCounterVertex = (counterVertex > maxCounterVertex) ? (counterVertex) : (maxCounterVertex);
}

void libertar(Graph grafo)
{
  No head;
  free(visited);
  free(disc);
  free(low);
  free(parent);
  free(ap);
  free(listAux);
  for (i = 0; i < grafo->vertices; i++)
  {
    head = grafo->listas[i].head;
    while (head != 0)
    {
      No temp = head;
      head = head->next;
      free(temp);
    }

  }

  free(grafo->listas);
  free(grafo);
}

int main(int argc, const char *argv[])
{
  int vertices;
  int arestas;
  vertices = new_sym_var(sizeof(int) * 8);
  Graph grafo = criaGrafo(vertices);
  arestas = new_sym_var(sizeof(int) * 8);
  int ligacoes[arestas][2];
  for (i = 0; i < arestas; i++)
  {
    if (2 == EOF)
    {
      printf("Incoerente\n");
      libertar(grafo);
      exit(0);
    }
    else
    {
      ligacoes[i][0] = new_sym_var(sizeof(int) * 8);
      ligacoes[i][1] = new_sym_var(sizeof(int) * 8);
      
    }

    addAresta(grafo, ligacoes[i][0], ligacoes[i][1]);
    addAresta(grafo, ligacoes[i][1], ligacoes[i][0]);
  }

  DFS(grafo);
  printf("%d\n", counterSubR);
  for (i = 0; i < (counterSubR - 1); i++)
    printf("%d ", listAux[i] + 1);

  printf("%d\n", listAux[i] + 1);
  printf("%d\n", counterAP);
  DFS2(grafo);
  printf("%d\n", maxCounterVertex);
  libertar(grafo);
  return 0;
}

