/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef int bool;
int time;
int n_sub_nets = 0;
int sub_net_id = 0;
int id_vector_size = 1;
int *id_vector;
bool *Articulation_points;
int *low;
int n_biggest_sub_net = 0;
int counter = 0;
struct node
{
  int number;
  struct node *next;
};
struct list
{
  struct node *head;
  int color;
  int t_discovery;
  int t_finish;
  bool parent;
  int children;
};
struct Graph
{
  int N_vertices;
  struct list *lista_adj;
};
struct node *new_node(int v)
{
  struct node *new_node = (struct node *) malloc(sizeof(struct node));
  new_node->number = v;
  new_node->next = 0;
  return new_node;
}

struct Graph *new_graph(int vertices)
{
  struct Graph *graph = (struct Graph *) malloc(sizeof(struct Graph));
  graph->N_vertices = vertices;
  graph->lista_adj = (struct list *) malloc((vertices + 1) * (sizeof(struct list)));
  int i;
  for (i = 1; i <= vertices; i++)
  {
    graph->lista_adj[i].head = 0;
    graph->lista_adj[i].color = 0;
    graph->lista_adj[i].t_discovery = 0;
    graph->lista_adj[i].t_finish = 0;
    graph->lista_adj[i].parent = -1;
    graph->lista_adj[i].children = 0;
  }

  return graph;
}

int min(int i1, int i2)
{
  return (i1 < i2) ? (i1) : (i2);
}

void DFS_visit(struct Graph *graph, int vertex)
{
  graph->lista_adj[vertex].color = 1;
  graph->lista_adj[vertex].t_discovery = (low[vertex] = time);
  time++;
  counter++;
  if (vertex > sub_net_id)
  {
    sub_net_id = vertex;
  }
  else
  {
    
  }

  struct node *aux_node = graph->lista_adj[vertex].head;
  while (aux_node)
  {
    if (graph->lista_adj[aux_node->number].color == 0)
    {
      graph->lista_adj[aux_node->number].parent = vertex;
      graph->lista_adj[vertex].children++;
      DFS_visit(graph, aux_node->number);
      low[vertex] = min(low[vertex], low[aux_node->number]);
      if ((graph->lista_adj[vertex].parent == (-1)) && (graph->lista_adj[vertex].children > 1))
      {
        Articulation_points[vertex] = 1;
      }
      else
      {
        
      }

      if ((graph->lista_adj[vertex].parent != (-1)) && (low[aux_node->number] >= graph->lista_adj[vertex].t_discovery))
      {
        Articulation_points[vertex] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (aux_node->number != graph->lista_adj[vertex].parent)
      {
        low[vertex] = min(low[vertex], graph->lista_adj[aux_node->number].t_discovery);
      }
      else
      {
        
      }

    }

    aux_node = aux_node->next;
  }

  graph->lista_adj[vertex].color = 2;
  graph->lista_adj[vertex].t_finish = time;
  time++;
}

void DFS(struct Graph *graph)
{
  int i;
  time = 1;
  for (i = graph->N_vertices; i >= 1; i--)
  {
    if (graph->lista_adj[i].color == 0)
    {
      DFS_visit(graph, i);
      if (counter > n_biggest_sub_net)
      {
        n_biggest_sub_net = counter;
      }
      else
      {
        
      }

      counter = 0;
      if (id_vector_size == n_sub_nets)
      {
        id_vector_size += 20;
        id_vector = realloc(id_vector, id_vector_size * (sizeof(int)));
      }
      else
      {
        
      }

      id_vector[n_sub_nets] = sub_net_id;
      sub_net_id = 0;
      n_sub_nets++;
    }
    else
    {
      
    }

  }

}

void add_to_graph(struct Graph *graph, int v, int u)
{
  struct node *aux_node = new_node(u);
  aux_node->next = graph->lista_adj[v].head;
  graph->lista_adj[v].head = aux_node;
  aux_node = new_node(v);
  aux_node->next = graph->lista_adj[u].head;
  graph->lista_adj[u].head = aux_node;
}

struct Graph *ficheiro()
{
  int vertices;
  int arestas;
  int u;
  int v;
  int i = 0;
  vertices = new_sym_var(sizeof(int) * 8);
  struct Graph *graph = new_graph(vertices);
  arestas = new_sym_var(sizeof(int) * 8);
  while (i != arestas)
  {
    u = new_sym_var(sizeof(int) * 8);
    v = new_sym_var(sizeof(int) * 8);
    add_to_graph(graph, u, v);
    i++;
  }

  return graph;
}

void free_graph(struct Graph *graph)
{
  int i;
  struct node *aux_node;
  for (i = 1; i <= graph->N_vertices; i++)
  {
    while (graph->lista_adj[i].head)
    {
      aux_node = graph->lista_adj[i].head;
      graph->lista_adj[i].head = aux_node->next;
      free(aux_node);
    }

  }

  free(graph->lista_adj);
  free(graph);
}

int main()
{
  int j;
  int contador = 0;
  struct Graph *graph = ficheiro();
  Articulation_points = malloc((graph->N_vertices + 1) * (sizeof(bool)));
  low = malloc((graph->N_vertices + 1) * (sizeof(int)));
  id_vector = malloc(1 * (sizeof(int)));
  for (j = 0; j <= graph->N_vertices; j++)
  {
    Articulation_points[j] = 0;
  }

  DFS(graph);
  printf("%d\n", n_sub_nets);
  printf("%d", id_vector[n_sub_nets - 1]);
  for (j = n_sub_nets - 2; j > (-1); j--)
  {
    printf(" %d", id_vector[j]);
  }

  printf("\n");
  for (j = 1; j <= graph->N_vertices; j++)
  {
    graph->lista_adj[j].color = 0;
    graph->lista_adj[j].t_discovery = 0;
    graph->lista_adj[j].t_finish = 0;
    graph->lista_adj[j].parent = -1;
    graph->lista_adj[j].children = 0;
    if (Articulation_points[j] == 1)
    {
      graph->lista_adj[j].color = 2;
      contador++;
    }
    else
    {
      
    }

  }

  printf("%d\n", contador);
  n_sub_nets = 0;
  n_biggest_sub_net = 0;
  counter = 0;
  DFS(graph);
  printf("%d\n", n_biggest_sub_net);
  free(id_vector);
  free(Articulation_points);
  free(low);
  free_graph(graph);
  return 0;
}

