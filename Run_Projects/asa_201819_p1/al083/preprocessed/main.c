/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


struct router
{
  int id;
  struct router *next;
};
struct Rede
{
  int numRouters;
  int tempo_atual;
  int subredes;
  int *visitado;
  int *predecessor;
  int *tempo;
  int *low;
  int *ponto_artic;
  struct router **lista_adj;
};
struct router *criarRouter(int);
struct Rede *criarRede(int);
int *criarVetor(int);
void addArco(struct Rede *, int, int);
int percorrerRede(struct Rede *);
int contarRouters(struct Rede *, int, int);
void DFS(struct Rede *);
void DFS_Visitar(struct Rede *, int i);
void libertarMemoria(struct Rede *);
int min(int, int);
int main()
{
  int i = 0;
  int router_x = 0;
  int router_y = 0;
  int V = 0;
  int E = 0;
  int nponto_artic = 0;
  int a = 0;
  if (!scanf("%d %d", &V, &E))
  {
    exit(1);
  }
  else
  {
    
  }

  struct Rede *rede = criarRede(V);
  for (i = 0; i < E; i++)
  {
    if (!scanf("%d %d", &router_x, &router_y))
    {
      exit(1);
    }
    else
    {
      
    }

    addArco(rede, router_x - 1, router_y - 1);
  }

  DFS(rede);
  printf("%d\n", rede->subredes);
  for (i = 0; i < V; i++)
  {
    if (rede->predecessor[i] == (-1))
    {
      if (a == 0)
      {
        printf("%d", i + 1);
        a++;
      }
      else
      {
        printf(" %d", i + 1);
      }

    }
    else
    {
      
    }

    if (rede->ponto_artic[i] == 1)
    {
      nponto_artic++;
    }
    else
    {
      
    }

  }

  printf("\n");
  printf("%d\n", nponto_artic);
  printf("%d\n", percorrerRede(rede));
  libertarMemoria(rede);
  return 0;
}

struct router *criarRouter(int id)
{
  struct router *novoRouter = malloc(sizeof(struct router));
  novoRouter->id = id;
  novoRouter->next = 0;
  return novoRouter;
}

int *criarVetor(int vertices)
{
  int *novoVetor = malloc(vertices * (sizeof(int)));
  int i;
  for (i = 0; i < vertices; i++)
    novoVetor[i] = -1;

  return novoVetor;
}

struct Rede *criarRede(int vertices)
{
  struct Rede *novaRede = malloc(sizeof(struct Rede));
  novaRede->numRouters = vertices;
  novaRede->lista_adj = malloc(vertices * (sizeof(struct router *)));
  novaRede->visitado = criarVetor(vertices);
  novaRede->predecessor = criarVetor(vertices);
  novaRede->tempo = criarVetor(vertices);
  novaRede->low = criarVetor(vertices);
  novaRede->ponto_artic = criarVetor(vertices);
  int i;
  for (i = 0; i < vertices; i++)
    novaRede->lista_adj[i] = 0;

  return novaRede;
}

void addArco(struct Rede *rede, int Router1, int Router2)
{
  struct router *novoRouter2 = criarRouter(Router2);
  novoRouter2->next = rede->lista_adj[Router1];
  rede->lista_adj[Router1] = novoRouter2;
  struct router *novoRouter1 = criarRouter(Router1);
  novoRouter1->next = rede->lista_adj[Router2];
  rede->lista_adj[Router2] = novoRouter1;
}

void DFS(struct Rede *rede)
{
  int i;
  rede->tempo_atual = 0;
  rede->subredes = 0;
  for (i = rede->numRouters - 1; i >= 0; i--)
  {
    if (rede->visitado[i] == (-1))
    {
      rede->subredes++;
      DFS_Visitar(rede, i);
    }
    else
    {
      
    }

  }

}

void DFS_Visitar(struct Rede *rede, int i)
{
  int filhos = 0;
  rede->visitado[i] = 0;
  rede->tempo[i] = rede->tempo_atual;
  rede->low[i] = rede->tempo_atual;
  rede->tempo_atual++;
  struct router *temp = rede->lista_adj[i];
  while (temp)
  {
    if (rede->visitado[temp->id] == (-1))
    {
      rede->predecessor[temp->id] = i;
      filhos++;
      DFS_Visitar(rede, temp->id);
      rede->low[i] = min(rede->low[i], rede->low[temp->id]);
      if (((rede->predecessor[i] != (-1)) && (rede->low[temp->id] >= rede->tempo[i])) || ((rede->predecessor[i] == (-1)) && (filhos > 1)))
      {
        rede->ponto_artic[i] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (temp->id != rede->predecessor[i])
      {
        rede->low[i] = min(rede->low[i], rede->tempo[temp->id]);
      }
      else
      {
        
      }

    }

    temp = temp->next;
  }

}

int percorrerRede(struct Rede *rede)
{
  int v;
  int nRouters = 0;
  int maxRouters = 0;
  for (v = 0; v < rede->numRouters; v++)
  {
    if ((rede->visitado[v] != 1) && (rede->ponto_artic[v] == (-1)))
    {
      rede->visitado[v] = 1;
      nRouters = 1;
      nRouters = contarRouters(rede, nRouters, v);
      if (nRouters > maxRouters)
      {
        maxRouters = nRouters;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return maxRouters;
}

int contarRouters(struct Rede *rede, int nRouters, int v)
{
  struct router *temp = rede->lista_adj[v];
  while (temp)
  {
    if ((rede->visitado[temp->id] != 1) && (rede->ponto_artic[temp->id] == (-1)))
    {
      rede->visitado[temp->id] = 1;
      nRouters++;
      nRouters = contarRouters(rede, nRouters, temp->id);
    }
    else
    {
      
    }

    temp = temp->next;
  }

  return nRouters;
}

void libertarMemoria(struct Rede *rede)
{
  int v;
  free(rede->visitado);
  free(rede->predecessor);
  free(rede->tempo);
  free(rede->low);
  free(rede->ponto_artic);
  for (v = 0; v < rede->numRouters; v++)
  {
    struct router *temp = rede->lista_adj[v];
    while (temp)
    {
      struct router *aux = temp;
      temp = temp->next;
      free(aux);
    }

  }

  free(rede->lista_adj);
  free(rede);
}

int min(int val1, int val2)
{
  if (val1 < val2)
  {
    return val1;
  }
  else
  {
    return val2;
  }

}

