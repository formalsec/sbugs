/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct arco *Arco;
typedef struct router *Vertice;
typedef struct ligacao *Ligacao;
typedef struct IdSubRede *IdSCC;
struct ligacao
{
  int v;
  int w;
  Ligacao next;
};
struct arco
{
  int v;
  Arco next;
};
struct router
{
  int id;
  int low;
  int depth;
  int parent;
  char stackMember;
  char newBCC;
  Arco a;
};
struct IdSubRede
{
  int id;
  IdSCC next;
};
typedef struct rede
{
  int numVert;
  Vertice *adjacencias;
} *Grafo;
IdSCC listSCC = 0;
Arco stSCC = 0;
Ligacao stBCC = 0;
int numSCC = 0;
int numRoutersRobustos = 0;
int numMaxRoutersBCC = 0;
int currNumComp = 0;
Grafo readInput();
Grafo GraphInit(int V, int E);
void InsertEdge(Grafo g, int v, int w);
Arco InsertBegin(Arco head, int v);
void SCC(Grafo g);
void BCC(Grafo g, int router, int profundidade);
void freeRede(Grafo g);
void freeArcos(Grafo g);
void printRede(Grafo g);
int main(int argc, const char *argv[])
{
  Grafo G = readInput();
  SCC(G);
  printf("%d\n", numSCC);
  printf("%d", listSCC->id);
  IdSCC aux = listSCC;
  listSCC = listSCC->next;
  free(aux);
  while (listSCC)
  {
    printf(" %d", listSCC->id);
    IdSCC aux = listSCC;
    listSCC = listSCC->next;
    free(aux);
  }

  printf("\n%d\n%d\n", numRoutersRobustos, numMaxRoutersBCC);
  freeRede(G);
  return 0;
}

Grafo readInput()
{
  int v;
  int e;
  int i;
  int j;
  v = new_sym_var(sizeof(int) * 8);
  e = new_sym_var(sizeof(int) * 8);
  Grafo G = GraphInit(v, e);
  while (e--)
  {
    i = new_sym_var(sizeof(int) * 8);
    j = new_sym_var(sizeof(int) * 8);
    InsertEdge(G, i - 1, j - 1);
  }

  return G;
}

Grafo GraphInit(int V, int E)
{
  int i = 0;
  Grafo G = malloc(sizeof(struct rede));
  G->numVert = V;
  G->adjacencias = malloc(V * (sizeof(Vertice)));
  for (; i < V; i++)
  {
    G->adjacencias[i] = malloc(sizeof(struct router));
    Vertice v = G->adjacencias[i];
    v->id = i + 1;
    v->low = -1;
    v->depth = -1;
    v->parent = -1;
    v->stackMember = 'f';
    v->newBCC = 'f';
    v->a = 0;
  }

  return G;
}

void InsertEdge(Grafo g, int v, int w)
{
  g->adjacencias[v]->a = InsertBegin(g->adjacencias[v]->a, w);
  g->adjacencias[w]->a = InsertBegin(g->adjacencias[w]->a, v);
}

Arco InsertBegin(Arco head, int v)
{
  Arco x = malloc(sizeof(struct arco));
  x->v = v;
  x->next = head;
  return x;
}

void SCC(Grafo g)
{
  int i = 0;
  int n = g->numVert;
  for (; i < n; i++)
  {
    if (g->adjacencias[i]->depth == (-1))
    {
      BCC(g, i, 0);
      currNumComp = 0;
      Ligacao aux;
      while (stBCC)
      {
        currNumComp++;
        aux = stBCC;
        stBCC = stBCC->next;
        free(aux);
      }

      if (numRoutersRobustos != 1)
      {
        currNumComp++;
      }
      else
      {
        
      }

      numMaxRoutersBCC = (numMaxRoutersBCC > currNumComp) ? (numMaxRoutersBCC) : (currNumComp);
      currNumComp = 0;
    }
    else
    {
      
    }

  }

}

void BCC(Grafo g, int router, int profundidade)
{
  static int time = 0;
  Vertice v = g->adjacencias[router];
  v->low = ++time;
  v->depth = profundidade;
  Arco new = malloc(sizeof(struct arco));
  new->v = v->id;
  new->next = stSCC;
  stSCC = new;
  v->stackMember = 't';
  int numFilhos = 0;
  Arco a = v->a;
  char check = 't';
  while (a)
  {
    Vertice curr = g->adjacencias[a->v];
    if (curr->depth == (-1))
    {
      curr->parent = router;
      numFilhos++;
      if (curr->newBCC == 'f')
      {
        currNumComp++;
        curr->newBCC = 't';
        Ligacao new = malloc(sizeof(struct ligacao));
        new->v = v->id;
        new->w = curr->id;
        new->next = stBCC;
        stBCC = new;
      }
      else
      {
        
      }

      BCC(g, a->v, profundidade + 1);
      if ((check == 't') && (((v->parent == (-1)) && (numFilhos > 1)) || ((v->parent != (-1)) && (curr->low >= v->depth))))
      {
        numRoutersRobustos++;
        check = 'f';
        Ligacao aux;
        while ((stBCC->v != v->id) || (stBCC->w != curr->id))
        {
          if (curr->newBCC == 't')
          {
            curr->newBCC = 'f';
            if (currNumComp)
            {
              currNumComp--;
            }
            else
            {
              
            }

          }
          else
          {
            
          }

          aux = stBCC;
          stBCC = stBCC->next;
          free(aux);
        }

        if (stBCC)
        {
          aux = stBCC;
          stBCC = stBCC->next;
          currNumComp--;
          free(aux);
        }
        else
        {
          
        }

        if (numRoutersRobustos != 1)
        {
          currNumComp++;
        }
        else
        {
          
        }

        numMaxRoutersBCC = (numMaxRoutersBCC > currNumComp) ? (numMaxRoutersBCC) : (currNumComp);
        currNumComp = 0;
      }
      else
      {
        
      }

      v->low = (v->low < curr->low) ? (v->low) : (curr->low);
    }
    else
    {
      if (curr->stackMember == 't')
      {
        v->low = (v->low < curr->depth) ? (v->low) : (curr->depth);
      }
      else
      {
        
      }

    }

    a = a->next;
  }

  if (v->low == v->depth)
  {
    numSCC++;
    int max = v->id;
    while (stSCC->v != v->id)
    {
      g->adjacencias[stSCC->v - 1]->stackMember = 'f';
      Arco aux = stSCC;
      stSCC = stSCC->next;
      max = (max > aux->v) ? (max) : (aux->v);
      free(aux);
    }

    g->adjacencias[stSCC->v - 1]->stackMember = 'f';
    Arco aux = stSCC;
    stSCC = stSCC->next;
    max = (max > aux->v) ? (max) : (aux->v);
    free(aux);
    IdSCC new = malloc(sizeof(struct IdSubRede));
    new->id = max;
    new->next = 0;
    if (listSCC == 0)
    {
      listSCC = new;
    }
    else
    {
      if (listSCC->id > max)
      {
        new->next = listSCC;
        listSCC = new;
      }
      else
      {
        IdSCC temp = listSCC;
        for (; temp->next; temp = temp->next)
        {
          if (temp->next->id > max)
          {
            new->next = temp->next;
            temp->next = new;
            return;
          }
          else
          {
            
          }

        }

        temp->next = new;
      }

    }

  }
  else
  {
    
  }

}

void freeRede(Grafo g)
{
  freeArcos(g);
  free(g->adjacencias);
  free(g);
}

void freeArcos(Grafo g)
{
  int numVert = g->numVert;
  int i = 0;
  for (; i < numVert; i++)
  {
    Arco prev = 0;
    Arco curr = g->adjacencias[i]->a;
    while (curr != 0)
    {
      prev = curr;
      curr = curr->next;
      free(prev);
    }

    free(g->adjacencias[i]);
  }

}

void printRede(Grafo g)
{
  printf("v: %d\n", g->numVert);
  int i = 0;
  for (; i < g->numVert; i++)
  {
    Arco prev = 0;
    Arco curr = g->adjacencias[i]->a;
    printf("Adjacencias de %d: ", g->adjacencias[i]->id);
    while (curr != 0)
    {
      prev = curr;
      curr = curr->next;
      printf(" %d", prev->v);
    }

    puts("");
  }

}

