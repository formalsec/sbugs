/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct Stack
{
  int top;
  int size;
  int *value;
} *Stack;
void findSccs(int n, int *id, int *counter, int *ids, int *low, int *onStack, Stack stack, int **matriz);
void dfs(int i, int n, int *id, int *counter, int *ids, int *low, int *onStack, Stack stack, int **matriz);
int min(int a, int b);
Stack createStack(int size);
int isStackEmpty(Stack stack);
void push(Stack stack, int value);
int pop(Stack stack);
int cmpfunc(const void *a, const void *b);
void resetValues(int n, int *counter, int *id, int *ids, int *low, int *onStack);
void createAdjacencyMatrix(int **matriz, int n);
void readAdjacencyMatrix(int **matriz);
void findSubRede(int *aux, int n, int *counter, int *low, int *ids);
int sccTest(int n, int *counter, int *id, int *ids, int *low, int *onStack, int **matriz, Stack stack, int *list, int *counteraux);
void biggestSubRede(int k, int n, int **matriz, int *low, int *onStack, int *ids, int *id, int *counteraux, Stack stack, int *list);
int main()
{
  int n;
  int i;
  int id = 0;
  int counter;
  int k;
  int counteraux;
  n = new_sym_var(sizeof(int) * 8);
  int *ids = (int *) malloc((sizeof(int)) * n);
  int *low = (int *) malloc((sizeof(int)) * n);
  int *aux;
  int *onStack = (int *) malloc((sizeof(int)) * n);
  int **matriz = (int **) malloc((sizeof(int *)) * n);
  int *list = (int *) malloc((sizeof(int)) * n);
  Stack stack = createStack(n);
  resetValues(n, &counter, &id, ids, low, onStack);
  createAdjacencyMatrix(matriz, n);
  readAdjacencyMatrix(matriz);
  findSccs(n, &id, &counter, ids, low, onStack, stack, matriz);
  printf("%d\n", counter);
  aux = (int *) malloc((sizeof(int)) * counter);
  findSubRede(aux, n, &counter, low, ids);
  for (i = 0; i < (counter - 1); i++)
  {
    printf("%d ", aux[i]);
  }

  printf("%d\n", aux[i]);
  k = sccTest(n, &counter, &id, ids, low, onStack, matriz, stack, list, &counteraux);
  biggestSubRede(k, n, matriz, low, onStack, ids, &id, &counteraux, stack, list);
  free(ids);
  free(low);
  free(list);
  free(onStack);
  free(stack->value);
  free(stack);
  free(aux);
  for (i = 0; i < n; i++)
  {
    free(matriz[i]);
  }

  free(matriz);
  return 0;
}

void createAdjacencyMatrix(int **matriz, int n)
{
  int i;
  int j;
  for (i = 0; i < n; i++)
  {
    matriz[i] = (int *) malloc((sizeof(int)) * n);
  }

  for (i = 0; i < n; i++)
    for (j = i; j < n; j++)
    matriz[i][j] = (matriz[j][i] = 0);


}

void readAdjacencyMatrix(int **matriz)
{
  int m;
  int i;
  int x;
  int y;
  m = new_sym_var(sizeof(int) * 8);
  for (i = 0; i < m; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    matriz[x - 1][y - 1] = 1;
    matriz[y - 1][x - 1] = 1;
  }

}

void resetValues(int n, int *counter, int *id, int *ids, int *low, int *onStack)
{
  int i;
  for (i = 0; i < n; i++)
  {
    ids[i] = -1;
    low[i] = 0;
    onStack[i] = -2;
  }

  *id = 0;
  *counter = 0;
}

int cmpfunc(const void *a, const void *b)
{
  return (*((int *) a)) - (*((int *) b));
}

void findSubRede(int *aux, int n, int *counter, int *low, int *ids)
{
  int i;
  int sccsFound = 0;
  int k = n - 1;
  for (i = 0; i < (*counter); i++)
  {
    aux[i] = 0;
  }

  i = (*counter) - 1;
  while (sccsFound < (*counter))
  {
    if (ids[low[k]] != (-1))
    {
      aux[i] = k + 1;
      ids[low[k]] = -1;
      sccsFound++;
      i--;
    }
    else
    {
      
    }

    k--;
  }

}

int sccTest(int n, int *counter, int *id, int *ids, int *low, int *onStack, int **matriz, Stack stack, int *list, int *counteraux)
{
  int i;
  int k = 0;
  int j;
  int *listaux = (int *) malloc((sizeof(int)) * n);
  for (i = 0; i < n; i++)
  {
    list[i] = 0;
    listaux[i] = 0;
  }

  resetValues(n, counteraux, id, ids, low, onStack);
  for (i = 0; i < n; i++)
  {
    for (j = 0; j < n; j++)
    {
      if (matriz[i][j] == 1)
      {
        matriz[i][j] = (matriz[j][i] = 0);
        listaux[j] = 1;
      }
      else
      {
        
      }

    }

    findSccs(n, id, counteraux, ids, low, onStack, stack, matriz);
    if (((*counteraux) - 1) > (*counter))
    {
      list[k] = i + 1;
      k++;
    }
    else
    {
      
    }

    resetValues(n, counteraux, id, ids, low, onStack);
    for (j = 0; j < n; j++)
    {
      matriz[i][j] = (matriz[j][i] = listaux[j]);
    }

    for (j = 0; j < n; j++)
      listaux[j] = 0;

  }

  printf("%d\n", k);
  return k;
}

void biggestSubRede(int k, int n, int **matriz, int *low, int *onStack, int *ids, int *id, int *counteraux, Stack stack, int *list)
{
  int i;
  int j;
  int max = 0;
  int maxaux = 0;
  for (i = 0; i < k; i++)
  {
    for (j = 0; j < n; j++)
    {
      matriz[list[i] - 1][j] = (matriz[j][list[i] - 1] = 0);
    }

  }

  resetValues(n, counteraux, id, ids, low, onStack);
  findSccs(n, id, counteraux, ids, low, onStack, stack, matriz);
  for (i = 0; i < n; i++)
  {
    for (j = 0; j < n; j++)
      if (low[j] == i)
    {
      maxaux += 1;
    }
    else
    {
      
    }


    if (maxaux > max)
    {
      max = maxaux;
    }
    else
    {
      
    }

    maxaux = 0;
  }

  printf("%d\n", max);
}

void findSccs(int n, int *id, int *counter, int *ids, int *low, int *onStack, Stack stack, int **matriz)
{
  int i;
  for (i = 0; i < n; i++)
  {
    if (ids[i] == (-1))
    {
      dfs(i, n, id, counter, ids, low, onStack, stack, matriz);
    }
    else
    {
      
    }

  }

}

void dfs(int i, int n, int *id, int *counter, int *ids, int *low, int *onStack, Stack stack, int **matriz)
{
  int j;
  push(stack, i);
  onStack[i] = 1;
  ids[i] = (low[i] = (*id)++);
  for (j = 0; j < n; j++)
  {
    if (matriz[i][j] == 1)
    {
      if (ids[j] == (-1))
      {
        dfs(j, n, id, counter, ids, low, onStack, stack, matriz);
      }
      else
      {
        
      }

      if (onStack[j])
      {
        low[i] = min(low[i], low[j]);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  if (ids[i] == low[i])
  {
    j = pop(stack);
    while (j != (-1))
    {
      onStack[j] = -2;
      low[j] = ids[i];
      if (j == i)
      {
        break;
      }
      else
      {
        
      }

      j = pop(stack);
    }

    (*counter)++;
  }
  else
  {
    
  }

}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

Stack createStack(int size)
{
  struct Stack *stack = (struct Stack *) malloc(sizeof(struct Stack));
  stack->top = -1;
  stack->size = size;
  stack->value = (int *) malloc(size * (sizeof(int)));
  return stack;
}

int isStackEmpty(Stack stack)
{
  return stack->top == (-1);
}

void push(Stack stack, int value)
{
  stack->top++;
  stack->value[stack->top] = value;
}

int pop(Stack stack)
{
  if (isStackEmpty(stack))
  {
    return -1;
  }
  else
  {
    
  }

  return stack->value[stack->top--];
}

