/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


int *verticeslist = 0;
int *breaks;
int *nredes = 0;
typedef struct vertex
{
  int _vertex;
  struct vertex *_nextNode;
} VertexNode;
typedef struct edgenode
{
  int _end;
  struct edgenode *_nextNode;
} EdgeNode;
typedef struct graph
{
  int _v;
  int _e;
  EdgeNode **_adjacencyList;
} Graph;
typedef struct info
{
  int _V;
  int _numSCCs;
  int _visited;
  bool *_AP;
  int *_parent;
  int *_d;
  int *_low;
  int *_isInStack;
  int *_SCCid;
  VertexNode *_stackHead;
} TarjanInfo;
Graph *inicGraph(int v, int e);
void insertInGraph(Graph *G, int u, int v);
TarjanInfo *inicTarjanInfo(int v);
TarjanInfo *Tarjan(Graph *g);
void TarjanVisit(Graph *g, TarjanInfo *ti, int u);
void pushStackVertex(TarjanInfo *ti, int u);
void popStackVertex(TarjanInfo *ti);
int find_SCCid(TarjanInfo *ti, int u);
void count_remove_AD(Graph *g, TarjanInfo *ti);
Graph *readInput(int *Vptr, int *Eptr)
{
  int V = 0;
  int E = 0;
  int u;
  int v;
  Graph *g;
  if (1 != 1)
  {
    printf("Erro ao ler de stdin \n");
    exit(1);
  }
  else
  {
    V = new_sym_var(sizeof(int) * 8);
    
  }

  if (1 != 1)
  {
    printf("Erro ao ler de stdin \n");
    exit(1);
  }
  else
  {
    E = new_sym_var(sizeof(int) * 8);
    
  }

  *Vptr = V;
  *Eptr = E;
  g = inicGraph(V, E);
  while (E > 0)
  {
    if (2 != 2)
    {
      printf("Erro ao ler de stdin \n");
      exit(1);
    }
    else
    {
      u = new_sym_var(sizeof(int) * 8);
      v = new_sym_var(sizeof(int) * 8);
      
    }

    insertInGraph(g, u - 1, v - 1);
    insertInGraph(g, v - 1, u - 1);
    E--;
  }

  return g;
}

Graph *inicGraph(int v, int e)
{
  Graph *g;
  int i = 0;
  g = malloc(sizeof(Graph));
  if (g == 0)
  {
    printf("erro em inicGraph\n");
    exit(0);
  }
  else
  {
    
  }

  g->_v = v;
  g->_e = e;
  g->_adjacencyList = malloc((sizeof(EdgeNode *)) * v);
  if (g->_adjacencyList == 0)
  {
    printf("erro em inicGraph\n");
    exit(0);
  }
  else
  {
    
  }

  for (i = 0; i < v; i++)
    g->_adjacencyList[i] = 0;

  return g;
}

void insertInGraph(Graph *G, int u, int v)
{
  EdgeNode *e = malloc(sizeof(EdgeNode));
  if (e == 0)
  {
    printf("erro ao fazer push para graph\n");
    exit(0);
  }
  else
  {
    
  }

  e->_end = v;
  e->_nextNode = G->_adjacencyList[u];
  G->_adjacencyList[u] = e;
}

TarjanInfo *inicTarjanInfo(int v)
{
  int i = 0;
  TarjanInfo *ti = malloc(sizeof(TarjanInfo));
  if (ti == 0)
  {
    printf("erro no inicTarjan\n");
    exit(0);
  }
  else
  {
    
  }

  ti->_V = v;
  ti->_numSCCs = 0;
  ti->_visited = 0;
  ti->_AP = malloc((sizeof(int)) * v);
  ti->_parent = malloc((sizeof(int)) * v);
  ti->_d = malloc((sizeof(int)) * v);
  ti->_low = malloc((sizeof(int)) * v);
  ti->_isInStack = malloc((sizeof(int)) * v);
  ti->_SCCid = malloc((sizeof(int)) * v);
  if ((((ti->_parent == 0) || (ti->_d == 0)) || (ti->_low == 0)) || (ti->_isInStack == 0))
  {
    printf("erro no inicTarjanInfo\n");
    exit(0);
  }
  else
  {
    
  }

  ti->_stackHead = 0;
  for (i = 0; i < v; i++)
  {
    ti->_parent[i] = -1;
    ti->_d[i] = 2147483646;
    ti->_low[i] = 2147483646;
    ti->_isInStack[i] = 0;
    ti->_SCCid[i] = -1;
  }

  return ti;
}

TarjanInfo *Tarjan(Graph *g)
{
  breaks = malloc(sizeof(int));
  *breaks = 1;
  nredes = 0;
  nredes = malloc((sizeof(int)) * 2);
  int i = 0;
  int max = g->_v;
  verticeslist = malloc((sizeof(int)) * 2);
  TarjanInfo *ti = inicTarjanInfo(g->_v);
  for (i = 0; i < max; i++)
  {
    if (ti->_d[i] == 2147483646)
    {
      if (i == 0)
      {
        nredes[0] = 1;
        TarjanVisit(g, ti, i);
      }
      else
      {
        *breaks = (*breaks) + 1;
        verticeslist = (int *) realloc(verticeslist, (sizeof(int)) * ((*breaks) - 1));
        nredes = (int *) realloc(nredes, (sizeof(int)) * ((*breaks) - 1));
        verticeslist[(*breaks) - 2] = i;
        nredes[(*breaks) - 1] = nredes[(*breaks) - 1] + 1;
        TarjanVisit(g, ti, i);
      }

    }
    else
    {
      
    }

  }

  verticeslist[(*breaks) - 1] = max;
  return ti;
}

void TarjanVisit(Graph *g, TarjanInfo *ti, int u)
{
  EdgeNode *aux = 0;
  int v;
  int aux2;
  int min;
  int child = 0;
  ti->_visited++;
  ti->_d[u] = ti->_visited;
  ti->_low[u] = ti->_visited;
  pushStackVertex(ti, u);
  for (aux = g->_adjacencyList[u]; aux != 0; aux = aux->_nextNode)
  {
    v = aux->_end;
    if ((ti->_d[v] == 2147483646) || (ti->_isInStack[v] == 1))
    {
      if (ti->_d[v] == 2147483646)
      {
        nredes[(*breaks) - 1] = nredes[(*breaks) - 1] + 1;
        child++;
        ti->_parent[v] = u;
        TarjanVisit(g, ti, v);
        ti->_low[u] = (ti->_low[v] < ti->_low[u]) ? (ti->_low[v]) : (ti->_low[u]);
        if ((ti->_parent[u] != (-1)) && (ti->_low[v] >= ti->_d[u]))
        {
          ti->_AP[u] = 1;
        }
        else
        {
          
        }

        if ((ti->_parent[u] == (-1)) && (child > 1))
        {
          ti->_AP[u] = 1;
        }
        else
        {
          
        }

      }
      else
      {
        if (v != ti->_parent[u])
        {
          ti->_low[u] = (ti->_low[u] < ti->_d[v]) ? (ti->_low[u]) : (ti->_d[v]);
        }
        else
        {
          
        }

      }

      ti->_low[u] = (ti->_low[v] < ti->_low[u]) ? (ti->_low[v]) : (ti->_low[u]);
    }
    else
    {
      
    }

  }

  if (ti->_d[u] == ti->_low[u])
  {
    min = find_SCCid(ti, u);
    while (1)
    {
      aux2 = ti->_stackHead->_vertex;
      ti->_SCCid[aux2] = min + 1;
      popStackVertex(ti);
      if (aux2 == u)
      {
        ti->_numSCCs++;
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

}

int find_SCCid(TarjanInfo *ti, int u)
{
  VertexNode *aux = 0;
  int min = ti->_V + 1;
  for (aux = ti->_stackHead; aux != 0; aux = aux->_nextNode)
  {
    min = (min < aux->_vertex) ? (min) : (aux->_vertex);
    if (aux->_vertex == u)
    {
      return min;
    }
    else
    {
      
    }

  }

  return -1;
}

void pushStackVertex(TarjanInfo *ti, int u)
{
  VertexNode *new = malloc(sizeof(VertexNode));
  if (new == 0)
  {
    printf("erro no push TARJAN\n");
    exit(0);
  }
  else
  {
    
  }

  new->_vertex = u;
  new->_nextNode = ti->_stackHead;
  ti->_stackHead = new;
  ti->_isInStack[u] = 1;
}

void popStackVertex(TarjanInfo *ti)
{
  int u = ti->_stackHead->_vertex;
  VertexNode *newhead = ti->_stackHead->_nextNode;
  free(ti->_stackHead);
  ti->_stackHead = newhead;
  ti->_isInStack[u] = 0;
}

void count_remove_AP(Graph *g, TarjanInfo *ti)
{
  int i = 0;
  int count = 0;
  int N = g->_v;
  for (i = 0; i < N; i++)
  {
    if (ti->_AP[i] == 1)
    {
      count++;
      g->_adjacencyList[i] = 0;
    }
    else
    {
      
    }

  }

  printf("%d\n", count);
}

int main(int argc, char *argv[])
{
  int V = 0;
  int maxnum = 0;
  int max = 0;
  int E = 0;
  int i = 0;
  Graph *g = 0;
  TarjanInfo *ti = 0;
  g = readInput(&V, &E);
  ti = Tarjan(g);
  puts("\nOutput:");
  printf("%d\n", ti->_numSCCs);
  for (i = 0; i < (*breaks); i++)
  {
    if (maxnum < nredes[i])
    {
      maxnum = nredes[i];
    }
    else
    {
      
    }

    printf("%d ", verticeslist[i]);
  }

  printf("\n");
  count_remove_AP(g, ti);
  Tarjan(g);
  for (i = 0; i < (*breaks); i++)
  {
    if (max < nredes[i])
    {
      max = nredes[i];
    }
    else
    {
      
    }

  }

  printf("%d\n", max);
  return 0;
}

