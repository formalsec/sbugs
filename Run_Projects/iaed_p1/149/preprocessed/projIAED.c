/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct 
{
  int ID;
  int QNTD;
  int PRECO;
  int PESO;
  char DESC[63];
} Produto;
typedef struct 
{
  Produto produto[10000];
  int PESO;
} Encomenda;
Produto produto[10000] = {0};
Produto produtos_p_ordenar[10000] = {0};
Encomenda encomenda[500] = {0};
Produto encomenda_p_ordenar[200] = {0};
int stock[10000] = {0};
int IDeS[500] = {0};
char *tira_doispontos(char input[])
{
  int len;
  int i;
  len = strlen(input);
  for (i = 0; i < len; i++)
  {
    if (input[i] == ':')
    {
      {
        input[i] = ' ';
      }
    }
    else
    {
      
    }

  }

  return input;
}

int in(int n, int array[])
{
  int i;
  for (i = 0; i < 10000; i++)
  {
    if (array[i] == n)
    {
      {
        return 1;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

int encomenda_existente(int IDe, int n_IDe)
{
  if ((IDeS[IDe] != IDe) || (n_IDe == 0))
  {
    {
      return 0;
    }
  }
  else
  {
    {
      return 1;
    }
  }

}

int produto_existente(int IDp, int n_IDp)
{
  if ((stock[IDp] != IDp) || (n_IDp == 0))
  {
    {
      return 0;
    }
  }
  else
  {
    {
      return 1;
    }
  }

}

void merge(Produto produto[], int e, int m, int d, int ativado)
{
  int i;
  int j;
  int k;
  int n1 = (m - e) + 1;
  int n2 = d - m;
  Produto E[10000];
  Produto D[10000];
  for (i = 0; i < n1; i++)
  {
    E[i] = produto[e + i];
  }

  for (j = 0; j < n2; j++)
  {
    D[j] = produto[(m + 1) + j];
  }

  i = 0;
  j = 0;
  k = e;
  while ((i < n1) && (j < n2))
  {
    if (ativado == 0)
    {
      {
        if (E[i].PRECO <= D[j].PRECO)
        {
          {
            produto[k] = E[i];
            i++;
          }
        }
        else
        {
          {
            produto[k] = D[j];
            j++;
          }
        }

        k++;
      }
    }
    else
    {
      if (ativado == 1)
      {
        {
          if (strcmp(D[j].DESC, E[i].DESC) >= 0)
          {
            {
              produto[k] = E[i];
              i++;
            }
          }
          else
          {
            {
              produto[k] = D[j];
              j++;
            }
          }

          k++;
        }
      }
      else
      {
        
      }

    }

  }

  while (i < n1)
  {
    produto[k] = E[i];
    i++;
    k++;
  }

  while (j < n2)
  {
    produto[k] = D[j];
    j++;
    k++;
  }

}

void mergeSort(Produto produto[], int e, int d, int ativado)
{
  if (e < d)
  {
    {
      int m = e + ((d - e) / 2);
      mergeSort(produto, e, m, ativado);
      mergeSort(produto, m + 1, d, ativado);
      merge(produto, e, m, d, ativado);
    }
  }
  else
  {
    
  }

}

void novo_produto(char input[], int n_IDp)
{
  char throwaway;
  throwaway = new_sym_var(sizeof(char) * 8);
  for (int produto_index = 0; produto_index < 10; produto_index++)
  {
    produto[n_IDp].DESC[produto_index] = new_sym_var(sizeof(char) * 8);
  }

  produto[n_IDp].DESC[10 - 1] = '\0';
  produto[n_IDp].PRECO = new_sym_var(sizeof(int) * 8);
  produto[n_IDp].PESO = new_sym_var(sizeof(int) * 8);
  produto[n_IDp].QNTD = new_sym_var(sizeof(int) * 8);
  produto[n_IDp].ID = n_IDp;
  printf("Novo produto %d.\n", n_IDp);
  stock[n_IDp] = n_IDp;
}

void adicionar_stock(char input[], int n_IDp)
{
  char throwaway;
  int IDp;
  int qntd;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDp = new_sym_var(sizeof(int) * 8);
  qntd = new_sym_var(sizeof(int) * 8);
  if ((stock[IDp] == IDp) && (n_IDp > 0))
  {
    {
      produto[IDp].QNTD += qntd;
    }
  }
  else
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", IDp);
    }
  }

}

void nova_encomenda(int n_IDe)
{
  printf("Nova encomenda %d.\n", n_IDe);
  IDeS[n_IDe] = n_IDe;
}

int adicionar_a_encomenda(char input[], int n_IDe, int n_IDp)
{
  char throwaway;
  int IDe;
  int IDp;
  int qntd;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDe = new_sym_var(sizeof(int) * 8);
  IDp = new_sym_var(sizeof(int) * 8);
  qntd = new_sym_var(sizeof(int) * 8);
  if (encomenda_existente(IDe, n_IDe) == 0)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", IDp, IDe);
      return 0;
    }
  }
  else
  {
    
  }

  if (produto_existente(IDp, n_IDp) == 0)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", IDp, IDe);
      return 0;
    }
  }
  else
  {
    
  }

  if ((produto[IDp].QNTD - qntd) < 0)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", IDp, IDe);
      return 0;
    }
  }
  else
  {
    
  }

  if ((encomenda[IDe].PESO + (qntd * produto[IDp].PESO)) > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", IDp, IDe);
      return 0;
    }
  }
  else
  {
    
  }

  encomenda[IDe].produto[IDp].ID = produto[IDp].ID;
  encomenda[IDe].produto[IDp].PRECO = produto[IDp].PRECO;
  strcpy(encomenda[IDe].produto[IDp].DESC, produto[IDp].DESC);
  encomenda[IDe].PESO += qntd * produto[IDp].PESO;
  encomenda[IDe].produto[IDp].QNTD += qntd;
  produto[IDp].QNTD -= qntd;
  return 0;
}

int remover_stock(char input[], int n_IDp)
{
  char throwaway;
  int IDp;
  int qntd;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDp = new_sym_var(sizeof(int) * 8);
  qntd = new_sym_var(sizeof(int) * 8);
  if ((stock[IDp] == IDp) && (n_IDp > 0))
  {
    {
      if ((produto[IDp].QNTD - qntd) < 0)
      {
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qntd, IDp);
          return 0;
        }
      }
      else
      {
        {
          produto[IDp].QNTD -= qntd;
          return 0;
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", IDp);
    }
  }

  return 0;
}

int remove_produto_enc(char input[], int n_IDe, int n_IDp)
{
  int IDe;
  int IDp;
  char throwaway;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDe = new_sym_var(sizeof(int) * 8);
  IDp = new_sym_var(sizeof(int) * 8);
  if (encomenda_existente(IDe, n_IDe) == 0)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", IDp, IDe);
      return 0;
    }
  }
  else
  {
    
  }

  if (produto_existente(IDp, n_IDp) == 0)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", IDp, IDe);
      return 0;
    }
  }
  else
  {
    
  }

  encomenda[IDe].PESO -= encomenda[IDe].produto[IDp].QNTD * produto[IDp].PESO;
  produto[IDp].QNTD += encomenda[IDe].produto[IDp].QNTD;
  encomenda[IDe].produto[IDp].QNTD = 0;
  return 0;
}

int calcula_custo_encomenda(char input[], int n_IDe, int n_IDp)
{
  int IDe;
  int custo;
  int i;
  char throwaway;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDe = new_sym_var(sizeof(int) * 8);
  if (encomenda_existente(IDe, n_IDe) == 0)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", IDe);
      return 0;
    }
  }
  else
  {
    
  }

  custo = 0;
  for (i = 0; i < n_IDp; i++)
  {
    custo += encomenda[IDe].produto[i].PRECO * encomenda[IDe].produto[i].QNTD;
  }

  printf("Custo da encomenda %d %d.\n", IDe, custo);
  return 0;
}

void altera_preco(char input[], int n_IDp, int n_IDe)
{
  char throwaway;
  int IDp;
  int preco;
  int IDe;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if ((stock[IDp] == IDp) && (n_IDp > 0))
  {
    {
      produto[IDp].PRECO = preco;
      for (IDe = 0; IDe < n_IDe; IDe++)
      {
        if (encomenda[IDe].produto[IDp].PRECO != 0)
        {
          {
            encomenda[IDe].produto[IDp].PRECO = preco;
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", IDp);
    }
  }

}

int lista_produto_enc(char input[], int n_IDp, int n_IDe)
{
  char throwaway;
  int IDe;
  int IDp;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDe = new_sym_var(sizeof(int) * 8);
  IDp = new_sym_var(sizeof(int) * 8);
  if (encomenda_existente(IDe, n_IDe) == 0)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", IDe);
      return 0;
    }
  }
  else
  {
    
  }

  if (produto_existente(IDp, n_IDp) == 0)
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", IDp);
      return 0;
    }
  }
  else
  {
    
  }

  printf("%s %d.\n", produto[IDp].DESC, encomenda[IDe].produto[IDp].QNTD);
  return 0;
}

int listar_produto_max(char input[], int n_IDp, int n_IDe)
{
  int IDp;
  int IDe;
  int res_IDe;
  int qntd_max;
  int IDe_menor;
  char throwaway;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDp = new_sym_var(sizeof(int) * 8);
  if (produto_existente(IDp, n_IDp) == 0)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", IDp);
      return 0;
    }
  }
  else
  {
    
  }

  qntd_max = -1;
  res_IDe = -1;
  IDe_menor = -1;
  for (IDe = 0; IDe < n_IDe; IDe++)
  {
    if (encomenda[IDe].produto[IDp].QNTD >= qntd_max)
    {
      {
        if ((qntd_max > 0) && (encomenda[IDe].produto[IDp].QNTD == qntd_max))
        {
          {
            IDe_menor = res_IDe;
          }
        }
        else
        {
          {
            qntd_max = encomenda[IDe].produto[IDp].QNTD;
            res_IDe = IDe;
            IDe_menor = -1;
          }
        }

      }
    }
    else
    {
      
    }

  }

  if (qntd_max > 0)
  {
    {
      if (IDe_menor == (-1))
      {
        {
          printf("Maximo produto %d %d %d.\n", IDp, res_IDe, qntd_max);
        }
      }
      else
      {
        {
          printf("Maximo produto %d %d %d.\n", IDp, IDe_menor, qntd_max);
        }
      }

    }
  }
  else
  {
    
  }

  return 0;
}

void listar_stock(int n_IDp)
{
  int i;
  int ativado;
  for (i = 0; i < n_IDp; i++)
  {
    produtos_p_ordenar[i] = produto[i];
  }

  ativado = 0;
  mergeSort(produtos_p_ordenar, 0, n_IDp - 1, ativado);
  printf("Produtos\n");
  for (i = 0; i < n_IDp; i++)
  {
    printf("* %s %d %d\n", produtos_p_ordenar[i].DESC, produtos_p_ordenar[i].PRECO, produtos_p_ordenar[i].QNTD);
  }

}

int listar_encomenda(char input[], int n_IDp, int n_IDe)
{
  char throwaway;
  int i;
  int j;
  int IDe;
  int ativado;
  throwaway = new_sym_var(sizeof(char) * 8);
  IDe = new_sym_var(sizeof(int) * 8);
  if (encomenda_existente(IDe, n_IDe) == 0)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", IDe);
      return 0;
    }
  }
  else
  {
    
  }

  j = 0;
  for (i = 0; i < n_IDp; i++)
  {
    if (encomenda[IDe].produto[i].QNTD > 0)
    {
      {
        encomenda_p_ordenar[j] = encomenda[IDe].produto[i];
        j++;
      }
    }
    else
    {
      
    }

  }

  ativado = 1;
  mergeSort(encomenda_p_ordenar, 0, j - 1, ativado);
  printf("Encomenda %d\n", IDe);
  for (i = 0; i < j; i++)
  {
    printf("* %s %d %d\n", encomenda_p_ordenar[i].DESC, encomenda_p_ordenar[i].PRECO, encomenda_p_ordenar[i].QNTD);
  }

  return 0;
}

int main()
{
  char input[100] = {0};
  int n_IDp;
  int n_IDe;
  n_IDp = 0;
  n_IDe = 0;
  while (1 > 0)
  {
    fgets(input, 100, stdin);
    if (input[0] == 'a')
    {
      {
        novo_produto(input, n_IDp);
        n_IDp++;
      }
    }
    else
    {
      
    }

    if (input[0] == 'q')
    {
      {
        adicionar_stock(input, n_IDp);
      }
    }
    else
    {
      
    }

    if (input[0] == 'N')
    {
      {
        nova_encomenda(n_IDe);
        n_IDe++;
      }
    }
    else
    {
      
    }

    if (input[0] == 'A')
    {
      {
        adicionar_a_encomenda(input, n_IDe, n_IDp);
      }
    }
    else
    {
      
    }

    if (input[0] == 'r')
    {
      {
        remover_stock(input, n_IDp);
      }
    }
    else
    {
      
    }

    if (input[0] == 'R')
    {
      {
        remove_produto_enc(input, n_IDe, n_IDp);
      }
    }
    else
    {
      
    }

    if (input[0] == 'C')
    {
      {
        calcula_custo_encomenda(input, n_IDe, n_IDp);
      }
    }
    else
    {
      
    }

    if (input[0] == 'p')
    {
      {
        altera_preco(input, n_IDp, n_IDe);
      }
    }
    else
    {
      
    }

    if (input[0] == 'E')
    {
      {
        lista_produto_enc(input, n_IDp, n_IDe);
      }
    }
    else
    {
      
    }

    if (input[0] == 'm')
    {
      {
        listar_produto_max(input, n_IDp, n_IDe);
      }
    }
    else
    {
      
    }

    if (input[0] == 'l')
    {
      {
        listar_stock(n_IDp);
      }
    }
    else
    {
      
    }

    if (input[0] == 'L')
    {
      {
        listar_encomenda(input, n_IDp, n_IDe);
      }
    }
    else
    {
      
    }

    if (input[0] == 'x')
    {
      {
        return 0;
      }
    }
    else
    {
      
    }

  }

}

