/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct product
{
  int stock;
  int ident;
  int price;
  int weight;
  char description[63];
} product;
typedef struct order
{
  int ident;
  int weight;
  int totalProd;
  int cost;
  product products[10000];
} order;
product system[10000];
int numProducts;
order orders[500];
int numOrders;
product aux[10000];
void new_product(char description[63], int price, int weight, int quant);
void add_stock(int identProd, int quant);
void new_order();
void add_product_order(int identOrder, int identProd, int quant);
void remove_stock(int identProd, int quant);
void remove_product(int identOrder, int identProd);
void order_cost(int identOrder);
void alter_price(int identProd, int price);
void list_desc_quant(int identOrder, int identProd);
void more_prod(int identProd);
void list_products_price();
void list_products_order(int identOrder);
int search(int ido, int idp);
void merge_sort(product array[], int left, int right, int mode);
void merge(product array[], int left, int mid, int right, int mode);
int main()
{
  char command;
  char description[63];
  int price;
  int weight;
  int quant;
  int identProd;
  int identOrder;
  while ((command = getchar()) != 'x')
  {
    switch (command)
    {
      case 'a':
        for (int description_index = 0; description_index < 10; description_index++)
      {
        description[description_index] = new_sym_var(sizeof(char) * 8);
      }

        description[10 - 1] = '\0';
        price = new_sym_var(sizeof(int) * 8);
        weight = new_sym_var(sizeof(int) * 8);
        quant = new_sym_var(sizeof(int) * 8);
        new_product(description, price, weight, quant);
        break;

      case 'q':
        identProd = new_sym_var(sizeof(int) * 8);
        quant = new_sym_var(sizeof(int) * 8);
        add_stock(identProd, quant);
        break;

      case 'N':
        new_order();
        break;

      case 'A':
        identOrder = new_sym_var(sizeof(int) * 8);
        identProd = new_sym_var(sizeof(int) * 8);
        quant = new_sym_var(sizeof(int) * 8);
        add_product_order(identOrder, identProd, quant);
        break;

      case 'r':
        identProd = new_sym_var(sizeof(int) * 8);
        quant = new_sym_var(sizeof(int) * 8);
        remove_stock(identProd, quant);
        break;

      case 'R':
        identOrder = new_sym_var(sizeof(int) * 8);
        identProd = new_sym_var(sizeof(int) * 8);
        remove_product(identOrder, identProd);
        break;

      case 'C':
        identOrder = new_sym_var(sizeof(int) * 8);
        order_cost(identOrder);
        break;

      case 'p':
        identProd = new_sym_var(sizeof(int) * 8);
        price = new_sym_var(sizeof(int) * 8);
        alter_price(identProd, price);
        break;

      case 'E':
        identOrder = new_sym_var(sizeof(int) * 8);
        identProd = new_sym_var(sizeof(int) * 8);
        list_desc_quant(identOrder, identProd);
        break;

      case 'm':
        identProd = new_sym_var(sizeof(int) * 8);
        more_prod(identProd);
        break;

      case 'l':
        list_products_price();
        break;

      case 'L':
        identOrder = new_sym_var(sizeof(int) * 8);
        list_products_order(identOrder);
        break;

    }

  }

  return 0;
}

void new_product(char description[63], int price, int weight, int quant)
{
  static int cont = 0;
  product new;
  new.stock = quant;
  new.ident = cont;
  new.price = price;
  new.weight = weight;
  strcpy(new.description, description);
  system[cont] = new;
  printf("Novo produto %d.\n", new.ident);
  numProducts = cont + 1;
  cont++;
}

void add_stock(int identProd, int quant)
{
  if (numProducts <= identProd)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", identProd);
    }
  }
  else
  {
    {
      system[identProd].stock = system[identProd].stock + quant;
    }
  }

}

void new_order()
{
  static int cont = 0;
  orders[cont].ident = cont;
  printf("Nova encomenda %d.\n", orders[cont].ident);
  numOrders = ++cont;
}

void add_product_order(int identOrder, int identProd, int quant)
{
  int cont = orders[identOrder].totalProd;
  int j = search(identOrder, identProd);
  product product_ = system[identProd];
  product new_product_order;
  if (numOrders <= identOrder)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", identProd, identOrder);
    }
  }
  else
  {
    if (numProducts <= identProd)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", identProd, identOrder);
      }
    }
    else
    {
      if (product_.stock < quant)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", identProd, identOrder);
        }
      }
      else
      {
        if (((quant * product_.weight) + orders[identOrder].weight) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", identProd, identOrder);
          }
        }
        else
        {
          {
            if (j != 250)
            {
              {
                orders[identOrder].products[j].stock += quant;
              }
            }
            else
            {
              {
                new_product_order = system[identProd];
                new_product_order.stock = quant;
                orders[identOrder].products[cont] = new_product_order;
                orders[identOrder].totalProd++;
              }
            }

            remove_stock(identProd, quant);
            orders[identOrder].cost += product_.price * quant;
            orders[identOrder].weight += quant * product_.weight;
          }
        }

      }

    }

  }

}

void remove_stock(int identProd, int quant)
{
  if (identProd >= numProducts)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", identProd);
    }
  }
  else
  {
    if (system[identProd].stock < quant)
    {
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quant, identProd);
      }
    }
    else
    {
      {
        system[identProd].stock -= quant;
      }
    }

  }

}

void remove_product(int identOrder, int identProd)
{
  int j = search(identOrder, identProd);
  if (identOrder >= numOrders)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", identProd, identOrder);
    }
  }
  else
  {
    if (identProd >= numProducts)
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", identProd, identOrder);
      }
    }
    else
    {
      if (j != 250)
      {
        {
          system[identProd].stock += orders[identOrder].products[j].stock;
          orders[identOrder].weight -= orders[identOrder].products[j].stock * system[identProd].weight;
          orders[identOrder].cost -= orders[identOrder].products[j].stock * system[identProd].price;
          orders[identOrder].products[j].stock = 0;
          orders[identOrder].products[j].ident = 0;
          orders[identOrder].products[j].price = 0;
          orders[identOrder].products[j].weight = 0;
          memset(orders[identOrder].products[j].description, 0, 63);
        }
      }
      else
      {
        
      }

    }

  }

}

void order_cost(int identOrder)
{
  if (identOrder >= numOrders)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", identOrder);
    }
  }
  else
  {
    {
      printf("Custo da encomenda %d %d.\n", identOrder, orders[identOrder].cost);
    }
  }

}

void alter_price(int identProd, int price)
{
  int i;
  int j;
  if (identProd >= numProducts)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", identProd);
    }
  }
  else
  {
    {
      system[identProd].price = price;
      for (i = 0; i < numOrders; i++)
      {
        j = search(orders[i].ident, identProd);
        if (j != 250)
        {
          {
            orders[i].cost = (orders[i].cost - (orders[i].products[j].stock * orders[i].products[j].price)) + (orders[i].products[j].stock * price);
            orders[i].products[j].price = price;
          }
        }
        else
        {
          
        }

      }

    }
  }

}

void list_desc_quant(int identOrder, int identProd)
{
  int j = search(identOrder, identProd);
  if (identOrder >= numOrders)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", identOrder);
    }
  }
  else
  {
    if (identProd >= numProducts)
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", identProd);
      }
    }
    else
    {
      if (j != 250)
      {
        {
          printf("%s %d.\n", orders[identOrder].products[j].description, orders[identOrder].products[j].stock);
        }
      }
      else
      {
        {
          printf("%s 0.\n", system[identProd].description);
        }
      }

    }

  }

}

void more_prod(int identProd)
{
  int i;
  int j;
  int maxProd = 0;
  int maxOrder = -1;
  int stock;
  int ido;
  if (identProd >= numProducts)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", identProd);
      return;
    }
  }
  else
  {
    {
      for (i = 0; i < numOrders; i++)
      {
        ido = orders[i].ident;
        j = search(ido, identProd);
        if ((j != 250) && (orders[i].products[j].stock >= maxProd))
        {
          {
            stock = orders[i].products[j].stock;
            if (maxProd < stock)
            {
              {
                maxProd = stock;
                maxOrder = ido;
              }
            }
            else
            {
              if (maxOrder > ido)
              {
                {
                  maxOrder = ido;
                }
              }
              else
              {
                
              }

            }

          }
        }
        else
        {
          
        }

      }

      if (maxOrder >= 0)
      {
        {
          printf("Maximo produto %d %d %d.\n", identProd, maxOrder, maxProd);
        }
      }
      else
      {
        
      }

    }
  }

}

void list_products_price()
{
  int i;
  product organized[10000];
  for (i = 0; i < numProducts; i++)
  {
    organized[i].stock = system[i].stock;
    organized[i].price = system[i].price;
    organized[i].ident = system[i].ident;
    organized[i].weight = system[i].weight;
    strcpy(organized[i].description, system[i].description);
  }

  merge_sort(organized, 0, i - 1, 1);
  printf("Produtos\n");
  for (i = 0; i < numProducts; i++)
  {
    printf("* %s %d %d\n", organized[i].description, organized[i].price, organized[i].stock);
  }

}

void list_products_order(int identOrder)
{
  int i;
  int cont = 0;
  product organized[10000];
  if (identOrder >= numOrders)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", identOrder);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < orders[identOrder].totalProd; i++)
  {
    if (orders[identOrder].products[i].price != 0)
    {
      {
        organized[cont].stock = orders[identOrder].products[i].stock;
        organized[cont].price = orders[identOrder].products[i].price;
        organized[cont].ident = orders[identOrder].products[i].ident;
        organized[cont].weight = orders[identOrder].products[i].weight;
        strcpy(organized[cont].description, orders[identOrder].products[i].description);
        cont++;
      }
    }
    else
    {
      
    }

  }

  merge_sort(organized, 0, --cont, 0);
  printf("Encomenda %d\n", identOrder);
  for (i = 0; i <= cont; i++)
  {
    printf("* %s %d %d\n", organized[i].description, organized[i].price, organized[i].stock);
  }

}

int search(int ido, int idp)
{
  int i;
  int total = orders[ido].totalProd;
  for (i = 0; i < total; i++)
  {
    if ((orders[ido].products[i].ident == idp) && (orders[ido].products[i].price != 0))
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return 250;
}

void merge_sort(product array[], int left, int right, int mode)
{
  int mid = (left + right) / 2;
  if (left < right)
  {
    {
      merge_sort(array, left, mid, mode);
      merge_sort(array, mid + 1, right, mode);
      merge(array, left, mid, right, mode);
    }
  }
  else
  {
    
  }

}

void merge(product array[], int left, int mid, int right, int mode)
{
  int i;
  int j;
  int k;
  for (i = mid + 1; i > left; i--)
  {
    aux[i - 1] = array[i - 1];
  }

  for (j = mid; j < right; j++)
  {
    aux[(right + mid) - j] = array[j + 1];
  }

  if (mode == 1)
  {
    {
      for (k = left; k <= right; k++)
      {
        if ((aux[j].price < aux[i].price) || ((aux[j].price == aux[i].price) && (aux[j].ident < aux[i].ident)))
        {
          {
            array[k] = aux[j--];
          }
        }
        else
        {
          {
            array[k] = aux[i++];
          }
        }

      }

    }
  }
  else
  {
    {
      for (k = left; k <= right; k++)
      {
        if (strcmp(aux[j].description, aux[i].description) < 0)
        {
          {
            array[k] = aux[j--];
          }
        }
        else
        {
          {
            array[k] = aux[i++];
          }
        }

      }

    }
  }

}

