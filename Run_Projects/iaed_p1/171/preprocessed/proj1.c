/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


static int ide = -1;
static int idp = -1;
typedef struct 
{
  char descricao[9999][62];
  int preco[9999];
  int peso[9999];
  int qtd[9999];
  int idps_ordenados[9999];
} sistema;
sistema sstm;
int preco_produto(int ident_p)
{
  return sstm.preco[ident_p];
}

int qtd_produto(int ident_p)
{
  return sstm.qtd[ident_p];
}

int peso_produto(int ident_p)
{
  return sstm.peso[ident_p];
}

int indice_idp_ordenado(int ident_p)
{
  int i;
  for (i = 0; i <= idp; i++)
  {
    if (sstm.idps_ordenados[i] == ident_p)
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return i;
}

int less_alfa(int ident1, int ident2)
{
  int i;
  int tamanho;
  char c1;
  char c2;
  if (strlen(sstm.descricao[ident1]) < strlen(sstm.descricao[ident2]))
  {
    {
      tamanho = strlen(sstm.descricao[ident1]);
    }
  }
  else
  {
    {
      tamanho = strlen(sstm.descricao[ident2]);
    }
  }

  for (i = 0; i <= tamanho; i++)
  {
    c1 = sstm.descricao[ident1][i];
    c2 = sstm.descricao[ident2][i];
    if (c1 < c2)
    {
      {
        return 1;
      }
    }
    else
    {
      
    }

    if (c2 < c1)
    {
      {
        return 0;
      }
    }
    else
    {
      
    }

  }

  return strlen(sstm.descricao[ident1]) <= strlen(sstm.descricao[ident2]);
}

typedef struct 
{
  int idpe[9999];
  int qtd[9999];
  int n_produtos_e;
} encomenda;
encomenda encomendas[499];
int n_produtos(int ident_e)
{
  return encomendas[ident_e].n_produtos_e;
}

int obter_indice_p(int ident_e, int ident_p)
{
  int i;
  for (i = 0; i <= n_produtos(ident_e); i += 1)
  {
    if (encomendas[ident_e].idpe[i] == ident_p)
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return i;
}

int peso_encomenda(int ident_e)
{
  int i;
  int peso = 0;
  for (i = 0; i <= n_produtos(ident_e); i += 1)
  {
    peso += peso_produto(encomendas[ident_e].idpe[i]) * encomendas[ident_e].qtd[i];
  }

  return peso;
}

int produto_in(int ident_e, int ident_p)
{
  int i;
  for (i = 0; i <= n_produtos(ident_e); i += 1)
  {
    if (encomendas[ident_e].idpe[i] == ident_p)
    {
      {
        return 1;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

int qtd_produto_e(int ident_e, int ident_p)
{
  return encomendas[ident_e].qtd[obter_indice_p(ident_e, ident_p)];
}

void a(char desc[62], int preco, int peso, int qtd)
{
  int i = 0;
  int j;
  idp++;
  strcpy(sstm.descricao[idp], desc);
  sstm.preco[idp] = preco;
  sstm.peso[idp] = peso;
  sstm.qtd[idp] = qtd;
  for (i = 0; (i < idp) && (preco_produto(idp) >= preco_produto(sstm.idps_ordenados[i])); i++)
  {
    ;
  }

  for (j = idp; j > i; j -= 1)
  {
    sstm.idps_ordenados[j] = sstm.idps_ordenados[j - 1];
  }

  sstm.idps_ordenados[i] = idp;
  printf("Novo produto %d.\n", idp);
}

void l()
{
  int j;
  printf("Produtos\n");
  for (j = 0; j <= idp; j += 1)
  {
    printf("* %s %d %d\n", sstm.descricao[sstm.idps_ordenados[j]], preco_produto(sstm.idps_ordenados[j]), qtd_produto(sstm.idps_ordenados[j]));
  }

}

void q(int ident_p, int qtd)
{
  if (ident_p <= idp)
  {
    {
      sstm.qtd[ident_p] += qtd;
    }
  }
  else
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", ident_p);
    }
  }

}

void N()
{
  ide++;
  encomendas[ide].n_produtos_e = -1;
  encomendas[ide].idpe[0] = -1;
  printf("Nova encomenda %d.\n", ide);
}

void r(int ident_p, int qtd)
{
  if (ident_p > idp)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", ident_p);
    }
  }
  else
  {
    if (qtd > qtd_produto(ident_p))
    {
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, ident_p);
      }
    }
    else
    {
      {
        sstm.qtd[ident_p] -= qtd;
      }
    }

  }

}

void A(int ident_e, int ident_p, int qtd)
{
  int i;
  int j;
  if (ident_e > ide)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", ident_p, ident_e);
    }
  }
  else
  {
    if (ident_p > idp)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", ident_p, ident_e);
      }
    }
    else
    {
      if (qtd > qtd_produto(ident_p))
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", ident_p, ident_e);
        }
      }
      else
      {
        if (((qtd * peso_produto(ident_p)) + peso_encomenda(ident_e)) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", ident_p, ident_e);
          }
        }
        else
        {
          {
            if (produto_in(ident_e, ident_p))
            {
              {
                encomendas[ident_e].qtd[obter_indice_p(ident_e, ident_p)] += qtd;
              }
            }
            else
            {
              {
                if (encomendas[ident_e].idpe[0] != (-1))
                {
                  {
                    for (i = 0; i <= n_produtos(ident_e); i++)
                    {
                      if (less_alfa(ident_p, encomendas[ident_e].idpe[i]))
                      {
                        {
                          break;
                        }
                      }
                      else
                      {
                        
                      }

                    }

                    for (j = n_produtos(ident_e) + 1; j > i; j--)
                    {
                      encomendas[ident_e].idpe[j] = encomendas[ident_e].idpe[j - 1];
                      encomendas[ident_e].qtd[j] = encomendas[ident_e].qtd[j - 1];
                    }

                    encomendas[ident_e].idpe[i] = ident_p;
                    encomendas[ident_e].qtd[i] = qtd;
                  }
                }
                else
                {
                  {
                    encomendas[ident_e].idpe[0] = ident_p;
                    encomendas[ident_e].qtd[0] = qtd;
                  }
                }

                encomendas[ident_e].n_produtos_e += 1;
              }
            }

            r(ident_p, qtd);
          }
        }

      }

    }

  }

}

void E(int ident_e, int ident_p)
{
  if (ident_e > ide)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ident_e);
    }
  }
  else
  {
    if (ident_p > idp)
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", ident_p);
      }
    }
    else
    {
      {
        if (produto_in(ident_e, ident_p))
        {
          {
            printf("%s %d.\n", sstm.descricao[ident_p], qtd_produto_e(ident_e, ident_p));
          }
        }
        else
        {
          {
            printf("%s 0.\n", sstm.descricao[ident_p]);
          }
        }

      }
    }

  }

}

void L(int ident_e)
{
  if (ident_e > ide)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ident_e);
    }
  }
  else
  {
    {
      int i;
      printf("Encomenda %d\n", ident_e);
      for (i = 0; i <= n_produtos(ident_e); i++)
      {
        printf("* %s %d %d\n", sstm.descricao[encomendas[ident_e].idpe[i]], sstm.preco[encomendas[ident_e].idpe[i]], qtd_produto_e(ident_e, encomendas[ident_e].idpe[i]));
      }

    }
  }

}

void R(int ident_e, int ident_p)
{
  int i;
  if (ident_e > ide)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", ident_p, ident_e);
    }
  }
  else
  {
    if (ident_p > idp)
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", ident_p, ident_e);
      }
    }
    else
    {
      {
        if (produto_in(ident_e, ident_p))
        {
          {
            q(ident_p, qtd_produto_e(ident_e, ident_p));
            for (i = obter_indice_p(ident_e, ident_p); i < n_produtos(ident_e); i++)
            {
              encomendas[ident_e].idpe[i] = encomendas[ident_e].idpe[i + 1];
              encomendas[ident_e].qtd[i] = encomendas[ident_e].qtd[i + 1];
            }

            encomendas[ident_e].n_produtos_e -= 1;
          }
        }
        else
        {
          
        }

      }
    }

  }

}

void C(int ident_e)
{
  if (ident_e > ide)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ident_e);
    }
  }
  else
  {
    {
      int i;
      int total = 0;
      for (i = 0; i <= n_produtos(ident_e); i++)
      {
        total += preco_produto(encomendas[ident_e].idpe[i]) * encomendas[ident_e].qtd[i];
      }

      printf("Custo da encomenda %d %d.\n", ident_e, total);
    }
  }

}

void p(int ident_p, int preco)
{
  int i;
  int j;
  if (ident_p > idp)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", ident_p);
    }
  }
  else
  {
    {
      if (preco > preco_produto(ident_p))
      {
        {
          for (i = idp; i > indice_idp_ordenado(ident_p); i--)
          {
            if ((preco_produto(sstm.idps_ordenados[i]) < preco) || ((preco_produto(sstm.idps_ordenados[i]) == preco) && (ident_p > sstm.idps_ordenados[i])))
            {
              {
                break;
              }
            }
            else
            {
              
            }

          }

          for (j = indice_idp_ordenado(ident_p); j < i; j++)
          {
            sstm.idps_ordenados[j] = sstm.idps_ordenados[j + 1];
          }

        }
      }
      else
      {
        {
          for (i = 0; i < indice_idp_ordenado(ident_p); i++)
          {
            if ((preco_produto(sstm.idps_ordenados[i]) > preco) || ((preco_produto(sstm.idps_ordenados[i]) == preco) && (ident_p < sstm.idps_ordenados[i])))
            {
              {
                break;
              }
            }
            else
            {
              
            }

          }

          for (j = indice_idp_ordenado(ident_p); j > i; j--)
          {
            sstm.idps_ordenados[j] = sstm.idps_ordenados[j - 1];
          }

        }
      }

      sstm.idps_ordenados[i] = ident_p;
      sstm.preco[ident_p] = preco;
    }
  }

}

void m(int ident_p)
{
  if (ident_p > idp)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", ident_p);
    }
  }
  else
  {
    {
      int i;
      int qtd_max = 0;
      int idpe_max;
      for (i = 0; i <= ide; i++)
      {
        if (produto_in(i, ident_p) && (encomendas[i].qtd[obter_indice_p(i, ident_p)] > qtd_max))
        {
          {
            qtd_max = encomendas[i].qtd[obter_indice_p(i, ident_p)];
            idpe_max = i;
          }
        }
        else
        {
          
        }

      }

      if (qtd_max != 0)
      {
        {
          printf("Maximo produto %d %d %d.\n", ident_p, idpe_max, qtd_max);
        }
      }
      else
      {
        
      }

    }
  }

}

int main()
{
  char c = '0';
  char descricao[62];
  int preco;
  int peso;
  int qtd;
  int identificador;
  int ident_e;
  int ident_p;
  while (c != 'x')
  {
    switch (c = getchar())
    {
      case 'a':
        for (int descricao_index = 0; descricao_index < 10; descricao_index++)
      {
        descricao[descricao_index] = new_sym_var(sizeof(char) * 8);
      }

        descricao[10 - 1] = '\0';
        preco = new_sym_var(sizeof(int) * 8);
        peso = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        a(descricao, preco, peso, qtd);
        break;

      case 'l':
        l();
        break;

      case 'q':
        identificador = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        q(identificador, qtd);
        break;

      case 'N':
        N();
        break;

      case 'A':
        ident_e = new_sym_var(sizeof(int) * 8);
        ident_p = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        A(ident_e, ident_p, qtd);
        break;

      case 'E':
        ident_e = new_sym_var(sizeof(int) * 8);
        ident_p = new_sym_var(sizeof(int) * 8);
        E(ident_e, ident_p);
        break;

      case 'L':
        ident_e = new_sym_var(sizeof(int) * 8);
        L(ident_e);
        break;

      case 'r':
        ident_p = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        r(ident_p, qtd);
        break;

      case 'R':
        ident_e = new_sym_var(sizeof(int) * 8);
        ident_p = new_sym_var(sizeof(int) * 8);
        R(ident_e, ident_p);
        break;

      case 'C':
        ident_e = new_sym_var(sizeof(int) * 8);
        C(ident_e);
        break;

      case 'p':
        ident_p = new_sym_var(sizeof(int) * 8);
        preco = new_sym_var(sizeof(int) * 8);
        p(ident_p, preco);
        break;

      case 'm':
        ident_p = new_sym_var(sizeof(int) * 8);
        m(ident_p);
        break;

    }

  }

  return 0;
}

