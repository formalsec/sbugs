/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int idp;
  char description_produto[64];
  int price_produto;
  int weight_produto;
  int qtd_produto;
  int isActive;
  int insideEcomenda;
} produto;
typedef struct 
{
  produto conj[200];
  int ide;
  int weight_encomenda;
  int isActive;
  int current_size;
  int total_price;
} encomenda;
produto stock[10000];
encomenda lista_encomendas[500];
int idp_counter = 0;
int ide_counter = 0;
void init_Stock();
void init_Encomendas();
void a();
void q();
void N();
void A();
void r();
void R();
void C();
void p();
void E();
void m();
void l();
void L();
void adicionaProdutoAEcomenda();
int produtoExiste(int aux_idp);
int encomendaExiste(int aux_ide);
int produtoDentroDeEncomenda(int aux_idp, int aux_ide);
int main()
{
  char comando;
  init_Stock();
  init_Encomendas();
  while ((comando = getchar()) != 'x')
  {
    switch (comando)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

      case '\n':
        break;

    }

  }

  return 0;
}

int produtoExiste(int aux_idp)
{
  int res = 1;
  if ((stock[aux_idp].idp == aux_idp) && (stock[aux_idp].isActive == 1))
  {
    {
      res = 2;
    }
  }
  else
  {
    
  }

  return res;
}

int encomendaExiste(int aux_ide)
{
  int res = 1;
  if ((lista_encomendas[aux_ide].ide == aux_ide) && (lista_encomendas[aux_ide].isActive == 1))
  {
    {
      res = 2;
    }
  }
  else
  {
    
  }

  return res;
}

int produtoDentroDeEncomenda(int aux_idp, int aux_ide)
{
  int res = 1;
  if (lista_encomendas[aux_ide].conj[aux_idp].insideEcomenda == 2)
  {
    {
      res = 2;
    }
  }
  else
  {
    
  }

  return res;
}

void init_Stock()
{
  int i;
  produto vazio;
  vazio.idp = -1;
  vazio.price_produto = 0;
  vazio.weight_produto = 0;
  vazio.qtd_produto = 0;
  vazio.isActive = 2;
  vazio.insideEcomenda = 2;
  for (i = 0; i < 10000; i++)
  {
    stock[i] = vazio;
  }

}

void init_Encomendas()
{
  int i;
  encomenda vazio;
  vazio.ide = -1;
  vazio.weight_encomenda = 0;
  vazio.isActive = 2;
  for (i = 0; i < 500; i++)
  {
    lista_encomendas[i] = vazio;
  }

}

void a()
{
  char aux_des[64];
  int aux_price;
  int aux_weight;
  int aux_qtd;
  char c_spaces;
  produto novo_produto;
  while ((c_spaces = getchar()) != ' ')
    ;

  for (int aux_des_index = 0; aux_des_index < 10; aux_des_index++)
  {
    aux_des[aux_des_index] = new_sym_var(sizeof(char) * 8);
  }

  aux_des[10 - 1] = '\0';
  aux_price = new_sym_var(sizeof(int) * 8);
  aux_weight = new_sym_var(sizeof(int) * 8);
  aux_qtd = new_sym_var(sizeof(int) * 8);
  novo_produto.idp = idp_counter;
  strcpy(novo_produto.description_produto, aux_des);
  novo_produto.price_produto = aux_price;
  novo_produto.weight_produto = aux_weight;
  novo_produto.qtd_produto = aux_qtd;
  novo_produto.isActive = 1;
  novo_produto.insideEcomenda = 1;
  stock[idp_counter] = novo_produto;
  idp_counter++;
  printf("Novo produto %d.\n", novo_produto.idp);
}

void q()
{
  int aux_idp;
  int aux_qtd;
  aux_idp = new_sym_var(sizeof(int) * 8);
  aux_qtd = new_sym_var(sizeof(int) * 8);
  if (produtoExiste(aux_idp) == 2)
  {
    {
      stock[aux_idp].qtd_produto += aux_qtd;
    }
  }
  else
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", aux_idp);
    }
  }

}

void N()
{
  int aux_weight = 0;
  encomenda nova_encomenda;
  nova_encomenda.weight_encomenda = aux_weight;
  nova_encomenda.ide = ide_counter;
  nova_encomenda.isActive = 1;
  nova_encomenda.current_size = 0;
  nova_encomenda.total_price = 0;
  lista_encomendas[ide_counter] = nova_encomenda;
  ide_counter++;
  printf("Nova encomenda %d.\n", nova_encomenda.ide);
}

void A()
{
  int aux_ide;
  int aux_idp;
  int aux_qtd;
  char c_spaces;
  while ((c_spaces = getchar()) != ' ')
    ;

  aux_ide = new_sym_var(sizeof(int) * 8);
  aux_idp = new_sym_var(sizeof(int) * 8);
  aux_qtd = new_sym_var(sizeof(int) * 8);
  if (encomendaExiste(aux_ide) == 2)
  {
    {
      if (produtoExiste(aux_idp) == 2)
      {
        {
          if (stock[aux_idp].qtd_produto >= aux_qtd)
          {
            {
              if ((lista_encomendas[aux_ide].weight_encomenda + (stock[aux_idp].weight_produto * aux_qtd)) <= 200)
              {
                {
                  adicionaProdutoAEcomenda(aux_ide, aux_idp, aux_qtd);
                }
              }
              else
              {
                {
                  printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", aux_idp, aux_ide);
                }
              }

            }
          }
          else
          {
            {
              printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", aux_idp, aux_ide);
            }
          }

        }
      }
      else
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", aux_idp, aux_ide);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", aux_idp, aux_ide);
    }
  }

}

void adicionaProdutoAEcomenda(int ide, int idp, int qtd)
{
  if (produtoDentroDeEncomenda(idp, ide) == 2)
  {
    {
      stock[idp].qtd_produto -= qtd;
      lista_encomendas[ide].conj[idp].qtd_produto += qtd;
      lista_encomendas[ide].weight_encomenda += stock[idp].weight_produto * qtd;
    }
  }
  else
  {
    {
      lista_encomendas[ide].conj[idp] = stock[idp];
      strcpy(lista_encomendas[ide].conj[idp].description_produto, stock[idp].description_produto);
      lista_encomendas[ide].conj[idp].insideEcomenda = 2;
      stock[idp].qtd_produto -= qtd;
      lista_encomendas[ide].conj[idp].qtd_produto = qtd;
      lista_encomendas[ide].weight_encomenda += stock[idp].weight_produto * qtd;
      lista_encomendas[ide].current_size += 1;
    }
  }

}

void r()
{
  int aux_idp;
  int aux_qtd;
  aux_idp = new_sym_var(sizeof(int) * 8);
  aux_qtd = new_sym_var(sizeof(int) * 8);
  if (produtoExiste(aux_idp) == 2)
  {
    {
      if ((stock[aux_idp].qtd_produto - aux_qtd) >= 0)
      {
        {
          stock[aux_idp].qtd_produto -= aux_qtd;
        }
      }
      else
      {
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", aux_qtd, aux_idp);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", aux_idp);
    }
  }

}

void R()
{
  int aux_ide;
  int aux_idp;
  aux_ide = new_sym_var(sizeof(int) * 8);
  aux_idp = new_sym_var(sizeof(int) * 8);
  if (encomendaExiste(aux_ide) == 2)
  {
    {
      if (produtoExiste(aux_idp) == 2)
      {
        {
          stock[aux_idp].qtd_produto += lista_encomendas[aux_ide].conj[aux_idp].qtd_produto;
          lista_encomendas[aux_ide].weight_encomenda -= stock[aux_idp].weight_produto * lista_encomendas[aux_ide].conj[aux_idp].qtd_produto;
          lista_encomendas[aux_ide].conj[aux_idp].qtd_produto = 0;
          lista_encomendas[aux_ide].current_size -= 1;
        }
      }
      else
      {
        {
          printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", aux_idp, aux_ide);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", aux_idp, aux_ide);
    }
  }

}

void C()
{
  int aux_ide;
  int i;
  int total;
  aux_ide = new_sym_var(sizeof(int) * 8);
  total = 0;
  if (encomendaExiste(aux_ide) == 2)
  {
    {
      for (i = 0; i < 500; i++)
      {
        total += stock[i].price_produto * lista_encomendas[aux_ide].conj[i].qtd_produto;
      }

      lista_encomendas[aux_ide].total_price = total;
      printf("Custo da encomenda %d %d.\n", aux_ide, lista_encomendas[aux_ide].total_price);
    }
  }
  else
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", aux_ide);
    }
  }

}

void p()
{
  int aux_idp;
  int aux_price;
  int i;
  int j;
  aux_idp = new_sym_var(sizeof(int) * 8);
  aux_price = new_sym_var(sizeof(int) * 8);
  if (produtoExiste(aux_idp) == 2)
  {
    {
      stock[aux_idp].price_produto = aux_price;
      for (i = 0; i < ide_counter; i++)
      {
        for (j = 0; j < 500; j++)
        {
          lista_encomendas[i].conj[j].price_produto = aux_price;
        }

      }

    }
  }
  else
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", aux_idp);
    }
  }

}

void E()
{
  int aux_ide;
  int aux_idp;
  aux_ide = new_sym_var(sizeof(int) * 8);
  aux_idp = new_sym_var(sizeof(int) * 8);
  if (encomendaExiste(aux_ide) == 2)
  {
    {
      if (produtoExiste(aux_idp) == 2)
      {
        {
          printf("%s %d.\n", stock[aux_idp].description_produto, lista_encomendas[aux_ide].conj[aux_idp].qtd_produto);
        }
      }
      else
      {
        {
          printf("Impossivel listar produto %d. Produto inexistente.\n", aux_idp);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", aux_ide);
    }
  }

}

void m()
{
  int aux_idp;
  int i;
  int encomenda_com_mais_produto;
  aux_idp = new_sym_var(sizeof(int) * 8);
  if (produtoExiste(aux_idp) == 2)
  {
    {
      int aux_qtd_2 = 0;
      for (i = 0; i < ide_counter; i++)
      {
        int aux_qtd = lista_encomendas[i].conj[aux_idp].qtd_produto;
        if (aux_qtd > aux_qtd_2)
        {
          {
            aux_qtd_2 = aux_qtd;
            encomenda_com_mais_produto = i;
          }
        }
        else
        {
          
        }

      }

      if (aux_qtd_2 > 0)
      {
        printf("Maximo produto %d %d %d.\n", aux_idp, encomenda_com_mais_produto, lista_encomendas[encomenda_com_mais_produto].conj[aux_idp].qtd_produto);
      }
      else
      {
        
      }

    }
  }
  else
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", aux_idp);
    }
  }

}

void l()
{
  int i;
  int j;
  for (i = 0; i < idp_counter; i++)
  {
    int min = i;
    produto aux;
    for (j = i + 1; j < idp_counter; j++)
    {
      if (stock[j].price_produto < stock[min].price_produto)
      {
        {
          min = j;
        }
      }
      else
      {
        if (stock[j].price_produto == stock[min].price_produto)
        {
          {
            if (stock[j].idp < stock[min].idp)
            {
              {
                min = j;
              }
            }
            else
            {
              
            }

          }
        }
        else
        {
          
        }

      }

    }

    aux = stock[i];
    stock[i] = stock[min];
    stock[min] = aux;
  }

  printf("Produtos\n");
  for (i = 0; i < idp_counter; i++)
  {
    printf("* %s %d %d\n", stock[i].description_produto, stock[i].price_produto, stock[i].qtd_produto);
  }

}

void L()
{
  int i;
  int j;
  int aux_ide;
  int tamanho_encomenda;
  aux_ide = new_sym_var(sizeof(int) * 8);
  tamanho_encomenda = lista_encomendas[aux_ide].current_size;
  if (encomendaExiste(aux_ide) == 2)
  {
    {
      for (i = 0; i < tamanho_encomenda; i++)
      {
        int min = i;
        produto aux;
        for (j = i + 1; j < tamanho_encomenda; j++)
        {
          if (lista_encomendas[aux_ide].conj[j].description_produto[0] <= lista_encomendas[aux_ide].conj[min].description_produto[0])
          {
            {
              min = j;
            }
          }
          else
          {
            
          }

        }

        aux = lista_encomendas[aux_ide].conj[i];
        lista_encomendas[aux_ide].conj[i] = lista_encomendas[aux_ide].conj[min];
        lista_encomendas[aux_ide].conj[min] = aux;
      }

      printf("Encomenda %d\n", aux_ide);
      for (i = 0; i < tamanho_encomenda; i++)
      {
        printf("* %s %d %d\n", lista_encomendas[aux_ide].conj[i].description_produto, stock[i].price_produto, lista_encomendas[aux_ide].conj[i].qtd_produto);
      }

    }
  }
  else
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", aux_ide);
    }
  }

}

