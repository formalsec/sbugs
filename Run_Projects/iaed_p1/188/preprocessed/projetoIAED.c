/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct produto
{
  char descricao[63];
  int preco;
  int peso;
  int qtd;
  int idp;
} produto;
typedef struct encomenda
{
  int ide;
  int estado;
  int pesoTotal;
} encomenda;
produto tabP[10000];
encomenda tabE[500];
int tabela_id[500][200][2] = {0};
int idp = 0;
int ide = 0;
void cria_produto()
{
  char descricao[63];
  int preco;
  int peso;
  int qtd;
  for (int descricao_index = 0; descricao_index < 10; descricao_index++)
  {
    descricao[descricao_index] = new_sym_var(sizeof(char) * 8);
  }

  descricao[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  strcpy(tabP[idp].descricao, descricao);
  tabP[idp].preco = preco;
  tabP[idp].peso = peso;
  tabP[idp].qtd = qtd;
  tabP[idp].idp = idp;
  printf("Novo produto %d.\n", idp);
  idp++;
  return;
}

void add_stock()
{
  int n_idp;
  int novaqtd;
  n_idp = new_sym_var(sizeof(int) * 8);
  novaqtd = new_sym_var(sizeof(int) * 8);
  if (n_idp > (idp - 1))
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", n_idp);
    }
  }
  else
  {
    {
      tabP[n_idp].qtd += novaqtd;
    }
  }

  return;
}

void cria_encomenda()
{
  tabE[ide].estado = 1;
  tabE[ide].ide = ide;
  tabE[ide].pesoTotal = 0;
  printf("Nova encomenda %d.\n", ide);
  ide++;
  return;
}

void add_produto()
{
  int n_ide;
  int n_idp;
  int qtd;
  int i = 0;
  int id_nada = -1;
  n_ide = new_sym_var(sizeof(int) * 8);
  n_idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (tabE[n_ide].estado == 1)
  {
    {
      if (n_idp > (idp - 1))
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", n_idp, n_ide);
      }
      else
      {
        if (tabP[n_idp].qtd < qtd)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", n_idp, n_ide);
        }
        else
        {
          if ((tabE[n_ide].pesoTotal + (qtd * tabP[n_idp].peso)) > 200)
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", n_idp, n_ide);
          }
          else
          {
            {
              for (i = 0; i <= (200 - 1); i++)
              {
                if ((tabela_id[n_ide][i][0] == n_idp) && (tabela_id[n_ide][i][1] != 0))
                {
                  {
                    tabela_id[n_ide][i][1] += qtd;
                    tabP[n_idp].qtd -= qtd;
                    tabE[n_ide].pesoTotal += tabP[n_idp].peso * qtd;
                    return;
                  }
                }
                else
                {
                  
                }

                if ((tabela_id[n_ide][i][0] == 0) && (tabela_id[n_ide][i][1] == 0))
                {
                  id_nada = i;
                }
                else
                {
                  
                }

              }

              if (id_nada != (-1))
              {
                {
                  tabela_id[n_ide][id_nada][0] = n_idp;
                  tabela_id[n_ide][id_nada][1] = qtd;
                  tabE[n_ide].pesoTotal += tabP[n_idp].peso * qtd;
                }
              }
              else
              {
                
              }

              tabP[n_idp].qtd -= qtd;
            }
          }

        }

      }

      return;
    }
  }
  else
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", n_idp, n_ide);
    }
  }

  ;
  return;
}

void r_stock()
{
  int n_idp;
  int qtd;
  n_idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (n_idp > (idp - 1))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", n_idp);
  }
  else
  {
    if (tabP[n_idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, n_idp);
    }
    else
    {
      {
        tabP[n_idp].qtd -= qtd;
      }
    }

  }

  return;
}

void r_produto()
{
  int n_ide;
  int n_idp;
  int i;
  n_ide = new_sym_var(sizeof(int) * 8);
  n_idp = new_sym_var(sizeof(int) * 8);
  if (tabE[n_ide].estado != 1)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", n_idp, n_ide);
  }
  else
  {
    if (n_idp > (idp - 1))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", n_idp, n_ide);
    }
    else
    {
      {
        for (i = 0; i <= (200 - 1); i++)
        {
          if ((tabela_id[n_ide][i][0] == n_idp) && (tabela_id[n_ide][i][1] != 0))
          {
            {
              tabP[n_idp].qtd += tabela_id[n_ide][i][1];
              tabE[n_ide].pesoTotal -= tabP[tabela_id[n_ide][i][0]].peso * tabela_id[n_ide][i][1];
              tabela_id[n_ide][i][0] = 0;
              tabela_id[n_ide][i][1] = 0;
              return;
            }
          }
          else
          {
            
          }

        }

      }
    }

  }

  return;
}

void custo()
{
  int n_ide;
  int i;
  int custo = 0;
  n_ide = new_sym_var(sizeof(int) * 8);
  if (tabE[n_ide].estado == 1)
  {
    {
      for (i = 0; i <= (200 - 1); i++)
      {
        if ((tabela_id[n_ide][i][0] == 0) && (tabela_id[n_ide][i][1] == 0))
        {
          {
            continue;
          }
        }
        else
        {
          {
            custo += tabP[tabela_id[n_ide][i][0]].preco * tabela_id[n_ide][i][1];
          }
        }

      }

      printf("Custo da encomenda %d %d.\n", n_ide, custo);
    }
  }
  else
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", n_ide);
    }
  }

  return;
}

void muda_preco()
{
  int n_idp;
  int preco;
  int i;
  n_idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  for (i = 0; i <= (10000 - 1); i++)
  {
    if (tabP[i].idp == n_idp)
    {
      {
        tabP[n_idp].preco = preco;
        return;
      }
    }
    else
    {
      
    }

  }

  printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", n_idp);
  return;
}

void lista_E()
{
  int n_ide;
  int n_idp;
  int i;
  n_ide = new_sym_var(sizeof(int) * 8);
  n_idp = new_sym_var(sizeof(int) * 8);
  if (n_idp > (idp - 1))
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", n_idp);
  }
  else
  {
    if (tabE[n_ide].estado != 1)
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", n_ide);
    }
    else
    {
      {
        for (i = 0; i <= (200 - 1); i++)
        {
          if ((tabela_id[n_ide][i][0] == n_idp) && (tabela_id[n_ide][i][1] != 0))
          {
            {
              printf("%s %d.\n", tabP[n_idp].descricao, tabela_id[n_ide][i][1]);
              return;
            }
          }
          else
          {
            
          }

        }

        printf("%s %d.\n", tabP[n_idp].descricao, 0);
      }
    }

  }

  return;
}

void maximo_produto()
{
  int n_idp;
  int i;
  int p;
  int maximo_qtd1 = 0;
  int maximo_qtd2 = 0;
  int maximo_ide;
  n_idp = new_sym_var(sizeof(int) * 8);
  if (n_idp > (idp - 1))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", n_idp);
  }
  else
  {
    {
      for (i = 0; (i <= (500 - 1)) && (tabE[i].estado == 1); i++)
      {
        for (p = 0; p <= (200 - 1); p++)
        {
          if ((tabela_id[i][p][0] == n_idp) && (tabela_id[i][p][1] != 0))
          {
            {
              maximo_qtd1 = tabela_id[i][p][1];
              if (maximo_qtd1 > maximo_qtd2)
              {
                {
                  maximo_qtd2 = maximo_qtd1;
                  maximo_ide = i;
                  break;
                }
              }
              else
              {
                
              }

            }
          }
          else
          {
            
          }

        }

      }

      if (maximo_qtd1 != 0)
      {
        printf("Maximo produto %d %d %d.\n", n_idp, maximo_ide, maximo_qtd2);
      }
      else
      {
        
      }

    }
  }

  return;
}

void quicksort_L(char a[][63], int b[], int left, int right)
{
  int i;
  int j;
  int troca1;
  int pivot;
  char troca2[63];
  if (left < right)
  {
    {
      pivot = left;
      i = left;
      j = right;
      while (i < j)
      {
        while ((strcmp(a[i], a[pivot]) <= 0) && (i < right))
          i++;

        while (strcmp(a[j], a[pivot]) > 0)
          j--;

        if (i < j)
        {
          {
            troca1 = b[i];
            b[i] = b[j];
            b[j] = troca1;
            strcpy(troca2, a[i]);
            strcpy(a[i], a[j]);
            strcpy(a[j], troca2);
          }
        }
        else
        {
          
        }

      }

      troca1 = b[pivot];
      b[pivot] = b[j];
      b[j] = troca1;
      strcpy(troca2, a[pivot]);
      strcpy(a[pivot], a[j]);
      strcpy(a[j], troca2);
      quicksort_L(a, b, left, j - 1);
      quicksort_L(a, b, j + 1, right);
    }
  }
  else
  {
    
  }

  return;
}

void sort_L()
{
  int n_ide;
  int i;
  int m = 0;
  int count = 0;
  int p = 0;
  int tabP_ids[200] = {0};
  char tabP_desc[200][63] = {0};
  n_ide = new_sym_var(sizeof(int) * 8);
  if (tabE[n_ide].estado == 1)
  {
    {
      for (i = 0; i <= (200 - 1); i++)
      {
        if ((tabela_id[n_ide][i][0] == 0) && (tabela_id[n_ide][i][1] == 0))
        {
          {
            continue;
          }
        }
        else
        {
          {
            count += 1;
            tabP_ids[m] = tabela_id[n_ide][i][0];
            strcpy(&tabP_desc[m][0], tabP[tabela_id[n_ide][i][0]].descricao);
            m++;
          }
        }

      }

      if (count == 0)
      {
        {
          printf("Encomenda %d\n", n_ide);
          return;
        }
      }
      else
      {
        
      }

      quicksort_L(tabP_desc, tabP_ids, 0, count - 1);
      printf("Encomenda %d\n", n_ide);
      for (p = 0; p <= (count - 1); p++)
      {
        for (i = 200 - 1; i >= 0; i--)
        {
          if ((tabela_id[n_ide][i][0] == tabP_ids[p]) && (tabela_id[n_ide][i][1] != 0))
          {
            {
              printf("* %s %d %d\n", tabP[tabP_ids[p]].descricao, tabP[tabP_ids[p]].preco, tabela_id[n_ide][i][1]);
            }
          }
          else
          {
            
          }

        }

      }

      return;
    }
  }
  else
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", n_ide);
      return;
    }
  }

}

void quicksort_l(int a[], int b[], int left, int right)
{
  int i;
  int j;
  int troca1;
  int troca2;
  int pivot;
  if (left < right)
  {
    {
      pivot = left;
      i = left;
      j = right;
      while (i < j)
      {
        while ((a[i] <= a[pivot]) && (i < right))
          i++;

        while (a[j] > a[pivot])
          j--;

        if (i < j)
        {
          {
            troca1 = b[i];
            b[i] = b[j];
            b[j] = troca1;
            troca2 = a[i];
            a[i] = a[j];
            a[j] = troca2;
          }
        }
        else
        {
          
        }

      }

      troca1 = b[pivot];
      b[pivot] = b[j];
      b[j] = troca1;
      troca2 = a[pivot];
      a[pivot] = a[j];
      a[j] = troca2;
      quicksort_l(a, b, left, j - 1);
      quicksort_l(a, b, j + 1, right);
    }
  }
  else
  {
    
  }

  return;
}

void sort_l()
{
  int tabP_ids[10000] = {0};
  int tabP_precos[10000] = {0};
  int i;
  int igual = 0;
  int primeiro;
  for (i = 0; i <= (idp - 1); i++)
  {
    tabP_ids[i] = i;
    tabP_precos[i] = tabP[i].preco;
  }

  quicksort_l(tabP_precos, tabP_ids, 0, idp - 1);
  if ((idp - 1) > 1)
  {
    {
      for (i = 1; i <= (idp - 1); i++)
      {
        if (tabP_precos[i] == tabP_precos[i - 1])
        {
          {
            if (igual == 0)
            {
              {
                primeiro = i - 1;
                igual = 1;
              }
            }
            else
            {
              
            }

          }
        }
        else
        {
          if (igual == 1)
          {
            {
              igual = 0;
              quicksort_l(tabP_ids, tabP_precos, primeiro, i - 1);
            }
          }
          else
          {
            
          }

        }

      }

      if ((igual == 1) && (tabP_precos[idp - 1] == tabP_precos[idp - 2]))
      {
        {
          igual = 0;
          quicksort_l(tabP_ids, tabP_precos, primeiro, idp - 1);
        }
      }
      else
      {
        if (igual == 1)
        {
          {
            igual = 0;
            quicksort_l(tabP_ids, tabP_precos, primeiro, idp - 2);
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    
  }

  printf("Produtos\n");
  for (i = 0; i <= (idp - 1); i++)
  {
    printf("* %s %d %d\n", tabP[tabP_ids[i]].descricao, tabP[tabP_ids[i]].preco, tabP[tabP_ids[i]].qtd);
  }

  return;
}

int main()
{
  char c = '\0';
  while (c != 'x')
  {
    c = getchar();
    switch (c)
    {
      case 'a':
        cria_produto();
        break;

      case 'q':
        add_stock();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        add_produto();
        break;

      case 'r':
        r_stock();
        break;

      case 'R':
        r_produto();
        break;

      case 'C':
        custo();
        break;

      case 'p':
        muda_preco();
        break;

      case 'E':
        lista_E();
        break;

      case 'm':
        maximo_produto();
        break;

      case 'l':
        sort_l();
        break;

      case 'L':
        sort_L();
        break;

    }

  }

  return 0;
}

