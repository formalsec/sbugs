/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include "proj1.h"


Product products[10000];
int price[10000];
int nr_products = 0;
int changed = 0;
Product aux[10000];
Order orders[500];
int nr_orders = 0;
int findProduct(Product *arr, int len, int id)
{
  int i;
  for (i = 0; i < len; i++)
  {
    if (arr[i].id == id)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void readString(char *s)
{
  int count = 0;
  int c;
  c = getchar();
  while ((c = getchar()) != ':')
  {
    s[count] = c;
    count++;
  }

  s[count] = '\0';
}

void printProduct(Product product)
{
  printf("%s ", product.description);
  printf("%d ", price[product.id]);
  printf("%d\n", product.stock);
}

void printProducts()
{
  int i;
  printf("Produtos\n");
  for (i = 0; i < nr_products; i++)
  {
    printf("* ");
    printProduct(products[i]);
  }

}

void printOrder(int order)
{
  int i;
  printf("Encomenda %d\n", order);
  for (i = 0; i < orders[order].nr_products; i++)
  {
    printf("* ");
    printProduct(orders[order].products[i]);
  }

}

void removeFromArray(Product *arr, int len, int position)
{
  int i;
  for (i = position + 1; i < len; i++)
  {
    arr[i - 1] = arr[i];
  }

}

void createProduct(char *d, int prc, int wght, int amount)
{
  strcpy(products[nr_products].description, d);
  products[nr_products].id = nr_products;
  products[nr_products].weight = wght;
  products[nr_products].stock = amount;
  price[nr_products] = prc;
  changed = 1;
  printf("Novo produto %d.\n", nr_products);
  nr_products++;
}

void incrementStock(int id, int amount)
{
  int position = findProduct(products, nr_products, id);
  if (position == (-1))
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
      return;
    }
  }
  else
  {
    
  }

  products[position].stock += amount;
}

void createOrder()
{
  orders[nr_orders].id = nr_orders;
  orders[nr_orders].nr_products = 0;
  orders[nr_orders].weight = 0;
  orders[nr_orders].ordered = 1;
  printf("Nova encomenda %d.\n", nr_orders);
  nr_orders++;
}

void addToOrder(int order, int product, int amount)
{
  int position;
  int productPosition;
  int weightAfter;
  if (order >= nr_orders)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", product, order);
      return;
    }
  }
  else
  {
    
  }

  position = findProduct(products, nr_products, product);
  if (position == (-1))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", product, order);
      return;
    }
  }
  else
  {
    
  }

  if (products[position].stock < amount)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", product, order);
      return;
    }
  }
  else
  {
    
  }

  weightAfter = orders[order].weight + (amount * products[position].weight);
  if (weightAfter > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", product, order);
      return;
    }
  }
  else
  {
    
  }

  productPosition = position;
  position = findProduct(orders[order].products, orders[order].nr_products, product);
  if (position == (-1))
  {
    {
      position = orders[order].nr_products++;
      orders[order].products[position].id = products[productPosition].id;
      orders[order].products[position].weight = products[productPosition].weight;
      orders[order].products[position].stock = 0;
      orders[order].ordered = 0;
      strcpy(orders[order].products[position].description, products[productPosition].description);
    }
  }
  else
  {
    
  }

  orders[order].products[position].stock += amount;
  orders[order].weight = weightAfter;
  products[productPosition].stock -= amount;
}

void removeStock(int product, int amount)
{
  int position;
  position = findProduct(products, nr_products, product);
  if (position != (-1))
  {
    {
      if (products[position].stock >= amount)
      {
        {
          products[position].stock -= amount;
        }
      }
      else
      {
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", amount, product);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", product);
    }
  }

}

void removeProductFromOrder(int order, int product)
{
  int position;
  if (order < nr_orders)
  {
    {
      position = findProduct(products, nr_products, product);
      if (position == (-1))
      {
        {
          printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", product, order);
        }
      }
      else
      {
        {
          position = findProduct(orders[order].products, orders[order].nr_products, product);
          if (position != (-1))
          {
            {
              incrementStock(product, orders[order].products[position].stock);
              orders[order].weight -= orders[order].products[position].stock * orders[order].products[position].weight;
              removeFromArray(orders[order].products, orders[order].nr_products, position);
              orders[order].nr_products--;
            }
          }
          else
          {
            
          }

        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", product, order);
    }
  }

}

void calcOrderCost(int order)
{
  int i;
  int sum = 0;
  if (order < nr_orders)
  {
    {
      for (i = 0; i < orders[order].nr_products; i++)
      {
        sum += orders[order].products[i].stock * price[orders[order].products[i].id];
      }

      printf("Custo da encomenda %d %d.\n", order, sum);
    }
  }
  else
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", order);
    }
  }

}

void changeProductPrice(int product, int newPrice)
{
  if (product < nr_products)
  {
    {
      price[product] = newPrice;
      changed = 1;
    }
  }
  else
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", product);
    }
  }

}

void infoProductInOrder(int order, int product)
{
  int position;
  if (order < nr_orders)
  {
    {
      position = findProduct(products, nr_products, product);
      if (position != (-1))
      {
        {
          printf("%s ", products[position].description);
          position = findProduct(orders[order].products, orders[order].nr_products, product);
          if (position != (-1))
          {
            {
              printf("%d.\n", orders[order].products[position].stock);
            }
          }
          else
          {
            {
              printf("0.\n");
            }
          }

        }
      }
      else
      {
        {
          printf("Impossivel listar produto %d. Produto inexistente.\n", product);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order);
    }
  }

}

void mostCommissioningOrder(int product)
{
  int i;
  int position;
  int max;
  int commissioned = -1;
  position = findProduct(products, nr_products, product);
  if (position == (-1))
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", product);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < nr_orders; i++)
  {
    position = findProduct(orders[i].products, orders[i].nr_products, product);
    if (position != (-1))
    {
      {
        if (orders[i].products[position].stock > commissioned)
        {
          {
            commissioned = orders[i].products[position].stock;
            max = i;
          }
        }
        else
        {
          
        }

      }
    }
    else
    {
      
    }

  }

  if (commissioned >= 0)
  {
    {
      printf("Maximo produto %d %d %d.\n", product, max, commissioned);
    }
  }
  else
  {
    
  }

}

int lowerPrice(const Product a, const Product b)
{
  if (price[a.id] == price[b.id])
  {
    return a.id < b.id;
  }
  else
  {
    
  }

  return price[a.id] < price[b.id];
}

int lowerName(const Product a, const Product b)
{
  int i = 0;
  int j = 0;
  while ((a.description[i] != '0') && (b.description[j] != '0'))
  {
    if (a.description[i] == ' ')
    {
      {
        i++;
      }
    }
    else
    {
      
    }

    if (b.description[j] == ' ')
    {
      {
        j++;
      }
    }
    else
    {
      
    }

    if (a.description[i] == b.description[j])
    {
      {
        i++;
        j++;
      }
    }
    else
    {
      {
        return a.description[i] < b.description[j];
      }
    }

  }

  return 0;
}

void merge(Product arr[], int left, int m, int right, int (*less)(const Product a, const Product b))
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = arr[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = arr[j + 1];

  for (k = left; k <= right; k++)
  {
    if (less(aux[j], aux[i]) || (i > m))
    {
      arr[k] = aux[j--];
    }
    else
    {
      arr[k] = aux[i++];
    }

  }

}

void mergeSort(Product arr[], int l, int r, int (*less)(const Product a, const Product b))
{
  int m;
  if (l < r)
  {
    {
      m = l + ((r - l) / 2);
      mergeSort(arr, l, m, less);
      mergeSort(arr, m + 1, r, less);
      merge(arr, l, m, r, less);
    }
  }
  else
  {
    
  }

}

void listProductsByPrice()
{
  if (changed)
  {
    {
      mergeSort(products, 0, nr_products - 1, lowerPrice);
      changed = 0;
    }
  }
  else
  {
    
  }

  printProducts();
}

void listOrderedProductsByName(int order)
{
  if (order >= nr_orders)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order);
      return;
    }
  }
  else
  {
    
  }

  if (!orders[order].ordered)
  {
    {
      mergeSort(orders[order].products, 0, orders[order].nr_products - 1, lowerName);
      orders[order].ordered = 1;
    }
  }
  else
  {
    
  }

  printOrder(order);
}

int main()
{
  int c;
  int id_prod;
  int id_ord;
  int prc;
  int wght;
  int qty;
  char s[64];
  while (1)
  {
    c = getchar();
    switch (c)
    {
      case 'a':
        readString(s);
        prc = new_sym_var(sizeof(int) * 8);
        wght = new_sym_var(sizeof(int) * 8);
        qty = new_sym_var(sizeof(int) * 8);
        createProduct(s, prc, wght, qty);
        break;

      case 'q':
        id_prod = new_sym_var(sizeof(int) * 8);
        qty = new_sym_var(sizeof(int) * 8);
        incrementStock(id_prod, qty);
        break;

      case 'N':
        createOrder();
        break;

      case 'A':
        id_ord = new_sym_var(sizeof(int) * 8);
        id_prod = new_sym_var(sizeof(int) * 8);
        qty = new_sym_var(sizeof(int) * 8);
        addToOrder(id_ord, id_prod, qty);
        break;

      case 'r':
        id_prod = new_sym_var(sizeof(int) * 8);
        qty = new_sym_var(sizeof(int) * 8);
        removeStock(id_prod, qty);
        break;

      case 'R':
        id_ord = new_sym_var(sizeof(int) * 8);
        id_prod = new_sym_var(sizeof(int) * 8);
        removeProductFromOrder(id_ord, id_prod);
        break;

      case 'C':
        id_ord = new_sym_var(sizeof(int) * 8);
        calcOrderCost(id_ord);
        break;

      case 'p':
        id_prod = new_sym_var(sizeof(int) * 8);
        prc = new_sym_var(sizeof(int) * 8);
        changeProductPrice(id_prod, prc);
        break;

      case 'E':
        id_ord = new_sym_var(sizeof(int) * 8);
        id_prod = new_sym_var(sizeof(int) * 8);
        infoProductInOrder(id_ord, id_prod);
        break;

      case 'm':
        id_prod = new_sym_var(sizeof(int) * 8);
        mostCommissioningOrder(id_prod);
        break;

      case 'l':
        listProductsByPrice();
        break;

      case 'L':
        id_ord = new_sym_var(sizeof(int) * 8);
        listOrderedProductsByName(id_ord);
        break;

      case 'x':
        return 0;

    }

  }

}

