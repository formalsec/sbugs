/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  char descricao[63];
  int preco;
  int peso;
  int qtd;
} produto;
typedef struct 
{
  produto prods[200];
  produto sprods[200];
  int peso;
  int loc;
} encomenda;
void exch(produto array[], int ind1, int ind2)
{
  produto save = array[ind1];
  array[ind1] = array[ind2];
  array[ind2] = save;
}

produto aux[10000] = {0};
void merge(produto a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
    if ((aux[j].preco < aux[i].preco) || (i > m))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

void merges(produto a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
    if ((strcmp(aux[j].descricao, aux[i].descricao) < 0) || (i > m))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

void mergesort(produto a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, left, m);
  mergesort(a, m + 1, right);
  merge(a, left, m, right);
}

void mergesorts(produto a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, left, m);
  mergesort(a, m + 1, right);
  merges(a, left, m, right);
}

int search(produto con[], char descricao[])
{
  int i;
  for (i = 0; i < 200; i++)
  {
    if (strcmp(con[i].descricao, descricao) == 0)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void a(produto lis[], int idp)
{
  char descricao[63] = {0};
  int preco;
  int peso;
  int qtd;
  for (int descricao_index = 0; descricao_index < 10; descricao_index++)
  {
    descricao[descricao_index] = new_sym_var(sizeof(char) * 8);
  }

  descricao[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  strcpy(lis[idp].descricao, descricao);
  lis[idp].peso = peso;
  lis[idp].preco = preco;
  lis[idp].qtd = qtd;
  printf("Novo produto %d.\n", idp);
}

void q(produto lis[], int maxidp)
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= maxidp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    lis[idp].qtd = lis[idp].qtd + qtd;
  }

}

void N(encomenda tab[], int ide)
{
  tab[ide].loc = 0;
  printf("Nova encomenda %d.\n", ide);
}

void A(int maxide, int maxidp, produto lis[], encomenda tab[])
{
  int ide;
  int idp;
  int qtd;
  int ind;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (maxide <= ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (maxidp <= idp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (lis[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((tab[ide].peso + (qtd * lis[idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          {
            ind = search(tab[ide].prods, lis[idp].descricao);
            if (ind < 0)
            {
              {
                tab[ide].prods[tab[ide].loc] = lis[idp];
                tab[ide].prods[tab[ide].loc].qtd = qtd;
                tab[ide].loc = tab[ide].loc + 1;
                tab[ide].peso = tab[ide].peso + (qtd * lis[idp].peso);
                lis[idp].qtd = lis[idp].qtd - qtd;
              }
            }
            else
            {
              {
                tab[ide].prods[ind].qtd = tab[ide].prods[ind].qtd + qtd;
                tab[ide].peso = tab[ide].peso + (qtd * tab[ide].prods[ind].peso);
                lis[idp].qtd = lis[idp].qtd - qtd;
              }
            }

          }
        }

      }

    }

  }

}

void r(int maxidp, produto lis[])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (maxidp <= idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (lis[idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      lis[idp].qtd = lis[idp].qtd - qtd;
    }

  }

}

void R(int maxide, int maxidp, produto lis[], encomenda tab[])
{
  int ide;
  int idp;
  int ind;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (maxide <= ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (maxidp <= idp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      {
        ind = search(tab[ide].prods, lis[idp].descricao);
        if (ind >= 0)
        {
          {
            lis[idp].qtd = lis[idp].qtd + tab[ide].prods[ind].qtd;
            tab[ide].peso = tab[ide].peso - (tab[ide].prods[ind].peso * tab[ide].prods[ind].qtd);
            tab[ide].prods[ind].qtd = 0;
          }
        }
        else
        {
          
        }

      }
    }

  }

}

void C(int maxide, encomenda tab[])
{
  int ide;
  int i;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (maxide <= ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (i = 0; i < tab[ide].loc; i++)
        total += tab[ide].prods[i].qtd * tab[ide].prods[i].preco;

      printf("Custo da encomenda %d %d.\n", ide, total);
    }
  }

}

void p(int maxide, int maxidp, produto lis[], encomenda tab[])
{
  int idp;
  int preco;
  int ind;
  int i;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= maxidp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      lis[idp].preco = preco;
      for (i = 0; i < maxide; i++)
      {
        ind = search(tab[i].prods, lis[idp].descricao);
        if (ind >= 0)
        {
          tab[i].prods[ind].preco = preco;
        }
        else
        {
          
        }

      }

    }
  }

}

void E(int maxide, int maxidp, produto lis[], encomenda tab[])
{
  int ide;
  int idp;
  int ind;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (maxide <= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (maxidp <= idp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      {
        ind = search(tab[ide].prods, lis[idp].descricao);
        if (ind >= 0)
        {
          printf("%s %d.\n", lis[idp].descricao, tab[ide].prods[ind].qtd);
        }
        else
        {
          printf("%s %d.\n", lis[idp].descricao, 0);
        }

      }
    }

  }

}

void m(int maxide, int maxidp, produto lis[], encomenda tab[])
{
  int idp;
  int i;
  int ide;
  int ind;
  int qtd = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= maxidp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      for (i = 0; i < maxide; i++)
      {
        ind = search(tab[i].prods, lis[idp].descricao);
        if (ind >= 0)
        {
          {
            if (tab[i].prods[ind].qtd > qtd)
            {
              {
                qtd = tab[i].prods[ind].qtd;
                ide = i;
              }
            }
            else
            {
              
            }

          }
        }
        else
        {
          
        }

      }

      if (qtd != 0)
      {
        printf("Maximo produto %d %d %d.\n", idp, ide, qtd);
      }
      else
      {
        
      }

    }
  }

}

void l(produto sortlis[], produto lis[], int maxidp)
{
  int i;
  for (i = 0; i < maxidp; i++)
    sortlis[i] = lis[i];

  mergesort(sortlis, 0, maxidp - 1);
  printf("Produtos\n");
  for (i = 0; i < maxidp; i++)
    printf("* %s %d %d\n", sortlis[i].descricao, sortlis[i].preco, sortlis[i].qtd);

}

void L(produto sortlis[], encomenda tab[], int maxide)
{
  int ide;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= maxide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (i = 0; i < tab[ide].loc; i++)
        sortlis[i] = tab[ide].prods[i];

      mergesorts(sortlis, 0, tab[ide].loc - 1);
      printf("Encomenda %d\n", ide);
      for (i = 0; i < tab[ide].loc; i++)
      {
        if (sortlis[i].qtd != 0)
        {
          printf("* %s %d %d\n", sortlis[i].descricao, sortlis[i].preco, sortlis[i].qtd);
        }
        else
        {
          
        }

      }

    }
  }

}

produto lp[10000] = {0};
produto sortlp[10000] = {0};
encomenda le[500] = {0};
int main()
{
  int ch;
  int midp;
  int mide;
  midp = (mide = 0);
  while (((ch = getchar()) != EOF) && (ch != 'x'))
  {
    if (ch == 'a')
    {
      {
        a(lp, midp);
        midp++;
      }
    }
    else
    {
      if (ch == 'q')
      {
        q(lp, midp);
      }
      else
      {
        if (ch == 'N')
        {
          {
            N(le, mide);
            mide++;
          }
        }
        else
        {
          if (ch == 'A')
          {
            {
              A(mide, midp, lp, le);
            }
          }
          else
          {
            if (ch == 'r')
            {
              r(midp, lp);
            }
            else
            {
              if (ch == 'R')
              {
                R(mide, midp, lp, le);
              }
              else
              {
                if (ch == 'C')
                {
                  C(mide, le);
                }
                else
                {
                  if (ch == 'p')
                  {
                    p(mide, midp, lp, le);
                  }
                  else
                  {
                    if (ch == 'E')
                    {
                      E(mide, midp, lp, le);
                    }
                    else
                    {
                      if (ch == 'm')
                      {
                        m(mide, midp, lp, le);
                      }
                      else
                      {
                        if (ch == 'l')
                        {
                          l(sortlp, lp, midp);
                        }
                        else
                        {
                          if (ch == 'L')
                          {
                            L(sortlp, le, mide);
                          }
                          else
                          {
                            
                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return 0;
}

