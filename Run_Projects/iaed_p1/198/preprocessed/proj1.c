/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct producto
{
  long int idp;
  char descricao[64];
  long int preco;
  long int peso;
  long int qtd;
} produto;
typedef struct enc
{
  long int ide;
  long int id[200];
  long int quant[200];
  long int indice;
} encomenda;
void funcao_a(produto [], long int []);
void funcao_q(produto [], long int []);
void funcao_N(long int [], encomenda []);
void funcao_A(encomenda [], produto [], long int [], long int []);
void funcao_r(long int [], produto []);
void funcao_R(encomenda [], produto [], long int [], long int []);
void funcao_C(encomenda [], produto [], long int []);
void funcao_p(long int [], produto []);
void funcao_E(encomenda [], produto [], long int [], long int []);
void funcao_m(encomenda [], long int [], long int []);
void funcao_l(produto [], long int []);
void funcao_L(produto [], encomenda [], long int []);
int aux_exist_prod(long int, long int []);
int aux_exist_enc(long int [], long int);
int aux_exist_stock(produto [], long int, long int);
long int aux_peso_enc(produto [], encomenda [], long int);
void selectionsort1(produto [], long int [], long int);
void selectionsort2(produto [], long int [], long int [], long int);
int main()
{
  char c[2];
  produto sistema[10000];
  encomenda encom[500];
  long int sistema_ocup[10000];
  long int encomendas_ocup[500];
  c[1] = '\0';
  c[0] = new_sym_var(sizeof(char) * 8);
  while (c[0] != EOF)
  {
    switch (c[0])
    {
      case 'a':
        funcao_a(sistema, sistema_ocup);
        break;

      case 'q':
        funcao_q(sistema, sistema_ocup);
        break;

      case 'N':
        funcao_N(encomendas_ocup, encom);
        break;

      case 'A':
        funcao_A(encom, sistema, encomendas_ocup, sistema_ocup);
        break;

      case 'r':
        funcao_r(sistema_ocup, sistema);
        break;

      case 'R':
        funcao_R(encom, sistema, sistema_ocup, encomendas_ocup);
        break;

      case 'C':
        funcao_C(encom, sistema, encomendas_ocup);
        break;

      case 'p':
        funcao_p(sistema_ocup, sistema);
        break;

      case 'E':
        funcao_E(encom, sistema, encomendas_ocup, sistema_ocup);
        break;

      case 'm':
        funcao_m(encom, sistema_ocup, encomendas_ocup);
        break;

      case 'l':
        funcao_l(sistema, sistema_ocup);
        break;

      case 'L':
        funcao_L(sistema, encom, encomendas_ocup);
        break;

      case 'x':
        exit(0);

    }

    c[0] = new_sym_var(sizeof(char) * 8);
  }

  return 0;
}

void funcao_a(produto sist[10000], long int ocupados[10000])
{
  char nome[64];
  long int prc;
  long int pes;
  long int quant;
  static long int ind = 0;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  prc = new_sym_var(sizeof(long int) * 8);
  pes = new_sym_var(sizeof(long int) * 8);
  quant = new_sym_var(sizeof(long int) * 8);
  sist[ind].idp = ind;
  strcpy(sist[ind].descricao, nome);
  sist[ind].preco = prc;
  sist[ind].peso = pes;
  sist[ind].qtd = quant;
  ocupados[ind] = 1;
  printf("Novo produto %ld.\n", ind);
  ++ind;
}

void funcao_q(produto sist[10000], long int ocupados[10000])
{
  long int quant;
  long int iprd;
  iprd = new_sym_var(sizeof(long int) * 8);
  quant = new_sym_var(sizeof(long int) * 8);
  if (ocupados[iprd] != 0)
  {
    sist[iprd].qtd += quant;
  }
  else
  {
    printf("Impossivel adicionar produto %ld ao stock. Produto inexistente.\n", iprd);
  }

}

void funcao_N(long int vetor_encomendas[500], encomenda conj_enc[500])
{
  static long int enc_n = 0;
  long int i;
  printf("Nova encomenda %ld.\n", enc_n);
  conj_enc[enc_n].indice = 0;
  conj_enc[enc_n].ide = enc_n;
  vetor_encomendas[enc_n] = 1;
  for (i = 0; i < 200; i++)
  {
    conj_enc[enc_n].id[i] = -1;
    conj_enc[enc_n].quant[i] = -1;
  }

  enc_n++;
}

void funcao_A(encomenda conj_enc[500], produto sist[10000], long int encs_exist[500], long int prods_exist[10000])
{
  long int iprd;
  long int ienc;
  long int quantd;
  ienc = new_sym_var(sizeof(long int) * 8);
  iprd = new_sym_var(sizeof(long int) * 8);
  quantd = new_sym_var(sizeof(long int) * 8);
  if (aux_exist_enc(encs_exist, ienc) == 0)
  {
    printf("Impossivel adicionar produto %ld a encomenda %ld. Encomenda inexistente.\n", iprd, ienc);
  }
  else
  {
    if (aux_exist_prod(iprd, prods_exist) == 0)
    {
      printf("Impossivel adicionar produto %ld a encomenda %ld. Produto inexistente.\n", iprd, ienc);
    }
    else
    {
      if (aux_exist_stock(sist, iprd, quantd) == 0)
      {
        printf("Impossivel adicionar produto %ld a encomenda %ld. Quantidade em stock insuficiente.\n", iprd, ienc);
      }
      else
      {
        if ((aux_peso_enc(sist, conj_enc, ienc) + (quantd * sist[iprd].peso)) > 200)
        {
          printf("Impossivel adicionar produto %ld a encomenda %ld. Peso da encomenda excede o maximo de 200.\n", iprd, ienc);
        }
        else
        {
          {
            int i;
            int estado;
            long int ind;
            estado = 0;
            i = 0;
            ind = conj_enc[ienc].indice;
            sist[iprd].qtd -= quantd;
            for (i = 0; i < ind; i++)
            {
              if (conj_enc[ienc].id[i] == iprd)
              {
                {
                  estado = 1;
                  conj_enc[ienc].quant[i] += quantd;
                }
              }
              else
              {
                
              }

            }

            if (estado == 0)
            {
              {
                conj_enc[ienc].id[ind] = iprd;
                conj_enc[ienc].quant[ind] = quantd;
                ++conj_enc[ienc].indice;
              }
            }
            else
            {
              
            }

          }
        }

      }

    }

  }

}

void funcao_r(long int ocupados[10000], produto sist[10000])
{
  long int iprd;
  long int quant;
  iprd = new_sym_var(sizeof(long int) * 8);
  quant = new_sym_var(sizeof(long int) * 8);
  if (ocupados[iprd] == 0)
  {
    printf("Impossivel remover stock do produto %ld. Produto inexistente.\n", iprd);
  }
  else
  {
    if ((sist[iprd].qtd - quant) < 0)
    {
      printf("Impossivel remover %ld unidades do produto %ld do stock. Quantidade insuficiente.\n", quant, iprd);
    }
    else
    {
      sist[iprd].qtd -= quant;
    }

  }

}

void funcao_R(encomenda conj_enc[500], produto sist[10000], long int prods_exist[10000], long int encs_exist[500])
{
  long int ienc;
  long int iprd;
  ienc = new_sym_var(sizeof(long int) * 8);
  iprd = new_sym_var(sizeof(long int) * 8);
  if (aux_exist_enc(encs_exist, ienc) == 0)
  {
    printf("Impossivel remover produto %ld a encomenda %ld. Encomenda inexistente.\n", iprd, ienc);
  }
  else
  {
    if (aux_exist_prod(iprd, prods_exist) == 0)
    {
      printf("Impossivel remover produto %ld a encomenda %ld. Produto inexistente.\n", iprd, ienc);
    }
    else
    {
      {
        long int ini;
        long int i_prod_enc;
        long int ind_p;
        long int a;
        long int estado;
        ind_p = conj_enc[ienc].indice;
        estado = 0;
        for (i_prod_enc = 0; i_prod_enc < ind_p; i_prod_enc++)
        {
          if (conj_enc[ienc].id[i_prod_enc] == iprd)
          {
            {
              a = i_prod_enc;
              estado = 1;
              sist[iprd].qtd += conj_enc[ienc].quant[i_prod_enc];
            }
          }
          else
          {
            
          }

        }

        if (estado == 1)
        {
          {
            for (ini = a; ini < (ind_p - 1); ini++)
            {
              conj_enc[ienc].id[ini] = conj_enc[ienc].id[ini + 1];
              conj_enc[ienc].quant[ini] = conj_enc[ienc].quant[ini + 1];
            }

            --conj_enc[ienc].indice;
          }
        }
        else
        {
          
        }

      }
    }

  }

}

void funcao_C(encomenda conj_enc[500], produto sist[10000], long int encs_exist[500])
{
  long int ienc;
  ienc = new_sym_var(sizeof(long int) * 8);
  if (aux_exist_enc(encs_exist, ienc) == 0)
  {
    printf("Impossivel calcular custo da encomenda %ld. Encomenda inexistente.\n", ienc);
  }
  else
  {
    {
      int i_prd_enc;
      int ind_p;
      int preco_t;
      long int idprd;
      preco_t = 0;
      ind_p = conj_enc[ienc].indice;
      for (i_prd_enc = 0; i_prd_enc < ind_p; i_prd_enc++)
      {
        idprd = conj_enc[ienc].id[i_prd_enc];
        preco_t += conj_enc[ienc].quant[i_prd_enc] * sist[idprd].preco;
      }

      printf("Custo da encomenda %ld %d.\n", ienc, preco_t);
    }
  }

}

void funcao_p(long int ocupados[10000], produto sist[10000])
{
  long int iprd;
  long int prc;
  iprd = new_sym_var(sizeof(long int) * 8);
  prc = new_sym_var(sizeof(long int) * 8);
  if (ocupados[iprd] == 0)
  {
    printf("Impossivel alterar preco do produto %ld. Produto inexistente.\n", iprd);
  }
  else
  {
    sist[iprd].preco = prc;
  }

}

void funcao_E(encomenda conj_enc[500], produto sist[10000], long int encs_exist[500], long int prods_exist[10000])
{
  long int ienc;
  long int iprd;
  ienc = new_sym_var(sizeof(long int) * 8);
  iprd = new_sym_var(sizeof(long int) * 8);
  if (aux_exist_enc(encs_exist, ienc) == 0)
  {
    printf("Impossivel listar encomenda %ld. Encomenda inexistente.\n", ienc);
  }
  else
  {
    if (aux_exist_prod(iprd, prods_exist) == 0)
    {
      printf("Impossivel listar produto %ld. Produto inexistente.\n", iprd);
    }
    else
    {
      {
        long int quantd;
        long int estado;
        int i_prd_enc;
        int ind_p;
        estado = 0;
        ind_p = conj_enc[ienc].indice;
        for (i_prd_enc = 0; (i_prd_enc < ind_p) && (estado == 0); i_prd_enc++)
        {
          if (conj_enc[ienc].id[i_prd_enc] == iprd)
          {
            {
              estado = 1;
              quantd = conj_enc[ienc].quant[i_prd_enc];
              printf("%s %ld.\n", sist[iprd].descricao, quantd);
            }
          }
          else
          {
            
          }

        }

        if (estado == 0)
        {
          printf("%s %d.\n", sist[iprd].descricao, 0);
        }
        else
        {
          
        }

      }
    }

  }

}

void funcao_m(encomenda conj_enc[500], long int prods_exist[10000], long int encs_exist[500])
{
  long int iprd;
  iprd = new_sym_var(sizeof(long int) * 8);
  if (aux_exist_prod(iprd, prods_exist) == 0)
  {
    printf("Impossivel listar maximo do produto %ld. Produto inexistente.\n", iprd);
  }
  else
  {
    {
      long int res_enc;
      long int quantd;
      long int id_enc;
      long int i_prod_enc;
      long int ind_p;
      res_enc = 0;
      quantd = -1;
      for (id_enc = 0; encs_exist[id_enc] != 0; id_enc++)
      {
        ind_p = conj_enc[id_enc].indice;
        for (i_prod_enc = 0; i_prod_enc < ind_p; i_prod_enc++)
        {
          if ((conj_enc[id_enc].id[i_prod_enc] == iprd) && (conj_enc[id_enc].quant[i_prod_enc] > quantd))
          {
            {
              quantd = conj_enc[id_enc].quant[i_prod_enc];
              res_enc = id_enc;
            }
          }
          else
          {
            
          }

        }

      }

      if (quantd != (-1))
      {
        printf("Maximo produto %ld %ld %ld.\n", iprd, res_enc, quantd);
      }
      else
      {
        
      }

    }
  }

}

void funcao_l(produto sist[10000], long int prods_exist[10000])
{
  long int contador;
  long int i;
  long int aux[10000];
  contador = 0;
  for (i = 0; prods_exist[i] != 0; i++)
  {
    ++contador;
    aux[i] = sist[i].idp;
  }

  selectionsort1(sist, aux, contador);
  printf("Produtos\n");
  for (i = 0; i < contador; i++)
  {
    printf("* %s %ld %ld\n", sist[aux[i]].descricao, sist[aux[i]].preco, sist[aux[i]].qtd);
  }

}

void funcao_L(produto sist[10000], encomenda conj_enc[500], long int encs_exist[500])
{
  long int ienc;
  ienc = new_sym_var(sizeof(long int) * 8);
  if (aux_exist_enc(encs_exist, ienc) == 0)
  {
    printf("Impossivel listar encomenda %ld. Encomenda inexistente.\n", ienc);
  }
  else
  {
    {
      long int iprd;
      long int ind_p;
      long int i;
      long int iprd2;
      long int aux[200];
      long int aux2[200];
      ind_p = conj_enc[ienc].indice;
      for (i = 0; i < ind_p; i++)
      {
        aux[i] = conj_enc[ienc].id[i];
        aux2[i] = i;
      }

      selectionsort2(sist, aux, aux2, ind_p);
      printf("Encomenda %ld\n", ienc);
      for (i = 0; i < ind_p; i++)
      {
        iprd = aux[i];
        iprd2 = aux2[i];
        printf("* %s %ld %ld\n", sist[iprd].descricao, sist[iprd].preco, conj_enc[ienc].quant[iprd2]);
      }

    }
  }

}

int aux_exist_prod(long int indice, long int vetor_prods[10000])
{
  if (vetor_prods[indice] == 0)
  {
    return 0;
  }
  else
  {
    return 1;
  }

}

int aux_exist_enc(long int vetor_encs[500], long int indice)
{
  if (vetor_encs[indice] == 0)
  {
    return 0;
  }
  else
  {
    return 1;
  }

}

int aux_exist_stock(produto sist[10000], long int id_produto, long int quantidade)
{
  if (sist[id_produto].qtd < quantidade)
  {
    return 0;
  }
  else
  {
    return 1;
  }

}

long int aux_peso_enc(produto sist[10000], encomenda conj_enc[500], long int id_enc)
{
  int i_prd_enc;
  int ind_p;
  int peso_t;
  long int idprd;
  peso_t = 0;
  ind_p = conj_enc[id_enc].indice;
  for (i_prd_enc = 0; i_prd_enc < ind_p; i_prd_enc++)
  {
    idprd = conj_enc[id_enc].id[i_prd_enc];
    peso_t += conj_enc[id_enc].quant[i_prd_enc] * sist[idprd].peso;
  }

  return peso_t;
}

void selectionsort1(produto sist[10000], long int vetor_num[], long int right)
{
  long int i;
  long int j;
  long int auxx;
  long int min;
  for (i = 0; i < (right - 1); i++)
  {
    min = i;
    for (j = i + 1; j < right; j++)
    {
      if (sist[vetor_num[j]].preco < sist[vetor_num[min]].preco)
      {
        min = j;
      }
      else
      {
        if ((sist[vetor_num[j]].preco == sist[vetor_num[min]].preco) && (sist[vetor_num[j]].idp < sist[vetor_num[min]].idp))
        {
          min = j;
        }
        else
        {
          
        }

      }

    }

    auxx = vetor_num[i];
    vetor_num[i] = vetor_num[min];
    vetor_num[min] = auxx;
  }

}

void selectionsort2(produto sist[10000], long int vetor_num[], long int vetor_inds[], long int right)
{
  long int i;
  long int j;
  long int auxx;
  long int min;
  long int min2;
  long int auxx2;
  int result;
  for (i = 0; i < (right - 1); i++)
  {
    min = i;
    min2 = i;
    for (j = i + 1; j < right; j++)
    {
      result = strcmp(sist[vetor_num[j]].descricao, sist[vetor_num[min]].descricao);
      if (result < 0)
      {
        {
          min = j;
          min2 = j;
        }
      }
      else
      {
        
      }

    }

    auxx = vetor_num[i];
    auxx2 = vetor_inds[i];
    vetor_num[i] = vetor_num[min];
    vetor_inds[i] = vetor_inds[min2];
    vetor_num[min] = auxx;
    vetor_inds[min2] = auxx2;
  }

}

