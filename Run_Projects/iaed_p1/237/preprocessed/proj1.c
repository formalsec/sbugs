/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  char desc[63];
  int preco;
  int peso;
  int qt_stock;
} produto;
typedef struct encomenda
{
  int carrinho_compras[200][2];
  int peso;
} encomenda;
int idp_atual = 0;
int ide_atual = 0;
int valores[3] = {0, 0, 0};
char descricao_prod[63];
produto produtos[10000];
encomenda encomendas[500];
void add_produto()
{
  int i;
  for (i = 0; descricao_prod[i] != '\0'; i++)
    produtos[idp_atual].desc[i] = descricao_prod[i];

  produtos[idp_atual].desc[i] = '\0';
  produtos[idp_atual].preco = valores[0];
  produtos[idp_atual].peso = valores[1];
  produtos[idp_atual].qt_stock = valores[2];
  printf("Novo produto %d.\n", idp_atual);
  idp_atual++;
}

void add_stock()
{
  int idp = valores[0];
  int qtd = valores[1];
  if ((idp_atual - 1) < idp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].qt_stock += qtd;
  }

}

void new_order()
{
  int i;
  for (i = 0; i < 200; i++)
  {
    encomendas[ide_atual].carrinho_compras[i][0] = -1;
    encomendas[ide_atual].carrinho_compras[i][1] = 0;
  }

  encomendas[ide_atual].peso = 0;
  printf("Nova encomenda %d.\n", ide_atual);
  ide_atual++;
}

void add_prod_to_order()
{
  int ide = valores[0];
  int idp = valores[1];
  int qtd = valores[2];
  if ((ide_atual - 1) < ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if ((idp_atual - 1) < idp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (produtos[idp].qt_stock < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((encomendas[ide].peso + (qtd * produtos[idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          {
            int i;
            for (i = 0; ((encomendas[ide].carrinho_compras[i][0] != idp) && (encomendas[ide].carrinho_compras[i][0] != (-1))) && (encomendas[ide].carrinho_compras[i][0] != (-2)); i++)
              ;

            if (encomendas[ide].carrinho_compras[i][0] == (-2))
            {
              {
                int j;
                for (j = i + 1; (encomendas[ide].carrinho_compras[j][0] != idp) && (encomendas[ide].carrinho_compras[j][0] != (-1)); j++)
                  ;

                if (encomendas[ide].carrinho_compras[j][0] == idp)
                {
                  i = j;
                }
                else
                {
                  
                }

              }
            }
            else
            {
              
            }

            encomendas[ide].carrinho_compras[i][0] = idp;
            encomendas[ide].carrinho_compras[i][1] += qtd;
            encomendas[ide].peso += qtd * produtos[idp].peso;
            produtos[idp].qt_stock -= qtd;
          }
        }

      }

    }

  }

}

void remove_stock()
{
  int idp = valores[0];
  int qtd = valores[1];
  if ((idp_atual - 1) < idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (produtos[idp].qt_stock < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      produtos[idp].qt_stock -= qtd;
    }

  }

}

void remove_prod_from_order()
{
  int ide = valores[0];
  int idp = valores[1];
  if ((ide_atual - 1) < ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if ((idp_atual - 1) < idp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      {
        int i;
        for (i = 0; ((i < 200) && (encomendas[ide].carrinho_compras[i][0] != idp)) && (encomendas[ide].carrinho_compras[i][0] != (-1)); i++)
          ;

        if (encomendas[ide].carrinho_compras[i][0] == idp)
        {
          {
            produtos[idp].qt_stock += encomendas[ide].carrinho_compras[i][1];
            encomendas[ide].carrinho_compras[i][0] = -2;
            encomendas[ide].peso -= encomendas[ide].carrinho_compras[i][1] * produtos[idp].peso;
            encomendas[ide].carrinho_compras[i][1] = 0;
          }
        }
        else
        {
          
        }

      }
    }

  }

}

void oder_cost()
{
  int ide = valores[0];
  if ((ide_atual - 1) < ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      int custo = 0;
      int i;
      for (i = 0; (i < 200) && (encomendas[ide].carrinho_compras[i][0] != (-1)); i++)
      {
        int idp = encomendas[ide].carrinho_compras[i][0];
        if (encomendas[ide].carrinho_compras[i][0] != (-2))
        {
          custo += encomendas[ide].carrinho_compras[i][1] * produtos[idp].preco;
        }
        else
        {
          
        }

      }

      printf("Custo da encomenda %d %d.\n", ide, custo);
    }
  }

}

void change_prod_price()
{
  int idp = valores[0];
  int preco = valores[1];
  if ((idp_atual - 1) < idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].preco = preco;
  }

}

void desc_qtd_prod_from_order()
{
  int ide = valores[0];
  int idp = valores[1];
  if ((ide_atual - 1) < ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if ((idp_atual - 1) < idp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      {
        int i;
        for (i = 0; ((i < 200) && (encomendas[ide].carrinho_compras[i][0] != idp)) && (encomendas[ide].carrinho_compras[i][0] != (-1)); i++)
          ;

        printf("%s %d.\n", produtos[idp].desc, ((i == 200) || (encomendas[ide].carrinho_compras[i][0] == (-1))) ? (0) : (encomendas[ide].carrinho_compras[i][1]));
      }
    }

  }

}

void id_order_most_qtd_prod()
{
  int idp = valores[0];
  if ((idp_atual - 1) < idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      int i;
      int j;
      int res[2] = {0, -1};
      for (i = 0; i < ide_atual; i++)
      {
        for (j = 0; (j < 200) && (encomendas[i].carrinho_compras[j][0] != (-1)); j++)
        {
          if (encomendas[i].carrinho_compras[j][0] == idp)
          {
            {
              if (encomendas[i].carrinho_compras[j][1] > res[1])
              {
                {
                  res[0] = i;
                  res[1] = encomendas[i].carrinho_compras[j][1];
                }
              }
              else
              {
                
              }

              break;
            }
          }
          else
          {
            
          }

        }

      }

      if ((ide_atual > 0) && (res[1] != (-1)))
      {
        printf("Maximo produto %d %d %d.\n", idp, res[0], res[1]);
      }
      else
      {
        
      }

    }
  }

}

int less(int state, int x, int y)
{
  int res = 0;
  if (state == 1)
  {
    res = ((produtos[x].preco < produtos[y].preco) || ((produtos[x].preco == produtos[y].preco) && (x < y))) ? (1) : (0);
  }
  else
  {
    if (x != y)
    {
      {
        int i = 0;
        for (i = 0; (i < (63 - 1)) && (produtos[x].desc[i] == produtos[y].desc[i]); i++)
          ;

        res = (produtos[x].desc[i] < produtos[y].desc[i]) ? (1) : (0);
      }
    }
    else
    {
      
    }

  }

  return res;
}

void merge(int state, int a[], int aux[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < r; j++)
    aux[(r + m) - j] = a[j + 1];

  for (k = l; k <= r; k++)
  {
    if (less(state, aux[j], aux[i]) || (i > m))
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void merge_sort(int state, int a[], int aux[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  merge_sort(state, a, aux, l, m);
  merge_sort(state, a, aux, m + 1, r);
  merge(state, a, aux, l, m, r);
}

void order_prods_price()
{
  int a[10000];
  int aux[10000];
  int i;
  int j;
  for (i = 0; i < idp_atual; i++)
    a[i] = i;

  merge_sort(1, a, aux, 0, idp_atual - 1);
  printf("Produtos\n");
  for (j = 0; j < idp_atual; j++)
    printf("* %s %d %d\n", produtos[a[j]].desc, produtos[a[j]].preco, produtos[a[j]].qt_stock);

}

void order_prods_from_order_desc()
{
  int ide = valores[0];
  if ((ide_atual - 1) < ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      int a[200];
      int aux[200];
      int i;
      int j = 0;
      int k;
      int p;
      for (i = 0; (i < 200) && (encomendas[ide].carrinho_compras[i][0] != (-1)); i++)
      {
        if (encomendas[ide].carrinho_compras[i][0] != (-2))
        {
          a[j++] = encomendas[ide].carrinho_compras[i][0];
        }
        else
        {
          
        }

      }

      merge_sort(0, a, aux, 0, j - 1);
      printf("Encomenda %d\n", ide);
      for (k = 0; k <= (j - 1); k++)
      {
        for (p = 0; encomendas[ide].carrinho_compras[p][0] != a[k]; p++)
          ;

        printf("* %s %d %d\n", produtos[a[k]].desc, produtos[a[k]].preco, encomendas[ide].carrinho_compras[p][1]);
      }

    }
  }

}

void call_function(char c)
{
  switch (c)
  {
    case 'a':
      add_produto();
      break;

    case 'q':
      add_stock();
      break;

    case 'N':
      new_order();
      break;

    case 'A':
      add_prod_to_order();
      break;

    case 'r':
      remove_stock();
      break;

    case 'R':
      remove_prod_from_order();
      break;

    case 'C':
      oder_cost();
      break;

    case 'p':
      change_prod_price();
      break;

    case 'E':
      desc_qtd_prod_from_order();
      break;

    case 'm':
      id_order_most_qtd_prod();
      break;

    case 'l':
      order_prods_price();
      break;

    case 'L':
      order_prods_from_order_desc();
      break;

    default:
      break;

  }

}

void read_values_from_line(char s[])
{
  int i;
  int j;
  int k;
  int v_atual = 0;
  for (k = 0; k < 3; k++)
    valores[k] = 0;

  if (s[0] == 'a')
  {
    {
      for (i = 2; s[i] != ':'; i++)
        descricao_prod[i - 2] = s[i];

      descricao_prod[i - 2] = '\0';
    }
  }
  else
  {
    
  }

  if (s[1] != '\n')
  {
    {
      i = (s[0] == 'a') ? (i + 1) : (2);
      for (j = i; s[j] != '\n'; j++)
      {
        if (s[j] == ':')
        {
          v_atual += 1;
        }
        else
        {
          valores[v_atual] = (valores[v_atual] * 10) + (s[j] - '0');
        }

      }

    }
  }
  else
  {
    
  }

}

int main()
{
  char s[200];
  char c;
  int i = 0;
  while (((c = getchar()) != EOF) && (!((c == 'x') && (i == 0))))
  {
    s[i++] = c;
    if (c == '\n')
    {
      {
        i = 0;
        read_values_from_line(s);
        call_function(s[0]);
      }
    }
    else
    {
      
    }

  }

  return 0;
}

