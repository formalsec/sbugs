/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "radix.h"


typedef struct Produto
{
  char descricao[63];
  int preco;
  int peso;
  int qtd;
  int idp;
} Produto;
typedef struct Encomenda
{
  int counterPE;
  int ide;
  int peso_total;
  int estado;
  int qtds[200];
  int idps[200];
} Encomenda;
Produto produtos[10000];
Encomenda encomendas[500];
int counterP = 0;
int counterE = 0;
int find_prod(int ide, int idp)
{
  int i;
  for (i = 0; i < (encomendas[ide].counterPE + 1); i++)
  {
    if (!encomendas[ide].counterPE)
    {
      return 200;
    }
    else
    {
      if (i == encomendas[ide].counterPE)
      {
        return 200;
      }
      else
      {
        if (encomendas[ide].idps[i] == idp)
        {
          break;
        }
        else
        {
          
        }

      }

    }

  }

  return i;
}

void a(char descricao[], int preco, int peso, int qtd)
{
  strcpy(produtos[counterP].descricao, descricao);
  produtos[counterP].preco = preco;
  produtos[counterP].peso = peso;
  produtos[counterP].qtd = qtd;
  produtos[counterP].idp = counterP;
  printf("Novo produto %d.\n", counterP);
  counterP++;
}

void q(int idp, int qtd)
{
  if (produtos[idp].descricao[0] == '\0')
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].qtd += qtd;
  }

}

void N()
{
  encomendas[counterE].counterPE = 0;
  encomendas[counterE].estado = 1;
  encomendas[counterE].peso_total = 0;
  encomendas[counterE].ide = counterE;
  printf("Nova encomenda %d.\n", counterE);
  counterE++;
}

void A(int ide, int idp, int qtd)
{
  int i;
  if (!encomendas[ide].estado)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (produtos[idp].descricao[0] == '\0')
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (produtos[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((encomendas[ide].peso_total + (produtos[idp].peso * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          if (find_prod(ide, idp) == 200)
          {
            {
              encomendas[ide].peso_total += produtos[idp].peso * qtd;
              encomendas[ide].idps[encomendas[ide].counterPE] = idp;
              encomendas[ide].qtds[encomendas[ide].counterPE] = qtd;
              encomendas[ide].counterPE++;
              produtos[idp].qtd -= qtd;
            }
          }
          else
          {
            {
              i = find_prod(ide, idp);
              encomendas[ide].qtds[i] += qtd;
              encomendas[ide].peso_total += produtos[idp].peso * qtd;
              produtos[idp].qtd -= qtd;
            }
          }

        }

      }

    }

  }

}

void r(int idp, int qtd)
{
  if (produtos[idp].descricao[0] == '\0')
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (produtos[idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      produtos[idp].qtd -= qtd;
    }

  }

}

void R(int ide, int idp)
{
  int posicao;
  int i;
  if (!encomendas[ide].estado)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (produtos[idp].descricao[0] == '\0')
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (find_prod(ide, idp) != 200)
      {
        {
          i = find_prod(ide, idp);
          produtos[idp].qtd += encomendas[ide].qtds[i];
          encomendas[ide].peso_total -= produtos[idp].peso * encomendas[ide].qtds[i];
          for (posicao = i; posicao < 200; posicao++)
          {
            encomendas[ide].idps[posicao] = encomendas[ide].idps[posicao + 1];
            encomendas[ide].qtds[posicao] = encomendas[ide].qtds[posicao + 1];
          }

          encomendas[ide].counterPE--;
        }
      }
      else
      {
        
      }

    }

  }

}

void C(int ide)
{
  int custo_total = 0;
  int i;
  if (!encomendas[ide].estado)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      for (i = 0; i < encomendas[ide].counterPE; i++)
        custo_total += produtos[encomendas[ide].idps[i]].preco * encomendas[ide].qtds[i];

      printf("Custo da encomenda %d %d.\n", ide, custo_total);
    }
  }

}

void p(int idp, int preco)
{
  if (produtos[idp].descricao[0] == '\0')
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].preco = preco;
  }

}

void E(int ide, int idp)
{
  int i;
  int q;
  if (!encomendas[ide].estado)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (produtos[idp].descricao[0] == '\0')
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      {
        i = find_prod(ide, idp);
        if (i == 200)
        {
          q = 0;
        }
        else
        {
          q = encomendas[ide].qtds[i];
        }

        printf("%s %d.\n", produtos[idp].descricao, q);
      }
    }

  }

}

void m(int idp)
{
  int i;
  int max_qtd = 0;
  int max_index = -1;
  int find;
  if (produtos[idp].descricao[0] == '\0')
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      for (i = 0; i < 500; i++)
      {
        find = find_prod(i, idp);
        if ((find != 200) && (max_qtd < encomendas[i].qtds[find]))
        {
          {
            max_qtd = encomendas[i].qtds[find_prod(i, idp)];
            max_index = i;
          }
        }
        else
        {
          
        }

      }

      if (max_index != (-1))
      {
        {
          printf("Maximo produto %d %d %d.\n", idp, max_index, max_qtd);
        }
      }
      else
      {
        
      }

    }
  }

}

void l()
{
  int precos[10000][2];
  int i;
  for (i = 0; i < counterP; i++)
  {
    precos[i][0] = i;
    precos[i][1] = produtos[i].preco;
  }

  radixSort(precos, counterP);
  printf("Produtos\n");
  for (i = 0; i < counterP; i++)
    printf("* %s %d %d\n", produtos[precos[i][0]].descricao, produtos[precos[i][0]].preco, produtos[precos[i][0]].qtd);

}

void L(int ide)
{
  int i;
  int j;
  Produto aux;
  Produto produtos_aux[200];
  if (!encomendas[ide].estado)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      printf("Encomenda %d\n", ide);
      for (i = 0; i < encomendas[ide].counterPE; i++)
      {
        produtos_aux[i] = produtos[encomendas[ide].idps[i]];
        produtos_aux[i].qtd = encomendas[ide].qtds[i];
        strcpy(produtos_aux[i].descricao, produtos[encomendas[ide].idps[i]].descricao);
      }

      for (i = 0; i < encomendas[ide].counterPE; i++)
        for (j = i + 1; j < encomendas[ide].counterPE; j++)
      {
        if (strcmp(produtos_aux[i].descricao, produtos_aux[j].descricao) > 0)
        {
          {
            aux = produtos_aux[i];
            produtos_aux[i] = produtos_aux[j];
            produtos_aux[j] = aux;
          }
        }
        else
        {
          
        }

      }


      for (i = 0; i < encomendas[ide].counterPE; i++)
        printf("* %s %d %d\n", produtos_aux[i].descricao, produtos_aux[i].preco, produtos_aux[i].qtd);

    }
  }

}

int main()
{
  char command;
  char desc[63];
  int i;
  int execucao = 1;
  int preco;
  int weight;
  int qtd;
  int idp;
  int ide;
  while (execucao)
  {
    command = getchar();
    for (i = 0; i < 120; i++)
    {
      switch (command)
      {
        case 'a':
          getchar();
          for (int desc_index = 0; desc_index < 10; desc_index++)
        {
          desc[desc_index] = new_sym_var(sizeof(char) * 8);
        }

          desc[10 - 1] = '\0';
          preco = new_sym_var(sizeof(int) * 8);
          weight = new_sym_var(sizeof(int) * 8);
          qtd = new_sym_var(sizeof(int) * 8);
          a(desc, preco, weight, qtd);
          break;

        case 'q':
          getchar();
          idp = new_sym_var(sizeof(int) * 8);
          qtd = new_sym_var(sizeof(int) * 8);
          q(idp, qtd);
          break;

        case 'N':
          N();
          break;

        case 'A':
          getchar();
          ide = new_sym_var(sizeof(int) * 8);
          idp = new_sym_var(sizeof(int) * 8);
          qtd = new_sym_var(sizeof(int) * 8);
          A(ide, idp, qtd);
          break;

        case 'r':
          getchar();
          idp = new_sym_var(sizeof(int) * 8);
          qtd = new_sym_var(sizeof(int) * 8);
          r(idp, qtd);
          break;

        case 'R':
          getchar();
          ide = new_sym_var(sizeof(int) * 8);
          idp = new_sym_var(sizeof(int) * 8);
          R(ide, idp);
          break;

        case 'C':
          getchar();
          ide = new_sym_var(sizeof(int) * 8);
          C(ide);
          break;

        case 'p':
          getchar();
          idp = new_sym_var(sizeof(int) * 8);
          preco = new_sym_var(sizeof(int) * 8);
          p(idp, preco);
          break;

        case 'E':
          getchar();
          ide = new_sym_var(sizeof(int) * 8);
          idp = new_sym_var(sizeof(int) * 8);
          E(ide, idp);
          break;

        case 'm':
          getchar();
          idp = new_sym_var(sizeof(int) * 8);
          m(idp);
          break;

        case 'l':
          l();
          break;

        case 'L':
          getchar();
          ide = new_sym_var(sizeof(int) * 8);
          L(ide);
          break;

        case 'x':
          return 0;

      }

      break;
    }

  }

  return 0;
}

