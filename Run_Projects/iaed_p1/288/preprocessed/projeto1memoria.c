/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int idp;
  int preco;
  int peso;
  int qtd;
  char descricao[64];
} PRODUTO;
typedef struct 
{
  int ide;
  int preco;
  int peso;
  int produtos[10000];
} ENCOMENDA;
void cria_produto();
void adiciona_qtd();
void cria_encomenda();
void adiciona_prod();
void remove_stock();
void remove_prod();
void custo_encomenda();
void altera_preco();
void des_qtd_enc();
void prod_mais_qtd();
void ordem_precos();
void ordem_prod_enc();
void mergesort_l(PRODUTO a[], int l, int r);
void merge_l(PRODUTO a[], int l, int m, int r);
void mergesort_L(PRODUTO a[], int l, int r);
void merge_L(PRODUTO a[], int l, int m, int r);
PRODUTO sistema[10000];
ENCOMENDA sistema_encomendas[500];
int idps_sistema = 0;
int ides_encomendas = 0;
int main()
{
  char c;
  while (1)
  {
    c = getchar();
    switch (c)
    {
      case 'a':
        cria_produto();
        break;

      case 'q':
        adiciona_qtd();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        adiciona_prod();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_prod();
        break;

      case 'C':
        custo_encomenda();
        break;

      case 'p':
        altera_preco();
        break;

      case 'E':
        des_qtd_enc();
        break;

      case 'm':
        prod_mais_qtd();
        break;

      case 'l':
        ordem_precos();
        break;

      case 'L':
        ordem_prod_enc();
        break;

      case 'x':
        return 0;

    }

  }

  return 0;
}

void cria_produto()
{
  int pr;
  int ps;
  int q;
  char d[64];
  PRODUTO novo;
  for (int d_index = 0; d_index < 10; d_index++)
  {
    d[d_index] = new_sym_var(sizeof(char) * 8);
  }

  d[10 - 1] = '\0';
  pr = new_sym_var(sizeof(int) * 8);
  ps = new_sym_var(sizeof(int) * 8);
  q = new_sym_var(sizeof(int) * 8);
  novo.idp = idps_sistema;
  idps_sistema += 1;
  strcpy(novo.descricao, d);
  novo.preco = pr;
  novo.peso = ps;
  novo.qtd = q;
  sistema[novo.idp] = novo;
  printf("Novo produto %d.\n", novo.idp);
}

void adiciona_qtd()
{
  int id;
  int q;
  id = new_sym_var(sizeof(int) * 8);
  q = new_sym_var(sizeof(int) * 8);
  if (id >= idps_sistema)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  }
  else
  {
    sistema[id].qtd += q;
  }

}

void cria_encomenda()
{
  int i;
  ENCOMENDA nova;
  nova.ide = ides_encomendas;
  ides_encomendas += 1;
  nova.preco = 0;
  nova.peso = 0;
  for (i = 0; i < 10000; i++)
    nova.produtos[i] = 0;

  sistema_encomendas[nova.ide] = nova;
  printf("Nova encomenda %d.\n", nova.ide);
}

void adiciona_prod()
{
  int e;
  int p;
  int q;
  e = new_sym_var(sizeof(int) * 8);
  p = new_sym_var(sizeof(int) * 8);
  q = new_sym_var(sizeof(int) * 8);
  if (e >= ides_encomendas)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  if (p >= idps_sistema)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  if (sistema[p].qtd < q)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  if ((sistema_encomendas[e].peso + (sistema[p].peso * q)) > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  sistema_encomendas[e].preco += sistema[p].preco * q;
  sistema_encomendas[e].peso += sistema[p].peso * q;
  sistema_encomendas[e].produtos[p] += q;
  sistema[p].qtd -= q;
}

void remove_stock()
{
  int p;
  int q;
  p = new_sym_var(sizeof(int) * 8);
  q = new_sym_var(sizeof(int) * 8);
  if (p >= idps_sistema)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", p);
      return;
    }
  }
  else
  {
    
  }

  if ((sistema[p].qtd - q) < 0)
  {
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", q, p);
      return;
    }
  }
  else
  {
    
  }

  sistema[p].qtd -= q;
}

void remove_prod()
{
  int e;
  int p;
  e = new_sym_var(sizeof(int) * 8);
  p = new_sym_var(sizeof(int) * 8);
  if (e >= ides_encomendas)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  if (p >= idps_sistema)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  sistema_encomendas[e].preco -= sistema[p].preco * sistema_encomendas[e].produtos[p];
  sistema_encomendas[e].peso -= sistema[p].peso * sistema_encomendas[e].produtos[p];
  sistema[p].qtd += sistema_encomendas[e].produtos[p];
  sistema_encomendas[e].produtos[p] = 0;
}

void custo_encomenda()
{
  int e;
  e = new_sym_var(sizeof(int) * 8);
  if (e >= ides_encomendas)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", e);
      return;
    }
  }
  else
  {
    
  }

  printf("Custo da encomenda %d %d.\n", e, sistema_encomendas[e].preco);
}

void altera_preco()
{
  int p;
  int novo_preco;
  int i;
  p = new_sym_var(sizeof(int) * 8);
  novo_preco = new_sym_var(sizeof(int) * 8);
  if (p >= idps_sistema)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", p);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < ides_encomendas; i++)
  {
    if (sistema_encomendas[i].produtos[p] != 0)
    {
      sistema_encomendas[i].preco += (novo_preco - sistema[p].preco) * sistema_encomendas[i].produtos[p];
    }
    else
    {
      
    }

  }

  sistema[p].preco = novo_preco;
}

void des_qtd_enc()
{
  int e;
  int p;
  e = new_sym_var(sizeof(int) * 8);
  p = new_sym_var(sizeof(int) * 8);
  if (e >= ides_encomendas)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", e);
      return;
    }
  }
  else
  {
    
  }

  if (p >= idps_sistema)
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", p);
      return;
    }
  }
  else
  {
    
  }

  printf("%s %d.\n", sistema[p].descricao, sistema_encomendas[e].produtos[p]);
}

void prod_mais_qtd()
{
  int p;
  int i;
  int max = 0;
  int ecom;
  p = new_sym_var(sizeof(int) * 8);
  if (p >= idps_sistema)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", p);
      return;
    }
  }
  else
  {
    
  }

  if (ides_encomendas == 0)
  {
    return;
  }
  else
  {
    
  }

  for (i = 0; i < ides_encomendas; i++)
  {
    if (sistema_encomendas[i].produtos[p] > max)
    {
      {
        max = sistema_encomendas[i].produtos[p];
        ecom = i;
      }
    }
    else
    {
      
    }

  }

  if (max == 0)
  {
    return;
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", p, ecom, max);
}

void ordem_precos()
{
  int i;
  int l = 0;
  int r = idps_sistema - 1;
  PRODUTO copia_sistema[10000];
  for (i = 0; i < idps_sistema; i++)
  {
    copia_sistema[i] = sistema[i];
  }

  mergesort_l(copia_sistema, l, r);
  printf("Produtos\n");
  for (i = 0; i < idps_sistema; i++)
  {
    printf("* %s %d %d\n", copia_sistema[i].descricao, copia_sistema[i].preco, copia_sistema[i].qtd);
  }

}

void merge_l(PRODUTO a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  PRODUTO L[10000];
  PRODUTO R[10000];
  for (i = 0; i < n1; i++)
    L[i] = a[l + i];

  for (j = 0; j < n2; j++)
    R[j] = a[(m + 1) + j];

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (L[i].preco <= R[j].preco)
    {
      a[k] = L[i++];
    }
    else
    {
      a[k] = R[j++];
    }

    k++;
  }

  while (i < n1)
  {
    a[k] = L[i++];
    k++;
  }

  while (j < n2)
  {
    a[k] = R[j++];
    k++;
  }

}

void mergesort_l(PRODUTO a[], int l, int r)
{
  if (l < r)
  {
    {
      int m = l + ((r - l) / 2);
      mergesort_l(a, l, m);
      mergesort_l(a, m + 1, r);
      merge_l(a, l, m, r);
    }
  }
  else
  {
    
  }

}

void ordem_prod_enc()
{
  int e;
  int i;
  int contador_prod = 0;
  PRODUTO copia_encomenda[10000];
  e = new_sym_var(sizeof(int) * 8);
  if (e >= ides_encomendas)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", e);
      return;
    }
  }
  else
  {
    
  }

  printf("Encomenda %d\n", e);
  for (i = 0; i < idps_sistema; i++)
  {
    if (sistema_encomendas[e].produtos[i] != 0)
    {
      {
        copia_encomenda[contador_prod] = sistema[i];
        copia_encomenda[contador_prod].qtd = sistema_encomendas[e].produtos[i];
        contador_prod += 1;
      }
    }
    else
    {
      
    }

  }

  mergesort_L(copia_encomenda, 0, contador_prod - 1);
  for (i = 0; i < contador_prod; i++)
    printf("* %s %d %d\n", copia_encomenda[i].descricao, copia_encomenda[i].preco, copia_encomenda[i].qtd);

}

void merge_L(PRODUTO a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  PRODUTO L[10000];
  PRODUTO R[10000];
  for (i = 0; i < n1; i++)
    L[i] = a[l + i];

  for (j = 0; j < n2; j++)
    R[j] = a[(m + 1) + j];

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (strcmp(L[i].descricao, R[j].descricao) < 0)
    {
      a[k] = L[i++];
    }
    else
    {
      a[k] = R[j++];
    }

    k++;
  }

  while (i < n1)
  {
    a[k] = L[i++];
    k++;
  }

  while (j < n2)
  {
    a[k] = R[j++];
    k++;
  }

}

void mergesort_L(PRODUTO a[], int l, int r)
{
  if (l < r)
  {
    {
      int m = l + ((r - l) / 2);
      mergesort_L(a, l, m);
      mergesort_L(a, m + 1, r);
      merge_L(a, l, m, r);
    }
  }
  else
  {
    
  }

}

