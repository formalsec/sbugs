/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


struct Product
{
  int id;
  char nome[64];
  int price;
  int weight;
  int quantidade;
};
struct Encomenda
{
  int idp[200];
  int qtds[200];
  int len;
  int peso;
};
struct Product produtos[10000];
int length_produtos = 0;
void adiciona()
{
  struct Product produto;
  for (int produto_index = 0; produto_index < 10; produto_index++)
  {
    produto.nome[produto_index] = new_sym_var(sizeof(char) * 8);
  }

  produto.nome[10 - 1] = '\0';
  produto.price = new_sym_var(sizeof(int) * 8);
  produto.weight = new_sym_var(sizeof(int) * 8);
  produto.quantidade = new_sym_var(sizeof(int) * 8);
  produto.id = length_produtos;
  produtos[length_produtos] = produto;
  length_produtos += 1;
  printf("Novo produto %d.\n", produto.id);
}

int busca_idxp(int idp)
{
  int n;
  for (n = 0; n < length_produtos; n++)
  {
    if (produtos[n].id == idp)
    {
      {
        return n;
      }
    }
    else
    {
      
    }

  }

  return -1;
}

void adiciona_stock()
{
  int idp;
  int quantidade;
  int idxp;
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (idp >= length_produtos)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  idxp = busca_idxp(idp);
  produtos[idxp].quantidade += quantidade;
}

struct Encomenda encomendas[500];
int len_encomendas = 0;
void cria_encomenda()
{
  struct Encomenda encomenda;
  encomenda.len = 0;
  encomenda.peso = 0;
  encomendas[len_encomendas] = encomenda;
  printf("Nova encomenda %d.\n", len_encomendas);
  len_encomendas += 1;
}

void adiciona_prod()
{
  int ide;
  int idp;
  int qtd;
  int n;
  int idxp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= len_encomendas)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (idp >= length_produtos)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  idxp = busca_idxp(idp);
  if (produtos[idxp].quantidade < qtd)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if ((encomendas[ide].peso + (qtd * produtos[idxp].weight)) > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  for (n = 0; n < encomendas[ide].len; n++)
  {
    if (encomendas[ide].idp[n] == idp)
    {
      {
        encomendas[ide].qtds[n] += qtd;
        produtos[idxp].quantidade -= qtd;
        encomendas[ide].peso += qtd * produtos[idxp].weight;
        return;
      }
    }
    else
    {
      
    }

  }

  encomendas[ide].idp[encomendas[ide].len] = idp;
  encomendas[ide].qtds[encomendas[ide].len] = qtd;
  encomendas[ide].len += 1;
  produtos[idxp].quantidade -= qtd;
  encomendas[ide].peso += qtd * produtos[idxp].weight;
}

void remove_stock()
{
  int idp;
  int qtd;
  int idxp;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= length_produtos)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  idxp = busca_idxp(idp);
  if (produtos[idxp].quantidade < qtd)
  {
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
      return;
    }
  }
  else
  {
    
  }

  produtos[idxp].quantidade -= qtd;
}

void remove_prod()
{
  int ide;
  int idp;
  int idxp;
  int n;
  int temp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= len_encomendas)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  if (idp >= length_produtos)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
  }
  else
  {
    
  }

  idxp = busca_idxp(idp);
  for (n = 0; n < encomendas[ide].len; n++)
  {
    if (encomendas[ide].idp[n] == idp)
    {
      {
        produtos[idxp].quantidade += encomendas[ide].qtds[n];
        encomendas[ide].peso -= encomendas[ide].qtds[n] * produtos[idxp].weight;
        temp = encomendas[ide].idp[n];
        encomendas[ide].idp[n] = encomendas[ide].idp[encomendas[ide].len - 1];
        encomendas[ide].idp[encomendas[ide].len - 1] = temp;
        temp = encomendas[ide].qtds[n];
        encomendas[ide].qtds[n] = encomendas[ide].qtds[encomendas[ide].len - 1];
        encomendas[ide].qtds[encomendas[ide].len - 1] = temp;
        encomendas[ide].len -= 1;
        return;
      }
    }
    else
    {
      
    }

  }

}

void calcula_custo()
{
  int ide;
  int custo;
  int idxp;
  int n;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= len_encomendas)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  custo = 0;
  for (n = 0; n < encomendas[ide].len; n++)
  {
    idxp = busca_idxp(encomendas[ide].idp[n]);
    custo += produtos[idxp].price * encomendas[ide].qtds[n];
  }

  printf("Custo da encomenda %d %d.\n", ide, custo);
}

void muda_preco()
{
  int idp;
  int preco;
  int idxp;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= length_produtos)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  idxp = busca_idxp(idp);
  produtos[idxp].price = preco;
}

void lista_desc()
{
  int ide;
  int idp;
  int idxp;
  int n;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= len_encomendas)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  if (idp >= length_produtos)
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  idxp = busca_idxp(idp);
  for (n = 0; n < encomendas[ide].len; n++)
  {
    if (encomendas[ide].idp[n] == idp)
    {
      {
        printf("%s %d.\n", produtos[idxp].nome, encomendas[ide].qtds[n]);
        return;
      }
    }
    else
    {
      
    }

  }

  printf("%s 0.\n", produtos[idxp].nome);
}

void lista_maior_encomenda()
{
  int idp;
  int n;
  int ide_max;
  int ide_qtd_max;
  int i;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= length_produtos)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  ide_max = -1;
  ide_qtd_max = -1;
  for (n = 0; n < len_encomendas; n++)
  {
    for (i = 0; i < encomendas[n].len; i++)
    {
      if (encomendas[n].idp[i] == idp)
      {
        {
          if ((encomendas[n].qtds[i] > ide_qtd_max) || ((encomendas[n].qtds[i] == ide_qtd_max) && (n < ide_max)))
          {
            {
              ide_max = n;
              ide_qtd_max = encomendas[n].qtds[i];
            }
          }
          else
          {
            
          }

        }
      }
      else
      {
        
      }

    }

  }

  if (ide_max != (-1))
  {
    {
      printf("Maximo produto %d %d %d.\n", idp, ide_max, ide_qtd_max);
    }
  }
  else
  {
    
  }

}

int lista_prod_less(int l, int r)
{
  if (produtos[l].price < produtos[r].price)
  {
    {
      return 1;
    }
  }
  else
  {
    if (produtos[l].price > produtos[r].price)
    {
      {
        return 0;
      }
    }
    else
    {
      if (produtos[l].id < produtos[r].id)
      {
        {
          return 1;
        }
      }
      else
      {
        {
          return 0;
        }
      }

    }

  }

}

void lista_prod_sort()
{
  struct Product temp;
  int i;
  int j;
  for (i = 0; i < (length_produtos - 1); i++)
  {
    int min = i;
    for (j = i + 1; j < length_produtos; j++)
    {
      if (lista_prod_less(j, min))
      {
        {
          min = j;
        }
      }
      else
      {
        
      }

    }

    temp = produtos[i];
    produtos[i] = produtos[min];
    produtos[min] = temp;
  }

}

void lista_prod()
{
  int n;
  lista_prod_sort();
  printf("Produtos\n");
  for (n = 0; n < length_produtos; n++)
  {
    printf("* %s %d %d\n", produtos[n].nome, produtos[n].price, produtos[n].quantidade);
  }

}

int lista_encomenda_alfabetica_less(int ide, int j, int min)
{
  int idxp_j;
  int idxp_min;
  idxp_j = busca_idxp(encomendas[ide].idp[j]);
  idxp_min = busca_idxp(encomendas[ide].idp[min]);
  return strcmp(produtos[idxp_j].nome, produtos[idxp_min].nome) <= 0;
}

void lista_encomenda_alfabetica_sort(int ide)
{
  int i;
  int j;
  int temp;
  for (i = 0; i < (encomendas[ide].len - 1); i++)
  {
    int min = i;
    for (j = i + 1; j < encomendas[ide].len; j++)
    {
      if (lista_encomenda_alfabetica_less(ide, j, min))
      {
        {
          min = j;
        }
      }
      else
      {
        
      }

    }

    temp = encomendas[ide].idp[i];
    encomendas[ide].idp[i] = encomendas[ide].idp[min];
    encomendas[ide].idp[min] = temp;
    temp = encomendas[ide].qtds[i];
    encomendas[ide].qtds[i] = encomendas[ide].qtds[min];
    encomendas[ide].qtds[min] = temp;
  }

}

void lista_encomenda_alfabetica()
{
  int ide;
  int n;
  int idxp;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= len_encomendas)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
  }
  else
  {
    
  }

  lista_encomenda_alfabetica_sort(ide);
  printf("Encomenda %d\n", ide);
  for (n = 0; n < encomendas[ide].len; n++)
  {
    idxp = busca_idxp(encomendas[ide].idp[n]);
    printf("* %s %d %d\n", produtos[idxp].nome, produtos[idxp].price, encomendas[ide].qtds[n]);
  }

}

int main()
{
  while (1)
  {
    int c = getchar();
    switch (c)
    {
      case 'a':
        adiciona();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        adiciona_prod();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_prod();
        break;

      case 'C':
        calcula_custo();
        break;

      case 'p':
        muda_preco();
        break;

      case 'E':
        lista_desc();
        break;

      case 'm':
        lista_maior_encomenda();
        break;

      case 'l':
        lista_prod();
        break;

      case 'L':
        lista_encomenda_alfabetica();
        break;

      case 'x':
        return 0;

    }

  }

}

