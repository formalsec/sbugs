/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  int idp;
  char descricao[63];
  int preco;
  int peso;
  int quant_stock;
} Produto;
typedef struct encomenda
{
  int ide;
  int n_produtos;
  Produto produtos[200];
} Encomenda;
Produto todos_produtos[10000];
Encomenda todas_encomendas[500];
int idp = 0;
int ide = 0;
int primeiro_produto = 0;
int primeira_encomenda = 0;
void novo_produto();
void ad_stock();
void nova_encomenda();
void adiciona_produto();
void re_stock(int idp_re, int quantidade_re);
void re_produto_encomenda();
void custo_encomenda();
void altera_preco();
void descricao_quantidade();
void ide_comais_produto();
void ordena_preco(Produto lista[], int n_produtos);
void ordena_alfabetica();
int compara_produtos(Produto a, Produto b, int metodo);
int calc_peso(Encomenda encomenda);
int partition(Produto a[], int l, int r, int metodo);
void quicksort(Produto a[], int l, int r, int metodo);
int main()
{
  int idp_re;
  int quantidade_re;
  while (1)
  {
    char command;
    command = getchar();
    switch (command)
    {
      case 'a':
        novo_produto();
        break;

      case 'q':
        ad_stock();
        break;

      case 'N':
        nova_encomenda();
        break;
        break;

      case 'A':
        adiciona_produto();
        break;

      case 'r':
        idp_re = new_sym_var(sizeof(int) * 8);
        quantidade_re = new_sym_var(sizeof(int) * 8);
        re_stock(idp_re, quantidade_re);
        break;

      case 'R':
        re_produto_encomenda();
        break;

      case 'C':
        custo_encomenda();
        break;

      case 'p':
        altera_preco();
        break;

      case 'E':
        descricao_quantidade();
        break;

      case 'm':
        ide_comais_produto();
        break;

      case 'l':
        ordena_preco(todos_produtos, idp + 1);
        break;

      case 'L':
        ordena_alfabetica(todos_produtos, idp + 1);
        break;

      case 'x':
        return 0;

    }

    getchar();
  }

}

void novo_produto()
{
  if (primeiro_produto == 1)
  {
    idp++;
  }
  else
  {
    
  }

  if (primeiro_produto == 0)
  {
    primeiro_produto = 1;
  }
  else
  {
    
  }

  todos_produtos[idp].idp = idp;
  for (int todos_produtos_index = 0; todos_produtos_index < 10; todos_produtos_index++)
  {
    todos_produtos[idp].descricao[todos_produtos_index] = new_sym_var(sizeof(char) * 8);
  }

  todos_produtos[idp].descricao[10 - 1] = '\0';
  todos_produtos[idp].preco = new_sym_var(sizeof(int) * 8);
  todos_produtos[idp].peso = new_sym_var(sizeof(int) * 8);
  todos_produtos[idp].quant_stock = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", todos_produtos[idp].idp);
}

void ad_stock()
{
  int idp_ad;
  int quantidade;
  idp_ad = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if ((idp < idp_ad) || (primeiro_produto == 0))
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp_ad);
      return;
    }
  }
  else
  {
    
  }

  todos_produtos[idp_ad].quant_stock += quantidade;
}

void nova_encomenda()
{
  if (primeira_encomenda == 1)
  {
    ide++;
  }
  else
  {
    
  }

  if (primeira_encomenda == 0)
  {
    primeira_encomenda = 1;
  }
  else
  {
    
  }

  printf("Nova encomenda %d.\n", ide);
}

void adiciona_produto()
{
  int ide_ad;
  int idp_ad;
  int quantidade;
  int i;
  ide_ad = new_sym_var(sizeof(int) * 8);
  idp_ad = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if ((ide < ide_ad) || (primeira_encomenda == 0))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp_ad, ide_ad);
  }
  else
  {
    if ((idp < idp_ad) || (primeiro_produto == 0))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp_ad, ide_ad);
    }
    else
    {
      if (quantidade > todos_produtos[idp_ad].quant_stock)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp_ad, ide_ad);
      }
      else
      {
        if (200 < (calc_peso(todas_encomendas[ide_ad]) + (todos_produtos[idp_ad].peso * quantidade)))
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp_ad, ide_ad);
        }
        else
        {
          {
            for (i = 0; i < todas_encomendas[ide_ad].n_produtos; i++)
            {
              if (todas_encomendas[ide_ad].produtos[i].idp == idp_ad)
              {
                {
                  todas_encomendas[ide_ad].produtos[i].quant_stock += quantidade;
                  re_stock(idp_ad, quantidade);
                  return;
                }
              }
              else
              {
                
              }

            }

            todas_encomendas[ide_ad].produtos[todas_encomendas[ide_ad].n_produtos] = todos_produtos[idp_ad];
            todas_encomendas[ide_ad].produtos[todas_encomendas[ide_ad].n_produtos].quant_stock = quantidade;
            todas_encomendas[ide_ad].n_produtos++;
            re_stock(idp_ad, quantidade);
          }
        }

      }

    }

  }

}

void ordena_preco(Produto lista[], int n_produtos)
{
  int i;
  Produto copia_lista[10000];
  for (i = 0; i <= idp; i++)
    copia_lista[i] = lista[i];

  quicksort(copia_lista, 0, n_produtos - 1, 1);
  printf("Produtos\n");
  if (primeiro_produto == 1)
  {
    for (i = 0; i < n_produtos; i++)
      printf("* %s %d %d\n", copia_lista[i].descricao, copia_lista[i].preco, copia_lista[i].quant_stock);

  }
  else
  {
    
  }

}

int calc_peso(Encomenda encomenda)
{
  int i;
  int peso = 0;
  for (i = 0; i < encomenda.n_produtos; i++)
    peso += encomenda.produtos[i].peso * encomenda.produtos[i].quant_stock;

  return peso;
}

void re_stock(int idp_re, int quantidade_re)
{
  if ((idp_re > idp) || (primeiro_produto == 0))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp_re);
  }
  else
  {
    if (todos_produtos[idp_re].quant_stock < quantidade_re)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantidade_re, idp_re);
    }
    else
    {
      todos_produtos[idp_re].quant_stock -= quantidade_re;
    }

  }

}

void re_produto_encomenda()
{
  int ide_re;
  int idp_re;
  int i;
  int i_pro_encomenda;
  int pro_removido = 0;
  ide_re = new_sym_var(sizeof(int) * 8);
  idp_re = new_sym_var(sizeof(int) * 8);
  if ((ide < ide_re) || (primeira_encomenda == 0))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp_re, ide_re);
    }
  }
  else
  {
    if ((idp < idp_re) || (primeiro_produto == 0))
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp_re, ide_re);
      }
    }
    else
    {
      
    }

  }

  for (i = 0; i < todas_encomendas[ide_re].n_produtos; i++)
  {
    if (todas_encomendas[ide_re].produtos[i].idp == idp_re)
    {
      {
        i_pro_encomenda = i;
        pro_removido = 1;
      }
    }
    else
    {
      
    }

  }

  if (pro_removido == 0)
  {
    return;
  }
  else
  {
    
  }

  todos_produtos[idp_re].quant_stock += todas_encomendas[ide_re].produtos[i_pro_encomenda].quant_stock;
  for (i = i_pro_encomenda; i < todas_encomendas[ide_re].n_produtos; i++)
    todas_encomendas[ide_re].produtos[i] = todas_encomendas[ide_re].produtos[i + 1];

  todas_encomendas[ide_re].n_produtos--;
}

void custo_encomenda()
{
  int custo_total = 0;
  int ide_input;
  int i;
  ide_input = new_sym_var(sizeof(int) * 8);
  if ((ide < ide_input) || (primeira_encomenda == 0))
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide_input);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < todas_encomendas[ide_input].n_produtos; i++)
  {
    custo_total += todas_encomendas[ide_input].produtos[i].preco * todas_encomendas[ide_input].produtos[i].quant_stock;
  }

  printf("Custo da encomenda %d %d.\n", ide_input, custo_total);
}

void altera_preco()
{
  int preco;
  int idp_input;
  int i;
  int j;
  idp_input = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if ((idp < idp_input) || (primeiro_produto == 0))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp_input);
  }
  else
  {
    
  }

  todos_produtos[idp_input].preco = preco;
  for (i = 0; i <= ide; i++)
    for (j = 0; j <= todas_encomendas[i].n_produtos; j++)
    if (todas_encomendas[i].produtos[j].idp == idp_input)
  {
    todas_encomendas[i].produtos[j].preco = preco;
  }
  else
  {
    
  }



}

void descricao_quantidade()
{
  int i;
  int idp_input;
  int ide_input;
  ide_input = new_sym_var(sizeof(int) * 8);
  idp_input = new_sym_var(sizeof(int) * 8);
  if ((ide < ide_input) || (primeira_encomenda == 0))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide_input);
      return;
    }
  }
  else
  {
    
  }

  if ((idp < idp_input) || (primeiro_produto == 0))
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp_input);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < todas_encomendas[ide_input].n_produtos; i++)
  {
    if (todas_encomendas[ide_input].produtos[i].idp == idp_input)
    {
      {
        printf("%s %d.\n", todas_encomendas[ide_input].produtos[i].descricao, todas_encomendas[ide_input].produtos[i].quant_stock);
        return;
      }
    }
    else
    {
      
    }

  }

  printf("%s 0.\n", todos_produtos[idp_input].descricao);
}

void ide_comais_produto()
{
  int idp_input;
  int i;
  int j;
  int ide_comais_produto = 0;
  int quantidade = 0;
  int flag = 0;
  idp_input = new_sym_var(sizeof(int) * 8);
  if ((idp < idp_input) || (primeiro_produto == 0))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp_input);
  }
  else
  {
    
  }

  for (i = 0; i <= ide; i++)
    for (j = 0; j < todas_encomendas[i].n_produtos; j++)
    if (todas_encomendas[i].produtos[j].idp == idp_input)
  {
    {
      if (todas_encomendas[i].produtos[j].quant_stock == quantidade)
      {
        if (i < ide_comais_produto)
        {
          ide_comais_produto = i;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      if (todas_encomendas[i].produtos[j].quant_stock > quantidade)
      {
        {
          ide_comais_produto = i;
          quantidade = todas_encomendas[i].produtos[j].quant_stock;
        }
      }
      else
      {
        
      }

      flag = 1;
    }
  }
  else
  {
    
  }



  if (flag == 1)
  {
    printf("Maximo produto %d %d %d.\n", idp_input, ide_comais_produto, quantidade);
  }
  else
  {
    
  }

}

void ordena_alfabetica()
{
  int i;
  int ide_input;
  Produto copia_lista[10000];
  ide_input = new_sym_var(sizeof(int) * 8);
  if ((ide < ide_input) || (primeira_encomenda == 0))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide_input);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < todas_encomendas[ide_input].n_produtos; i++)
    copia_lista[i] = todas_encomendas[ide_input].produtos[i];

  quicksort(copia_lista, 0, todas_encomendas[ide_input].n_produtos - 1, 0);
  printf("Encomenda %d\n", ide_input);
  for (i = 0; i < todas_encomendas[ide_input].n_produtos; i++)
    printf("* %s %d %d\n", copia_lista[i].descricao, copia_lista[i].preco, copia_lista[i].quant_stock);

}

int compara_produtos(Produto a, Produto b, int metodo)
{
  if (metodo == 0)
  {
    return strcmp(a.descricao, b.descricao) < 0;
  }
  else
  {
    
  }

  if (metodo == 1)
  {
    {
      if (a.preco != b.preco)
      {
        return a.preco < b.preco;
      }
      else
      {
        return a.idp < b.idp;
      }

    }
  }
  else
  {
    
  }

  return 0;
}

int partition(Produto a[], int l, int r, int metodo)
{
  int i = l - 1;
  int j = r;
  Produto v = a[r];
  while (i < j)
  {
    while (compara_produtos(a[++i], v, metodo))
      ;

    while (compara_produtos(v, a[--j], metodo))
      if (j == l)
    {
      break;
    }
    else
    {
      
    }


    if (i < j)
    {
      {
        Produto t = a[i];
        a[i] = a[j];
        a[j] = t;
      }
    }
    else
    {
      
    }

    ;
  }

  {
    Produto t = a[i];
    a[i] = a[r];
    a[r] = t;
  }
  ;
  return i;
}

void quicksort(Produto a[], int l, int r, int metodo)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition(a, l, r, metodo);
  quicksort(a, l, i - 1, metodo);
  quicksort(a, i + 1, r, metodo);
}

