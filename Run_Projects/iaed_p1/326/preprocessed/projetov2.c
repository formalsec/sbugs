/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int indexprod;
  int preco;
  int peso;
  int qtd;
  char dscr[63];
} produto;
typedef struct 
{
  produto prodenc[200];
  int pesoenc;
  int precoenc;
  int numeroprod;
} encomenda;
int idp = 0;
int ide = 0;
produto prod[10000];
encomenda enc[500];
int peso_da_encomenda(int n)
{
  int i = 0;
  enc[n].pesoenc = 0;
  while (i < enc[n].numeroprod)
  {
    enc[n].pesoenc += enc[n].prodenc[i].peso * enc[n].prodenc[i].qtd;
    i++;
  }

  return enc[n].pesoenc;
}

void adiciona_produto()
{
  for (int prod_index = 0; prod_index < 10; prod_index++)
  {
    prod[idp].dscr[prod_index] = new_sym_var(sizeof(char) * 8);
  }

  prod[idp].dscr[10 - 1] = '\0';
  prod[idp].preco = new_sym_var(sizeof(int) * 8);
  prod[idp].peso = new_sym_var(sizeof(int) * 8);
  prod[idp].qtd = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", idp);
  idp++;
}

void adiciona_stock()
{
  int idptemp;
  int qtd;
  idptemp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idptemp > (idp - 1))
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idptemp);
    }
  }
  else
  {
    {
      prod[idptemp].qtd += qtd;
    }
  }

}

void cria_encomenda()
{
  printf("Nova encomenda %d.\n", ide);
  enc[ide].numeroprod = 0;
  ide++;
}

void adiciona_produto_a_encomenda()
{
  int idetemp;
  int i;
  int idptemp;
  int qtd;
  idetemp = new_sym_var(sizeof(int) * 8);
  idptemp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idetemp > (ide - 1))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idptemp, idetemp);
    }
  }
  else
  {
    if (idptemp > (idp - 1))
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idptemp, idetemp);
      }
    }
    else
    {
      if (qtd > prod[idptemp].qtd)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idptemp, idetemp);
        }
      }
      else
      {
        if ((peso_da_encomenda(idetemp) + (qtd * prod[idptemp].peso)) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idptemp, idetemp);
          }
        }
        else
        {
          {
            for (i = 0; i < enc[idetemp].numeroprod; i++)
            {
              if (enc[idetemp].prodenc[i].indexprod == idptemp)
              {
                {
                  enc[idetemp].prodenc[i].qtd += qtd;
                  enc[idetemp].prodenc[i].preco = prod[idptemp].preco;
                  enc[idetemp].prodenc[i].peso = prod[idptemp].peso;
                  strcpy(enc[idetemp].prodenc[i].dscr, prod[idptemp].dscr);
                  prod[idptemp].qtd -= qtd;
                  return;
                }
              }
              else
              {
                
              }

            }

            enc[idetemp].prodenc[enc[idetemp].numeroprod].indexprod = idptemp;
            enc[idetemp].prodenc[enc[idetemp].numeroprod].qtd += qtd;
            enc[idetemp].prodenc[enc[idetemp].numeroprod].preco = prod[idptemp].preco;
            enc[idetemp].prodenc[enc[idetemp].numeroprod].peso = prod[idptemp].peso;
            strcpy(enc[idetemp].prodenc[enc[idetemp].numeroprod].dscr, prod[idptemp].dscr);
            prod[idptemp].qtd -= qtd;
            enc[idetemp].numeroprod++;
          }
        }

      }

    }

  }

}

void remove_stock()
{
  int idptemp;
  int qtd;
  idptemp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idptemp > (idp - 1))
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idptemp);
    }
  }
  else
  {
    if ((prod[idptemp].qtd - qtd) < 0)
    {
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idptemp);
      }
    }
    else
    {
      {
        prod[idptemp].qtd -= qtd;
      }
    }

  }

}

void remove_produto_a_encomenda()
{
  int idetemp;
  int i;
  int idptemp;
  idetemp = new_sym_var(sizeof(int) * 8);
  idptemp = new_sym_var(sizeof(int) * 8);
  if (idetemp > (ide - 1))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idptemp, idetemp);
    }
  }
  else
  {
    if (idptemp > (idp - 1))
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idptemp, idetemp);
      }
    }
    else
    {
      {
        for (i = 0; i < enc[idetemp].numeroprod; i++)
        {
          if (enc[idetemp].prodenc[i].indexprod == idptemp)
          {
            {
              prod[idptemp].qtd += enc[idetemp].prodenc[i].qtd;
              enc[idetemp].prodenc[i].qtd = 0;
            }
          }
          else
          {
            
          }

        }

      }
    }

  }

}

void custo_encomenda()
{
  int idetemp;
  int i;
  idetemp = new_sym_var(sizeof(int) * 8);
  if (idetemp > (ide - 1))
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", idetemp);
    }
  }
  else
  {
    {
      enc[idetemp].precoenc = 0;
      for (i = 0; i < enc[idetemp].numeroprod; i++)
      {
        enc[idetemp].precoenc += enc[idetemp].prodenc[i].preco * enc[idetemp].prodenc[i].qtd;
      }

      printf("Custo da encomenda %d %d.\n", idetemp, enc[idetemp].precoenc);
    }
  }

}

void altera_preco()
{
  int idptemp;
  int i;
  int j;
  int precotemp;
  idptemp = new_sym_var(sizeof(int) * 8);
  precotemp = new_sym_var(sizeof(int) * 8);
  if (idptemp > (idp - 1))
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idptemp);
    }
  }
  else
  {
    {
      for (i = 0; i < ide; i++)
      {
        for (j = 0; j < enc[i].numeroprod; j++)
        {
          if (enc[i].prodenc[j].indexprod == idptemp)
          {
            enc[i].prodenc[j].preco = precotemp;
          }
          else
          {
            
          }

        }

      }

      prod[idptemp].preco = precotemp;
    }
  }

}

void lista_produtos_enc()
{
  int idetemp;
  int i;
  int idptemp;
  idetemp = new_sym_var(sizeof(int) * 8);
  idptemp = new_sym_var(sizeof(int) * 8);
  if (idetemp > (ide - 1))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idetemp);
    }
  }
  else
  {
    if (idptemp > (idp - 1))
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", idptemp);
      }
    }
    else
    {
      {
        for (i = 0; i < enc[idetemp].numeroprod; i++)
        {
          if (enc[idetemp].prodenc[i].indexprod == idptemp)
          {
            {
              printf("%s %d.\n", enc[idetemp].prodenc[i].dscr, enc[idetemp].prodenc[i].qtd);
              return;
            }
          }
          else
          {
            
          }

        }

        printf("%s %d.\n", prod[idptemp].dscr, 0);
      }
    }

  }

}

void lista_prod_mais_vezes()
{
  int idptemp;
  int i;
  int j;
  int a = 0;
  int b = 0;
  int max = 0;
  idptemp = new_sym_var(sizeof(int) * 8);
  if (idptemp > (idp - 1))
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idptemp);
    }
  }
  else
  {
    {
      for (i = 0; i < ide; i++)
      {
        for (j = 0; j < enc[i].numeroprod; j++)
        {
          if ((enc[i].prodenc[j].indexprod == idptemp) && (enc[i].prodenc[j].qtd > max))
          {
            {
              max = enc[i].prodenc[j].qtd;
              a = i;
              b = j;
            }
          }
          else
          {
            
          }

        }

      }

      if (max > 0)
      {
        {
          printf("Maximo produto %d %d %d.\n", idptemp, a, enc[a].prodenc[b].qtd);
        }
      }
      else
      {
        
      }

    }
  }

}

int partition(int prodord[10000], int l, int r)
{
  int i = l - 1;
  int j = r;
  int aux = prodord[r];
  while (i < j)
  {
    while ((prod[prodord[++i]].preco < prod[aux].preco) || ((prod[prodord[i]].preco == prod[aux].preco) && (prodord[i] < aux)))
      ;

    while ((prod[aux].preco < prod[prodord[--j]].preco) || ((prod[aux].preco == prod[prodord[j]].preco) && (aux < prodord[j])))
      if (j == l)
    {
      break;
    }
    else
    {
      
    }


    if (i < j)
    {
      {
        int t;
        t = prodord[i];
        prodord[i] = prodord[j];
        prodord[j] = t;
      }
    }
    else
    {
      
    }

    ;
  }

  {
    int t;
    t = prodord[i];
    prodord[i] = prodord[r];
    prodord[r] = t;
  }
  ;
  return i;
}

void quicksort(int prodord[10000], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition(prodord, l, r);
  quicksort(prodord, l, i - 1);
  quicksort(prodord, i + 1, r);
}

void lista_por_preco()
{
  int i;
  int l = 0;
  int n;
  int r = idp - 1;
  int prodord[10000];
  for (i = 0; i < idp; i++)
  {
    prodord[i] = i;
  }

  quicksort(prodord, l, r);
  printf("Produtos\n");
  for (n = 0; n < idp; n++)
  {
    printf("* %s %d %d\n", prod[prodord[n]].dscr, prod[prodord[n]].preco, prod[prodord[n]].qtd);
  }

}

void lista_por_ordem_alfa()
{
  int idetemp;
  int j;
  int k;
  int n;
  int min;
  produto temp;
  idetemp = new_sym_var(sizeof(int) * 8);
  if (idetemp > (ide - 1))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idetemp);
    }
  }
  else
  {
    {
      for (j = 0; j < (enc[idetemp].numeroprod - 1); j++)
      {
        min = j;
        for (k = j + 1; k < enc[idetemp].numeroprod; k++)
        {
          if (strcmp(enc[idetemp].prodenc[min].dscr, enc[idetemp].prodenc[k].dscr) > 0)
          {
            {
              min = k;
            }
          }
          else
          {
            
          }

        }

        temp = enc[idetemp].prodenc[min];
        enc[idetemp].prodenc[min] = enc[idetemp].prodenc[j];
        enc[idetemp].prodenc[j] = temp;
      }

      printf("Encomenda %d\n", idetemp);
      for (n = 0; n < enc[idetemp].numeroprod; n++)
      {
        if (enc[idetemp].prodenc[n].qtd > 0)
        {
          {
            printf("* %s %d %d\n", enc[idetemp].prodenc[n].dscr, enc[idetemp].prodenc[n].preco, enc[idetemp].prodenc[n].qtd);
          }
        }
        else
        {
          
        }

      }

    }
  }

}

int main()
{
  char c;
  for (;;)
  {
    c = new_sym_var(sizeof(char) * 8);
    switch (c)
    {
      case 'a':
        adiciona_produto();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        adiciona_produto_a_encomenda();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_produto_a_encomenda();
        break;

      case 'C':
        custo_encomenda();
        break;

      case 'p':
        altera_preco();
        break;

      case 'E':
        lista_produtos_enc();
        break;

      case 'm':
        lista_prod_mais_vezes();
        break;

      case 'l':
        lista_por_preco();
        break;

      case 'L':
        lista_por_ordem_alfa();
        break;

      case 'x':
        return 0;
        break;

      default:
        break;

    }

  }

  return 0;
}

