/*File generated by PreProcessor.py*/


#include <stdio.h>


typedef struct produto
{
  int indentificador;
  char descricao[63];
  int preco;
  int peso;
  int qtd;
} produto;
typedef struct itens
{
  int idp;
  int qtd;
} itens;
typedef struct encomenda
{
  int N_enc;
  itens itens[1000];
  int marcador;
} encomenda;
void q(int p, int qtd, produto P[], int idp)
{
  if ((P[p].indentificador != p) || (idp == 0))
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", p);
      return;
    }
  }
  else
  {
    
  }

  P[p].qtd += qtd;
}

void A(int e, int p, int qtd, produto P[], encomenda E[], int ide, int idp)
{
  int peso_total = 0;
  int i;
  int j;
  int produto_ja_existente = 0;
  if ((E[e].N_enc != e) || (ide == 0))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  if ((P[p].indentificador != p) || (idp == 0))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  if (P[p].qtd < qtd)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < E[e].marcador; i++)
  {
    if (E[e].itens[i].qtd >= 0)
    {
      {
        peso_total += E[e].itens[i].qtd * P[E[e].itens[i].idp].peso;
      }
    }
    else
    {
      
    }

  }

  peso_total += P[p].peso * qtd;
  if (peso_total > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < E[e].marcador; i++)
  {
    if ((E[e].itens[i].idp == p) && (E[e].itens[i].qtd >= 0))
    {
      {
        produto_ja_existente = 1;
        j = i;
      }
    }
    else
    {
      
    }

  }

  if (produto_ja_existente == 0)
  {
    {
      E[e].itens[E[e].marcador].idp = p;
      E[e].itens[E[e].marcador].qtd = qtd;
      P[p].qtd -= qtd;
      E[e].marcador += 1;
    }
  }
  else
  {
    {
      E[e].itens[j].qtd += qtd;
      P[p].qtd -= qtd;
    }
  }

}

void r(int idp, int qtd, produto P[], int IDP)
{
  int total;
  if ((P[idp].indentificador == idp) && (IDP != 0))
  {
    {
      total = P[idp].qtd - qtd;
      if (total >= 0)
      {
        {
          P[idp].qtd = total;
        }
      }
      else
      {
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
        }
      }

    }
  }
  else
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    }
  }

}

void R(int e, int p, encomenda E[], produto P[], int ide, int idp)
{
  int i;
  if ((E[e].N_enc != e) || (ide == 0))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  if ((P[p].indentificador != p) || (idp == 0))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", p, e);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < E[e].marcador; i++)
  {
    if ((E[e].itens[i].idp == p) && (E[e].itens[i].qtd >= 0))
    {
      {
        P[p].qtd += E[e].itens[i].qtd;
        E[e].itens[i].qtd = -1;
      }
    }
    else
    {
      
    }

  }

}

void C(int e, encomenda E[], produto P[], int ide)
{
  int soma = 0;
  int i;
  if ((E[e].N_enc == e) || (ide == 0))
  {
    {
      for (i = 0; i < E[e].marcador; i++)
      {
        if (E[e].itens[i].qtd >= 0)
        {
          {
            soma += P[E[e].itens[i].idp].preco * E[e].itens[i].qtd;
          }
        }
        else
        {
          
        }

      }

      printf("Custo da encomenda %d %d.\n", e, soma);
    }
  }
  else
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", e);
    }
  }

}

void p(int idp, int p, produto P[], int IDP)
{
  if ((P[idp].indentificador == idp) || (IDP == 0))
  {
    {
      P[idp].preco = p;
    }
  }
  else
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    }
  }

}

void E(int e, int p, produto P[], encomenda E[], int ide, int idp)
{
  int i;
  if ((E[e].N_enc != e) || (ide == 0))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", e);
      return;
    }
  }
  else
  {
    
  }

  if ((P[p].indentificador != p) || (idp == 0))
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", p);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < E[e].marcador; i++)
  {
    if ((E[e].itens[i].idp == p) && (E[e].itens[i].qtd >= 0))
    {
      {
        printf("%s %d.\n", P[p].descricao, E[e].itens[i].qtd);
        return;
      }
    }
    else
    {
      
    }

  }

  printf("%s %d.\n", P[p].descricao, 0);
  return;
}

void m(int idp, int e, encomenda E[], produto P[], int IDP)
{
  int i;
  int j;
  int IDE = 0;
  int QTD = 0;
  int Ocorrencia = 0;
  if ((idp != P[idp].indentificador) || (IDP == 0))
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < e; i++)
  {
    for (j = 0; j < E[i].marcador; j++)
    {
      if (E[i].itens[j].idp == P[idp].indentificador)
      {
        {
          if (E[i].itens[j].qtd > QTD)
          {
            {
              QTD = E[i].itens[j].qtd;
              IDE = i;
              Ocorrencia = 1;
            }
          }
          else
          {
            if (E[i].itens[j].qtd == QTD)
            {
              {
                if (E[i].N_enc < IDE)
                {
                  {
                    QTD = E[i].itens[j].qtd;
                    IDE = i;
                    Ocorrencia = 1;
                  }
                }
                else
                {
                  
                }

              }
            }
            else
            {
              
            }

          }

        }
      }
      else
      {
        
      }

    }

  }

  if (Ocorrencia != 0)
  {
    {
      printf("Maximo produto %d %d %d.\n", idp, IDE, QTD);
    }
  }
  else
  {
    
  }

}

void merge(int a[], int l, int m, int r, produto P[])
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = a[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if (P[aux[j]].preco < P[aux[i]].preco)
    {
      a[k] = aux[j--];
    }
    else
    {
      if (P[aux[j]].preco == P[aux[i]].preco)
      {
        {
          if (P[aux[j]].indentificador < P[aux[i]].indentificador)
          {
            a[k] = aux[j--];
          }
          else
          {
            a[k] = aux[i++];
          }

        }
      }
      else
      {
        a[k] = aux[i++];
      }

    }

  }

}

void mergesort(int a[], int l, int r, produto P[])
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, l, m, P);
  mergesort(a, m + 1, r, P);
  merge(a, l, m, r, P);
}

void l(produto P[], int idp)
{
  int P2[10000];
  int i;
  for (i = 0; i < idp; i++)
  {
    P2[i] = P[i].indentificador;
  }

  mergesort(P2, 0, idp - 1, P);
  printf("Produtos\n");
  for (i = 0; i < idp; i++)
  {
    printf("* %s %d %d\n", P[P2[i]].descricao, P[P2[i]].preco, P[P2[i]].qtd);
  }

}

int Alphabetic(char A[], char B[])
{
  int a;
  int b;
  int termina = 0;
  while (termina < 63)
  {
    a = A[termina];
    b = B[termina];
    if (a < b)
    {
      {
        termina = 63;
        return 0;
      }
    }
    else
    {
      if (a > b)
      {
        {
          termina = 63;
          return 1;
        }
      }
      else
      {
        termina += 1;
      }

    }

  }

  return 0;
}

void merge2(itens a[], int l, int m, int r, produto P[])
{
  int i;
  int j;
  int k;
  itens aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1].idp = a[i - 1].idp;
    aux[i - 1].qtd = a[i - 1].qtd;
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j].idp = a[j + 1].idp;
    aux[(r + m) - j].qtd = a[j + 1].qtd;
  }

  for (k = l; k <= r; k++)
  {
    if (Alphabetic(P[aux[j].idp].descricao, P[aux[i].idp].descricao) == 0)
    {
      {
        a[k].idp = aux[j].idp;
        a[k].qtd = aux[j].qtd;
        j -= 1;
      }
    }
    else
    {
      {
        a[k].idp = aux[i].idp;
        a[k].qtd = aux[i].qtd;
        i += 1;
      }
    }

  }

}

void mergesort2(itens a[], int l, int r, produto P[])
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort2(a, l, m, P);
  mergesort2(a, m + 1, r, P);
  merge2(a, l, m, r, P);
}

void L(produto P[], encomenda E[], int e, int ide)
{
  itens E2[10000];
  int i;
  int j = 0;
  if ((e != E[e].N_enc) || (ide == 0))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", e);
      return;
    }
  }
  else
  {
    
  }

  for (i = 0; i < E[e].marcador; i++)
  {
    if (E[e].itens[i].qtd >= 0)
    {
      {
        E2[j].idp = E[e].itens[i].idp;
        E2[j].qtd = E[e].itens[i].qtd;
        j += 1;
      }
    }
    else
    {
      
    }

  }

  mergesort2(E2, 0, j - 1, P);
  printf("Encomenda %d\n", e);
  for (i = 0; i < j; i++)
  {
    printf("* %s %d %d\n", P[E2[i].idp].descricao, P[E2[i].idp].preco, E2[i].qtd);
  }

}

int main()
{
  int FIM = 0;
  int idp = 0;
  int ide = 0;
  int l1;
  int l2;
  int l3;
  char X;
  struct encomenda Encomenda[500];
  struct produto Padc[10000];
  X = new_sym_var(sizeof(char) * 8);
  while (FIM == 0)
  {
    switch (X)
    {
      case 'a':
        Padc[idp].indentificador = idp;
        for (int Padc_index = 0; Padc_index < 10; Padc_index++)
      {
        Padc[idp].descricao[Padc_index] = new_sym_var(sizeof(char) * 8);
      }

        Padc[idp].descricao[10 - 1] = '\0';
        Padc[idp].preco = new_sym_var(sizeof(int) * 8);
        Padc[idp].peso = new_sym_var(sizeof(int) * 8);
        Padc[idp].qtd = new_sym_var(sizeof(int) * 8);
        printf("Novo produto %d.\n", Padc[idp].indentificador);
        idp += 1;
        break;

      case 'q':
        l2 = 0;
        l1 = new_sym_var(sizeof(int) * 8);
        l2 = new_sym_var(sizeof(int) * 8);
        q(l1, l2, Padc, idp);
        break;

      case 'N':
        Encomenda[ide].N_enc = ide;
        Encomenda[ide].marcador = 0;
        printf("Nova encomenda %d.\n", Encomenda[ide].N_enc);
        ide += 1;
        break;

      case 'A':
        l1 = new_sym_var(sizeof(int) * 8);
        l2 = new_sym_var(sizeof(int) * 8);
        l3 = new_sym_var(sizeof(int) * 8);
        A(l1, l2, l3, Padc, Encomenda, ide, idp);
        break;

      case 'r':
        l1 = new_sym_var(sizeof(int) * 8);
        l2 = new_sym_var(sizeof(int) * 8);
        r(l1, l2, Padc, idp);
        break;

      case 'R':
        l1 = new_sym_var(sizeof(int) * 8);
        l2 = new_sym_var(sizeof(int) * 8);
        R(l1, l2, Encomenda, Padc, ide, idp);
        break;

      case 'C':
        l1 = new_sym_var(sizeof(int) * 8);
        C(l1, Encomenda, Padc, ide);
        break;

      case 'p':
        l1 = new_sym_var(sizeof(int) * 8);
        l2 = new_sym_var(sizeof(int) * 8);
        p(l1, l2, Padc, idp);
        break;

      case 'E':
        l1 = new_sym_var(sizeof(int) * 8);
        l2 = new_sym_var(sizeof(int) * 8);
        E(l1, l2, Padc, Encomenda, ide, idp);
        break;

      case 'm':
        l1 = new_sym_var(sizeof(int) * 8);
        m(l1, ide, Encomenda, Padc, idp);
        break;

      case 'l':
        l(Padc, idp);
        break;

      case 'L':
        l1 = new_sym_var(sizeof(int) * 8);
        L(Padc, Encomenda, l1, ide);
        break;

      case 'x':
        FIM = 1;
        break;

    }

    X = new_sym_var(sizeof(char) * 8);
  }

  return 0;
}

