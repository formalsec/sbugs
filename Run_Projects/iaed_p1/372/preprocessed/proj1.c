/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


int flag_Ll = 0;
typedef struct produto
{
  int idp;
  char desc[64];
  int preco;
  int peso;
  int qtd;
} Produto;
Produto converte(int idp, char descricao[64], int preco, int peso, int qtd)
{
  Produto produto;
  produto.idp = idp;
  strcpy(produto.desc, descricao);
  produto.preco = preco;
  produto.peso = peso;
  produto.qtd = qtd;
  return produto;
}

const char *slicing_char(char a[])
{
  char desc[64];
  char *desc_f;
  int i;
  int j = 0;
  for (i = 2; i < (64 + 2); i++)
  {
    desc[j] = a[i];
    j++;
  }

  desc_f = desc;
  return desc_f;
}

int slicing_int(char a[])
{
  int num;
  char desc[64];
  strcpy(desc, slicing_char(a));
  num = atoi(desc);
  return num;
}

void merge(Produto a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  Produto aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = a[j + 1];
  }

  if (flag_Ll == 1)
  {
    {
      for (k = l; k <= r; k++)
      {
        if ((aux[i].preco < aux[j].preco) || (j < m))
        {
          {
            a[k] = aux[i];
            i++;
          }
        }
        else
        {
          if ((aux[j].preco < aux[i].preco) || (i > m))
          {
            {
              a[k] = aux[j];
              j--;
            }
          }
          else
          {
            {
              if ((aux[i].idp < aux[j].idp) || (j < m))
              {
                {
                  a[k] = aux[i];
                  i++;
                }
              }
              else
              {
                {
                  a[k] = aux[j];
                  j--;
                }
              }

            }
          }

        }

      }

    }
  }
  else
  {
    if (flag_Ll == 2)
    {
      {
        for (k = l; k <= r; k++)
        {
          if ((strcmp(aux[i].desc, aux[j].desc) < 0) || (j < m))
          {
            {
              a[k] = aux[i];
              i++;
            }
          }
          else
          {
            {
              a[k] = aux[j];
              j--;
            }
          }

        }

      }
    }
    else
    {
      
    }

  }

}

void mergesort(Produto a[], int l, int r)
{
  int m;
  if (l < r)
  {
    {
      m = (r + l) / 2;
      mergesort(a, l, m);
      mergesort(a, m + 1, r);
      merge(a, l, m, r);
    }
  }
  else
  {
    
  }

}

void print_vetor(Produto a[], int lim)
{
  int i;
  for (i = 0; i < lim; i++)
  {
    if (flag_Ll == 1)
    {
      {
        printf("* %s %i %i\n", a[i].desc, a[i].preco, a[i].qtd);
      }
    }
    else
    {
      if ((flag_Ll == 2) && (a[i].qtd != 0))
      {
        {
          printf("* %s %i %i\n", a[i].desc, a[i].preco, a[i].qtd);
        }
      }
      else
      {
        
      }

    }

  }

}

Produto lista_enc[500][10000];
int main()
{
  int arg2;
  int arg3;
  int arg4;
  int i;
  int idp = 0;
  int id_p;
  int id_e;
  int ide = 0;
  int preco;
  int max;
  int peso;
  char arg1[64 + 2];
  char desc[64];
  char comando;
  Produto produto;
  Produto prod_enc;
  Produto lista_prod[10000];
  Produto lista_copia[10000];
  for (int arg1_index = 0; arg1_index < (64 + 2); arg1_index++)
  {
    arg1[arg1_index] = new_sym_var(sizeof(char) * 8);
  }

  arg1[(64 + 2) - 1] = '\0';
  arg2 = new_sym_var(sizeof(int) * 8);
  arg3 = new_sym_var(sizeof(int) * 8);
  arg4 = new_sym_var(sizeof(int) * 8);
  comando = arg1[0];
  while (comando != 'x')
  {
    switch (comando)
    {
      case 'a':
        strcpy(desc, slicing_char(arg1));
        produto = converte(idp, desc, arg2, arg3, arg4);
        printf("Novo produto %i.\n", idp);
        lista_prod[idp] = produto;
        idp++;
        break;

      case 'q':
        id_p = slicing_int(arg1);
        produto = lista_prod[id_p];
        if (idp <= id_p)
      {
        {
          printf("Impossivel adicionar produto %i ao stock. Produto inexistente.\n", id_p);
        }
      }
      else
      {
        {
          produto.qtd += arg2;
          lista_prod[id_p] = produto;
        }
      }

        break;

      case 'N':
        printf("Nova encomenda %i.\n", ide);
        ide++;
        break;

      case 'A':
        produto = lista_prod[arg2];
        id_e = slicing_int(arg1);
        peso = 0;
        for (i = 0; i < idp; i++)
      {
        prod_enc = lista_enc[id_e][i];
        peso += prod_enc.peso * prod_enc.qtd;
      }

        if (ide <= id_e)
      {
        {
          printf("Impossivel adicionar produto %i a encomenda %i. Encomenda inexistente.\n", arg2, id_e);
        }
      }
      else
      {
        if (idp <= arg2)
        {
          {
            printf("Impossivel adicionar produto %i a encomenda %i. Produto inexistente.\n", arg2, id_e);
          }
        }
        else
        {
          if (arg3 > produto.qtd)
          {
            {
              printf("Impossivel adicionar produto %i a encomenda %i. Quantidade em stock insuficiente.\n", arg2, id_e);
            }
          }
          else
          {
            if ((peso + (arg3 * produto.peso)) > 200)
            {
              {
                printf("Impossivel adicionar produto %i a encomenda %i. Peso da encomenda excede o maximo de 200.\n", arg2, id_e);
              }
            }
            else
            {
              if ((prod_enc = lista_enc[id_e][arg2]).qtd != 0)
              {
                {
                  prod_enc.qtd += arg3;
                  lista_enc[id_e][arg2] = prod_enc;
                  produto.qtd = produto.qtd - arg3;
                  lista_prod[arg2] = produto;
                }
              }
              else
              {
                {
                  prod_enc = converte(arg2, produto.desc, produto.preco, produto.peso, arg3);
                  lista_enc[id_e][arg2] = prod_enc;
                  produto.qtd = produto.qtd - arg3;
                  lista_prod[arg2] = produto;
                }
              }

            }

          }

        }

      }

        break;

      case 'r':
        id_p = slicing_int(arg1);
        produto = lista_prod[id_p];
        if (idp <= id_p)
      {
        {
          printf("Impossivel remover stock do produto %i. Produto inexistente.\n", id_p);
        }
      }
      else
      {
        if (produto.qtd < arg2)
        {
          {
            printf("Impossivel remover %i unidades do produto %i do stock. Quantidade insuficiente.\n", arg2, id_p);
          }
        }
        else
        {
          {
            produto.qtd -= arg2;
            lista_prod[id_p] = produto;
          }
        }

      }

        break;

      case 'R':
        id_e = slicing_int(arg1);
        if (ide <= id_e)
      {
        {
          printf("Impossivel remover produto %i a encomenda %i. Encomenda inexistente.\n", arg2, id_e);
        }
      }
      else
      {
        if (idp <= arg2)
        {
          {
            printf("Impossivel remover produto %i a encomenda %i. Produto inexistente.\n", arg2, id_e);
          }
        }
        else
        {
          {
            produto = lista_enc[id_e][arg2];
            lista_prod[arg2].qtd += produto.qtd;
            produto.qtd = 0;
            lista_enc[id_e][arg2] = produto;
          }
        }

      }

        break;

      case 'C':
        id_e = slicing_int(arg1);
        preco = 0;
        if (ide <= id_e)
      {
        {
          printf("Impossivel calcular custo da encomenda %i. Encomenda inexistente.\n", id_e);
        }
      }
      else
      {
        {
          for (i = 0; i < idp; i++)
          {
            produto = lista_enc[id_e][i];
            preco += produto.preco * produto.qtd;
          }

          printf("Custo da encomenda %i %i.\n", id_e, preco);
        }
      }

        break;

      case 'p':
        id_p = slicing_int(arg1);
        if (idp <= id_p)
      {
        {
          printf("Impossivel alterar preco do produto %i. Produto inexistente.\n", id_p);
        }
      }
      else
      {
        {
          lista_prod[id_p].preco = arg2;
          for (i = 0; i < ide; i++)
          {
            lista_enc[i][id_p].preco = arg2;
          }

        }
      }

        break;

      case 'E':
        id_e = slicing_int(arg1);
        if (ide <= id_e)
      {
        {
          printf("Impossivel listar encomenda %i. Encomenda inexistente.\n", id_e);
        }
      }
      else
      {
        if (idp <= arg2)
        {
          {
            printf("Impossivel listar produto %i. Produto inexistente.\n", arg2);
          }
        }
        else
        {
          {
            strcpy(desc, lista_prod[arg2].desc);
            printf("%s %i.\n", desc, lista_enc[id_e][arg2].qtd);
          }
        }

      }

        break;

      case 'm':
        id_p = slicing_int(arg1);
        id_e = 0;
        max = 0;
        if (idp <= id_p)
      {
        {
          printf("Impossivel listar maximo do produto %i. Produto inexistente.\n", id_p);
        }
      }
      else
      {
        {
          for (i = 0; i < ide; i++)
          {
            if ((lista_enc[i][id_p].qtd != 0) && (lista_enc[i][id_p].qtd > max))
            {
              {
                max = lista_enc[i][id_p].qtd;
                id_e = i;
              }
            }
            else
            {
              if ((lista_enc[i][id_p].qtd != 0) && (lista_enc[i][id_p].qtd == max))
              {
                {
                  if (id_e > i)
                  {
                    {
                      id_e = i;
                    }
                  }
                  else
                  {
                    
                  }

                }
              }
              else
              {
                
              }

            }

          }

          if ((max != 0) && (ide != 0))
          {
            {
              printf("Maximo produto %i %i %i.\n", id_p, id_e, max);
            }
          }
          else
          {
            
          }

        }
      }

        break;

      case 'l':
        flag_Ll = 1;
        printf("Produtos\n");
        for (i = 0; i < idp; i++)
      {
        lista_copia[i] = lista_prod[i];
      }

        mergesort(lista_copia, 0, idp - 1);
        print_vetor(lista_copia, idp);
        flag_Ll = 0;
        break;

      case 'L':
        id_e = slicing_int(arg1);
        if (ide <= id_e)
      {
        {
          printf("Impossivel listar encomenda %i. Encomenda inexistente.\n", id_e);
        }
      }
      else
      {
        {
          flag_Ll = 2;
          printf("Encomenda %i\n", id_e);
          for (i = 0; i < idp; i++)
          {
            lista_copia[i] = lista_enc[id_e][i];
          }

          mergesort(lista_copia, 0, idp - 1);
          print_vetor(lista_copia, idp);
          flag_Ll = 0;
        }
      }

        break;

    }

    for (int arg1_index = 0; arg1_index < (64 + 2); arg1_index++)
    {
      arg1[arg1_index] = new_sym_var(sizeof(char) * 8);
    }

    arg1[(64 + 2) - 1] = '\0';
    arg2 = new_sym_var(sizeof(int) * 8);
    arg3 = new_sym_var(sizeof(int) * 8);
    arg4 = new_sym_var(sizeof(int) * 8);
    comando = arg1[0];
  }

  return 0;
}

