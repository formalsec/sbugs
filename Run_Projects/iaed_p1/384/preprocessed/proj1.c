/*File generated by PreProcessor.py*/


#include <stdio.h>
#include<string.h>


typedef struct produto
{
  char descricao[64];
  int idp;
  int preco;
  int peso;
  int qtd;
  int flag;
} Produto;
Produto prod[10000];
typedef struct encomenda
{
  int cont;
  int flag;
  int peso;
  Produto encop[200];
} Encomenda;
Encomenda enco[500];
int prods;
int encos;
void case_a(int preco, int peso, int qtd)
{
  prod[prods].preco = preco;
  prod[prods].peso = peso;
  prod[prods].qtd = qtd;
  prod[prods].flag = 1;
  printf("Novo produto %d.\n", prods);
}

void case_q(int idp, int qtd)
{
  if (prod[idp].flag != 1)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    }
  }
  else
  {
    {
      prod[idp].qtd += qtd;
    }
  }

}

void case_N(int ide)
{
  printf("Nova encomenda %d.\n", ide);
  enco[encos].flag = 1;
  enco[encos].cont = 0;
}

void case_A(int ide, int idp, int qtd)
{
  if (enco[ide].flag != 1)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
  }
  else
  {
    if (prod[idp].flag != 1)
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
    }
    else
    {
      if (qtd > prod[idp].qtd)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        }
      }
      else
      {
        if (((enco[ide].peso + (prod[idp].peso * qtd)) > 200) || ((prod[idp].peso * qtd) > 200))
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          }
        }
        else
        {
          {
            int i;
            for (i = 0; i < enco[ide].cont; i++)
            {
              if (enco[ide].encop[i].idp == idp)
              {
                {
                  enco[ide].encop[i].flag = 1;
                  break;
                }
              }
              else
              {
                {
                  enco[ide].encop[i].flag = 0;
                }
              }

            }

            if (enco[ide].encop[i].flag)
            {
              {
                enco[ide].peso += prod[idp].peso * qtd;
                enco[ide].encop[i].qtd += qtd;
                prod[idp].qtd -= qtd;
              }
            }
            else
            {
              {
                enco[ide].encop[enco[ide].cont] = prod[idp];
                enco[ide].encop[enco[ide].cont].qtd = qtd;
                enco[ide].peso += prod[idp].peso * qtd;
                prod[idp].qtd -= qtd;
                enco[ide].encop[i].flag = 1;
                enco[ide].cont++;
              }
            }

          }
        }

      }

    }

  }

}

void case_r(int idp, int qtd)
{
  if (prod[idp].flag != 1)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    if (prod[idp].qtd < qtd)
    {
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
      }
    }
    else
    {
      {
        prod[idp].qtd -= qtd;
      }
    }

  }

}

void case_R(int ide, int idp)
{
  if (enco[ide].flag != 1)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
  }
  else
  {
    if (prod[idp].flag != 1)
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
    }
    else
    {
      {
        int i;
        int j;
        int in;
        for (i = 0; i < enco[ide].cont; i++)
        {
          if (enco[ide].encop[i].idp == idp)
          {
            {
              enco[ide].peso -= prod[idp].peso * enco[ide].encop[i].qtd;
              prod[idp].qtd += enco[ide].encop[i].qtd;
              in = 1;
              break;
            }
          }
          else
          {
            {
              in = 0;
            }
          }

        }

        if (in)
        {
          {
            for (j = i; j < enco[ide].cont; j++)
            {
              enco[ide].encop[j] = enco[ide].encop[j + 1];
            }

            enco[ide].cont--;
            if (enco[ide].cont < 0)
            {
              {
                enco[ide].cont = 0;
              }
            }
            else
            {
              
            }

          }
        }
        else
        {
          
        }

      }
    }

  }

}

void case_C(int ide)
{
  if (enco[ide].flag != 1)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    {
      int i = 0;
      int total = 0;
      while (enco[ide].encop[i].qtd > 0)
      {
        total += prod[enco[ide].encop[i].idp].preco * enco[ide].encop[i].qtd;
        i++;
      }

      printf("Custo da encomenda %d %d.\n", ide, total);
    }
  }

}

void case_p(int idp, int preco)
{
  if (prod[idp].flag != 1)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    {
      int i;
      int j;
      prod[idp].preco = preco;
      for (i = 0; i < encos; i++)
      {
        for (j = 0; j < enco[i].cont; j++)
        {
          if (enco[i].encop[j].idp == idp)
          {
            {
              enco[i].encop[j].preco = preco;
              break;
            }
          }
          else
          {
            
          }

        }

      }

    }
  }

}

void case_E(int ide, int idp)
{
  int a = 0;
  int i;
  if (enco[ide].flag != 1)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    if (prod[idp].flag != 1)
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      }
    }
    else
    {
      {
        for (i = 0; i < enco[ide].cont; i++)
        {
          if (enco[ide].encop[i].idp == idp)
          {
            {
              a = enco[ide].encop[i].qtd;
              break;
            }
          }
          else
          {
            
          }

        }

        printf("%s %d.\n", prod[idp].descricao, a);
      }
    }

  }

}

void case_m(int idp)
{
  if (prod[idp].flag != 1)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    }
  }
  else
  {
    {
      int maxA = 0;
      int i;
      int j;
      int m_ide;
      int in = 0;
      for (i = 0; i < encos; i++)
      {
        for (j = 0; j < enco[i].cont; j++)
        {
          if (enco[i].encop[j].idp == idp)
          {
            {
              if (maxA < enco[i].encop[j].qtd)
              {
                {
                  maxA = enco[i].encop[j].qtd;
                  m_ide = i;
                  in = 1;
                  break;
                }
              }
              else
              {
                
              }

            }
          }
          else
          {
            
          }

        }

      }

      if (in)
      {
        {
          printf("Maximo produto %d %d %d.\n", idp, m_ide, maxA);
        }
      }
      else
      {
        
      }

    }
  }

}

void copy_newprod(Produto newprod[])
{
  int i;
  for (i = 0; i < prods; i++)
  {
    newprod[i] = prod[i];
  }

}

void merge(Produto newprod[], int left, int mid, int right)
{
  int i;
  int j;
  int k;
  Produto aux[10000];
  for (i = mid + 1; i > left; i--)
  {
    aux[i - 1] = newprod[i - 1];
  }

  for (j = mid; j < right; j++)
  {
    aux[(right + mid) - j] = newprod[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if (aux[j].preco < aux[i].preco)
    {
      {
        newprod[k] = aux[j--];
      }
    }
    else
    {
      if (aux[j].preco == aux[i].preco)
      {
        {
          if (aux[j].idp < aux[i].idp)
          {
            {
              newprod[k] = aux[j--];
            }
          }
          else
          {
            {
              newprod[k] = aux[i++];
            }
          }

        }
      }
      else
      {
        {
          newprod[k] = aux[i++];
        }
      }

    }

  }

}

void mergesort(Produto newprod[], int left, int right)
{
  int mid = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(newprod, left, mid);
  mergesort(newprod, mid + 1, right);
  merge(newprod, left, mid, right);
}

void case_l()
{
  Produto newprod[10000];
  int i;
  copy_newprod(newprod);
  mergesort(newprod, 0, prods - 1);
  printf("Produtos\n");
  for (i = 0; i < prods; i++)
  {
    printf("* %s %d %d\n", newprod[i].descricao, newprod[i].preco, newprod[i].qtd);
  }

}

void bubblesort(int ide)
{
  Produto aux;
  int i;
  int j;
  for (i = 0; i < enco[ide].cont; i++)
    for (j = i + 1; j < enco[ide].cont; j++)
  {
    if (strcmp(enco[ide].encop[i].descricao, enco[ide].encop[j].descricao) > 0)
    {
      {
        aux = enco[ide].encop[i];
        enco[ide].encop[i] = enco[ide].encop[j];
        enco[ide].encop[j] = aux;
      }
    }
    else
    {
      
    }

  }


}

void case_L(int ide)
{
  if (enco[ide].flag != 1)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
  }
  else
  {
    {
      int i;
      bubblesort(ide);
      printf("Encomenda %d\n", ide);
      for (i = 0; i < enco[ide].cont; i++)
      {
        printf("* %s %d %d\n", enco[ide].encop[i].descricao, enco[ide].encop[i].preco, enco[ide].encop[i].qtd);
      }

    }
  }

}

int main()
{
  char a;
  int qtd;
  int idp = 0;
  int ide = 0;
  int preco = 0;
  while (a != 'x')
  {
    switch (a = getchar())
    {
      case 'a':
        getchar();
        for (int prod_index = 0; prod_index < 10; prod_index++)
      {
        prod[prods].descricao[prod_index] = new_sym_var(sizeof(char) * 8);
      }

        prod[prods].descricao[10 - 1] = '\0';
        prod[prods].preco = new_sym_var(sizeof(int) * 8);
        prod[prods].peso = new_sym_var(sizeof(int) * 8);
        prod[prods].qtd = new_sym_var(sizeof(int) * 8);
        case_a(prod[prods].preco, prod[prods].peso, prod[prods].qtd);
        prod[prods].idp = prods;
        prods++;
        break;

      case 'q':
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        case_q(idp, qtd);
        break;

      case 'N':
        case_N(encos);
        encos++;
        break;

      case 'A':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        case_A(ide, idp, qtd);
        break;

      case 'r':
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        case_r(idp, qtd);
        break;

      case 'R':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        case_R(ide, idp);
        break;

      case 'C':
        ide = new_sym_var(sizeof(int) * 8);
        case_C(ide);
        break;

      case 'p':
        idp = new_sym_var(sizeof(int) * 8);
        preco = new_sym_var(sizeof(int) * 8);
        case_p(idp, preco);
        break;

      case 'E':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        case_E(ide, idp);
        break;

      case 'm':
        idp = new_sym_var(sizeof(int) * 8);
        case_m(idp);
        break;

      case 'l':
        case_l();
        break;

      case 'L':
        ide = new_sym_var(sizeof(int) * 8);
        case_L(ide);
        break;

      default:
        break;

    }

  }

  return 0;
}

