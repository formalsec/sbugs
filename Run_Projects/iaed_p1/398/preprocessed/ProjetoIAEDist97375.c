/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct produto
{
  int idp;
  char descricao[63 + 1];
  int preco;
  int peso;
  int qtd;
  int Local_Enc[500];
} Produto;
typedef struct prdt_em_enc
{
  int idp;
  char descricao[63 + 1];
  int preco;
  int peso;
  int qtd_e;
} Prdt_Enc;
typedef struct encomenda
{
  int ide;
  int next_item;
  Prdt_Enc Itens[200];
} Encomenda;
Produto Stock[10000];
int next_produto = 0;
Encomenda Pedidos[500];
int next_encomenda = 0;
Produto aux[10000];
Prdt_Enc item_nulo()
{
  Prdt_Enc p;
  p.idp = -1;
  p.descricao[0] = '\0';
  p.preco = 0;
  p.peso = 0;
  p.qtd_e = 0;
  return p;
}

Produto produto_nulo()
{
  Produto p;
  int i;
  p.idp = -1;
  p.descricao[0] = '\0';
  p.preco = 0;
  p.peso = 0;
  p.qtd = 0;
  for (i = 0; i < 500; i++)
    p.Local_Enc[i] = -1;

  return p;
}

Encomenda encomenda_nula()
{
  Encomenda e;
  Prdt_Enc p;
  int i;
  e.ide = -1;
  e.next_item = -1;
  p = item_nulo();
  for (i = 0; i < 200; i++)
    e.Itens[i] = p;

  return e;
}

void Inicializar()
{
  int i;
  Encomenda e;
  Produto p;
  e = encomenda_nula();
  p = produto_nulo();
  for (i = 0; i < 10000; i++)
    Stock[i] = p;

  for (i = 0; i < 500; i++)
    Pedidos[i] = e;

  return;
}

void a_NovoProduto()
{
  Produto p;
  int i;
  for (int p_index = 0; p_index < (63 + 1); p_index++)
  {
    p.descricao[p_index] = new_sym_var(sizeof(char) * 8);
  }

  p.descricao[(63 + 1) - 1] = '\0';
  p.preco = new_sym_var(sizeof(int) * 8);
  p.peso = new_sym_var(sizeof(int) * 8);
  p.qtd = new_sym_var(sizeof(int) * 8);
  p.idp = next_produto;
  p.descricao[63] = '\0';
  for (i = 0; i < 500; i++)
    p.Local_Enc[i] = -1;

  Stock[next_produto] = p;
  printf("Novo produto %d.\n", p.idp);
  next_produto++;
  return;
}

void q_MaisStock()
{
  int idp;
  int a_adicionar;
  idp = new_sym_var(sizeof(int) * 8);
  a_adicionar = new_sym_var(sizeof(int) * 8);
  if (idp >= next_produto)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    Stock[idp].qtd += a_adicionar;
  }

  return;
}

void N_NovaEncomenda()
{
  int i;
  Encomenda e;
  Prdt_Enc p;
  e.ide = next_encomenda;
  e.next_item = 0;
  p = item_nulo();
  for (i = 0; i < 200; i++)
    e.Itens[i] = p;

  Pedidos[next_encomenda] = e;
  printf("Nova encomenda %d.\n", e.ide);
  next_encomenda++;
  return;
}

void A_MaisProdutoEnc()
{
  int i;
  int ide;
  int idp;
  int local;
  int qtd_a_adicionar;
  int size_d;
  int peso_e = 0;
  Encomenda e;
  Produto p;
  Prdt_Enc item;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd_a_adicionar = new_sym_var(sizeof(int) * 8);
  if (ide >= next_encomenda)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= next_produto)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (Stock[idp].qtd < qtd_a_adicionar)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        {
          p = Stock[idp];
          e = Pedidos[ide];
          for (i = 0; i < e.next_item; i++)
            peso_e += e.Itens[i].peso * e.Itens[i].qtd_e;

          peso_e += p.peso * qtd_a_adicionar;
          if (peso_e > 200)
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          }
          else
          {
            {
              local = p.Local_Enc[ide];
              if (local != (-1))
              {
                e.Itens[local].qtd_e += qtd_a_adicionar;
              }
              else
              {
                {
                  item = e.Itens[e.next_item];
                  size_d = strlen(p.descricao);
                  for (i = 0; i < size_d; i++)
                    item.descricao[i] = p.descricao[i];

                  item.idp = p.idp;
                  item.descricao[size_d] = '\0';
                  item.preco = p.preco;
                  item.peso = p.peso;
                  item.qtd_e = qtd_a_adicionar;
                  e.Itens[e.next_item] = item;
                  p.Local_Enc[ide] = e.next_item;
                  Stock[idp] = p;
                  e.next_item++;
                }
              }

              Stock[idp].qtd -= qtd_a_adicionar;
              Pedidos[ide] = e;
            }
          }

        }
      }

    }

  }

  return;
}

void r_MenosStock()
{
  int idp;
  int a_remover;
  idp = new_sym_var(sizeof(int) * 8);
  a_remover = new_sym_var(sizeof(int) * 8);
  if (idp >= next_produto)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (Stock[idp].qtd < a_remover)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", a_remover, idp);
    }
    else
    {
      Stock[idp].qtd -= a_remover;
    }

  }

  return;
}

void R_MenosProdutoEnc()
{
  Encomenda e;
  Prdt_Enc item;
  int ide;
  int idp;
  int i;
  int local;
  int max;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= next_encomenda)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= next_produto)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      {
        local = Stock[idp].Local_Enc[ide];
        if (local != (-1))
        {
          {
            Stock[idp].qtd += Pedidos[ide].Itens[local].qtd_e;
            e = Pedidos[ide];
            if (e.next_item == 1)
            {
              {
                item = e.Itens[0];
                Stock[item.idp].Local_Enc[ide] = -1;
                e.Itens[0] = item_nulo();
              }
            }
            else
            {
              if (local < (e.next_item - 1))
              {
                {
                  max = e.next_item - 1;
                  for (i = local; i < max; i++)
                  {
                    e.Itens[i] = e.Itens[i + 1];
                    item = e.Itens[i];
                    Stock[item.idp].Local_Enc[ide] -= 1;
                  }

                  e.Itens[max] = item_nulo();
                }
              }
              else
              {
                
              }

            }

            e.next_item--;
            Pedidos[ide] = e;
          }
        }
        else
        {
          
        }

      }
    }

  }

  return;
}

void C_CustoEncomenda()
{
  int i;
  int ide;
  int custo = 0;
  Encomenda e;
  Prdt_Enc item;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= next_encomenda)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    {
      e = Pedidos[ide];
      for (i = 0; i < e.next_item; i++)
      {
        item = e.Itens[i];
        custo += item.qtd_e * item.preco;
      }

      printf("Custo da encomenda %d %d.\n", ide, custo);
    }
  }

  return;
}

void p_AlterarPrecoPrdt()
{
  int i;
  int idp;
  int local;
  int preco_novo;
  Produto p;
  Encomenda e;
  idp = new_sym_var(sizeof(int) * 8);
  preco_novo = new_sym_var(sizeof(int) * 8);
  if (idp >= next_produto)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      Stock[idp].preco = preco_novo;
      p = Stock[idp];
      for (i = 0; i < 500; i++)
        if (p.Local_Enc[i] != (-1))
      {
        {
          e = Pedidos[i];
          local = p.Local_Enc[i];
          e.Itens[local].preco = p.preco;
          Pedidos[i] = e;
        }
      }
      else
      {
        
      }


    }
  }

  return;
}

void E_ProdutoInfoEnc()
{
  int idp;
  int ide;
  int ammnt;
  int local;
  Produto stock_p;
  Prdt_Enc p_e;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= next_encomenda)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= next_produto)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      {
        stock_p = Stock[idp];
        local = stock_p.Local_Enc[ide];
        if (local == (-1))
        {
          ammnt = 0;
        }
        else
        {
          {
            p_e = Pedidos[ide].Itens[local];
            ammnt = p_e.qtd_e;
          }
        }

        printf("%s %d.\n", Stock[idp].descricao, ammnt);
      }
    }

  }

  return;
}

void m_IdMaiorPedidoPrdt()
{
  int idp;
  int ide;
  int max = -1;
  int nr_occorencias;
  int local;
  int i;
  Produto p;
  Encomenda e;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= next_produto)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    {
      p = Stock[idp];
      for (i = 0; i < next_encomenda; i++)
      {
        local = p.Local_Enc[i];
        if (local != (-1))
        {
          {
            e = Pedidos[i];
            nr_occorencias = e.Itens[local].qtd_e;
            if (nr_occorencias > max)
            {
              {
                ide = i;
                max = nr_occorencias;
              }
            }
            else
            {
              
            }

          }
        }
        else
        {
          
        }

      }

      if (max != (-1))
      {
        printf("Maximo produto %d %d %d.\n", idp, ide, max);
      }
      else
      {
        
      }

    }
  }

  return;
}

void l_merge(Produto arr[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = arr[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = arr[j + 1];

  for (k = left; k <= right; k++)
    if ((aux[j].preco < aux[i].preco) || (i > m))
  {
    arr[k] = aux[j--];
  }
  else
  {
    arr[k] = aux[i++];
  }


  return;
}

void l_mergesort(Produto arr[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  l_mergesort(arr, left, m);
  l_mergesort(arr, m + 1, right);
  l_merge(arr, left, m, right);
}

void l_ListaPrdtPreco()
{
  Produto lista[10000];
  int i;
  for (i = 0; i < 10000; i++)
    lista[i] = Stock[i];

  l_mergesort(lista, 0, next_produto - 1);
  printf("Produtos\n");
  for (i = 0; i < next_produto; i++)
    printf(" %s %d %d\n", lista[i].descricao, lista[i].preco, lista[i].qtd);

  return;
}

void L_ListaPrdtAlfabeto()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= next_encomenda)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    return;
  }

}

int main()
{
  char comando;
  comando = new_sym_var(sizeof(char) * 8);
  Inicializar();
  while (comando != 'x')
  {
    switch (comando)
    {
      case 'a':
        a_NovoProduto();
        break;

      case 'q':
        q_MaisStock();
        break;

      case 'N':
        N_NovaEncomenda();
        break;

      case 'A':
        A_MaisProdutoEnc();
        break;

      case 'r':
        r_MenosStock();
        break;

      case 'R':
        R_MenosProdutoEnc();
        break;

      case 'C':
        C_CustoEncomenda();
        break;

      case 'p':
        p_AlterarPrecoPrdt();
        break;

      case 'E':
        E_ProdutoInfoEnc();
        break;

      case 'm':
        m_IdMaiorPedidoPrdt();
        break;

      case 'l':
        l_ListaPrdtPreco();
        break;

      case 'L':
        L_ListaPrdtAlfabeto();
        break;

    }

    comando = new_sym_var(sizeof(char) * 8);
  }

  return 0;
}

