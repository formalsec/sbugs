/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int identifier;
  char description[64];
  int price;
  int weight;
  int stock;
} Product;
typedef struct 
{
  int identifier;
  int order_stock;
  int price;
  char description[64];
} Product_resumido;
typedef struct 
{
  Product_resumido products[200];
  int total_weight;
  int total_price;
  int identifier;
  int nr_of_prod;
} Order;
void add_prod(char descrp[], int p, int w, int s);
void add_stock(int prd_id, int qtd);
void new_order();
void add_to_order(int ord_id, int prd_id, int qtd);
void remove_prd(int prd_id, int qtd);
void remove_from_ord(int ord_id, int prd_id);
void order_price(int ord_id);
void change_price(int prd_id, int price);
void list_prd(int ord_id, int prd_id);
void most_order(int prd_id);
void list_all();
void list_order(int ord_id);
void quicksort(Product_resumido list[], int left, int right, char mode);
int partition_l(Product_resumido list[], int left, int right);
int partition_L(Product_resumido list[], int left, int right);
void troca_produto(Product_resumido list_change[], int p1, int p2);
Product all_produce[10000];
Order all_orders[500];
int product_nr = 0;
int order_nr = 0;
int main()
{
  int order_id;
  int prdct_id;
  int quantity;
  int weight;
  int price;
  char command;
  char description[64];
  command = new_sym_var(sizeof(char) * 8);
  while (command != 'x')
  {
    switch (command)
    {
      case 'a':
        for (int description_index = 0; description_index < 10; description_index++)
      {
        description[description_index] = new_sym_var(sizeof(char) * 8);
      }

        description[10 - 1] = '\0';
        price = new_sym_var(sizeof(int) * 8);
        weight = new_sym_var(sizeof(int) * 8);
        quantity = new_sym_var(sizeof(int) * 8);
        add_prod(description, price, weight, quantity);
        break;

      case 'q':
        prdct_id = new_sym_var(sizeof(int) * 8);
        quantity = new_sym_var(sizeof(int) * 8);
        add_stock(prdct_id, quantity);
        break;

      case 'N':
        new_order();
        break;

      case 'A':
        order_id = new_sym_var(sizeof(int) * 8);
        prdct_id = new_sym_var(sizeof(int) * 8);
        quantity = new_sym_var(sizeof(int) * 8);
        add_to_order(order_id, prdct_id, quantity);
        break;

      case 'r':
        prdct_id = new_sym_var(sizeof(int) * 8);
        quantity = new_sym_var(sizeof(int) * 8);
        remove_prd(prdct_id, quantity);
        break;

      case 'R':
        order_id = new_sym_var(sizeof(int) * 8);
        prdct_id = new_sym_var(sizeof(int) * 8);
        remove_from_ord(order_id, prdct_id);
        break;

      case 'C':
        order_id = new_sym_var(sizeof(int) * 8);
        order_price(order_id);
        break;

      case 'p':
        prdct_id = new_sym_var(sizeof(int) * 8);
        price = new_sym_var(sizeof(int) * 8);
        change_price(prdct_id, price);
        break;

      case 'E':
        order_id = new_sym_var(sizeof(int) * 8);
        prdct_id = new_sym_var(sizeof(int) * 8);
        list_prd(order_id, prdct_id);
        break;

      case 'm':
        prdct_id = new_sym_var(sizeof(int) * 8);
        most_order(prdct_id);
        break;

      case 'l':
        list_all();
        break;

      case 'L':
        order_id = new_sym_var(sizeof(int) * 8);
        list_order(order_id);
        break;

    }

    command = new_sym_var(sizeof(char) * 8);
  }

  return 0;
}

void add_prod(char descrp[], int p, int w, int s)
{
  Product new_product;
  new_product.identifier = product_nr;
  new_product.price = p;
  new_product.weight = w;
  new_product.stock = s;
  strcpy(new_product.description, descrp);
  all_produce[product_nr] = new_product;
  product_nr++;
  printf("Novo produto %d.\n", new_product.identifier);
}

void add_stock(int prd_id, int qtd)
{
  if (product_nr <= prd_id)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", prd_id);
  }
  else
  {
    all_produce[prd_id].stock += qtd;
  }

}

void new_order()
{
  Order new_order;
  new_order.nr_of_prod = 0;
  new_order.total_weight = 0;
  new_order.total_price = 0;
  new_order.identifier = order_nr;
  all_orders[order_nr] = new_order;
  order_nr++;
  printf("Nova encomenda %d.\n", new_order.identifier);
}

void add_to_order(int ord_id, int prd_id, int qtd)
{
  int in_order = 0;
  int i = 0;
  if (order_nr <= ord_id)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", prd_id, ord_id);
  }
  else
  {
    if (product_nr <= prd_id)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", prd_id, ord_id);
    }
    else
    {
      if (all_produce[prd_id].stock < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", prd_id, ord_id);
      }
      else
      {
        if ((all_orders[ord_id].total_weight + (all_produce[prd_id].weight * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", prd_id, ord_id);
        }
        else
        {
          {
            while (i < all_orders[ord_id].nr_of_prod)
            {
              if (all_orders[ord_id].products[i].identifier == prd_id)
              {
                {
                  in_order = 1;
                  break;
                }
              }
              else
              {
                
              }

              i++;
            }

            if (in_order)
            {
              all_orders[ord_id].products[i].order_stock += qtd;
            }
            else
            {
              {
                all_orders[ord_id].products[i].identifier = prd_id;
                all_orders[ord_id].products[i].order_stock = qtd;
                all_orders[ord_id].products[i].price = all_produce[prd_id].price;
                strcpy(all_orders[ord_id].products[i].description, all_produce[prd_id].description);
                all_orders[ord_id].nr_of_prod += 1;
              }
            }

            all_orders[ord_id].total_price += all_produce[prd_id].price * qtd;
            all_orders[ord_id].total_weight += all_produce[prd_id].weight * qtd;
            remove_prd(prd_id, qtd);
          }
        }

      }

    }

  }

}

void remove_prd(int prd_id, int qtd)
{
  if (product_nr <= prd_id)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", prd_id);
  }
  else
  {
    if (all_produce[prd_id].stock < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, prd_id);
    }
    else
    {
      all_produce[prd_id].stock -= qtd;
    }

  }

}

void remove_from_ord(int ord_id, int prd_id)
{
  int i = 0;
  if (order_nr <= ord_id)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", prd_id, ord_id);
  }
  else
  {
    if (product_nr <= prd_id)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", prd_id, ord_id);
    }
    else
    {
      {
        while (i < all_orders[ord_id].nr_of_prod)
        {
          if (all_orders[ord_id].products[i].identifier == prd_id)
          {
            {
              int qtnty = all_orders[ord_id].products[i].order_stock;
              all_orders[ord_id].total_price -= all_produce[prd_id].price * qtnty;
              all_orders[ord_id].total_weight -= all_produce[prd_id].weight * qtnty;
              add_stock(prd_id, qtnty);
              all_orders[ord_id].products[i].order_stock = 0;
              break;
            }
          }
          else
          {
            
          }

          i++;
        }

      }
    }

  }

}

void order_price(int ord_id)
{
  if (order_nr <= ord_id)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ord_id);
  }
  else
  {
    {
      printf("Custo da encomenda %d %d.\n", ord_id, all_orders[ord_id].total_price);
    }
  }

}

void change_price(int prd_id, int price)
{
  int i;
  int j;
  int b4_price;
  int after_price = price;
  if (product_nr <= prd_id)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", prd_id);
  }
  else
  {
    {
      b4_price = all_produce[prd_id].price;
      all_produce[prd_id].price = price;
      for (i = 0; i < order_nr; i++)
      {
        if (all_orders[i].total_weight > 0)
        {
          {
            for (j = 0; j < all_orders[i].nr_of_prod; j++)
            {
              if (all_orders[i].products[j].identifier == prd_id)
              {
                {
                  all_orders[i].products[j].price = price;
                  all_orders[i].total_price += (after_price - b4_price) * all_orders[i].products[j].order_stock;
                }
              }
              else
              {
                
              }

            }

          }
        }
        else
        {
          
        }

      }

    }
  }

}

void list_prd(int ord_id, int prd_id)
{
  if (order_nr <= ord_id)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ord_id);
  }
  else
  {
    if (product_nr <= prd_id)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", prd_id);
    }
    else
    {
      {
        int i = 0;
        while (i < all_orders[ord_id].nr_of_prod)
        {
          if (all_orders[ord_id].products[i].identifier == prd_id)
          {
            {
              printf("%s %d.\n", all_produce[prd_id].description, all_orders[ord_id].products[i].order_stock);
              break;
            }
          }
          else
          {
            
          }

          i++;
        }

        if (i == all_orders[ord_id].nr_of_prod)
        {
          printf("%s 0.\n", all_produce[prd_id].description);
        }
        else
        {
          
        }

      }
    }

  }

}

void most_order(int prd_id)
{
  if (product_nr <= prd_id)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", prd_id);
  }
  else
  {
    {
      int i;
      int j;
      int max = 0;
      int max_id;
      for (i = 0; i < order_nr; i++)
      {
        if (all_orders[i].total_weight > 0)
        {
          {
            for (j = 0; j < all_orders[i].nr_of_prod; j++)
            {
              if ((all_orders[i].products[j].identifier == prd_id) && (all_orders[i].products[j].order_stock > max))
              {
                {
                  max = all_orders[i].products[j].order_stock;
                  max_id = i;
                  break;
                }
              }
              else
              {
                
              }

            }

          }
        }
        else
        {
          
        }

      }

      if (max > 0)
      {
        printf("Maximo produto %d %d %d.\n", prd_id, max_id, max);
      }
      else
      {
        
      }

    }
  }

}

void list_all()
{
  int i;
  Product_resumido aux_list[10000];
  for (i = 0; i < product_nr; i++)
  {
    aux_list[i].order_stock = all_produce[i].stock;
    aux_list[i].identifier = all_produce[i].identifier;
    aux_list[i].price = all_produce[i].price;
    strcpy(aux_list[i].description, all_produce[i].description);
  }

  quicksort(aux_list, 0, product_nr - 1, 'l');
  printf("Produtos\n");
  for (i = 0; i < product_nr; i++)
  {
    printf("* %s %d %d\n", aux_list[i].description, aux_list[i].price, aux_list[i].order_stock);
  }

}

void list_order(int ord_id)
{
  if (order_nr <= ord_id)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ord_id);
  }
  else
  {
    {
      int i = 0;
      quicksort(all_orders[ord_id].products, 0, all_orders[ord_id].nr_of_prod - 1, 'L');
      printf("Encomenda %d\n", ord_id);
      while (i < all_orders[ord_id].nr_of_prod)
      {
        if (all_orders[ord_id].products[i].order_stock > 0)
        {
          {
            printf("* %s %d %d\n", all_orders[ord_id].products[i].description, all_orders[ord_id].products[i].price, all_orders[ord_id].products[i].order_stock);
          }
        }
        else
        {
          
        }

        i++;
      }

    }
  }

}

void quicksort(Product_resumido list[], int left, int right, char mode)
{
  int i;
  if (right <= left)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  if (mode == 'l')
  {
    i = partition_l(list, left, right);
  }
  else
  {
    if (mode == 'L')
    {
      i = partition_L(list, left, right);
    }
    else
    {
      
    }

  }

  quicksort(list, left, i - 1, mode);
  quicksort(list, i + 1, right, mode);
}

int partition_l(Product_resumido list[], int left, int right)
{
  int i = left;
  int j = right;
  while (i < j)
  {
    while ((list[i].price < list[right].price) || ((list[i].price == list[right].price) && (list[i].identifier < list[right].identifier)))
    {
      i++;
    }

    while (((list[--j].price > list[right].price) || ((list[j].price == list[right].price) && (list[j].identifier > list[right].identifier))) && (j >= left))
      ;

    if (i < j)
    {
      {
        troca_produto(list, i, j);
        i++;
      }
    }
    else
    {
      
    }

  }

  troca_produto(list, i, right);
  return i;
}

int partition_L(Product_resumido list[], int left, int right)
{
  int i = left;
  int j = right;
  while (i < j)
  {
    while ((strcmp(list[i].description, list[right].description) < 0) || ((strcmp(list[i].description, list[right].description) == 0) && (list[i].identifier < list[right].identifier)))
    {
      i++;
    }

    while (((strcmp(list[--j].description, list[right].description) > 0) || ((strcmp(list[j].description, list[right].description) == 0) && (list[j].identifier > list[right].identifier))) && (j >= left))
      ;

    if (i < j)
    {
      {
        troca_produto(list, i, j);
        i++;
      }
    }
    else
    {
      
    }

  }

  troca_produto(list, i, right);
  return i;
}

void troca_produto(Product_resumido list_change[], int p1, int p2)
{
  Product_resumido pos_aux;
  pos_aux = list_change[p1];
  list_change[p1] = list_change[p2];
  list_change[p2] = pos_aux;
}

