/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int identifier;
  char description[63];
  int price;
  int weight;
  int quantity;
} product;
typedef struct 
{
  product ordered_products[200];
  int size;
  int weight;
} order;
product stock[10000];
order requested_orders[500];
int product_identification = 0;
int order_identification = 0;
int product_exits(int prd_id)
{
  return (prd_id < product_identification) ? (1) : (0);
}

int order_exits(int ord_id)
{
  return (ord_id < order_identification) ? (1) : (0);
}

int prod_is_inside_order(int prd_id, int ord_id)
{
  int amount_of_orders = requested_orders[ord_id].size;
  int i;
  for (i = 0; i < amount_of_orders; i++)
  {
    if (requested_orders[ord_id].ordered_products[i].identifier == prd_id)
    {
      {
        return 1;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

product aux[10000];
void merge(product *array_to_sort, int left, int middle, int right, int method)
{
  int i;
  int j;
  int k;
  for (i = middle + 1; i > left; i--)
  {
    aux[i - 1] = array_to_sort[i - 1];
  }

  for (j = middle; j < right; j++)
  {
    aux[(right + middle) - j] = array_to_sort[j + 1];
  }

  if (method == 1)
  {
    {
      for (k = left; k <= right; k++)
      {
        if ((aux[j].price < aux[i].price) || ((aux[j].price == aux[i].price) && (aux[j].identifier < aux[i].identifier)))
        {
          {
            array_to_sort[k] = aux[j--];
          }
        }
        else
        {
          {
            array_to_sort[k] = aux[i++];
          }
        }

      }

    }
  }
  else
  {
    if (method == 0)
    {
      {
        for (k = left; k <= right; k++)
        {
          if ((strcmp(aux[j].description, aux[i].description) < 0) || ((strcmp(aux[j].description, aux[i].description) == 0) && (aux[j].identifier < aux[i].identifier)))
          {
            {
              array_to_sort[k] = aux[j--];
            }
          }
          else
          {
            {
              array_to_sort[k] = aux[i++];
            }
          }

        }

      }
    }
    else
    {
      
    }

  }

}

void mergesort(product *array_to_sort, int left, int right, int method)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(array_to_sort, left, m, method);
  mergesort(array_to_sort, m + 1, right, method);
  merge(array_to_sort, left, m, right, method);
}

void creates_product()
{
  char char_input;
  product new_prod;
  int i = 0;
  char_input = getchar();
  while ((i < (63 - 1)) && ((char_input = getchar()) != ':'))
  {
    new_prod.description[i++] = char_input;
  }

  new_prod.description[i] = '\0';
  new_prod.price = new_sym_var(sizeof(int) * 8);
  new_prod.weight = new_sym_var(sizeof(int) * 8);
  new_prod.quantity = new_sym_var(sizeof(int) * 8);
  new_prod.identifier = product_identification;
  stock[product_identification] = new_prod;
  printf("Novo produto %d.\n", product_identification);
  product_identification++;
}

void adds_stock()
{
  int prd_id;
  int quantity;
  prd_id = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (!product_exits(prd_id))
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", prd_id);
    }
  }
  else
  {
    {
      stock[prd_id].quantity += quantity;
    }
  }

}

void creates_order()
{
  order new_order;
  new_order.weight = 0;
  new_order.size = 0;
  requested_orders[order_identification] = new_order;
  printf("Nova encomenda %d.\n", order_identification);
  order_identification++;
}

void adds_prod_to_order()
{
  int ord_id;
  int prd_id;
  int quantity;
  int amount_of_products;
  int index;
  int i;
  ord_id = new_sym_var(sizeof(int) * 8);
  prd_id = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (!order_exits(ord_id))
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", prd_id, ord_id);
    }
  }
  else
  {
    if (!product_exits(prd_id))
    {
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", prd_id, ord_id);
      }
    }
    else
    {
      if (quantity > stock[prd_id].quantity)
      {
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", prd_id, ord_id);
        }
      }
      else
      {
        if ((requested_orders[ord_id].weight + (quantity * stock[prd_id].weight)) > 200)
        {
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", prd_id, ord_id);
          }
        }
        else
        {
          {
            if (!prod_is_inside_order(prd_id, ord_id))
            {
              {
                index = requested_orders[ord_id].size;
                requested_orders[ord_id].ordered_products[index] = stock[prd_id];
                requested_orders[ord_id].ordered_products[index].quantity = quantity;
                requested_orders[ord_id].size++;
              }
            }
            else
            {
              {
                amount_of_products = requested_orders[ord_id].size;
                for (i = 0; i < amount_of_products; i++)
                {
                  if (requested_orders[ord_id].ordered_products[i].identifier == prd_id)
                  {
                    {
                      requested_orders[ord_id].ordered_products[i].quantity += quantity;
                      break;
                    }
                  }
                  else
                  {
                    
                  }

                }

              }
            }

            stock[prd_id].quantity -= quantity;
            requested_orders[ord_id].weight += stock[prd_id].weight * quantity;
          }
        }

      }

    }

  }

}

void removes_quantity_from_stock()
{
  int prd_id;
  int quantity;
  prd_id = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (!product_exits(prd_id))
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", prd_id);
    }
  }
  else
  {
    if ((stock[prd_id].quantity - quantity) < 0)
    {
      {
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantity, prd_id);
      }
    }
    else
    {
      {
        stock[prd_id].quantity -= quantity;
      }
    }

  }

}

void removes_product_from_order()
{
  int ord_id;
  int prd_id;
  int amount_of_products;
  product prod;
  int i;
  ord_id = new_sym_var(sizeof(int) * 8);
  prd_id = new_sym_var(sizeof(int) * 8);
  if (!order_exits(ord_id))
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", prd_id, ord_id);
    }
  }
  else
  {
    if (!product_exits(prd_id))
    {
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", prd_id, ord_id);
      }
    }
    else
    {
      {
        amount_of_products = requested_orders[ord_id].size;
        for (i = 0; i < amount_of_products; i++)
        {
          prod = requested_orders[ord_id].ordered_products[i];
          if (prod.identifier == prd_id)
          {
            {
              stock[prd_id].quantity += prod.quantity;
              requested_orders[ord_id].weight -= prod.quantity * stock[prd_id].weight;
              requested_orders[ord_id].ordered_products[i].quantity = 0;
              break;
            }
          }
          else
          {
            
          }

        }

      }
    }

  }

}

void orders_price()
{
  int ord_id;
  int total_price = 0;
  int amount_of_products;
  product prod;
  int i;
  ord_id = new_sym_var(sizeof(int) * 8);
  amount_of_products = requested_orders[ord_id].size;
  if (!order_exits(ord_id))
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ord_id);
    }
  }
  else
  {
    {
      for (i = 0; i < amount_of_products; i++)
      {
        prod = requested_orders[ord_id].ordered_products[i];
        total_price += stock[prod.identifier].price * prod.quantity;
      }

      printf("Custo da encomenda %d %d.\n", ord_id, total_price);
    }
  }

}

void changes_prod_price()
{
  int prd_id;
  int new_price;
  prd_id = new_sym_var(sizeof(int) * 8);
  new_price = new_sym_var(sizeof(int) * 8);
  if (!product_exits(prd_id))
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", prd_id);
    }
  }
  else
  {
    {
      stock[prd_id].price = new_price;
    }
  }

}

void product_desc_and_qt_inside_order()
{
  int ord_id;
  int prd_id;
  int amount_of_products;
  product prod;
  int i;
  ord_id = new_sym_var(sizeof(int) * 8);
  prd_id = new_sym_var(sizeof(int) * 8);
  amount_of_products = requested_orders[ord_id].size;
  if (!order_exits(ord_id))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ord_id);
    }
  }
  else
  {
    if (!product_exits(prd_id))
    {
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", prd_id);
      }
    }
    else
    {
      {
        for (i = 0; i < amount_of_products; i++)
        {
          prod = requested_orders[ord_id].ordered_products[i];
          if (prod.identifier == prd_id)
          {
            {
              printf("%s %d.\n", stock[prd_id].description, prod.quantity);
              return;
            }
          }
          else
          {
            
          }

        }

        printf("%s %d.\n", stock[prd_id].description, 0);
      }
    }

  }

}

void most_occurring_prod_in_order()
{
  int prd_id;
  int max[2] = {-1, -1};
  int control[2] = {-1, -1};
  int total_amount;
  product prod;
  int ord_id;
  int i;
  prd_id = new_sym_var(sizeof(int) * 8);
  if (!product_exits(prd_id))
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", prd_id);
    }
  }
  else
  {
    {
      for (ord_id = 0; ord_id < order_identification; ord_id++)
      {
        total_amount = requested_orders[ord_id].size;
        for (i = 0; i < total_amount; i++)
        {
          prod = requested_orders[ord_id].ordered_products[i];
          if ((prod.identifier == prd_id) && (prod.quantity > max[1]))
          {
            {
              max[0] = ord_id;
              max[1] = prod.quantity;
            }
          }
          else
          {
            
          }

        }

      }

      if ((memcmp(max, control, 2) != 0) && (max[1] != 0))
      {
        {
          printf("Maximo produto %d %d %d.\n", prd_id, max[0], max[1]);
        }
      }
      else
      {
        
      }

    }
  }

}

void lists_products_by_price()
{
  product array_to_sort[10000] = {0};
  int i;
  memcpy(array_to_sort, stock, sizeof(stock));
  mergesort(array_to_sort, 0, product_identification - 1, 1);
  printf("Produtos\n");
  for (i = 0; i < product_identification; i++)
  {
    printf("* %s %d %d\n", array_to_sort[i].description, array_to_sort[i].price, array_to_sort[i].quantity);
  }

}

void list_products_in_order_by_desc()
{
  int ord_id;
  int amount_of_products;
  int prod_id;
  product array_to_sort[200];
  int i;
  ord_id = new_sym_var(sizeof(int) * 8);
  if (!order_exits(ord_id))
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ord_id);
    }
  }
  else
  {
    {
      memcpy(array_to_sort, requested_orders[ord_id].ordered_products, sizeof(requested_orders[ord_id].ordered_products));
      amount_of_products = requested_orders[ord_id].size;
      mergesort(array_to_sort, 0, amount_of_products - 1, 0);
      printf("Encomenda %d\n", ord_id);
      for (i = 0; i < amount_of_products; i++)
      {
        prod_id = array_to_sort[i].identifier;
        if (array_to_sort[i].quantity != 0)
        {
          {
            printf("* %s %d %d\n", stock[prod_id].description, stock[prod_id].price, array_to_sort[i].quantity);
          }
        }
        else
        {
          
        }

      }

    }
  }

}

int main()
{
  int command;
  while ((command = getchar()) != 'x')
  {
    switch (command)
    {
      case 'a':
        creates_product();
        break;

      case 'q':
        adds_stock();
        break;

      case 'N':
        creates_order();
        break;

      case 'A':
        adds_prod_to_order();
        break;

      case 'r':
        removes_quantity_from_stock();
        break;

      case 'R':
        removes_product_from_order();
        break;

      case 'C':
        orders_price();
        break;

      case 'p':
        changes_prod_price();
        break;

      case 'E':
        ;
        product_desc_and_qt_inside_order();
        break;

      case 'm':
        most_occurring_prod_in_order();
        break;

      case 'l':
        lists_products_by_price();
        break;

      case 'L':
        list_products_in_order_by_desc();
        break;

      default:
        continue;

    }

  }

  return 0;
}

