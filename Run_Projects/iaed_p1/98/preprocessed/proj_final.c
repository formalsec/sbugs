/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  char descr[64];
  int preco;
  int peso;
  int stock;
} produto;
typedef struct 
{
  int id_prod;
  int quant;
} compra;
typedef struct 
{
  compra lista[200];
  int peso;
  int num_compras;
} encomenda;
produto sist_prods[10000];
encomenda sist_encs[500];
int prod_max;
int enc_max;
produto cria_produto(char descr[64], int preco, int peso, int stock);
encomenda cria_enc_vazia(void);
int add_produto(void);
void add_stock(void);
int add_encomenda(void);
void add_prod_encomenda(void);
void remove_stock(void);
void remove_prod_encomenda(void);
void calcula_custo_enc(void);
int qtd_prod_enc(int id_prod, int id_enc);
void change_preco(void);
void lista_info_prod(void);
void lista_prod_ordenados(void);
void lista_prod_enc_alfa(void);
int find_prod_encomenda(int id_prod, int id_enc);
void enc_max_prod(void);
void mergesort(int lista[][2], int low, int high, int modo);
void merge(int lista[][2], int low, int med, int high, int modo);
int compare(int id1, int id2, int modo);
int main()
{
  char ch_menu;
  while (1)
  {
    ch_menu = getchar();
    switch (ch_menu)
    {
      case 'a':
        add_produto();
        break;

      case 'q':
        add_stock();
        break;

      case 'N':
        add_encomenda();
        break;

      case 'A':
        add_prod_encomenda();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_prod_encomenda();
        break;

      case 'C':
        calcula_custo_enc();
        break;

      case 'p':
        change_preco();
        break;

      case 'E':
        lista_info_prod();
        break;

      case 'm':
        enc_max_prod();
        break;

      case 'l':
        lista_prod_ordenados();
        break;

      case 'L':
        lista_prod_enc_alfa();
        break;

      case 'x':
        return 0;

      default:
        break;

    }

  }

  return -1;
}

produto cria_produto(char descr[64], int preco, int peso, int stock)
{
  produto prod_aux;
  strcpy(prod_aux.descr, descr);
  prod_aux.preco = preco;
  prod_aux.peso = peso;
  prod_aux.stock = stock;
  return prod_aux;
}

encomenda cria_enc_vazia(void)
{
  encomenda enc_aux;
  enc_aux.peso = 0;
  enc_aux.num_compras = 0;
  return enc_aux;
}

int add_produto(void)
{
  char descr[64];
  int preco;
  int peso;
  int stock;
  for (int descr_index = 0; descr_index < 10; descr_index++)
  {
    descr[descr_index] = new_sym_var(sizeof(char) * 8);
  }

  descr[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  stock = new_sym_var(sizeof(int) * 8);
  sist_prods[prod_max] = cria_produto(descr, preco, peso, stock);
  printf("Novo produto %d.\n", prod_max);
  return ++prod_max;
}

void add_stock(void)
{
  int id_prod;
  int qtd;
  id_prod = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (id_prod >= prod_max)
  {
    {
      printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id_prod);
      return;
    }
  }
  else
  {
    
  }

  sist_prods[id_prod].stock += qtd;
  return;
}

int add_encomenda(void)
{
  sist_encs[enc_max] = cria_enc_vazia();
  printf("Nova encomenda %d.\n", enc_max);
  return ++enc_max;
}

int find_prod_encomenda(int id_prod, int id_enc)
{
  int i;
  encomenda enc_aux;
  enc_aux = sist_encs[id_enc];
  for (i = 0; i < enc_aux.num_compras; i++)
  {
    if (enc_aux.lista[i].id_prod == id_prod)
    {
      {
        return i;
      }
    }
    else
    {
      
    }

  }

  return -1;
}

void add_prod_encomenda(void)
{
  int id_enc;
  int id_prod;
  int qtd;
  int novo_peso;
  int indice;
  encomenda enc_aux;
  produto prod_aux;
  id_enc = new_sym_var(sizeof(int) * 8);
  id_prod = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (id_enc >= enc_max)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id_prod, id_enc);
      return;
    }
  }
  else
  {
    
  }

  if (id_prod >= prod_max)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id_prod, id_enc);
      return;
    }
  }
  else
  {
    
  }

  if (qtd > sist_prods[id_prod].stock)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_prod, id_enc);
      return;
    }
  }
  else
  {
    
  }

  enc_aux = sist_encs[id_enc];
  prod_aux = sist_prods[id_prod];
  novo_peso = enc_aux.peso + (qtd * prod_aux.peso);
  if (novo_peso > 200)
  {
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de %d.\n", id_prod, id_enc, 200);
      return;
    }
  }
  else
  {
    
  }

  indice = find_prod_encomenda(id_prod, id_enc);
  if (indice != (-1))
  {
    {
      sist_encs[id_enc].lista[indice].quant += qtd;
    }
  }
  else
  {
    {
      enc_aux = sist_encs[id_enc];
      sist_encs[id_enc].lista[enc_aux.num_compras].id_prod = id_prod;
      sist_encs[id_enc].lista[enc_aux.num_compras].quant = qtd;
      sist_encs[id_enc].num_compras++;
    }
  }

  sist_prods[id_prod].stock -= qtd;
  sist_encs[id_enc].peso = novo_peso;
  return;
}

void remove_stock(void)
{
  int id_prod;
  int qtd;
  id_prod = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (id_prod >= prod_max)
  {
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id_prod);
      return;
    }
  }
  else
  {
    
  }

  if (qtd > sist_prods[id_prod].stock)
  {
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, id_prod);
      return;
    }
  }
  else
  {
    
  }

  sist_prods[id_prod].stock -= qtd;
  return;
}

void remove_prod_encomenda(void)
{
  int id_prod;
  int id_enc;
  int indice;
  int qtd;
  id_enc = new_sym_var(sizeof(int) * 8);
  id_prod = new_sym_var(sizeof(int) * 8);
  if (id_enc >= enc_max)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id_prod, id_enc);
      return;
    }
  }
  else
  {
    
  }

  if (id_prod >= prod_max)
  {
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_prod, id_enc);
      return;
    }
  }
  else
  {
    
  }

  indice = find_prod_encomenda(id_prod, id_enc);
  if (indice != (-1))
  {
    {
      qtd = sist_encs[id_enc].lista[indice].quant;
      sist_encs[id_enc].lista[indice].quant = 0;
      sist_encs[id_enc].peso -= sist_prods[id_prod].peso * qtd;
      sist_prods[id_prod].stock += qtd;
    }
  }
  else
  {
    
  }

  return;
}

void calcula_custo_enc(void)
{
  encomenda enc_aux;
  compra compra_aux;
  produto prod_aux;
  int i;
  int id_enc;
  int total = 0;
  id_enc = new_sym_var(sizeof(int) * 8);
  if (id_enc >= enc_max)
  {
    {
      printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", id_enc);
      return;
    }
  }
  else
  {
    
  }

  enc_aux = sist_encs[id_enc];
  for (i = 0; i < enc_aux.num_compras; i++)
  {
    compra_aux = enc_aux.lista[i];
    prod_aux = sist_prods[compra_aux.id_prod];
    total += prod_aux.preco * compra_aux.quant;
  }

  printf("Custo da encomenda %d %d.\n", id_enc, total);
  return;
}

void change_preco(void)
{
  int preco;
  int id_prod;
  id_prod = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (id_prod >= prod_max)
  {
    {
      printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id_prod);
      return;
    }
  }
  else
  {
    
  }

  sist_prods[id_prod].preco = preco;
  return;
}

void lista_info_prod(void)
{
  encomenda enc_aux;
  compra compra_aux;
  produto prod_aux;
  int id_prod;
  int id_enc;
  int indice;
  id_enc = new_sym_var(sizeof(int) * 8);
  id_prod = new_sym_var(sizeof(int) * 8);
  if (id_enc >= enc_max)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_enc);
      return;
    }
  }
  else
  {
    
  }

  if (id_prod >= prod_max)
  {
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", id_prod);
      return;
    }
  }
  else
  {
    
  }

  indice = find_prod_encomenda(id_prod, id_enc);
  prod_aux = sist_prods[id_prod];
  if (indice != (-1))
  {
    {
      enc_aux = sist_encs[id_enc];
      compra_aux = enc_aux.lista[indice];
      printf("%s %d.\n", prod_aux.descr, compra_aux.quant);
    }
  }
  else
  {
    {
      printf("%s %d.\n", prod_aux.descr, 0);
    }
  }

  return;
}

void enc_max_prod(void)
{
  int id_prod;
  int id_enc;
  int qtd;
  int id_enc_max = 0;
  int qtd_max = 0;
  id_prod = new_sym_var(sizeof(int) * 8);
  if (id_prod >= prod_max)
  {
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id_prod);
      return;
    }
  }
  else
  {
    
  }

  for (id_enc = 0; id_enc < enc_max; id_enc++)
  {
    qtd = qtd_prod_enc(id_prod, id_enc);
    if (qtd > qtd_max)
    {
      {
        qtd_max = qtd;
        id_enc_max = id_enc;
      }
    }
    else
    {
      
    }

  }

  if (qtd_max == 0)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", id_prod, id_enc_max, qtd_max);
  return;
}

int qtd_prod_enc(int id_prod, int id_enc)
{
  encomenda enc_aux;
  compra compra_aux;
  int i;
  enc_aux = sist_encs[id_enc];
  for (i = 0; i < enc_aux.num_compras; i++)
  {
    compra_aux = enc_aux.lista[i];
    if (compra_aux.id_prod == id_prod)
    {
      {
        return compra_aux.quant;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

void mergesort(int lista[][2], int low, int high, int modo)
{
  int med = (low + high) / 2;
  if (high <= low)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  mergesort(lista, low, med, modo);
  mergesort(lista, med + 1, high, modo);
  merge(lista, low, med, high, modo);
  return;
}

void merge(int lista[][2], int low, int med, int high, int modo)
{
  int aux[10000][2];
  int i;
  int j;
  int k;
  int status;
  for (i = med + 1; i > low; i--)
  {
    aux[i - 1][0] = lista[i - 1][0];
    aux[i - 1][1] = lista[i - 1][1];
  }

  for (j = med; j < high; j++)
  {
    aux[(high + med) - j][0] = lista[j + 1][0];
    aux[(high + med) - j][1] = lista[j + 1][1];
  }

  for (k = low; k <= high; k++)
  {
    status = compare(aux[j][0], aux[i][0], modo);
    if (status < 0)
    {
      {
        lista[k][0] = aux[j][0];
        lista[k][1] = aux[j][1];
        j--;
      }
    }
    else
    {
      if (status == 0)
      {
        {
          if (aux[j][0] < aux[i][0])
          {
            {
              lista[k][0] = aux[j][0];
              lista[k][1] = aux[j][1];
              j--;
            }
          }
          else
          {
            {
              lista[k][0] = aux[i][0];
              lista[k][1] = aux[i][1];
              i++;
            }
          }

        }
      }
      else
      {
        {
          lista[k][0] = aux[i][0];
          lista[k][1] = aux[i][1];
          i++;
        }
      }

    }

  }

  return;
}

int compare(int id1, int id2, int modo)
{
  produto prod1 = sist_prods[id1];
  produto prod2 = sist_prods[id2];
  if (modo == 0)
  {
    {
      if (prod1.preco < prod2.preco)
      {
        {
          return -1;
        }
      }
      else
      {
        if (prod1.preco == prod2.preco)
        {
          {
            return 0;
          }
        }
        else
        {
          {
            return 1;
          }
        }

      }

    }
  }
  else
  {
    {
      if (strcmp(prod1.descr, prod2.descr) < 0)
      {
        {
          return -1;
        }
      }
      else
      {
        if (strcmp(prod1.descr, prod2.descr) == 0)
        {
          {
            return 0;
          }
        }
        else
        {
          {
            return 1;
          }
        }

      }

    }
  }

}

void lista_prod_ordenados(void)
{
  int lista[10000][2];
  int i;
  produto prod_aux;
  printf("Produtos\n");
  for (i = 0; i < prod_max; i++)
  {
    lista[i][0] = i;
  }

  mergesort(lista, 0, prod_max - 1, 0);
  for (i = 0; i < prod_max; i++)
  {
    prod_aux = sist_prods[lista[i][0]];
    printf("* %s %d %d\n", prod_aux.descr, prod_aux.preco, prod_aux.stock);
  }

  return;
}

void lista_prod_enc_alfa(void)
{
  int id_enc;
  int i;
  int qtd;
  int lista[200][2];
  encomenda enc_aux;
  produto prod_aux;
  id_enc = new_sym_var(sizeof(int) * 8);
  if (id_enc >= enc_max)
  {
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_enc);
      return;
    }
  }
  else
  {
    
  }

  enc_aux = sist_encs[id_enc];
  for (i = 0; i < enc_aux.num_compras; i++)
  {
    lista[i][0] = enc_aux.lista[i].id_prod;
    lista[i][1] = enc_aux.lista[i].quant;
  }

  mergesort(lista, 0, enc_aux.num_compras - 1, 1);
  printf("Encomenda %d\n", id_enc);
  for (i = 0; i < enc_aux.num_compras; i++)
  {
    prod_aux = sist_prods[lista[i][0]];
    qtd = lista[i][1];
    if (qtd > 0)
    {
      {
        printf("* %s %d %d\n", prod_aux.descr, prod_aux.preco, qtd);
      }
    }
    else
    {
      
    }

  }

  return;
}

