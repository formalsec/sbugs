/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct equipa
{
  char *nome;
  int vitorias;
} *pEquipa;
typedef struct jogo
{
  char *nome_jogo;
  char *equipa1;
  char *equipa2;
  unsigned int score1;
  unsigned int score2;
} *pJogo;
typedef struct node_equipa
{
  pEquipa e;
  struct node_equipa *next;
} *link_equipa;
typedef struct node_jogo
{
  pJogo j;
  struct node_jogo *next;
} *link_jogo;
link_equipa *heads_equipa;
link_jogo *heads_jogo;
int hash_code(char *v)
{
  int h;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*v) != '\0'; v++, a = (a * b) % (1069 - 1))
  {
    h = ((a * h) + (*v)) % 1069;
  }

  return h;
}

void init_hash_table_equipas()
{
  int i;
  heads_equipa = (link_equipa *) malloc(1069 * (sizeof(link_equipa)));
  for (i = 0; i < 1069; i++)
  {
    heads_equipa[i] = 0;
  }

}

void init_hash_table_jogos()
{
  int i;
  heads_jogo = (link_jogo *) malloc(1069 * (sizeof(link_jogo)));
  for (i = 0; i < 1069; i++)
  {
    heads_jogo[i] = 0;
  }

}

link_equipa NEW_equipa(char *buffer)
{
  link_equipa x = (link_equipa) malloc(sizeof(struct node_equipa));
  x->e = (pEquipa) malloc(sizeof(struct equipa));
  x->e->nome = (char *) malloc(strlen(buffer) + 1);
  strcpy(x->e->nome, buffer);
  x->e->vitorias = 0;
  return x;
}

link_jogo NEW_jogo(char *nome_jogo, char *equipa1, char *equipa2, int score1, int score2)
{
  link_jogo x = (link_jogo) malloc(sizeof(struct node_jogo));
  x->j = (pJogo) malloc(sizeof(struct jogo));
  x->j->nome_jogo = (char *) malloc(strlen(nome_jogo) + 1);
  x->j->equipa1 = (char *) malloc(strlen(equipa1) + 1);
  x->j->equipa2 = (char *) malloc(strlen(equipa2) + 1);
  strcpy(x->j->nome_jogo, nome_jogo);
  strcpy(x->j->equipa1, equipa1);
  strcpy(x->j->equipa2, equipa2);
  x->j->score1 = score1;
  x->j->score2 = score2;
  return x;
}

void insert_tab_equipas(char *nome, int ed, int equipas[100000])
{
  equipas[ed] = hash_code(nome);
  return;
}

void insert_tab_jogos(char *nome_jogo, int id, int jogos[100000])
{
  jogos[id] = hash_code(nome_jogo);
  return;
}

link_equipa insertBegin_equipa(link_equipa head, char *nome, int ed, int equipas[100000])
{
  link_equipa x = NEW_equipa(nome);
  insert_tab_equipas(nome, ed, equipas);
  x->next = head;
  return x;
}

link_jogo insertBegin_jogo(link_jogo head, char *nome_jogo, char *equipa1, char *equipa2, int score1, int score2, int id, int jogos[100000])
{
  link_jogo x = NEW_jogo(nome_jogo, equipa1, equipa2, score1, score2);
  insert_tab_jogos(nome_jogo, id, jogos);
  x->next = head;
  return x;
}

link_equipa searchList_equipa(link_equipa head, char *nome)
{
  link_equipa x;
  for (x = head; x != 0; x = x->next)
  {
    if (strcmp(x->e->nome, nome) == 0)
    {
      {
        return x;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

link_jogo searchList_jogo(link_jogo head, char *nome)
{
  link_jogo x;
  for (x = head; x != 0; x = x->next)
  {
    if (strcmp(x->j->nome_jogo, nome) == 0)
    {
      {
        return x;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

void insert_equipa(char *nome, int ed, int equipas[100000])
{
  int i = hash_code(nome);
  heads_equipa[i] = insertBegin_equipa(heads_equipa[i], nome, ed, equipas);
}

void insert_jogo(char *nome_jogo, char *equipa1, char *equipa2, int score1, int score2, int id, int jogos[100000])
{
  int i = hash_code(nome_jogo);
  heads_jogo[i] = insertBegin_jogo(heads_jogo[i], nome_jogo, equipa1, equipa2, score1, score2, id, jogos);
}

link_jogo delete(link_jogo head, char *nome_jogo)
{
  link_jogo t;
  link_jogo prev;
  for (t = head, prev = 0; t != 0; prev = t, t = t->next)
  {
    if (strcmp(t->j->nome_jogo, nome_jogo) == 0)
    {
      {
        if (t == head)
        {
          head = t->next;
        }
        else
        {
          prev->next = t->next;
        }

        free(t->j);
        free(t);
      }
    }
    else
    {
      
    }

  }

  return head;
}

link_equipa procura_equipa(char *nome)
{
  int i = hash_code(nome);
  return searchList_equipa(heads_equipa[i], nome);
}

link_jogo procura_jogo(char *nome_jogo)
{
  int i = hash_code(nome_jogo);
  return searchList_jogo(heads_jogo[i], nome_jogo);
}

void delete_tab_jogos(char *nome_jogo, int id, int jogos[100000])
{
  int e;
  for (e = 0; e < id; e++)
  {
    if (jogos[e] == hash_code(nome_jogo))
    {
      {
        jogos[e] = 0;
        return;
      }
    }
    else
    {
      
    }

  }

  return;
}

void delete_jogo(char *nome_jogo, int id, int jogos[100000])
{
  int i = hash_code(nome_jogo);
  delete_tab_jogos(nome_jogo, id, jogos);
  heads_jogo[i] = delete(heads_jogo[i], nome_jogo);
}

void A(int cont, int ed, int equipas[100000])
{
  char equipa[1024];
  for (int equipa_index = 0; equipa_index < 10; equipa_index++)
  {
    equipa[equipa_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa[10 - 1] = '\0';
  if (procura_equipa(equipa) == 0)
  {
    {
      insert_equipa(equipa, ed, equipas);
      return;
    }
  }
  else
  {
    {
      printf("%d Equipa existente.\n", cont);
      return;
    }
  }

}

void P(int cont)
{
  char equipa[1024];
  for (int equipa_index = 0; equipa_index < 10; equipa_index++)
  {
    equipa[equipa_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa[10 - 1] = '\0';
  if (procura_equipa(equipa) != 0)
  {
    {
      printf("%d %s %d\n", cont, equipa, heads_equipa[hash_code(equipa)]->e->vitorias);
      return;
    }
  }
  else
  {
    {
      printf("%d Equipa inexistente.\n", cont);
      return;
    }
  }

}

void add_vitoria(char *equipa1, char *equipa2, int score1, int score2)
{
  if (score1 > score2)
  {
    {
      heads_equipa[hash_code(equipa1)]->e->vitorias++;
      return;
    }
  }
  else
  {
    if (score2 > score1)
    {
      {
        heads_equipa[hash_code(equipa2)]->e->vitorias++;
        return;
      }
    }
    else
    {
      {
        return;
      }
    }

  }

}

void a(int cont, int id, int jogos[100000])
{
  char jogo[1024];
  char equipa1[1024];
  char equipa2[1024];
  int score1;
  int score2;
  for (int jogo_index = 0; jogo_index < 10; jogo_index++)
  {
    jogo[jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  jogo[10 - 1] = '\0';
  for (int equipa1_index = 0; equipa1_index < 10; equipa1_index++)
  {
    equipa1[equipa1_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa1[10 - 1] = '\0';
  for (int equipa2_index = 0; equipa2_index < 10; equipa2_index++)
  {
    equipa2[equipa2_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  if (procura_jogo(jogo) != 0)
  {
    {
      printf("%d Jogo existente.\n", cont);
      return;
    }
  }
  else
  {
    if ((procura_equipa(equipa1) == 0) || (procura_equipa(equipa2) == 0))
    {
      {
        printf("%d Equipa inexistente.\n", cont);
        return;
      }
    }
    else
    {
      {
        insert_jogo(jogo, equipa1, equipa2, score1, score2, id, jogos);
        add_vitoria(equipa1, equipa2, score1, score2);
        return;
      }
    }

  }

}

void p(int cont)
{
  char jogo[1024];
  for (int jogo_index = 0; jogo_index < 10; jogo_index++)
  {
    jogo[jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  jogo[10 - 1] = '\0';
  if (procura_jogo(jogo) != 0)
  {
    {
      printf("%d %s %s %s %d %d\n", cont, jogo, heads_jogo[hash_code(jogo)]->j->equipa1, heads_jogo[hash_code(jogo)]->j->equipa2, heads_jogo[hash_code(jogo)]->j->score1, heads_jogo[hash_code(jogo)]->j->score2);
      return;
    }
  }
  else
  {
    {
      printf("%d Jogo inexistente.\n", cont);
      return;
    }
  }

}

void muda_vitoria(char *equipa1, char *equipa2, int score1, int score2)
{
  if ((score1 > score2) && (score2 > 0))
  {
    {
      heads_equipa[hash_code(equipa1)]->e->vitorias++;
      heads_equipa[hash_code(equipa2)]->e->vitorias--;
      return;
    }
  }
  else
  {
    if ((score2 > score1) && (score1 > 0))
    {
      {
        heads_equipa[hash_code(equipa2)]->e->vitorias++;
        heads_equipa[hash_code(equipa1)]->e->vitorias--;
        return;
      }
    }
    else
    {
      {
        return;
      }
    }

  }

}

void s(int cont)
{
  char jogo[1024];
  int score1;
  int score2;
  for (int jogo_index = 0; jogo_index < 10; jogo_index++)
  {
    jogo[jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  jogo[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  if (procura_jogo(jogo) != 0)
  {
    {
      heads_jogo[hash_code(jogo)]->j->score1 = score1;
      heads_jogo[hash_code(jogo)]->j->score2 = score2;
      muda_vitoria(heads_jogo[hash_code(jogo)]->j->equipa1, heads_jogo[hash_code(jogo)]->j->equipa2, score1, score2);
      return;
    }
  }
  else
  {
    {
      printf("%d Jogo inexistente.\n", cont);
      return;
    }
  }

}

void tira_vitoria(char *equipa1, char *equipa2, int score1, int score2)
{
  if (score1 > score2)
  {
    {
      heads_equipa[hash_code(equipa1)]->e->vitorias--;
      return;
    }
  }
  else
  {
    if (score2 > score1)
    {
      {
        heads_equipa[hash_code(equipa2)]->e->vitorias--;
        return;
      }
    }
    else
    {
      {
        return;
      }
    }

  }

}

void r(int cont, int id, int jogos[100000])
{
  char jogo[1024];
  for (int jogo_index = 0; jogo_index < 10; jogo_index++)
  {
    jogo[jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  jogo[10 - 1] = '\0';
  if (procura_jogo(jogo) == 0)
  {
    {
      printf("%d Jogo inexistente.\n", cont);
      return;
    }
  }
  else
  {
    {
      tira_vitoria(heads_jogo[hash_code(jogo)]->j->equipa1, heads_jogo[hash_code(jogo)]->j->equipa2, heads_jogo[hash_code(jogo)]->j->score1, heads_jogo[hash_code(jogo)]->j->score2);
      delete_jogo(jogo, id, jogos);
      return;
    }
  }

}

void l(int cont, int id, int jogos[100000])
{
  int e;
  for (e = 0; e < id; e++)
  {
    if (jogos[e] != 0)
    {
      {
        printf("%d %s %s %s %d %d\n", cont, heads_jogo[jogos[e]]->j->nome_jogo, heads_jogo[jogos[e]]->j->equipa1, heads_jogo[jogos[e]]->j->equipa2, heads_jogo[jogos[e]]->j->score1, heads_jogo[jogos[e]]->j->score2);
      }
    }
    else
    {
      
    }

  }

  return;
}

int compare(const void *a, const void *b)
{
  const char **ia = (const char **) a;
  const char **ib = (const char **) b;
  return strcmp(*ia, *ib);
}

void g(int cont, int ed, int equipas[100000])
{
  int e;
  int i = 0;
  char winners[100][1024];
  int maior_vitorias = 0;
  for (e = 0; e < ed; e++)
  {
    if (heads_equipa[equipas[e]]->e->vitorias > maior_vitorias)
    {
      {
        maior_vitorias = heads_equipa[equipas[e]]->e->vitorias;
      }
    }
    else
    {
      
    }

  }

  if (maior_vitorias == 0)
  {
    {
      return;
    }
  }
  else
  {
    
  }

  for (e = 0; e < ed; e++)
  {
    if ((heads_equipa[equipas[e]]->e->vitorias == maior_vitorias) && (maior_vitorias != 0))
    {
      {
        strcpy(winners[i], heads_equipa[equipas[e]]->e->nome);
        i++;
      }
    }
    else
    {
      
    }

  }

  qsort(winners, 1, sizeof(char *), compare);
  printf("%d Melhores numero-de-jogos-ganhos\n", cont);
  for (e = 0; e < i; e++)
  {
    printf("%d * %s\n", cont, winners[e]);
  }

  return;
}

int main()
{
  int carater;
  int cont = 1;
  int jogos[100000];
  int id = 0;
  int equipas[100000];
  int ed = 0;
  init_hash_table_equipas();
  init_hash_table_jogos();
  while ((carater = getchar()) != EOF)
  {
    switch (carater)
    {
      case 'a':
      {
        a(cont, id, jogos);
        cont++;
        id++;
        break;
      }

      case 'l':
      {
        l(cont, id, jogos);
        cont++;
        break;
      }

      case 'p':
      {
        p(cont);
        cont++;
        break;
      }

      case 'r':
      {
        r(cont, id, jogos);
        cont++;
        break;
      }

      case 's':
      {
        s(cont);
        cont++;
        break;
      }

      case 'A':
      {
        A(cont, ed, equipas);
        cont++;
        ed++;
        break;
      }

      case 'P':
      {
        P(cont);
        cont++;
        break;
      }

      case 'g':
      {
        g(cont, ed, equipas);
        cont++;
        break;
      }
        free(heads_equipa);
        free(heads_jogo);

    }

  }

  return 0;
}

