/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "hashTables.h"


typedef Team *Item;
TeamsHash *expandT(TeamsHash *HashT)
{
  TeamsHash *new_HashT;
  int new_size = HashT->size * 2;
  new_HashT = initTeamsHash(new_size);
  copy_elementsT(new_HashT, HashT);
  free(HashT->headsT);
  free(HashT);
  return new_HashT;
}

GamesHash *expandG(GamesHash *HashG)
{
  GamesHash *new_HashG;
  int new_size = HashG->size * 2;
  new_HashG = initGamesHash(new_size);
  copy_elementsG(new_HashG, HashG);
  free(HashG->headsG);
  free(HashG);
  return new_HashG;
}

void copy_elementsT(TeamsHash *new_Hash, TeamsHash *old_Hash)
{
  int i;
  int new_i;
  teamNodeP x;
  teamNodeP prev;
  for (i = 0; i < old_Hash->size; i++)
  {
    for (x = old_Hash->headsT[i]; (x != 0) && (x->next != 0); x = x->next)
      ;

    if (x != 0)
    {
      {
        for (prev = x->prev; prev != 0; x = prev, prev = prev->prev)
        {
          new_i = hashU(x->team->name, new_Hash->size);
          prev->next = 0;
          x->prev = 0;
          new_Hash = addTeam(new_Hash, new_i, x);
        }

        new_i = hashU(x->team->name, new_Hash->size);
        new_Hash = addTeam(new_Hash, new_i, x);
      }
    }
    else
    {
      
    }

  }

}

void copy_elementsG(GamesHash *new_Hash, GamesHash *old_Hash)
{
  int i;
  int new_i;
  gameNodeP x;
  gameNodeP prev;
  for (i = 0; i < old_Hash->size; i++)
  {
    for (x = old_Hash->headsG[i]; (x != 0) && (x->nextH != 0); x = x->nextH)
      ;

    if (x != 0)
    {
      {
        for (prev = x->prevH; prev != 0; x = prev, prev = prev->prevH)
        {
          new_i = hashU(x->game->name, new_Hash->size);
          prev->nextH = 0;
          x->prevH = 0;
          new_Hash = addGameHash(new_Hash, new_i, x);
        }

        new_i = hashU(x->game->name, new_Hash->size);
        new_Hash = addGameHash(new_Hash, new_i, x);
      }
    }
    else
    {
      
    }

  }

}

TeamsHash *initTeamsHash(int M)
{
  int i;
  TeamsHash *Hash;
  teamNodeP *heads;
  Hash = (TeamsHash *) malloc(sizeof(TeamsHash));
  heads = (teamNodeP *) malloc((sizeof(teamNodeP)) * M);
  for (i = 0; i < M; i++)
  {
    heads[i] = 0;
  }

  Hash->headsT = heads;
  Hash->n_elements = 0;
  Hash->size = M;
  return Hash;
}

GamesHash *initGamesHash(int M)
{
  int i;
  GamesHash *Hash;
  gameNodeP *heads;
  Hash = (GamesHash *) malloc(sizeof(GamesHash));
  heads = (gameNodeP *) malloc((sizeof(gameNodeP)) * M);
  for (i = 0; i < M; i++)
  {
    heads[i] = 0;
  }

  Hash->headsG = heads;
  Hash->n_elements = 0;
  Hash->size = M;
  return Hash;
}

int verifyExistentTeam(TeamsHash *HashT, char *name)
{
  teamNodeP *headsT = HashT->headsT;
  int i = hashU(name, HashT->size);
  if (headsT[i] != 0)
  {
    {
      teamNodeP x;
      for (x = headsT[i]; x != 0; x = x->next)
      {
        if (strcmp(x->team->name, name) == 0)
        {
          {
            return -1;
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    
  }

  return i;
}

int verifyExistentGame(GamesHash *HashG, char *name)
{
  gameNodeP *headsG = HashG->headsG;
  int i = hashU(name, HashG->size);
  if (headsG[i] != 0)
  {
    {
      gameNodeP x;
      for (x = headsG[i]; x != 0; x = x->nextH)
      {
        if (strcmp(x->game->name, name) == 0)
        {
          {
            return -1;
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    
  }

  return i;
}

TeamsHash *addTeam(TeamsHash *HashT, int i, TeamNode *eq)
{
  int load_factor = HashT->n_elements / HashT->size;
  if (load_factor >= 1)
  {
    {
      HashT = expandT(HashT);
      i = hashU(eq->team->name, HashT->size);
    }
  }
  else
  {
    
  }

  HashT->headsT[i] = insertBeginT(HashT->headsT[i], eq);
  HashT->n_elements++;
  return HashT;
}

teamNodeP insertBeginT(teamNodeP head, teamNodeP eq)
{
  if (head != 0)
  {
    {
      head->prev = eq;
    }
  }
  else
  {
    
  }

  eq->next = head;
  return eq;
}

GamesHash *addGameHash(GamesHash *HashG, int i, gameNodeP game)
{
  int load_factor = HashG->n_elements / HashG->size;
  if (load_factor >= 1)
  {
    {
      HashG = expandG(HashG);
      i = hashU(game->game->name, HashG->size);
    }
  }
  else
  {
    
  }

  HashG->headsG[i] = insertBeginG(HashG->headsG[i], game);
  HashG->n_elements++;
  return HashG;
}

gameNodeP insertBeginG(gameNodeP head, gameNodeP game)
{
  if (head != 0)
  {
    {
      head->prevH = game;
    }
  }
  else
  {
    
  }

  game->nextH = head;
  return game;
}

Team *searchTeam(TeamsHash *HashT, char *name)
{
  teamNodeP *headsT = HashT->headsT;
  int i = hashU(name, HashT->size);
  return searchListT(headsT[i], name);
}

Team *searchListT(teamNodeP head, char *name)
{
  if (head != 0)
  {
    {
      teamNodeP x;
      for (x = head; x != 0; x = x->next)
      {
        if (strcmp(x->team->name, name) == 0)
        {
          {
            return x->team;
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    
  }

  return 0;
}

Game *searchGame(GamesHash *HashG, char *name)
{
  gameNodeP *headsG = HashG->headsG;
  int i = hashU(name, HashG->size);
  return searchListG(headsG[i], name);
}

Game *searchListG(gameNodeP head, char *name)
{
  if (head != 0)
  {
    {
      gameNodeP x;
      for (x = head; x != 0; x = x->nextH)
      {
        if (strcmp(x->game->name, name) == 0)
        {
          {
            return x->game;
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    
  }

  return 0;
}

void deleteGame(gameListP gameList, GamesHash *HashG, char *name)
{
  int i = hashU(name, HashG->size);
  gameNodeP x;
  gameNodeP prev;
  gameNodeP *headsG = HashG->headsG;
  for (x = headsG[i], prev = 0; x != 0; prev = x, x = x->nextH)
  {
    if (strcmp(x->game->name, name) == 0)
    {
      {
        if (x == headsG[i])
        {
          {
            headsG[i] = x->nextH;
            if (headsG[i] != 0)
            {
              {
                headsG[i]->prevH = 0;
              }
            }
            else
            {
              
            }

          }
        }
        else
        {
          {
            prev->nextH = x->nextH;
            if (prev->nextH != 0)
            {
              {
                prev->nextH->prevH = prev;
              }
            }
            else
            {
              
            }

          }
        }

        deleteGameList(gameList, name);
        free(x->game->name);
        free(x->game);
        free(x);
        break;
      }
    }
    else
    {
      
    }

  }

  HashG->n_elements--;
}

void deleteGameList(gameListP gameList, char *name)
{
  gameNodeP x;
  gameNodeP prev;
  for (x = gameList->head, prev = 0; x != 0; prev = x, x = x->nextL)
  {
    if (strcmp(x->game->name, name) == 0)
    {
      {
        if (x == gameList->head)
        {
          {
            gameList->head = x->nextL;
            if (gameList->head != 0)
            {
              {
                gameList->head->previous = 0;
              }
            }
            else
            {
              
            }

          }
        }
        else
        {
          {
            prev->nextL = x->nextL;
            if (x == gameList->last)
            {
              {
                gameList->last = prev;
              }
            }
            else
            {
              {
                x->nextL->previous = prev;
              }
            }

          }
        }

        break;
      }
    }
    else
    {
      
    }

  }

}

void changeScores(GamesHash *HashG, char *name, int s1, int s2)
{
  int winner = 0;
  Game *x;
  x = searchGame(HashG, name);
  if (x->score1 > x->score2)
  {
    {
      winner = 1;
    }
  }
  else
  {
    if (x->score2 > x->score1)
    {
      {
        winner = 2;
      }
    }
    else
    {
      
    }

  }

  x->score1 = s1;
  x->score2 = s2;
  if ((winner == 1) && (s1 <= s2))
  {
    {
      x->team1->wins--;
      if (s1 < s2)
      {
        {
          x->team2->wins++;
        }
      }
      else
      {
        
      }

    }
  }
  else
  {
    if ((winner == 2) && (s2 <= s1))
    {
      {
        x->team2->wins--;
        if (s2 < s1)
        {
          {
            x->team1->wins++;
          }
        }
        else
        {
          
        }

      }
    }
    else
    {
      if (winner == 0)
      {
        {
          if (s1 > s2)
          {
            {
              x->team1->wins++;
            }
          }
          else
          {
            if (s2 > s1)
            {
              {
                x->team2->wins++;
              }
            }
            else
            {
              
            }

          }

        }
      }
      else
      {
        
      }

    }

  }

}

Team **winners(TeamsHash *HashT, Team **winnersTable, int maxCapacity, int cont)
{
  int i;
  int max = 0;
  int len = 1;
  int topMax = 0;
  teamNodeP *headsT = HashT->headsT;
  for (i = 0; i < HashT->size; i++)
  {
    if (headsT[i] != 0)
    {
      {
        winnersTable = searchWinners(headsT, &max, i, &len, winnersTable, &maxCapacity);
      }
    }
    else
    {
      
    }

  }

  for (i = 0; i < (len - 1); i++)
  {
    if (winnersTable[i]->wins >= max)
    {
      {
        topMax = winnersTable[i]->wins;
      }
    }
    else
    {
      
    }

  }

  winnersTable = sortWinners(winnersTable, &len);
  if (len > 1)
  {
    {
      printf("%d Melhores %d\n", cont, topMax);
      for (i = 0; i < (len - 1); i++)
      {
        if (winnersTable[i]->wins == topMax)
        {
          {
            printf("%d * %s\n", cont, winnersTable[i]->name);
          }
        }
        else
        {
          
        }

      }

    }
  }
  else
  {
    
  }

  return winnersTable;
}

Team **searchWinners(teamNodeP *headsT, int *maxP, int i, int *lenP, Team **winnersTable, int *maxC)
{
  teamNodeP x;
  for (x = headsT[i]; x != 0; x = x->next)
  {
    if (x->team->wins >= (*maxP))
    {
      {
        winnersTable = addWinnerTable(x->team, lenP, winnersTable, maxC);
        (*lenP)++;
        *maxP = x->team->wins;
      }
    }
    else
    {
      
    }

  }

  return winnersTable;
}

Team **addWinnerTable(Team *x, int *lenP, Team **winnersTable, int *maxC)
{
  if ((*lenP) == 1)
  {
    {
      winnersTable[0] = x;
    }
  }
  else
  {
    {
      if ((*lenP) == (*maxC))
      {
        {
          winnersTable = (Team **) realloc(winnersTable, ((sizeof(Team *)) * (*maxC)) * 2);
          *maxC = (*maxC) * 2;
          winnersTable[(*lenP) - 1] = x;
        }
      }
      else
      {
        {
          winnersTable[(*lenP) - 1] = x;
        }
      }

    }
  }

  return winnersTable;
}

Team **sortWinners(Team **winnersTable, int *lenP)
{
  int l = 0;
  int r = (*lenP) - 2;
  int j;
  int i;
  for (i = l; i < r; i++)
  {
    for (j = l; j < (r + (l - i)); j++)
    {
      if (strcmp(winnersTable[j + 1]->name, winnersTable[j]->name) < 0)
      {
        {
          {
            Item t = winnersTable[j + 1];
            winnersTable[j + 1] = winnersTable[j];
            winnersTable[j] = t;
          }
          ;
          ;
        }
      }
      else
      {
        
      }

    }

  }

  return winnersTable;
}

void destroyTeamsHash(TeamsHash *HashT)
{
  int i = 0;
  teamNodeP x;
  teamNodeP aux;
  teamNodeP *headsT = HashT->headsT;
  for (i = 0; i < HashT->size; i++)
  {
    if (headsT[i] == 0)
    {
      continue;
    }
    else
    {
      
    }

    x = headsT[i];
    aux = x->next;
    for (; (x != 0) && (aux != 0); aux = x->next)
    {
      free(x->team->name);
      free(x->team);
      free(x);
      x = aux;
    }

    free(x->team->name);
    free(x->team);
    free(x);
  }

  free(HashT->headsT);
}

void destroyGamesHash(GamesHash *HashG)
{
  int i = 0;
  gameNodeP x;
  gameNodeP aux;
  gameNodeP *headsG = HashG->headsG;
  for (i = 0; i < HashG->size; i++)
  {
    if (headsG[i] == 0)
    {
      continue;
    }
    else
    {
      
    }

    x = headsG[i];
    aux = x->nextH;
    for (; (x != 0) && (aux != 0); aux = x->nextH)
    {
      free(x->game->name);
      free(x->game);
      free(x);
      x = aux;
    }

    free(x->game->name);
    free(x->game);
    free(x);
  }

  free(HashG->headsG);
}

