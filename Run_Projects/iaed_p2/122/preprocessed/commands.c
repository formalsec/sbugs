/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "hashtable.h"
#include "commands.h"
#include "match.h"
#include "stack.h"
#include "strdup.h"
#include "list.h"


int compare(const void *a, const void *b)
{
  int x;
  teamwins *teamA = (teamwins *) a;
  teamwins *teamB = (teamwins *) b;
  x = teamB->wins - teamA->wins;
  if (x == 0)
  {
    {
      x = strcmp(teamA->team, teamB->team);
    }
  }
  else
  {
    
  }

  return x;
}

link a(link matches, tSTACK teams, int lineCounter)
{
  MATCH newMatch;
  newMatch = malloc(sizeof(struct match));
  newMatch->name = malloc((sizeof(char)) * 1024);
  newMatch->team1 = malloc((sizeof(char)) * 1024);
  newMatch->team2 = malloc((sizeof(char)) * 1024);
  for (int newMatch_index = 0; newMatch_index < 10; newMatch_index++)
  {
    newMatch->name[newMatch_index] = new_sym_var(sizeof(char) * 8);
  }

  newMatch->name[10 - 1] = '\0';
  for (int newMatch_index = 0; newMatch_index < 10; newMatch_index++)
  {
    newMatch->team1[newMatch_index] = new_sym_var(sizeof(char) * 8);
  }

  newMatch->team1[10 - 1] = '\0';
  for (int newMatch_index = 0; newMatch_index < 10; newMatch_index++)
  {
    newMatch->team2[newMatch_index] = new_sym_var(sizeof(char) * 8);
  }

  newMatch->team2[10 - 1] = '\0';
  newMatch->score.score_team1 = new_sym_var(sizeof(int) * 8);
  newMatch->score.score_team2 = new_sym_var(sizeof(int) * 8);
  if (STsearch(newMatch->name) == 0)
  {
    {
      if (tSTACKteamsearch(teams, newMatch->team1) != 0)
      {
        {
          if (tSTACKteamsearch(teams, newMatch->team2) != 0)
          {
            {
              matches = insertEnd(matches, _strdup(newMatch->name));
              STinsert(matchdup(newMatch));
            }
          }
          else
          {
            printf("%d Equipa inexistente.\n", lineCounter);
          }

        }
      }
      else
      {
        printf("%d Equipa inexistente.\n", lineCounter);
      }

    }
  }
  else
  {
    {
      printf("%d Jogo existente.\n", lineCounter);
    }
  }

  free(newMatch->name);
  free(newMatch->team1);
  free(newMatch->team2);
  free(newMatch);
  return matches;
}

void l(link matches, int lineCounter)
{
  MATCH match;
  link t;
  if (!isEmpty(matches))
  {
    for (t = matches; t != 0; t = t->next)
    {
      match = STsearch(t->name);
      if (match != 0)
      {
        printf("%d %s %s %s %d %d\n", lineCounter, match->name, match->team1, match->team2, match->score.score_team1, match->score.score_team2);
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

}

void p(int lineCounter)
{
  MATCH match;
  char *name;
  name = malloc((sizeof(char)) * 1024);
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  match = STsearch(name);
  if (match != 0)
  {
    printf("%d %s %s %s %d %d\n", lineCounter, match->name, match->team1, match->team2, match->score.score_team1, match->score.score_team2);
  }
  else
  {
    printf("%d Jogo inexistente.\n", lineCounter);
  }

  free(name);
}

link r(link matches, int lineCounter)
{
  char *name;
  name = malloc((sizeof(char)) * 1024);
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  if (STsearch(name) != 0)
  {
    {
      STdelete(name);
      matches = delete(matches, name);
    }
  }
  else
  {
    printf("%d Jogo inexistente.\n", lineCounter);
  }

  free(name);
  return matches;
}

void s(int lineCounter)
{
  MATCH match;
  char *name;
  int newscore1;
  int newscore2;
  name = malloc((sizeof(char)) * 1024);
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  newscore1 = new_sym_var(sizeof(int) * 8);
  newscore2 = new_sym_var(sizeof(int) * 8);
  match = STsearch(name);
  if (match != 0)
  {
    {
      match->score.score_team1 = newscore1;
      match->score.score_team2 = newscore2;
    }
  }
  else
  {
    printf("%d Jogo inexistente.\n", lineCounter);
  }

  free(name);
}

void A(tSTACK teams, int lineCounter)
{
  char *newteam;
  newteam = malloc((sizeof(char)) * 1024);
  for (int newteam_index = 0; newteam_index < 10; newteam_index++)
  {
    newteam[newteam_index] = new_sym_var(sizeof(char) * 8);
  }

  newteam[10 - 1] = '\0';
  if (tSTACKteamsearch(teams, newteam) == 0)
  {
    {
      tSTACKpush(teams, newteam);
    }
  }
  else
  {
    {
      printf("%d Equipa existente.\n", lineCounter);
      free(newteam);
    }
  }

}

void P(link matches, tSTACK teams, int lineCounter)
{
  char *team;
  int wins = 0;
  team = malloc((sizeof(char)) * 1024);
  for (int team_index = 0; team_index < 10; team_index++)
  {
    team[team_index] = new_sym_var(sizeof(char) * 8);
  }

  team[10 - 1] = '\0';
  if (tSTACKteamsearch(teams, team) != 0)
  {
    {
      link t;
      MATCH match;
      for (t = matches; t != 0; t = t->next)
      {
        match = STsearch(t->name);
        if (match != 0)
        {
          {
            if (strcmp(match->team1, team) == 0)
            {
              {
                if (match->score.score_team1 > match->score.score_team2)
                {
                  wins++;
                }
                else
                {
                  
                }

              }
            }
            else
            {
              if (strcmp(match->team2, team) == 0)
              {
                {
                  if (match->score.score_team2 > match->score.score_team1)
                  {
                    wins++;
                  }
                  else
                  {
                    
                  }

                }
              }
              else
              {
                
              }

            }

          }
        }
        else
        {
          
        }

      }

      printf("%d %s %d\n", lineCounter, team, wins);
    }
  }
  else
  {
    printf("%d Equipa inexistente.\n", lineCounter);
  }

  free(team);
}

void g(link matches, tSTACK teams, int lineCounter)
{
  int wins;
  int mostwins = 0;
  int i = 0;
  int j;
  int len;
  teamwins *twArray;
  len = tSTACKlength(teams);
  twArray = (teamwins *) malloc(((sizeof(teamwins)) * 1024) * len);
  if (!tSTACKempty(teams))
  {
    {
      tlink t;
      link v;
      MATCH match;
      for (t = teams->head; t != 0; t = t->next)
      {
        wins = 0;
        for (v = matches; v != 0; v = v->next)
        {
          match = STsearch(v->name);
          if (match != 0)
          {
            {
              if (strcmp(match->team1, t->team) == 0)
              {
                {
                  if (match->score.score_team1 > match->score.score_team2)
                  {
                    wins++;
                  }
                  else
                  {
                    
                  }

                }
              }
              else
              {
                if (strcmp(match->team2, t->team) == 0)
                {
                  {
                    if (match->score.score_team2 > match->score.score_team1)
                    {
                      wins++;
                    }
                    else
                    {
                      
                    }

                  }
                }
                else
                {
                  
                }

              }

            }
          }
          else
          {
            
          }

        }

        if (wins > mostwins)
        {
          {
            mostwins = wins;
          }
        }
        else
        {
          
        }

        twArray[i].team = _strdup(t->team);
        twArray[i].wins = wins;
        i++;
      }

      qsort(twArray, len, sizeof(teamwins), compare);
      printf("%d Melhores %d\n", lineCounter, mostwins);
      i = 0;
      while (twArray[i].wins == mostwins)
      {
        if (twArray[i].team == 0)
        {
          break;
        }
        else
        {
          
        }

        printf("%d * %s\n", lineCounter, twArray[i].team);
        i++;
      }

    }
  }
  else
  {
    
  }

  for (j = 0; j < len; j++)
  {
    free(twArray[j].team);
  }

  free(twArray);
}

link x(link matches, tSTACK teams)
{
  STdeletetable();
  tSTACKdelete(teams);
  destroy(matches);
  return 0;
}

