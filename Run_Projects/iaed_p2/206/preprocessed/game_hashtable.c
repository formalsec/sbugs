/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "function_hashtable.h"
#include "game_hashtable.h"


void init_game_hashtable_table(Game_Hashtable *GH)
{
  int i;
  GH->game_table = malloc((sizeof(Game)) * GH->size);
  for (i = 0; i < GH->size; i++)
  {
    GH->game_table[i] = 0;
  }

}

Game_Hashtable *init_game_hashtable(int game_hashtable_size)
{
  Game_Hashtable *GH = malloc(sizeof(struct game_hashtable));
  GH->size = game_hashtable_size;
  GH->count = 0;
  init_game_hashtable_table(GH);
  return GH;
}

void insert_game_hashtable(Game_Hashtable *GH, Game game)
{
  int index = hash(game->name, GH->size);
  int position = index;
  if (GH->count > (GH->size / 2))
  {
    {
      expand_game_hashtable(GH);
    }
  }
  else
  {
    
  }

  while (GH->game_table[position] != 0)
  {
    position = (index++) % GH->size;
  }

  GH->game_table[position] = game;
  GH->count++;
}

void expand_game_hashtable(Game_Hashtable *GH)
{
  int i;
  int old_size = GH->size;
  Game *aux_game_table = GH->game_table;
  GH->count = 0;
  GH->size = old_size * 4;
  init_game_hashtable_table(GH);
  for (i = 0; i < old_size; i++)
  {
    if (aux_game_table[i] != 0)
    {
      {
        insert_game_hashtable(GH, aux_game_table[i]);
      }
    }
    else
    {
      
    }

  }

  free(aux_game_table);
}

Game search_game_hashtable(Game_Hashtable *GH, char *name)
{
  int index = hash(name, GH->size);
  int position = index;
  while (GH->game_table[position] != 0)
  {
    if (strcmp(GH->game_table[position]->name, name) == 0)
    {
      {
        return GH->game_table[position];
      }
    }
    else
    {
      
    }

    position = (index++) % GH->size;
  }

  return 0;
}

void remove_game_hashtable(Game_Hashtable *GH, char *name)
{
  int i;
  int index = hash(name, GH->size);
  int position = index;
  Game aux_game;
  while (GH->game_table[position] != 0)
  {
    if (strcmp(GH->game_table[position]->name, name) == 0)
    {
      {
        free_game_hashtable_table(GH, position);
        GH->game_table[position] = 0;
        for (i = position; GH->game_table[i] != 0; i = (index++) % GH->size)
        {
          aux_game = GH->game_table[i];
          GH->game_table[i] = 0;
          insert_game_hashtable(GH, aux_game);
        }

        break;
      }
    }
    else
    {
      {
        position = (index++) % GH->size;
      }
    }

  }

  if (GH->game_table[position] == 0)
  {
    {
      return;
    }
  }
  else
  {
    
  }

}

void free_game_hashtable_table(Game_Hashtable *GH, int index)
{
  free(GH->game_table[index]->name);
  free(GH->game_table[index]->team1);
  free(GH->game_table[index]->team2);
  free(GH->game_table[index]);
}

void free_games_hashtable(Game_Hashtable *GH)
{
  int i = 0;
  while (GH->game_table[i] != 0)
  {
    free_game_hashtable_table(GH, i);
    i++;
  }

  free(GH->game_table);
  free(GH);
}

