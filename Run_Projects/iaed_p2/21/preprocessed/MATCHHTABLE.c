/*File generated by PreProcessor.py*/


#include "MATCHHTABLE.h"
#include "TEAM.h"
#include "MATCH.h"


int hashM(char *v, int m)
{
  int h = 0;
  int a = 127;
  for (; (*v) != '\0'; v++)
    h = ((a * h) + (*v)) % m;

  return h;
  return h;
}

void matchInit()
{
  int i;
  matchHeads = (matchNode *) malloc(199999 * (sizeof(matchNode)));
  for (i = 0; i < 199999; i++)
  {
    matchHeads[i] = 0;
  }

}

void matchInsert(Match match)
{
  int i = hashM(match->name, 199999);
  if (matchHeads[i] == 0)
  {
    {
      matchHeads[i] = (matchNode) malloc(sizeof(struct matchnode));
      matchHeads[i]->match = match;
      matchHeads[i]->next = 0;
    }
  }
  else
  {
    {
      matchNode t;
      matchNode prev;
      matchNode newNode = (matchNode) malloc(sizeof(struct matchnode));
      newNode->match = match;
      newNode->next = 0;
      for (t = matchHeads[i], prev = 0; t != 0; prev = t, t = t->next)
      {
      }

      prev->next = newNode;
    }
  }

  addMatchNodeList(match);
}

void matchDelete(Match match)
{
  matchNode t;
  matchNode prev;
  int i = hashM(match->name, 199999);
  for (t = matchHeads[i], prev = 0; t != 0; prev = t, t = t->next)
  {
    if (strcmp(t->match->name, match->name) == 0)
    {
      {
        if (t == matchHeads[i])
        {
          {
            matchHeads[i] = t->next;
          }
        }
        else
        {
          {
            prev->next = t->next;
          }
        }

        strcpy(t->match->name, ":");
        free(t);
        break;
      }
    }
    else
    {
      
    }

  }

}

matchNode matchSearch(char *name)
{
  int i = hashM(name, 199999);
  matchNode aux;
  for (aux = matchHeads[i]; aux != 0; aux = aux->next)
  {
    if (strcmp(aux->match->name, name) == 0)
    {
      {
        return aux;
      }
    }
    else
    {
      
    }

  }

  return 0;
}

void matchHashListFREE(matchNode m)
{
  if (m != 0)
  {
    {
      matchHashListFREE(m->next);
      free(m);
    }
  }
  else
  {
    
  }

}

void matchHashFREE()
{
  int i;
  for (i = 0; i < 199999; i++)
  {
    matchHashListFREE(matchHeads[i]);
  }

}

void MlistInit()
{
  head = 0;
  tail = 0;
}

matchNode newMatchNode(Match match, matchNode next)
{
  matchNode x = (matchNode) malloc(sizeof(struct matchnode));
  x->match = match;
  x->next = next;
  return x;
}

void addMatchNodeList(Match match)
{
  if (head == 0)
  {
    {
      head = (tail = newMatchNode(match, head));
    }
  }
  else
  {
    {
      tail->next = newMatchNode(match, tail->next);
      tail = tail->next;
    }
  }

}

void MfreeHead(matchNode node)
{
  if (node != 0)
  {
    {
      freeMatch(node->match);
      MfreeHead(node->next);
      free(node);
    }
  }
  else
  {
    
  }

}

