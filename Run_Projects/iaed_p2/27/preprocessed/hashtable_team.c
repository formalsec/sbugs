/*File generated by PreProcessor.py*/


#include <stdio.h>
#include "hashtable_team.h"
#include "hashtable_game.h"


ht_team *ht_create_hteam(void)
{
  int i = 0;
  ht_team *hashtable = malloc((sizeof(ht_team)) * 1);
  hashtable->entries = malloc((sizeof(entry_team)) * 20000);
  for (; i < 20000; ++i)
  {
    hashtable->entries[i] = 0;
  }

  return hashtable;
}

entry_team *ht_pair_team(TEAM *team)
{
  entry_team *entry = malloc(sizeof(entry_team));
  entry->team = team;
  entry->next = 0;
  return entry;
}

unsigned int hash_team(char *team)
{
  unsigned int value = 0;
  unsigned int i = 0;
  unsigned int len = strlen(team);
  for (; i < len; ++i)
  {
    value = (value * 37) + team[i];
  }

  value = value % 20000;
  return value;
}

void ht_set_team(int line, ht_team *hashtable, TEAM *team)
{
  entry_team *prev = 0;
  unsigned int slot = hash_team(team->name);
  entry_team *entry = hashtable->entries[slot];
  if (entry == 0)
  {
    {
      hashtable->entries[slot] = ht_pair_team(team);
      return;
    }
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->team->name, team->name) == 0)
    {
      {
        printf("%d Equipa existente.\n", line);
        free(team->name);
        free(team);
        return;
      }
    }
    else
    {
      
    }

    prev = entry;
    entry = prev->next;
  }

  prev->next = ht_pair_team(team);
}

TEAM *ht_get_team(ht_team *hashtable, char *team)
{
  unsigned int slot = hash_team(team);
  entry_team *entry = hashtable->entries[slot];
  if (entry == 0)
  {
    {
      return 0;
    }
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->team->name, team) == 0)
    {
      {
        return entry->team;
      }
    }
    else
    {
      
    }

    entry = entry->next;
  }

  return 0;
}

void ht_dump_team(ht_team *hashtable)
{
  entry_team *temp = 0;
  entry_team *entry = 0;
  int i;
  for (i = 0; i < 20000; i++)
  {
    if (hashtable->entries[i] != 0)
    {
      {
        entry = hashtable->entries[i];
        while (entry != 0)
        {
          temp = entry->next;
          free(entry->team->name);
          free(entry->team);
          free(entry);
          entry = temp;
        }

        temp = entry;
        free(temp);
      }
    }
    else
    {
      
    }

  }

}

void find_max(ht_team *hashtable, int line)
{
  entry_team *temp = 0;
  entry_team *entry = 0;
  int i;
  int maxTeamNumber = 0;
  int max = 0;
  for (i = 0; i < 20000; i++)
  {
    if (hashtable->entries[i] != 0)
    {
      {
        entry = hashtable->entries[i]->next;
        if (hashtable->entries[i]->team->gameswon > max)
        {
          {
            max = hashtable->entries[i]->team->gameswon;
            maxTeamNumber = 1;
          }
        }
        else
        {
          if (hashtable->entries[i]->team->gameswon == max)
          {
            {
              maxTeamNumber++;
            }
          }
          else
          {
            
          }

        }

        while (entry != 0)
        {
          if (entry->team->gameswon > max)
          {
            {
              max = entry->team->gameswon;
              maxTeamNumber = 1;
            }
          }
          else
          {
            if (entry->team->gameswon == max)
            {
              {
                maxTeamNumber++;
              }
            }
            else
            {
              
            }

          }

          temp = entry->next;
          entry = temp;
        }

      }
    }
    else
    {
      
    }

  }

  order_array(hashtable, max, maxTeamNumber, line);
}

void order_array(ht_team *hashtable, int max, int maxTeamNumber, int line)
{
  entry_team *temp = 0;
  entry_team *entry = 0;
  int i = 0;
  int j = 0;
  TEAM teams[100000];
  for (i = 0; i < 20000; i++)
  {
    if (hashtable->entries[i] != 0)
    {
      {
        entry = hashtable->entries[i]->next;
        if (hashtable->entries[i]->team->gameswon == max)
        {
          {
            teams[j] = *hashtable->entries[i]->team;
            j++;
          }
        }
        else
        {
          
        }

        while (entry != 0)
        {
          if (entry->team->gameswon == max)
          {
            {
              teams[j] = *hashtable->entries[i]->team;
              j++;
            }
          }
          else
          {
            
          }

          temp = entry->next;
          entry = temp;
        }

      }
    }
    else
    {
      
    }

  }

  if (maxTeamNumber > 1)
  {
    {
      mergesort_alphabet(teams, 0, maxTeamNumber - 1);
      printf("%d Melhores %d\n", line, max);
      for (i = 0; i < maxTeamNumber; i++)
      {
        printf("%d * %s\n", line, teams[i].name);
      }

    }
  }
  else
  {
    if (maxTeamNumber == 1)
    {
      {
        printf("%d Melhores %d\n", line, max);
        printf("%d * %s\n", line, teams[0].name);
      }
    }
    else
    {
      
    }

  }

}

void merge_alphabet(TEAM a[], int left, int m, int right)
{
  int i = 0;
  int j = 0;
  int k = 0;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
  {
    if (strcmp(aux[j].name, aux[i].name) < 0)
    {
      {
        a[k] = aux[j--];
      }
    }
    else
    {
      {
        a[k] = aux[i++];
      }
    }

  }

}

void mergesort_alphabet(TEAM a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_alphabet(a, l, m);
  mergesort_alphabet(a, m + 1, r);
  merge_alphabet(a, l, m, r);
}

TEAM *getTeam(char *name)
{
  TEAM *team = malloc(sizeof(TEAM));
  team->name = malloc(strlen(name) + 1);
  strcpy(team->name, name);
  team->gameswon = 0;
  return team;
}

