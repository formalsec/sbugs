/*File generated by PreProcessor.py*/


#include "structs.h"
#include <string.h>
#include <stdio.h>


Node *adicionaJogo(Node *head, Hash_table *jogosT, Hash_tableEq *equipasT, int nl)
{
  int h1;
  int h2;
  int h3;
  int control = 0;
  int len1;
  int len2;
  int len3;
  Node *novoJogo;
  Hash_node *node;
  Hash_nodeEq *nodeEq1;
  Hash_nodeEq *nodeEq2;
  char *aux_string;
  char *aux_equipa1;
  char *aux_equipa2;
  char nome_buffer[1024];
  char equipa1_buffer[1024];
  char equipa2_buffer[1024];
  int score1_buffer;
  int score2_buffer;
  for (int nome_buffer_index = 0; nome_buffer_index < 10; nome_buffer_index++)
  {
    nome_buffer[nome_buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_buffer[10 - 1] = '\0';
  for (int equipa1_buffer_index = 0; equipa1_buffer_index < 10; equipa1_buffer_index++)
  {
    equipa1_buffer[equipa1_buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa1_buffer[10 - 1] = '\0';
  for (int equipa2_buffer_index = 0; equipa2_buffer_index < 10; equipa2_buffer_index++)
  {
    equipa2_buffer[equipa2_buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa2_buffer[10 - 1] = '\0';
  score1_buffer = new_sym_var(sizeof(int) * 8);
  score2_buffer = new_sym_var(sizeof(int) * 8);
  len1 = strlen(nome_buffer) + 1;
  len2 = strlen(equipa1_buffer) + 1;
  len3 = strlen(equipa2_buffer) + 1;
  aux_string = (char *) malloc((sizeof(char)) * len1);
  aux_equipa1 = (char *) malloc((sizeof(char)) * len2);
  aux_equipa2 = (char *) malloc((sizeof(char)) * len3);
  strcpy(aux_string, nome_buffer);
  strcpy(aux_equipa1, equipa1_buffer);
  strcpy(aux_equipa2, equipa2_buffer);
  h1 = hash(aux_string, jogosT->capacity);
  node = jogosT->table[h1];
  while (node != 0)
  {
    if (!strcmp(node->jogo->nome, aux_string))
    {
      {
        printf("%d Jogo existente.\n", nl);
        free(aux_string);
        free(aux_equipa1);
        free(aux_equipa2);
        return head;
      }
    }
    else
    {
      
    }

    node = node->next;
  }

  h2 = hash(aux_equipa1, equipasT->capacity);
  h3 = hash(aux_equipa2, equipasT->capacity);
  nodeEq1 = equipasT->table[h2];
  nodeEq2 = equipasT->table[h3];
  while (nodeEq1 != 0)
  {
    if (!strcmp(nodeEq1->equipa->nome, aux_equipa1))
    {
      {
        control++;
        break;
      }
    }
    else
    {
      
    }

    nodeEq1 = nodeEq1->next;
  }

  while (nodeEq2 != 0)
  {
    if (!strcmp(nodeEq2->equipa->nome, aux_equipa2))
    {
      {
        control++;
        break;
      }
    }
    else
    {
      
    }

    nodeEq2 = nodeEq2->next;
  }

  if (control < 2)
  {
    {
      printf("%d Equipa inexistente.\n", nl);
      free(aux_string);
      free(aux_equipa1);
      free(aux_equipa2);
      return head;
    }
  }
  else
  {
    
  }

  if (score1_buffer > score2_buffer)
  {
    {
      nodeEq1->equipa->vitorias++;
    }
  }
  else
  {
    if (score2_buffer > score1_buffer)
    {
      {
        nodeEq2->equipa->vitorias++;
      }
    }
    else
    {
      
    }

  }

  novoJogo = (Node *) malloc(sizeof(Node));
  novoJogo->nome = (char *) malloc((sizeof(char)) * len1);
  novoJogo->equipa1 = (char *) malloc((sizeof(char)) * len2);
  novoJogo->equipa2 = (char *) malloc((sizeof(char)) * len3);
  strcpy(novoJogo->nome, nome_buffer);
  strcpy(novoJogo->equipa1, equipa1_buffer);
  strcpy(novoJogo->equipa2, equipa2_buffer);
  novoJogo->score1 = score1_buffer;
  novoJogo->score2 = score2_buffer;
  novoJogo->next = head;
  if (head != 0)
  {
    head->prev = novoJogo;
  }
  else
  {
    
  }

  head = novoJogo;
  insertJogo_T(jogosT, head);
  free(aux_string);
  free(aux_equipa1);
  free(aux_equipa2);
  return head;
}

Node *removeJogo(Hash_table *jogosT, Hash_tableEq *equipasT, Node *head, int nl)
{
  int len;
  char nome_buffer[1024];
  char *nome_ptr;
  Node *node;
  node = head;
  for (int nome_buffer_index = 0; nome_buffer_index < 10; nome_buffer_index++)
  {
    nome_buffer[nome_buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_buffer[10 - 1] = '\0';
  len = strlen(nome_buffer) + 1;
  nome_ptr = (char *) malloc((sizeof(char)) * len);
  strcpy(nome_ptr, nome_buffer);
  if (head == 0)
  {
    {
      free(nome_ptr);
      printf("%d Jogo inexistente.\n", nl);
      return head;
    }
  }
  else
  {
    
  }

  if (!strcmp(head->nome, nome_ptr))
  {
    {
      node = head->next;
      if (node != 0)
      {
        node->prev = 0;
      }
      else
      {
        
      }

      removeTable(jogosT, equipasT, nome_ptr, nl);
      free(nome_ptr);
      free(head->nome);
      free(head->equipa1);
      free(head->equipa2);
      free(head);
      return node;
    }
  }
  else
  {
    {
      node = removeTable(jogosT, equipasT, nome_ptr, nl);
      if (!node)
      {
        {
          free(nome_ptr);
          return head;
        }
      }
      else
      {
        
      }

      node->prev->next = node->next;
      if (node->next != 0)
      {
        node->next->prev = node->prev;
      }
      else
      {
        
      }

      free(nome_ptr);
      free(node->nome);
      free(node->equipa1);
      free(node->equipa2);
      free(node);
      return head;
    }
  }

}

void alteraScore(Hash_table *jogosT, Hash_tableEq *equipasT, int nl)
{
  Hash_node *node;
  Hash_nodeEq *nodeEq1;
  Hash_nodeEq *nodeEq2;
  int h;
  int h2;
  int h3;
  int new_score1;
  int new_score2;
  int len;
  char nome_buffer[1024];
  char *buffer;
  char *equipa1;
  char *equipa2;
  for (int nome_buffer_index = 0; nome_buffer_index < 10; nome_buffer_index++)
  {
    nome_buffer[nome_buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_buffer[10 - 1] = '\0';
  new_score1 = new_sym_var(sizeof(int) * 8);
  new_score2 = new_sym_var(sizeof(int) * 8);
  len = strlen(nome_buffer) + 1;
  buffer = (char *) malloc((sizeof(char)) * len);
  strcpy(buffer, nome_buffer);
  h = hash(buffer, jogosT->capacity);
  node = jogosT->table[h];
  while ((node != 0) && strcmp(node->jogo->nome, buffer))
    node = node->next;

  if (node == 0)
  {
    {
      free(buffer);
      printf("%d Jogo inexistente.\n", nl);
      return;
    }
  }
  else
  {
    
  }

  equipa1 = node->jogo->equipa1;
  equipa2 = node->jogo->equipa2;
  h2 = hash(equipa1, equipasT->capacity);
  h3 = hash(equipa2, equipasT->capacity);
  while (node != 0)
  {
    if (!strcmp(node->jogo->nome, buffer))
    {
      {
        nodeEq1 = equipasT->table[h2];
        nodeEq2 = equipasT->table[h3];
        while (strcmp(nodeEq1->equipa->nome, equipa1))
          nodeEq1 = nodeEq1->next;

        while (strcmp(nodeEq2->equipa->nome, equipa2))
          nodeEq2 = nodeEq2->next;

        if ((node->jogo->score1 > node->jogo->score2) && (new_score1 < new_score2))
        {
          {
            nodeEq1->equipa->vitorias--;
            nodeEq2->equipa->vitorias++;
          }
        }
        else
        {
          if ((node->jogo->score1 < node->jogo->score2) && (new_score1 > new_score2))
          {
            {
              nodeEq1->equipa->vitorias++;
              nodeEq2->equipa->vitorias--;
            }
          }
          else
          {
            if ((node->jogo->score1 == node->jogo->score2) && (new_score1 > new_score2))
            {
              {
                nodeEq1->equipa->vitorias++;
              }
            }
            else
            {
              if ((node->jogo->score1 == node->jogo->score2) && (new_score1 < new_score2))
              {
                {
                  nodeEq2->equipa->vitorias++;
                }
              }
              else
              {
                if ((node->jogo->score1 > node->jogo->score2) && (new_score1 == new_score2))
                {
                  {
                    nodeEq1->equipa->vitorias--;
                  }
                }
                else
                {
                  if ((node->jogo->score1 < node->jogo->score2) && (new_score1 == new_score2))
                  {
                    {
                      nodeEq2->equipa->vitorias--;
                    }
                  }
                  else
                  {
                    
                  }

                }

              }

            }

          }

        }

        node->jogo->score1 = new_score1;
        node->jogo->score2 = new_score2;
        free(buffer);
        return;
      }
    }
    else
    {
      
    }

    node = node->next;
  }

  printf("%d Jogo inexistente.\n", nl);
}

void listaJogos(Node *h, int nl)
{
  if (h == 0)
  {
    return;
  }
  else
  {
    
  }

  listaJogos(h->next, nl);
  printf("%d %s %s %s %d %d\n", nl, h->nome, h->equipa1, h->equipa2, h->score1, h->score2);
}

void procuraJogo(Hash_table *t, int nl)
{
  int h;
  int len;
  char nome_buffer[1024];
  char *nomeJogo;
  Hash_node *node;
  Node *nodeJ;
  for (int nome_buffer_index = 0; nome_buffer_index < 10; nome_buffer_index++)
  {
    nome_buffer[nome_buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_buffer[10 - 1] = '\0';
  len = strlen(nome_buffer) + 1;
  nomeJogo = (char *) malloc((sizeof(char)) * len);
  strcpy(nomeJogo, nome_buffer);
  h = hash(nomeJogo, t->capacity);
  node = t->table[h];
  while (node != 0)
  {
    if (!strcmp(node->jogo->nome, nomeJogo))
    {
      {
        nodeJ = node->jogo;
        printf("%d %s %s %s %d %d\n", nl, nodeJ->nome, nodeJ->equipa1, nodeJ->equipa2, nodeJ->score1, nodeJ->score2);
        free(nomeJogo);
        return;
      }
    }
    else
    {
      
    }

    node = node->next;
  }

  printf("%d Jogo inexistente.\n", nl);
  free(nomeJogo);
}

