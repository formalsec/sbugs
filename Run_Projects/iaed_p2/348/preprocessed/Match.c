/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Const.h"
#include "MatchHashTable.h"
#include "TeamHashTable.h"
#include "MatchLinkedList.h"
#include "Team.h"


void addMatch(int debugLine, Hash_Table_Team *hash_Team, Hash_Table_Match *hash_Match, LinkedList_Team *ll_Teams, LinkedList_Match *ll_Matches)
{
  char matchName[1023];
  char team1[1023];
  char team2[1023];
  int score1;
  int score2;
  int index;
  Hash_Node_Match *pHN;
  Team *t1;
  Team *t2;
  for (int matchName_index = 0; matchName_index < 10; matchName_index++)
  {
    matchName[matchName_index] = new_sym_var(sizeof(char) * 8);
  }

  matchName[10 - 1] = '\0';
  for (int team1_index = 0; team1_index < 10; team1_index++)
  {
    team1[team1_index] = new_sym_var(sizeof(char) * 8);
  }

  team1[10 - 1] = '\0';
  for (int team2_index = 0; team2_index < 10; team2_index++)
  {
    team2[team2_index] = new_sym_var(sizeof(char) * 8);
  }

  team2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  index = hash_key(matchName, hash_Match->capacity);
  pHN = hash_Match->table[index];
  while (pHN)
  {
    if (!strcmp(matchName, pHN->match->name))
    {
      {
        printf("%d Jogo existente.\n", debugLine);
        return;
      }
    }
    else
    {
      
    }

    pHN = pHN->next;
  }

  if ((!(t1 = teamExists(team1, hash_Team))) || (!(t2 = teamExists(team2, hash_Team))))
  {
    {
      printf("%d Equipa inexistente.\n", debugLine);
      return;
    }
  }
  else
  {
    
  }

  addToMatchHashList(matchName, t1, t2, score1, score2, hash_Match, ll_Teams, index);
  addToMatchLinkedList(ll_Matches, hash_Match->table[index]);
}

void listMatches(int debugLine, LinkedList_Match *ll_Matches)
{
  List_Node_Match *tail = ll_Matches->tail;
  while (tail)
  {
    printf("%d %s %s %s %d %d\n", debugLine, tail->match->name, tail->match->team1, tail->match->team2, tail->match->score1, tail->match->score2);
    tail = tail->prev;
  }

}

void findMatch(int debugLine, Hash_Table_Match *t)
{
  int index;
  char matchName[1023];
  Hash_Node_Match *pHN;
  for (int matchName_index = 0; matchName_index < 10; matchName_index++)
  {
    matchName[matchName_index] = new_sym_var(sizeof(char) * 8);
  }

  matchName[10 - 1] = '\0';
  index = hash_key(matchName, t->capacity);
  pHN = t->table[index];
  while (pHN)
  {
    if (!strcmp(matchName, pHN->match->name))
    {
      {
        printf("%d %s %s %s %d %d\n", debugLine, pHN->match->name, pHN->match->team1, pHN->match->team2, pHN->match->score1, pHN->match->score2);
        return;
      }
    }
    else
    {
      
    }

    pHN = pHN->next;
  }

  printf("%d Jogo inexistente.\n", debugLine);
}

void updateTeamScores(Team *t1, Team *t2, Match *match, LinkedList_Team *llT)
{
  if (match->score1 > match->score2)
  {
    {
      if (t1->gamesWon == llT->maxVictories)
      {
        llT->maxTeamsVictories--;
      }
      else
      {
        
      }

      t1->gamesWon--;
    }
  }
  else
  {
    if (match->score1 < match->score2)
    {
      {
        if (t2->gamesWon == llT->maxVictories)
        {
          llT->maxTeamsVictories--;
        }
        else
        {
          
        }

        t2->gamesWon--;
      }
    }
    else
    {
      
    }

  }

  if (llT->maxTeamsVictories == 0)
  {
    {
      updateMaxVictories(llT);
    }
  }
  else
  {
    
  }

}

void freeLinkedListNode(List_Node_Match *lNM, LinkedList_Match *llM)
{
  if ((lNM->prev == 0) && (lNM->next == 0))
  {
    {
      free(lNM);
      llM->head = 0;
      llM->tail = 0;
    }
  }
  else
  {
    if ((lNM->prev == 0) && (lNM->next != 0))
    {
      {
        lNM->next->prev = lNM->prev;
        llM->head = lNM->next;
        free(lNM);
      }
    }
    else
    {
      if ((lNM->prev != 0) && (lNM->next == 0))
      {
        {
          lNM->prev->next = lNM->next;
          llM->tail = lNM->prev;
          free(lNM);
        }
      }
      else
      {
        if ((lNM->prev != 0) && (lNM->next != 0))
        {
          {
            lNM->next->prev = lNM->prev;
            lNM->prev->next = lNM->next;
            free(lNM);
          }
        }
        else
        {
          
        }

      }

    }

  }

}

void free_nd_match(Hash_Node_Match *hNM)
{
  free(hNM->match->name);
  free(hNM->match);
}

void freeHashTableNode(Hash_Node_Match *hNM, int index, Hash_Table_Match *hTM)
{
  if ((hNM->prev == 0) && (hNM->next == 0))
  {
    {
      free_nd_match(hNM);
      free(hNM);
      hTM->table[index] = 0;
    }
  }
  else
  {
    if ((hNM->prev == 0) && (hNM->next != 0))
    {
      {
        hNM->next->prev = hNM->prev;
        hTM->table[index] = hNM->next;
        free_nd_match(hNM);
        free(hNM);
      }
    }
    else
    {
      if ((hNM->prev != 0) && (hNM->next == 0))
      {
        {
          hNM->prev->next = hNM->next;
          free_nd_match(hNM);
          free(hNM);
        }
      }
      else
      {
        if ((hNM->prev != 0) && (hNM->next != 0))
        {
          {
            hNM->prev->next = hNM->next;
            hNM->next->prev = hNM->prev;
            free_nd_match(hNM);
            free(hNM);
          }
        }
        else
        {
          
        }

      }

    }

  }

}

void freeMatch(Hash_Node_Match *hNM, int index, Hash_Table_Match *hTM, LinkedList_Match *llM)
{
  freeLinkedListNode(hNM->lNM, llM);
  freeHashTableNode(hNM, index, hTM);
}

void deleteMatch(int debugLine, Hash_Table_Match *hash_Match, LinkedList_Team *ll_Teams, LinkedList_Match *ll_Matches, Hash_Table_Team *hTT)
{
  char matchName[1023];
  int index;
  Team *t1;
  Team *t2;
  Hash_Node_Match *pHN;
  for (int matchName_index = 0; matchName_index < 10; matchName_index++)
  {
    matchName[matchName_index] = new_sym_var(sizeof(char) * 8);
  }

  matchName[10 - 1] = '\0';
  index = hash_key(matchName, hash_Match->capacity);
  pHN = hash_Match->table[index];
  while (pHN)
  {
    if (!strcmp(matchName, pHN->match->name))
    {
      {
        t1 = teamExists(pHN->match->team1, hTT);
        t2 = teamExists(pHN->match->team2, hTT);
        updateTeamScores(t1, t2, pHN->match, ll_Teams);
        freeMatch(pHN, index, hash_Match, ll_Matches);
        return;
      }
    }
    else
    {
      
    }

    pHN = pHN->next;
  }

  printf("%d Jogo inexistente.\n", debugLine);
}

void changeScores(int score1, int score2, Match *match, Hash_Table_Team *hTT, LinkedList_Team *llT)
{
  Team *t1 = teamExists(match->team1, hTT);
  Team *t2 = teamExists(match->team2, hTT);
  if (match->score1 > match->score2)
  {
    t1->gamesWon--;
  }
  else
  {
    if (match->score1 < match->score2)
    {
      t2->gamesWon--;
    }
    else
    {
      
    }

  }

  match->score1 = score1;
  match->score2 = score2;
  if (match->score1 > match->score2)
  {
    t1->gamesWon++;
  }
  else
  {
    if (match->score1 < match->score2)
    {
      t2->gamesWon++;
    }
    else
    {
      
    }

  }

  updateMaxVictories(llT);
}

void changeMatchScore(int debugLine, Hash_Table_Match *hTM, Hash_Table_Team *hTT, LinkedList_Team *llT)
{
  char matchName[1023];
  int score1;
  int score2;
  int index;
  Hash_Node_Match *pHN;
  for (int matchName_index = 0; matchName_index < 10; matchName_index++)
  {
    matchName[matchName_index] = new_sym_var(sizeof(char) * 8);
  }

  matchName[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  index = hash_key(matchName, hTM->capacity);
  pHN = hTM->table[index];
  while (pHN)
  {
    if (!strcmp(matchName, pHN->match->name))
    {
      {
        changeScores(score1, score2, pHN->match, hTT, llT);
        return;
      }
    }
    else
    {
      
    }

    pHN = pHN->next;
  }

  printf("%d Jogo inexistente.\n", debugLine);
}

