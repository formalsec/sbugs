/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


int nl = 0;
int entry = 1;
typedef struct team
{
  char *name;
  int wins;
} *pteam;
typedef struct team Team;
static pteam *teamtable;
void Teamtableinit()
{
  int i;
  teamtable = (pteam *) malloc(20111 * (sizeof(pteam)));
  for (i = 0; i < 20111; i++)
    teamtable[i] = 0;

}

int hash(char *name, int M)
{
  int h;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*name) != '\0'; name++, a = (a * b) % (M - 1))
    h = ((a * h) + (*name)) % M;

  return h;
}

void add_team_to_table(pteam team)
{
  int i = hash(team->name, 20111);
  while (teamtable[i] != 0)
    i = (i + 1) % 20111;

  teamtable[i] = team;
}

void add_team(char *new_name)
{
  pteam new_team;
  new_team = (pteam) malloc(sizeof(Team));
  new_team->name = (char *) malloc(strlen(new_name) + 1);
  strncpy(new_team->name, new_name, strlen(new_name) + 1);
  new_team->wins = 0;
  add_team_to_table(new_team);
}

pteam search_team_in_table(char *team_name)
{
  int i = hash(team_name, 20111);
  while (teamtable[i] != 0)
  {
    if (strncmp(teamtable[i]->name, team_name, strlen(team_name) + 1) == 0)
    {
      return teamtable[i];
    }
    else
    {
      i = (i + 1) % 20111;
    }

  }

  return 0;
}

void search_team(char *team_name)
{
  pteam current_team = search_team_in_table(team_name);
  if (search_team_in_table(team_name) != 0)
  {
    printf("%d %s %d\n", nl, current_team->name, current_team->wins);
  }
  else
  {
    printf("%d Equipa inexistente.\n", nl);
  }

}

typedef struct match
{
  char *id;
  char *team1;
  char *team2;
  int score1;
  int score2;
  int entry;
} *pmatch;
typedef struct match Match;
static pmatch *matchtable;
void Matchtableinit()
{
  int i;
  matchtable = (pmatch *) malloc(40897 * (sizeof(Match)));
  for (i = 0; i < 40897; i++)
    matchtable[i] = 0;

}

void add_match_to_table(pmatch match)
{
  int i = hash(match->id, 40897);
  while (matchtable[i] != 0)
    i = (i + 1) % 40897;

  matchtable[i] = match;
}

void add_match(char *name, char *team_1, char *team_2, int score_1, int score_2)
{
  pmatch new_match;
  new_match = (pmatch) malloc(sizeof(Match));
  new_match->id = (char *) malloc(strlen(name) + 1);
  new_match->team1 = (char *) malloc(strlen(team_1) + 1);
  new_match->team2 = (char *) malloc(strlen(team_2) + 1);
  strcpy(new_match->id, name);
  strcpy(new_match->team1, team_1);
  strcpy(new_match->team2, team_2);
  new_match->score1 = score_1;
  new_match->score2 = score_2;
  new_match->entry = entry;
  add_match_to_table(new_match);
}

void winner(char *team_1, char *team_2, int score_1, int score_2)
{
  pteam current_team;
  if (score_1 > score_2)
  {
    {
      current_team = search_team_in_table(team_1);
      current_team->wins++;
    }
  }
  else
  {
    if (score_2 > score_1)
    {
      {
        current_team = search_team_in_table(team_2);
        current_team->wins++;
      }
    }
    else
    {
      
    }

  }

}

void remove_win(char *team_1, char *team_2, int score_1, int score_2)
{
  pteam current_team;
  if (score_1 > score_2)
  {
    {
      current_team = search_team_in_table(team_1);
      current_team->wins--;
    }
  }
  else
  {
    if (score_2 > score_1)
    {
      {
        current_team = search_team_in_table(team_2);
        current_team->wins--;
      }
    }
    else
    {
      
    }

  }

}

pmatch search_match_in_table(char *match_id)
{
  int i = hash(match_id, 40897);
  while (matchtable[i] != 0)
  {
    if (strncmp(matchtable[i]->id, match_id, strlen(match_id) + 1) == 0)
    {
      return matchtable[i];
    }
    else
    {
      i = (i + 1) % 40897;
    }

  }

  return 0;
}

int matchSort(const void *a, const void *b)
{
  const pmatch pa = *((const pmatch *) a);
  const pmatch pb = *((const pmatch *) b);
  return pa->entry - pb->entry;
}

void list_games()
{
  int i;
  int nrMatches = 0;
  pmatch matches[40897];
  for (i = 0; i < 40897; i++)
  {
    if (matchtable[i] != 0)
    {
      {
        matches[nrMatches] = matchtable[i];
        nrMatches++;
      }
    }
    else
    {
      
    }

  }

  if (nrMatches > 0)
  {
    {
      qsort(matches, nrMatches, sizeof(pmatch), matchSort);
      for (i = 0; i < nrMatches; i++)
        printf("%d %s %s %s %d %d\n", nl, matches[i]->id, matches[i]->team1, matches[i]->team2, matches[i]->score1, matches[i]->score2);

    }
  }
  else
  {
    
  }

}

void edit_result(pmatch game, int new_s1, int new_s2)
{
  remove_win(game->team1, game->team2, game->score1, game->score2);
  winner(game->team1, game->team2, new_s1, new_s2);
  game->score1 = new_s1;
  game->score2 = new_s2;
}

void free_match(pmatch game)
{
  free(game->id);
  free(game->team1);
  free(game->team2);
  free(game);
}

void remove_match(pmatch game)
{
  int j;
  int i = hash(game->id, 40897);
  pmatch aux;
  while (matchtable[i] != 0)
    if (strcmp(matchtable[i]->id, game->id) == 0)
  {
    break;
  }
  else
  {
    i = (i + 1) % 40897;
  }


  if (matchtable[i] == 0)
  {
    return;
  }
  else
  {
    
  }

  free_match(matchtable[i]);
  matchtable[i] = 0;
  for (j = (i + 1) % 40897; matchtable[j] != 0; j = (j + 1) % 40897)
  {
    aux = matchtable[j];
    matchtable[j] = 0;
    add_match_to_table(aux);
  }

}

char *str_treatment(char str[1024])
{
  char *new_str;
  str[strlen(str) + 1] = '\0';
  new_str = (char *) malloc((sizeof(char)) * (strlen(str) + 1));
  strncpy(new_str, str, strlen(str) + 1);
  return new_str;
}

int sortComp(const void *a, const void *b)
{
  const char *pa = *((const char **) a);
  const char *pb = *((const char **) b);
  return strcmp(pa, pb);
}

void best_teams()
{
  int i;
  int max_wins = 0;
  int verify = 0;
  int team_counter = 0;
  char *team_array[20111];
  for (i = 0; i < 20111; i++)
    if (teamtable[i] != 0)
  {
    {
      verify = 1;
      if (teamtable[i]->wins > max_wins)
      {
        max_wins = teamtable[i]->wins;
      }
      else
      {
        
      }

    }
  }
  else
  {
    
  }


  if (verify == 1)
  {
    {
      printf("%d Melhores %d\n", nl, max_wins);
      for (i = 0; i < 20111; i++)
        if (teamtable[i] != 0)
      {
        if (teamtable[i]->wins == max_wins)
        {
          {
            team_array[team_counter] = teamtable[i]->name;
            team_counter++;
          }
        }
        else
        {
          
        }

      }
      else
      {
        
      }


    }
  }
  else
  {
    
  }

  if (team_counter > 0)
  {
    {
      int j;
      qsort(team_array, team_counter, sizeof(char *), sortComp);
      for (j = 0; j < team_counter; j++)
      {
        printf("%d * %s\n", nl, team_array[j]);
      }

    }
  }
  else
  {
    
  }

}

void flush_in()
{
  int ch;
  do
  {
    ch = fgetc(stdin);
  }
  while ((ch != EOF) && (ch != '\n'));
}

void free_all()
{
  int i;
  for (i = 0; i < 40897; i++)
    if (matchtable[i] != 0)
  {
    {
      free_match(matchtable[i]);
    }
  }
  else
  {
    
  }


  free(matchtable);
  for (i = 0; i < 20111; i++)
    if (teamtable[i] != 0)
  {
    {
      free(teamtable[i]->name);
      free(teamtable[i]);
    }
  }
  else
  {
    
  }


  free(teamtable);
}

int main()
{
  int command;
  char match_id[1024];
  char t1[1024];
  char t2[1024];
  char t[1024];
  char *taux;
  int s1;
  int s2;
  pmatch found_match;
  pmatch match_to_remove;
  pmatch current_match;
  Teamtableinit();
  Matchtableinit();
  while ((command = getchar()) != 'x')
  {
    nl++;
    switch (command)
    {
      case 'a':
        for (int match_id_index = 0; match_id_index < 10; match_id_index++)
      {
        match_id[match_id_index] = new_sym_var(sizeof(char) * 8);
      }

        match_id[10 - 1] = '\0';
        for (int t1_index = 0; t1_index < 10; t1_index++)
      {
        t1[t1_index] = new_sym_var(sizeof(char) * 8);
      }

        t1[10 - 1] = '\0';
        for (int t2_index = 0; t2_index < 10; t2_index++)
      {
        t2[t2_index] = new_sym_var(sizeof(char) * 8);
      }

        t2[10 - 1] = '\0';
        s1 = new_sym_var(sizeof(int) * 8);
        s2 = new_sym_var(sizeof(int) * 8);
        if (search_match_in_table(match_id) != 0)
      {
        printf("%d Jogo existente.\n", nl);
      }
      else
      {
        if ((search_team_in_table(t1) == 0) || (search_team_in_table(t2) == 0))
        {
          {
            printf("%d Equipa inexistente.\n", nl);
          }
        }
        else
        {
          {
            winner(t1, t2, s1, s2);
            add_match(match_id, t1, t2, s1, s2);
            entry++;
          }
        }

      }

        break;

      case 'A':
        for (int t_index = 0; t_index < 10; t_index++)
      {
        t[t_index] = new_sym_var(sizeof(char) * 8);
      }

        t[10 - 1] = '\0';
        taux = str_treatment(t);
        if (search_team_in_table(taux) == 0)
      {
        add_team(taux);
      }
      else
      {
        printf("%d Equipa existente.\n", nl);
      }

        free(taux);
        break;

      case 'l':
        list_games();
        break;

      case 'p':
        for (int match_id_index = 0; match_id_index < 10; match_id_index++)
      {
        match_id[match_id_index] = new_sym_var(sizeof(char) * 8);
      }

        match_id[10 - 1] = '\0';
        found_match = search_match_in_table(match_id);
        if (found_match != 0)
      {
        printf("%d %s %s %s %d %d\n", nl, found_match->id, found_match->team1, found_match->team2, found_match->score1, found_match->score2);
      }
      else
      {
        printf("%d Jogo inexistente.\n", nl);
      }

        break;

      case 'P':
        for (int t_index = 0; t_index < 10; t_index++)
      {
        t[t_index] = new_sym_var(sizeof(char) * 8);
      }

        t[10 - 1] = '\0';
        taux = str_treatment(t);
        search_team(taux);
        free(taux);
        break;

      case 'r':
        for (int match_id_index = 0; match_id_index < 10; match_id_index++)
      {
        match_id[match_id_index] = new_sym_var(sizeof(char) * 8);
      }

        match_id[10 - 1] = '\0';
        match_to_remove = search_match_in_table(match_id);
        if (match_to_remove == 0)
      {
        printf("%d Jogo inexistente.\n", nl);
      }
      else
      {
        {
          remove_win(match_to_remove->team1, match_to_remove->team2, match_to_remove->score1, match_to_remove->score2);
          remove_match(match_to_remove);
        }
      }

        break;

      case 's':
        for (int match_id_index = 0; match_id_index < 10; match_id_index++)
      {
        match_id[match_id_index] = new_sym_var(sizeof(char) * 8);
      }

        match_id[10 - 1] = '\0';
        s1 = new_sym_var(sizeof(int) * 8);
        s2 = new_sym_var(sizeof(int) * 8);
        current_match = search_match_in_table(match_id);
        if (current_match == 0)
      {
        printf("%d Jogo inexistente.\n", nl);
      }
      else
      {
        edit_result(current_match, s1, s2);
      }

        break;

      case 'g':
        best_teams();
        break;

      case 'x':
        break;

    }

    flush_in();
  }

  free_all();
  return 0;
}

