/*File generated by PreProcessor.py*/


#include "proj_aux.h"


int hash(char *nome)
{
  int h = 0;
  int a = 127;
  for (; (*nome) != '\0'; nome++)
    h = ((a * h) + (*nome)) % 647;

  return h;
}

elink *init_eq()
{
  int i;
  elink *heads_eq;
  heads_eq = malloc(647 * (sizeof(struct equipa)));
  for (i = 0; i < 647; i++)
    heads_eq[i] = 0;

  return heads_eq;
}

jlink *init_jog()
{
  int i;
  jlink *heads_j;
  heads_j = malloc(647 * (sizeof(struct jogo)));
  for (i = 0; i < 647; i++)
    heads_j[i] = 0;

  return heads_j;
}

eq lookup_eq(elink head, char *nome)
{
  elink e;
  for (e = head; e != 0; e = e->next)
  {
    if (strcmp(e->eq->nome, nome) == 0)
    {
      return e->eq;
    }
    else
    {
      
    }

  }

  return 0;
}

j lookup_j(jlink head, char *nome)
{
  jlink j;
  for (j = head; j != 0; j = j->next)
    if (strcmp(j->jog->nome, nome) == 0)
  {
    return j->jog;
  }
  else
  {
    
  }


  return 0;
}

elink insertBegin_eq(elink head, eq equipa)
{
  elink eq = malloc(sizeof(struct equipa));
  eq->eq = equipa;
  eq->next = head;
  return eq;
}

jlink insertBegin_j(jlink head, j jogo)
{
  jlink j = malloc(sizeof(struct jogo));
  if (head != 0)
  {
    head->prev = j;
  }
  else
  {
    
  }

  j->jog = jogo;
  j->next = head;
  return j;
}

void executa_a(jlink *heads_j, list_j *list_j, elink *heads_eq, int nl)
{
  char nome_jogo[1024];
  char nome_eq1[1024];
  char nome_eq2[1024];
  int score1;
  int score2;
  j jogo;
  int i;
  int j;
  int k;
  eq eq1;
  eq eq2;
  for (int nome_jogo_index = 0; nome_jogo_index < 10; nome_jogo_index++)
  {
    nome_jogo[nome_jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_jogo[10 - 1] = '\0';
  for (int nome_eq1_index = 0; nome_eq1_index < 10; nome_eq1_index++)
  {
    nome_eq1[nome_eq1_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_eq1[10 - 1] = '\0';
  for (int nome_eq2_index = 0; nome_eq2_index < 10; nome_eq2_index++)
  {
    nome_eq2[nome_eq2_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_eq2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  i = hash(nome_jogo);
  j = hash(nome_eq1);
  k = hash(nome_eq2);
  if (lookup_j(heads_j[i], nome_jogo) != 0)
  {
    {
      printf("%d Jogo existente.\n", nl);
    }
  }
  else
  {
    if (((eq1 = lookup_eq(heads_eq[j], nome_eq1)) == 0) || ((eq2 = lookup_eq(heads_eq[k], nome_eq2)) == 0))
    {
      {
        printf("%d Equipa inexistente.\n", nl);
      }
    }
    else
    {
      {
        jogo = malloc(sizeof(struct jogo));
        jogo->equipa1 = eq1;
        jogo->equipa2 = eq2;
        jogo->score1 = score1;
        jogo->score2 = score2;
        jogo->nome = (char *) malloc((sizeof(char)) * (strlen(nome_jogo) + 1));
        strcpy(jogo->nome, nome_jogo);
        heads_j[i] = insertBegin_j(heads_j[i], jogo);
        insertEndList(list_j, jogo);
        if (score1 < score2)
        {
          {
            eq2->vitorias += 1;
          }
        }
        else
        {
          if (score1 > score2)
          {
            {
              eq1->vitorias += 1;
            }
          }
          else
          {
            
          }

        }

      }
    }

  }

}

void executa_A(elink *heads_eq, int nl)
{
  char nome_eq[1024];
  int i;
  eq equipa;
  int j;
  eq eq;
  for (int nome_eq_index = 0; nome_eq_index < 10; nome_eq_index++)
  {
    nome_eq[nome_eq_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_eq[10 - 1] = '\0';
  j = hash(nome_eq);
  if ((eq = lookup_eq(heads_eq[j], nome_eq)) != 0)
  {
    printf("%d Equipa existente.\n", nl);
  }
  else
  {
    {
      equipa = malloc(sizeof(struct equipa));
      equipa->nome = (char *) malloc((sizeof(char)) * (strlen(nome_eq) + 1));
      strcpy(equipa->nome, nome_eq);
      equipa->vitorias = 0;
      i = hash(equipa->nome);
      heads_eq[i] = insertBegin_eq(heads_eq[i], equipa);
    }
  }

}

void executa_l(list_j *list_j, int nl)
{
  jlink t;
  for (t = list_j->head; t != 0; t = t->next)
    printf("%d %s %s %s %d %d\n", nl, t->jog->nome, t->jog->equipa1->nome, t->jog->equipa2->nome, t->jog->score1, t->jog->score2);

}

void executa_p(jlink *heads_j, int nl)
{
  char nome_jogo[1024];
  int i;
  j jog;
  for (int nome_jogo_index = 0; nome_jogo_index < 10; nome_jogo_index++)
  {
    nome_jogo[nome_jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_jogo[10 - 1] = '\0';
  i = hash(nome_jogo);
  if ((jog = lookup_j(heads_j[i], nome_jogo)) == 0)
  {
    printf("%d Jogo inexistente.\n", nl);
  }
  else
  {
    {
      printf("%d %s %s %s %d %d\n", nl, jog->nome, jog->equipa1->nome, jog->equipa2->nome, jog->score1, jog->score2);
    }
  }

}

void executa_P(elink *heads_eq, int nl)
{
  char nome_eq[1024];
  int i;
  eq equipa;
  for (int nome_eq_index = 0; nome_eq_index < 10; nome_eq_index++)
  {
    nome_eq[nome_eq_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_eq[10 - 1] = '\0';
  i = hash(nome_eq);
  if ((equipa = lookup_eq(heads_eq[i], nome_eq)) == 0)
  {
    printf("%d Equipa inexistente.\n", nl);
  }
  else
  {
    {
      printf("%d %s %d\n", nl, equipa->nome, equipa->vitorias);
    }
  }

}

void executa_s(jlink *heads_j, int nl)
{
  char nome_jogo[1024];
  int score1;
  int score2;
  j jogo;
  int i;
  for (int nome_jogo_index = 0; nome_jogo_index < 10; nome_jogo_index++)
  {
    nome_jogo[nome_jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_jogo[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  i = hash(nome_jogo);
  if ((jogo = lookup_j(heads_j[i], nome_jogo)) == 0)
  {
    printf("%d Jogo inexistente.\n", nl);
  }
  else
  {
    {
      if ((jogo->score1 > jogo->score2) && (score1 <= score2))
      {
        jogo->equipa1->vitorias -= 1;
      }
      else
      {
        if ((jogo->score1 < jogo->score2) && (score1 >= score2))
        {
          jogo->equipa2->vitorias -= 1;
        }
        else
        {
          
        }

      }

      if ((jogo->score1 <= jogo->score2) && (score1 > score2))
      {
        jogo->equipa1->vitorias += 1;
      }
      else
      {
        if ((jogo->score1 >= jogo->score2) && (score1 < score2))
        {
          jogo->equipa2->vitorias += 1;
        }
        else
        {
          
        }

      }

      jogo->score1 = score1;
      jogo->score2 = score2;
    }
  }

}

void executa_r(jlink *heads_j, list_j *list_j, int nl)
{
  char nome_jogo[1024];
  int i;
  j jogo;
  for (int nome_jogo_index = 0; nome_jogo_index < 10; nome_jogo_index++)
  {
    nome_jogo[nome_jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_jogo[10 - 1] = '\0';
  i = hash(nome_jogo);
  if ((jogo = lookup_j(heads_j[i], nome_jogo)) == 0)
  {
    printf("%d Jogo inexistente.\n", nl);
  }
  else
  {
    {
      if (jogo->score1 > jogo->score2)
      {
        jogo->equipa1->vitorias -= 1;
      }
      else
      {
        if (jogo->score1 < jogo->score2)
        {
          jogo->equipa2->vitorias -= 1;
        }
        else
        {
          
        }

      }

      heads_j[i] = delete_jog(heads_j[i], nome_jogo);
      *list_j = delete_j(*list_j, nome_jogo);
    }
  }

}

jlink delete_jog(jlink head, char *nome)
{
  jlink jogo;
  for (jogo = head; jogo != 0; jogo = jogo->next)
  {
    if (strcmp(jogo->jog->nome, nome) == 0)
    {
      {
        if (jogo == head)
        {
          head = jogo->next;
        }
        else
        {
          jogo->prev->next = jogo->next;
        }

        if (jogo->next != 0)
        {
          jogo->next->prev = jogo->prev;
        }
        else
        {
          
        }

        free(jogo);
        break;
      }
    }
    else
    {
      
    }

  }

  return head;
}

list_j delete_j(list_j list_j, char *nome)
{
  jlink jogo;
  for (jogo = list_j.head; jogo != 0; jogo = jogo->next)
  {
    if (strcmp(jogo->jog->nome, nome) == 0)
    {
      {
        if (jogo == list_j.head)
        {
          list_j.head = jogo->next;
        }
        else
        {
          jogo->prev->next = jogo->next;
        }

        if (jogo->next != 0)
        {
          jogo->next->prev = jogo->prev;
        }
        else
        {
          list_j.tail = jogo->prev;
        }

        free(jogo->jog->nome);
        free(jogo->jog);
        free(jogo);
        break;
      }
    }
    else
    {
      
    }

  }

  return list_j;
}

list_j *insertEndList(list_j *list_j, j jogo)
{
  jlink j = malloc(sizeof(struct node_jog));
  j->jog = jogo;
  j->next = 0;
  if (list_j->head == 0)
  {
    {
      list_j->head = j;
    }
  }
  else
  {
    list_j->tail->next = j;
  }

  j->prev = list_j->tail;
  list_j->tail = j;
  return list_j;
}

void free_hash_eq(elink *heads_eq)
{
  int i;
  for (i = 0; i < 647; i++)
    free_list_eq(heads_eq[i]);

  free(heads_eq);
}

void free_list_eq(elink head)
{
  elink eq;
  while (head != 0)
  {
    eq = head->next;
    free(head->eq->nome);
    free(head->eq);
    free(head);
    head = eq;
  }

}

void free_hash_jog(jlink *heads_j)
{
  int i;
  for (i = 0; i < 647; i++)
    free_list_jog(heads_j[i]);

  free(heads_j);
}

void free_list_jog(jlink head)
{
  jlink j;
  while (head != 0)
  {
    j = head->next;
    free(head->jog->nome);
    free(head->jog);
    free(head);
    head = j;
  }

}

void free_list_j(list_j *list_j)
{
  jlink j;
  while (list_j->head != 0)
  {
    j = list_j->head->next;
    free(list_j->head);
    list_j->head = j;
  }

}

