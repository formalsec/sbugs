/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <string.h>
#include "hash.h"


int get_hash_value(char *word, int table_size)
{
  int hash = 0;
  int a = 127;
  for (; (*word) != '\0'; word++)
    hash = ((a * hash) + (*word)) % table_size;

  return hash;
}

hash_teams create_teams_hash_table(int table_size)
{
  hash_teams table = malloc(sizeof(struct my_hash_teams));
  table->table = calloc(table_size, sizeof(struct sl_node));
  table->max_size = table_size;
  table->current_size = 0;
  return table;
}

void insert_team_hash(hash_teams table, sl_link team_node)
{
  int hash = get_hash_value(team_node->value->name, table->max_size);
  while (table->table[hash] != 0)
    hash = (hash + 1) % table->max_size;

  table->table[hash] = team_node;
  table->current_size++;
  if (table->current_size > (table->max_size / 2))
  {
    expands_team_hash(table);
  }
  else
  {
    
  }

}

int search_team_index_in_hash(hash_teams table, char *team_name)
{
  int hash = get_hash_value(team_name, table->max_size);
  while (table->table[hash] != 0)
  {
    if (strcmp(table->table[hash]->value->name, team_name) == 0)
    {
      {
        return hash;
      }
    }
    else
    {
      {
        hash = (hash + 1) % table->max_size;
      }
    }

  }

  return -1;
}

void expands_team_hash(hash_teams table)
{
  int i;
  sl_link *aux = table->table;
  table->table = (sl_link *) calloc(table->max_size * 2, sizeof(sl_link));
  table->max_size = table->max_size * 2;
  table->current_size = 0;
  for (i = 0; i < (table->max_size / 2); i++)
  {
    if (aux[i] != 0)
    {
      {
        insert_team_hash(table, aux[i]);
      }
    }
    else
    {
      
    }

  }

  free(aux);
}

void destroy_teams_hash(hash_teams table)
{
  if (table)
  {
    {
      free(table->table);
      free(table);
    }
  }
  else
  {
    
  }

}

hash_games create_games_hash_table(int table_size)
{
  hash_games table = malloc(sizeof(struct my_hash_games));
  table->table = calloc(table_size, sizeof(struct dl_node));
  table->max_size = table_size;
  table->current_size = 0;
  return table;
}

void insert_games_hash(hash_games table, dl_link game_node)
{
  int hash = get_hash_value(game_node->value->name, table->max_size);
  while (table->table[hash] != 0)
    hash = (hash + 1) % table->max_size;

  table->table[hash] = game_node;
  table->current_size++;
  if (table->current_size > (table->max_size / 2))
  {
    expands_games_hash(table);
  }
  else
  {
    
  }

  if (table->current_size > (table->max_size / 2))
  {
    expands_games_hash(table);
  }
  else
  {
    
  }

}

int search_game_index_in_hash(hash_games table, char *game_name)
{
  int hash = get_hash_value(game_name, table->max_size);
  while (table->table[hash] != 0)
  {
    if (strcmp(table->table[hash]->value->name, game_name) == 0)
    {
      {
        return hash;
      }
    }
    else
    {
      {
        hash = (hash + 1) % table->max_size;
      }
    }

  }

  return -1;
}

void expands_games_hash(hash_games table)
{
  int i;
  dl_link *temp = table->table;
  table->table = (dl_link *) calloc(table->max_size * 2, sizeof(dl_link));
  table->max_size = table->max_size * 2;
  table->current_size = 0;
  for (i = 0; i < (table->max_size / 2); i++)
  {
    if (temp[i] != 0)
    {
      {
        insert_games_hash(table, temp[i]);
      }
    }
    else
    {
      
    }

  }

  free(temp);
}

void deletes_game_hash(hash_games table, int game_index)
{
  int i;
  dl_link node;
  table->current_size--;
  table->table[game_index] = 0;
  for (i = (game_index + 1) % table->max_size; table->table[i] != 0; i = (i + 1) % table->max_size)
  {
    node = table->table[i];
    table->table[i] = 0;
    insert_games_hash(table, node);
  }

}

void destroy_games_hash(hash_games table)
{
  if (table)
  {
    {
      free(table->table);
      free(table);
    }
  }
  else
  {
    
  }

}

