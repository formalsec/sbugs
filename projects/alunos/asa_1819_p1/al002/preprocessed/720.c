#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int *topology_order;
int total_vertices;
int scc = 0;
int biggest_scc = 0;
int *scc_ids;
int counter_c = 0;
int counter_max = 1;
int max_counter = 0;
int *topology;
typedef struct graph *Graph;
typedef struct node *link;
struct node
{
  int v;
  link next;
};
struct graph
{
  int n_vertices;
  int n_edges;
  link *array;
};
typedef struct 
{
  int colour;
  int disc;
  int low;
  int parent;
} node_components;
typedef struct 
{
  int colour;
  int v;
  int car_articulation_point;
} vertex;
vertex *ap;
node_components *node_aux_components;
Graph createGraph();
link insertBegin(int v, link head);
void addEdge(Graph graph, int router1, int router2);
int min(int a, int b);
void DFS(Graph graph);
void DFSvisit(Graph graph, int index, int transpose);
void resetVisited(Graph graph);
void printSccIds();
void sortSccIds();
void findScc(Graph graph);
void articulationsPoints(Graph graph);
void maxScc(Graph graph);
void DFST(Graph graph, int index, int transpose);
int main()
{
  int r1;
  int r2;
  int inter;
  Graph graph = createGraph();
  for (inter = 0; inter < graph->n_edges; inter++)
  {
    if (2)
    {
      r1 = new_sym_var(sizeof(int) * 8);
      r2 = new_sym_var(sizeof(int) * 8);
    }
    else
    {
      
    }

    addEdge(graph, r1, r2);
  }

  DFS(graph);
  resetVisited(graph);
  findScc(graph);
  articulationsPoints(graph);
  maxScc(graph);
  return 0;
}

Graph createGraph()
{
  int index;
  Graph graph = malloc(sizeof(struct graph));
  if (1)
  {
    graph->n_vertices = new_sym_var(sizeof(int) * 8);
  }
  else
  {
    
  }

  if (1)
  {
    graph->n_edges = new_sym_var(sizeof(int) * 8);
  }
  else
  {
    
  }

  total_vertices = graph->n_vertices;
  graph->array = malloc((graph->n_vertices + 1) * (sizeof(link)));
  for (index = 0; index < graph->n_vertices; index++)
  {
    graph->array[index] = 0;
  }

  scc_ids = malloc(sizeof(int));
  scc_ids[0] = 0;
  return graph;
}

link insertBegin(int v, link old_head)
{
  link new_head = malloc((sizeof(struct node)) + 1);
  new_head->next = old_head;
  new_head->v = v;
  return new_head;
}

void addEdge(Graph graph, int router1, int router2)
{
  graph->array[router1] = insertBegin(router2, graph->array[router1]);
  graph->array[router2] = insertBegin(router1, graph->array[router2]);
}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

void DFS(Graph graph)
{
  int index;
  node_aux_components = malloc(graph->n_vertices * (sizeof(node_components)));
  topology_order = (int *) malloc((graph->n_vertices + 1) * (sizeof(int)));
  for (index = 1; index <= graph->n_vertices; index++)
  {
    node_aux_components[index].colour = 0;
  }

  for (index = 1; index <= graph->n_vertices; index++)
  {
    if (node_aux_components[index].colour == 0)
    {
      DFSvisit(graph, index, 1);
    }
    else
    {
      
    }

  }

}

void DFSvisit(Graph graph, int value, int transpose)
{
  static int time = 0;
  int children = 0;
  int flag = 0;
  node_aux_components[value].colour = 1;
  if (transpose == (-2))
  {
    time++;
    node_aux_components[value].disc = (node_aux_components[value].low = time);
  }
  else
  {
    
  }

  link node = graph->array[value];
  while (node != 0)
  {
    if ((transpose != (-2)) && (node_aux_components[node->v].colour == 0))
    {
      if ((transpose == (-1)) && (node->v > biggest_scc))
      {
        biggest_scc = node->v;
      }
      else
      {
        
      }

      DFSvisit(graph, node->v, transpose);
    }
    else
    {
      
    }

    if ((transpose == (-2)) && (node_aux_components[node->v].colour == 0))
    {
      children++;
      node_aux_components[node->v].parent = value;
      DFSvisit(graph, node->v, transpose);
      node_aux_components[value].low = min(node_aux_components[value].low, node_aux_components[node->v].low);
      if ((node_aux_components[value].parent == (-1)) && (children > 1))
      {
        ap[value].car_articulation_point = 1;
        flag = 1;
      }
      else
      {
        
      }

      if ((node_aux_components[value].parent != (-1)) && (node_aux_components[value].disc <= node_aux_components[node->v].low))
      {
        ap[value].car_articulation_point = 1;
        flag = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if ((transpose == (-2)) && (node->v != node_aux_components[value].parent))
      {
        node_aux_components[value].low = min(node_aux_components[value].low, node_aux_components[node->v].disc);
      }
      else
      {
        
      }

    }

    node = node->next;
  }

  if (flag == 1)
  {
    counter_c++;
    flag = 0;
  }
  else
  {
    
  }

  if (transpose == 1)
  {
    topology_order[total_vertices] = value;
    total_vertices--;
  }
  else
  {
    
  }

}

void resetVisited(Graph graph)
{
  int index;
  for (index = 1; index <= graph->n_vertices; index++)
  {
    node_aux_components[index].colour = 0;
  }

  total_vertices = graph->n_vertices;
}

void printSccIds()
{
  int index;
  for (index = 0; index < (scc - 1); index++)
  {
    printf("%d ", scc_ids[index]);
  }

  printf("%d\n", scc_ids[scc - 1]);
}

void sortSccIds()
{
  int aux;
  int index;
  for (index = scc - 1; (index >= 0) && (scc_ids[index] < scc_ids[index - 1]); index--)
  {
    aux = scc_ids[index];
    scc_ids[index] = scc_ids[index - 1];
    scc_ids[index - 1] = aux;
  }

}

void findScc(Graph graph)
{
  int flag = 0;
  int index;
  for (index = 1; index <= graph->n_vertices; index++)
  {
    int vertice_colour = node_aux_components[topology_order[index]].colour;
    if (vertice_colour == 0)
    {
      scc++;
      flag = 1;
      biggest_scc = 0;
      DFSvisit(graph, topology_order[index], -1);
    }
    else
    {
      
    }

    if (flag == 1)
    {
      scc_ids[scc - 1] = biggest_scc;
      sortSccIds();
      scc_ids = (int *) realloc(scc_ids, (sizeof(int)) * (scc + 1));
      flag = 0;
    }
    else
    {
      
    }

  }

  printf("%d\n", scc);
  printSccIds();
}

void articulationsPoints(Graph graph)
{
  int index;
  ap = malloc(graph->n_vertices * (sizeof(vertex)));
  topology = malloc(graph->n_vertices * (sizeof(vertex)));
  for (index = 1; index <= graph->n_vertices; index++)
  {
    node_aux_components[index].parent = -1;
    node_aux_components[index].colour = 0;
    ap[index].colour = 0;
    ap[index].car_articulation_point = 0;
    ap[index].v = index;
  }

  for (index = 1; index <= graph->n_vertices; index++)
  {
    if (node_aux_components[index].colour == 0)
    {
      DFSvisit(graph, index, -2);
    }
    else
    {
      
    }

  }

  printf("%d\n", counter_c);
}

void DFST(Graph graph, int index, int transpose)
{
  ap[index].colour = 1;
  link node = graph->array[index];
  while (node != 0)
  {
    if ((ap[node->v].car_articulation_point == 0) && (ap[node->v].colour == 0))
    {
      if (transpose == (-1))
      {
        counter_max++;
      }
      else
      {
        
      }

      DFST(graph, node->v, transpose);
    }
    else
    {
      
    }

    node = node->next;
  }

  if (transpose == 1)
  {
    topology[total_vertices] = index;
    total_vertices--;
  }
  else
  {
    
  }

}

void maxScc(Graph graph)
{
  int index;
  total_vertices = graph->n_vertices;
  for (index = 1; index <= graph->n_vertices; index++)
  {
    if ((ap[index].car_articulation_point == 0) && (ap[index].colour == 0))
    {
      DFST(graph, index, 1);
    }
    else
    {
      
    }

  }

  for (index = 1; index <= graph->n_vertices; index++)
  {
    ap[index].colour = 0;
  }

  total_vertices = graph->n_vertices;
  for (index = counter_c + 1; index <= graph->n_vertices; index++)
  {
    int vertice_colour = ap[topology[index]].colour;
    if (vertice_colour == 0)
    {
      DFST(graph, topology[index], -1);
    }
    else
    {
      
    }

    if (counter_max > max_counter)
    {
      max_counter = counter_max;
    }
    else
    {
      
    }

    counter_max = 1;
  }

  printf("%d\n", max_counter);
}

