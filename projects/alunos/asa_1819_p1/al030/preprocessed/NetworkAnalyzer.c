#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


struct Node
{
  int Id;
  struct Node *next;
} Node;
int router_number;
int connections_number;
int subnetworks;
int artic_number;
int root_node;
int child_nodes;
int current_subn_id;
int subnetwork_size;
int dfs_time;
int *node_depth;
int *node_low;
int *node_parent;
int *network_articulations;
int *subnetwork_identifiers;
struct Node *network;
void read_input();
void save_to_network(int node1, int node2);
void main_art();
void Articulation_recursive(int u);
int subnetwork_dfs();
void sub_finder(int u);
void print_results();
int main(int argc, const char *argv[])
{
  read_input();
  main_art();
  print_results();
  return 0;
}

void read_input()
{
  int i;
  int j;
  int node1;
  int node2;
  int k;
  k = 1;
  router_number = new_sym_var(sizeof(int) * 8);
  k = 1;
  connections_number = new_sym_var(sizeof(int) * 8);
  k = k + 1;
  network = malloc((sizeof(Node)) * router_number);
  for (j = 0; j < router_number; j++)
  {
    network[j].Id = j + 1;
    network[j].next = 0;
  }

  for (i = 1; i <= connections_number; i++)
  {
    k = 2;
    node1 = new_sym_var(sizeof(int) * 8);
    node2 = new_sym_var(sizeof(int) * 8);
    save_to_network(node1, node2);
  }

}

void save_to_network(int node1, int node2)
{
  struct Node *newnode1;
  struct Node *newnode2;
  struct Node *network_point;
  network_point = &network[node1 - 1];
  newnode2 = malloc(sizeof(Node));
  newnode2->Id = node2;
  newnode2->next = network_point->next;
  network_point->next = newnode2;
  network_point = &network[node2 - 1];
  newnode1 = malloc(sizeof(Node));
  newnode1->Id = node1;
  newnode1->next = network_point->next;
  network_point->next = newnode1;
}

void main_art()
{
  int i;
  node_depth = malloc((sizeof(int)) * router_number);
  node_low = malloc((sizeof(int)) * router_number);
  node_parent = malloc((sizeof(int)) * router_number);
  network_articulations = malloc((sizeof(int)) * router_number);
  subnetwork_identifiers = malloc((sizeof(int)) * router_number);
  for (i = 0; i < router_number; i++)
  {
    node_depth[i] = -1;
    node_low[i] = 0;
    node_parent[i] = 0;
    network_articulations[i] = 1;
    subnetwork_identifiers[i] = 0;
  }

  dfs_time = 0;
  artic_number = 0;
  for (i = 0; i < router_number; i++)
  {
    if (node_depth[i] == (-1))
    {
      subnetworks++;
      current_subn_id = i + 1;
      root_node = i;
      child_nodes = 0;
      Articulation_recursive(i);
      subnetwork_identifiers[current_subn_id - 1] = 1;
      network_articulations[root_node] = child_nodes;
    }
    else
    {
      
    }

  }

}

void Articulation_recursive(int this_node)
{
  struct Node current;
  int adj_node;
  node_depth[this_node] = (node_low[this_node] = dfs_time++);
  if (current_subn_id < (this_node + 1))
  {
    current_subn_id = this_node + 1;
  }
  else
  {
    
  }

  for (current = network[this_node]; current.next != 0; current = *current.next)
  {
    adj_node = current.next->Id - 1;
    if (node_depth[adj_node] == (-1))
    {
      node_parent[adj_node] = this_node;
      if (this_node == root_node)
      {
        child_nodes++;
      }
      else
      {
        
      }

      Articulation_recursive(adj_node);
      if (node_low[adj_node] >= node_depth[this_node])
      {
        network_articulations[this_node]++;
      }
      else
      {
        
      }

      node_low[this_node] = (node_low[this_node] < node_low[adj_node]) ? (node_low[this_node]) : (node_low[adj_node]);
    }
    else
    {
      if (adj_node != node_parent[this_node])
      {
        node_low[this_node] = (node_low[this_node] < node_depth[adj_node]) ? (node_low[this_node]) : (node_depth[adj_node]);
      }
      else
      {
        
      }

    }

  }

}

int subnetwork_dfs()
{
  int i;
  int largest_subnetwork = 0;
  for (i = 0; i < router_number; i++)
  {
    node_depth[i] = -1;
  }

  for (i = 0; i < router_number; i++)
  {
    subnetwork_size = 0;
    if ((node_depth[i] == (-1)) && (network_articulations[i] <= 1))
    {
      sub_finder(i);
      if (subnetwork_size > largest_subnetwork)
      {
        largest_subnetwork = subnetwork_size;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return largest_subnetwork;
}

void sub_finder(int this_node)
{
  struct Node current;
  int adj_node;
  node_depth[this_node] = 0;
  subnetwork_size++;
  for (current = network[this_node]; current.next != 0; current = *current.next)
  {
    adj_node = current.next->Id - 1;
    if ((node_depth[adj_node] == (-1)) && (network_articulations[adj_node] <= 1))
    {
      sub_finder(adj_node);
    }
    else
    {
      
    }

  }

}

void print_results()
{
  int i;
  printf("%d\n", subnetworks);
  for (i = 0; i < router_number; i++)
  {
    if (subnetwork_identifiers[i] == 1)
    {
      printf("%d", i + 1);
      i++;
      break;
    }
    else
    {
      
    }

  }

  while (i < router_number)
  {
    if (subnetwork_identifiers[i] == 1)
    {
      printf(" %d", i + 1);
    }
    else
    {
      
    }

    i++;
  }

  printf("\n");
  for (i = 0; i < router_number; i++)
  {
    if (network_articulations[i] > 1)
    {
      artic_number++;
    }
    else
    {
      
    }

  }

  printf("%d\n", artic_number);
  printf("%d\n", subnetwork_dfs());
}

