/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct Node *node;
struct Node
{
  int number;
  node nextNode;
};
void initList(node *list);
void printAndClearList(node list);
node pushNode(node list, int number);
int isEmpty(node *list);
int popNode(node *list);
void clearList(node list);
typedef struct Graph *graph;
struct Graph
{
  int V;
  int E;
  int visit;
  int componentsNumber;
  int *d;
  int *d_cut;
  int *low;
  int *low_cut;
  int *parent;
  node *adj;
  node stack;
};
void initVertex(graph g, int v);
graph graphInit(int V);
void graphDestroy(graph g);
graph graphReset(graph g);
graph readLineArguments();
int max(int u, int v);
int min(int u, int v);
void tarjanVisitCut(graph g, int v, node *maxSCC, int *cutVertexNum);
void tarjanCut(graph g, node *maxSCC, int *cutVertexNum);
void tarjanVisit(graph g, int v, int *maxRouterNumber);
void tarjan(graph g, int *maxRouterNumber);
void initList(node *list)
{
  *list = 0;
}

void printAndClearList(node list)
{
  node prev;
  while (list->nextNode != 0)
  {
    printf("%d ", list->number);
    prev = list;
    list = list->nextNode;
    free(prev);
  }

  printf("%d\n", list->number);
  free(list);
}

node pushNode(node list, int number)
{
  node newNode = (node) malloc(sizeof(struct Node));
  newNode->number = number;
  newNode->nextNode = list;
  return newNode;
}

int isEmpty(node *list)
{
  if ((*list) == 0)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int popNode(node *list)
{
  int number;
  node aux;
  if (!isEmpty(list))
  {
    number = (*list)->number;
    aux = *list;
    *list = aux->nextNode;
    free(aux);
    return number;
  }
  else
  {
    return 0;
  }

}

void clearList(node list)
{
  node prev;
  while (list != 0)
  {
    prev = list;
    list = list->nextNode;
    free(prev);
  }

}

void initVertex(graph g, int v)
{
  g->d[v] = -1;
  g->parent[v] = -1;
  g->d_cut[v] = (g->low_cut[v] = 1);
  initList(&g->adj[v]);
}

graph graphInit(int V)
{
  int v;
  graph g = (graph) malloc(sizeof(struct Graph));
  g->V = V;
  g->E = 0;
  g->componentsNumber = 0;
  g->visit = 1;
  g->d = (int *) malloc(V * (sizeof(int)));
  g->d_cut = (int *) malloc(V * (sizeof(int)));
  g->low = (int *) malloc(V * (sizeof(int)));
  g->low_cut = (int *) malloc(V * (sizeof(int)));
  g->parent = (int *) malloc(V * (sizeof(int)));
  g->adj = (node *) malloc(V * (sizeof(node)));
  for (v = 0; v < V; v++)
  {
    initVertex(g, v);
  }

  return g;
}

void graphInsertE(graph g, int v, int w)
{
  g->adj[v] = pushNode(g->adj[v], w);
  g->adj[w] = pushNode(g->adj[w], v);
  g->E++;
}

void graphDestroy(graph g)
{
  int v;
  for (v = 0; v < g->V; v++)
  {
    if (g->adj[v] != 0)
    {
      clearList(g->adj[v]);
    }
    else
    {
      
    }

  }

  free(g->d);
  free(g->low);
  free(g->adj);
  free(g);
}

graph graphReset(graph g)
{
  int v;
  g->componentsNumber = 0;
  g->visit = 1;
  for (v = 1; v < g->V; v++)
  {
    if (g->adj[v] != 0)
    {
      g->d[v] = -1;
      g->low[v] = -1;
    }
    else
    {
      
    }

  }

  free(g->d_cut);
  free(g->low_cut);
  free(g->parent);
  return g;
}

graph readLineArguments()
{
  int V;
  int E;
  int i;
  V = new_sym_var(sizeof(int) * 8);
  E = new_sym_var(sizeof(int) * 8);
  graph g = graphInit(V + 1);
  for (i = 0; i < E; i++)
  {
    int v;
    int w;
    v = new_sym_var(sizeof(int) * 8);
    w = new_sym_var(sizeof(int) * 8);
    graphInsertE(g, v, w);
  }

  return g;
}

int max(int u, int v)
{
  if (u > v)
  {
    return u;
  }
  else
  {
    return v;
  }

}

int min(int u, int v)
{
  if (u < v)
  {
    return u;
  }
  else
  {
    return v;
  }

}

void tarjanVisitCut(graph g, int v, node *maxSCC, int *cutVertexNum)
{
  int w;
  int isCut = 0;
  int children = 0;
  g->d[v] = (g->low[v] = g->visit++);
  if (g->parent[v] != (-1))
  {
    g->d_cut[v] = (g->low_cut[v] = g->d_cut[g->parent[v]] + 1);
  }
  else
  {
    
  }

  node *stack = &g->stack;
  *stack = pushNode(*stack, v);
  node adj = g->adj[v];
  for (; adj != 0; adj = adj->nextNode)
  {
    w = adj->number;
    if (g->d[w] == (-1))
    {
      children++;
      g->parent[w] = v;
      tarjanVisitCut(g, w, maxSCC, cutVertexNum);
      g->low[v] = min(g->low[v], g->low[w]);
      g->low_cut[v] = min(g->low_cut[v], g->low_cut[w]);
      if (g->low_cut[w] >= g->d_cut[v])
      {
        isCut = 1;
      }
      else
      {
        
      }

    }
    else
    {
      g->low[v] = min(g->low[v], g->d[w]);
    }

    if ((g->d[w] != (-1)) && (g->parent[v] != adj->number))
    {
      g->low_cut[v] = min(g->low_cut[v], g->d_cut[w]);
    }
    else
    {
      
    }

  }

  if (((g->parent[v] != (-1)) && isCut) || ((g->parent[v] == (-1)) && (children > 1)))
  {
    (*cutVertexNum)++;
    clearList(g->adj[v]);
    g->adj[v] = 0;
  }
  else
  {
    
  }

  if (g->d[v] == g->low[v])
  {
    int number;
    int maxNum = 0;
    g->componentsNumber++;
    do
    {
      number = popNode(stack);
      maxNum = max(number, maxNum);
    }
    while (number != v);
    *maxSCC = pushNode(*maxSCC, maxNum);
  }
  else
  {
    
  }

}

void tarjanCut(graph g, node *maxSCC, int *cutVertexNum)
{
  int i;
  for (i = g->V - 1; i > 0; i--)
  {
    if (g->d[i] == (-1))
    {
      tarjanVisitCut(g, i, maxSCC, cutVertexNum);
    }
    else
    {
      
    }

  }

}

void tarjanVisit(graph g, int v, int *maxRouterNumber)
{
  int w;
  g->d[v] = (g->low[v] = g->visit++);
  node *stack = &g->stack;
  *stack = pushNode(*stack, v);
  node adj = g->adj[v];
  for (; adj != 0; adj = adj->nextNode)
  {
    w = adj->number;
    if (g->adj[w] != 0)
    {
      if (g->d[w] == (-1))
      {
        tarjanVisit(g, w, maxRouterNumber);
        g->low[v] = min(g->low[v], g->low[w]);
      }
      else
      {
        g->low[v] = min(g->low[v], g->d[w]);
      }

    }
    else
    {
      
    }

  }

  if (g->d[v] == g->low[v])
  {
    int number;
    int inc = 0;
    do
    {
      number = popNode(stack);
      inc++;
    }
    while (number != v);
    if (inc > (*maxRouterNumber))
    {
      *maxRouterNumber = inc;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

}

void tarjan(graph g, int *maxRouterNumber)
{
  int i = 1;
  for (; i < g->V; i++)
  {
    if (g->d[i] == (-1))
    {
      tarjanVisit(g, i, maxRouterNumber);
    }
    else
    {
      
    }

  }

}

int main()
{
  int cutVertexNum = 0;
  int maxRouterNumber = 0;
  node maxSCC;
  initList(&maxSCC);
  graph g = readLineArguments();
  tarjanCut(g, &maxSCC, &cutVertexNum);
  printf("%d\n", g->componentsNumber);
  printAndClearList(maxSCC);
  printf("%d\n", cutVertexNum);
  graphReset(g);
  tarjan(g, &maxRouterNumber);
  printf("%d\n", maxRouterNumber);
  graphDestroy(g);
  return 0;
}

