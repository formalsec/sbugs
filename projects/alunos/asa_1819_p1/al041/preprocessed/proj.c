#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int N = 0;
int M = 0;
typedef struct 
{
  int v;
  int w;
} Edge;
typedef struct graph *Graph;
typedef struct node *link;
struct node
{
  int v;
  link next;
};
struct graph
{
  int V;
  int E;
  link *adj;
};
int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

link insertBegin(int v, link head)
{
  link x = malloc(sizeof(struct node));
  x->v = v;
  x->next = head;
  return x;
}

void insertEdge(Graph G, Edge e)
{
  int v = e.v;
  int w = e.w;
  G->adj[v] = insertBegin(w, G->adj[v]);
  G->adj[w] = insertBegin(v, G->adj[w]);
  G->E++;
}

Edge createEdge(int x, int y)
{
  Edge e;
  e.v = x;
  e.w = y;
  return e;
}

void printGraph(Graph G)
{
  int i;
  for (i = 1; i <= N; i++)
  {
    struct node *temp = G->adj[i];
    printf("Vertice: %d\n ", i);
    while (temp)
    {
      printf("%d -> ", temp->v);
      temp = temp->next;
    }

    printf("\n");
  }

}

Graph initializeGraph(int V)
{
  int v;
  Graph G = malloc(sizeof(struct graph));
  G->V = V;
  G->E = 0;
  G->adj = malloc((V + 1) * (sizeof(link)));
  for (v = 0; v <= V; v++)
    G->adj[v] = 0;

  return G;
}

void merge(int low, int mid, int high, int a[], int b[])
{
  int l1;
  int l2;
  int i;
  for (l1 = low, l2 = mid + 1, i = low; (l1 <= mid) && (l2 <= high); i++)
  {
    if (a[l1] <= a[l2])
    {
      b[i] = a[l1++];
    }
    else
    {
      b[i] = a[l2++];
    }

  }

  while (l1 <= mid)
    b[i++] = a[l1++];

  while (l2 <= high)
    b[i++] = a[l2++];

  for (i = low; i <= high; i++)
    a[i] = b[i];

}

void mergeSort(int low, int high, int list[], int listSorted[])
{
  int mid;
  if (low < high)
  {
    mid = (low + high) / 2;
    mergeSort(low, mid, list, listSorted);
    mergeSort(mid + 1, high, list, listSorted);
    merge(low, mid, high, list, listSorted);
  }
  else
  {
    return;
  }

}

void DFSAux(Graph G, int v, int visited[], int des[], int parent[], int low[], int ap[], int *ID, int *count)
{
  struct node *temp = 0;
  static int time = 0;
  int children = 0;
  temp = G->adj[v];
  visited[v] = 1;
  time++;
  des[v] = (low[v] = time);
  if (v > (*ID))
  {
    *ID = v;
  }
  else
  {
    
  }

  if (temp != 0)
  {
    *count = (*count) + 1;
  }
  else
  {
    
  }

  while (temp != 0)
  {
    if (!visited[temp->v])
    {
      children++;
      parent[temp->v] = v;
      DFSAux(G, temp->v, visited, des, parent, low, ap, ID, count);
      low[v] = min(low[v], low[temp->v]);
      if ((parent[v] == 0) && (children > 1))
      {
        ap[v] = 1;
      }
      else
      {
        
      }

      if ((parent[v] != 0) && (des[v] <= low[temp->v]))
      {
        ap[v] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (temp->v != parent[v])
      {
        low[v] = min(low[v], des[temp->v]);
      }
      else
      {
        
      }

    }

    temp = temp->next;
  }

}

void DFS(Graph G)
{
  int visited[N + 1];
  int ap[N + 1];
  int des[N + 1];
  int ID = 0;
  int j = 0;
  int k = 0;
  int i;
  int count = 0;
  int biggestSub = 0;
  int articulationPoints = 0;
  int subNetworks = 0;
  int *low = malloc((sizeof(int)) * (N + 1));
  int *parent = malloc((sizeof(int)) * (N + 1));
  int *ids = malloc((sizeof(int)) * (N + 1));
  int *idsSorted = malloc((sizeof(int)) * (N + 1));
  int *aps = malloc((sizeof(int)) * (N + 1));
  for (i = 0; i <= N; i++)
  {
    parent[i] = 0;
    visited[i] = 0;
    ap[i] = 0;
    ids[i] = 0;
    idsSorted[i] = 0;
    aps[i] = 0;
  }

  for (i = 1; i <= N; i++)
  {
    if (visited[i] == 0)
    {
      subNetworks++;
      DFSAux(G, i, visited, des, parent, low, ap, &ID, &count);
      ids[j] = ID;
      j++;
      ID = 0;
    }
    else
    {
      
    }

  }

  for (i = 0; i <= N; i++)
  {
    if (ap[i] == 1)
    {
      aps[k] = i;
      k++;
      articulationPoints++;
    }
    else
    {
      
    }

  }

  printf("%d\n", subNetworks);
  mergeSort(0, N, ids, idsSorted);
  for (i = 0; i <= N; i++)
  {
    if (idsSorted[i] == N)
    {
      printf("%d", idsSorted[i]);
    }
    else
    {
      if (idsSorted[i] != 0)
      {
        printf("%d ", idsSorted[i]);
      }
      else
      {
        
      }

    }

  }

  printf("\n%d\n", articulationPoints);
  for (i = 0; i <= N; i++)
  {
    if (aps[i] != 0)
    {
      G->adj[aps[i]] = 0;
    }
    else
    {
      
    }

  }

  for (i = 0; i <= N; i++)
  {
    parent[i] = 0;
    visited[i] = 0;
  }

  count = 0;
  for (i = 1; i <= N; i++)
  {
    if (visited[i] == 0)
    {
      DFSAux(G, i, visited, des, parent, low, ap, &ID, &count);
      if (count > biggestSub)
      {
        biggestSub = count;
      }
      else
      {
        
      }

      count = 0;
    }
    else
    {
      
    }

  }

  printf("%d\n", biggestSub);
  for (i = 0; i <= N; i++)
    free(G->adj[i]);

  free(G);
  free(low);
  free(parent);
  free(ids);
  free(idsSorted);
  free(aps);
}

int main()
{
  N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  Graph G = initializeGraph(N);
  int v;
  int w;
  int i;
  for (i = 0; i < M; i++)
  {
    v = new_sym_var(sizeof(int) * 8);
    w = new_sym_var(sizeof(int) * 8);
    insertEdge(G, createEdge(v, w));
  }

  DFS(G);
  return 0;
}

