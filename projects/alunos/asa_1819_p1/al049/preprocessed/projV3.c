/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct vector
{
  int capacity;
  int size;
  int *elements;
} *Vector;
Vector vectorInit(int initSize);
void vectorFree(Vector vectorPtr);
int vectorIndexAt(Vector vectorPtr, int index);
int vectorPush(Vector vectorPtr, int element);
int vectorPop(Vector vectorPtr);
int vectorSize(Vector v);
typedef struct vertex
{
  int visits;
  int time;
  int low;
  struct vertex *parent;
  Vector connections;
} *Vertex;
Vertex vertexInit(int n);
void vertexFree(Vertex v);
void vertexAddVisit(Vertex v);
int vertexVisited(Vertex v);
int vertexVisitCount(Vertex v);
void vertexSetTime(Vertex v, int t);
int vertexGetTime(Vertex v);
int vertexGetLow(Vertex v);
void vertexSetLow(Vertex v, int t);
void vertexSetParent(Vertex v, Vertex p);
Vertex vertexGetParent(Vertex v);
int vertexHasParent(Vertex v);
void vertexAddConnection(Vertex v, int n);
Vector vertexGetConnections(Vertex v);
typedef struct graph
{
  Vertex *vertices;
  int size;
} *Graph;
Graph graphInit(int v);
void graphFree(Graph g);
Vertex graphGetVertex(Graph g, int n);
int graphSize(Graph g);
int graphConnect(Graph g, int n1, int n2);
void errorFound(const char *message);
Graph readInput();
void calcArtPoints(Graph g, Vertex v, int *t, int *artPoints);
int calcSize(Graph g, Vertex v);
Vector networkAnalysis(Graph g, int *artPoints, int *maxTree);
void printOutput(Vector trees, int artPoints, int maxTree);
Vector vectorInit(int initSize)
{
  Vector vectorPtr = (Vector) malloc(sizeof(struct vector));
  if (vectorPtr == 0)
  {
    return 0;
  }
  else
  {
    
  }

  vectorPtr->capacity = (initSize > 1) ? (initSize) : (1);
  vectorPtr->size = 0;
  vectorPtr->elements = (int *) malloc((sizeof(int)) * vectorPtr->capacity);
  if (vectorPtr->elements == 0)
  {
    free(vectorPtr);
    return 0;
  }
  else
  {
    
  }

  return vectorPtr;
}

void vectorFree(Vector vectorPtr)
{
  free(vectorPtr->elements);
  free(vectorPtr);
}

int vectorIndexAt(Vector vectorPtr, int index)
{
  if ((index < 0) || (index >= vectorPtr->size))
  {
    return 0;
  }
  else
  {
    
  }

  return vectorPtr->elements[index];
}

int vectorPush(Vector vectorPtr, int element)
{
  if (vectorPtr->size == vectorPtr->capacity)
  {
    int *tmp = (int *) realloc(vectorPtr->elements, ((sizeof(int)) * 2) * vectorPtr->capacity);
    if (tmp == 0)
    {
      return 0;
    }
    else
    {
      
    }

    vectorPtr->elements = tmp;
    vectorPtr->capacity = vectorPtr->capacity * 2;
  }
  else
  {
    
  }

  vectorPtr->elements[vectorPtr->size++] = element;
  return 1;
}

int vectorPop(Vector vectorPtr)
{
  if (vectorPtr->size == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return vectorPtr->elements[--vectorPtr->size];
}

int vectorSize(Vector v)
{
  return v->size;
}

Vertex vertexInit(int n)
{
  Vertex v = (Vertex) malloc(sizeof(struct vertex));
  if (v == 0)
  {
    return 0;
  }
  else
  {
    
  }

  v->connections = vectorInit(-1);
  if (v->connections == 0)
  {
    free(v);
    return 0;
  }
  else
  {
    
  }

  v->visits = 0;
  v->time = 0;
  v->parent = 0;
  return v;
}

void vertexFree(Vertex v)
{
  vectorFree(v->connections);
  free(v);
}

void vertexAddVisit(Vertex v)
{
  v->visits++;
}

int vertexVisited(Vertex v)
{
  return v->visits != 0;
}

int vertexVisitCount(Vertex v)
{
  return v->visits;
}

void vertexSetTime(Vertex v, int t)
{
  v->time = t;
}

int vertexGetTime(Vertex v)
{
  return v->time;
}

int vertexGetLow(Vertex v)
{
  return v->low;
}

void vertexSetLow(Vertex v, int t)
{
  v->low = t;
}

void vertexSetParent(Vertex v, Vertex p)
{
  if (v == p)
  {
    return;
  }
  else
  {
    
  }

  v->parent = p;
}

Vertex vertexGetParent(Vertex v)
{
  return v->parent;
}

int vertexHasParent(Vertex v)
{
  if (v->parent != 0)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void vertexAddConnection(Vertex v, int n)
{
  vectorPush(v->connections, n);
}

Vector vertexGetConnections(Vertex v)
{
  return v->connections;
}

Graph graphInit(int v)
{
  Graph g;
  int i;
  int j;
  if (v < 2)
  {
    return 0;
  }
  else
  {
    
  }

  g = (Graph) malloc(sizeof(struct graph));
  if (g == 0)
  {
    return 0;
  }
  else
  {
    
  }

  g->vertices = (Vertex *) malloc((sizeof(Vertex)) * v);
  if (g->vertices == 0)
  {
    free(g);
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < v; ++i)
  {
    g->vertices[i] = vertexInit(i + 1);
    if (g->vertices[i] == 0)
    {
      for (j = 0; j < i; ++j)
        vertexFree(g->vertices[j]);

      free(g->vertices);
      free(g);
      return 0;
    }
    else
    {
      
    }

  }

  g->size = v;
  return g;
}

void graphFree(Graph g)
{
  int i;
  for (i = 0; i < g->size; ++i)
    vertexFree(g->vertices[i]);

  free(g->vertices);
  free(g);
}

Vertex graphGetVertex(Graph g, int n)
{
  if (((g == 0) || (n < 1)) || (n > g->size))
  {
    return 0;
  }
  else
  {
    
  }

  return g->vertices[n - 1];
}

int graphSize(Graph g)
{
  return g->size;
}

int graphConnect(Graph g, int n1, int n2)
{
  if (((((n1 == n2) || (n1 < 1)) || (n2 < 1)) || (n1 > g->size)) || (n2 > g->size))
  {
    return 0;
  }
  else
  {
    
  }

  vertexAddConnection(g->vertices[n1 - 1], n2);
  vertexAddConnection(g->vertices[n2 - 1], n1);
  return 1;
}

void errorFound(const char *message)
{
  printf("%s", message);
  exit(1);
}

Graph readInput()
{
  int nrouters;
  int nconnects;
  int u;
  int v;
  int i = 0;
  Graph g;
  if (1 < 0)
  {
    errorFound("error reading input\n");
  }
  else
  {
    nrouters = new_sym_var(sizeof(int) * 8);
    
  }

  if (nrouters < 2)
  {
    errorFound("Number of routers needs to be at least 2\n");
  }
  else
  {
    
  }

  if (1 < 0)
  {
    errorFound("error reading input\n");
  }
  else
  {
    nconnects = new_sym_var(sizeof(int) * 8);
    
  }

  if (nconnects < 1)
  {
    errorFound("Number of connections needs to be at least 1\n");
  }
  else
  {
    
  }

  g = graphInit(nrouters);
  if (g == 0)
  {
    errorFound("Error creating graph\n");
  }
  else
  {
    
  }

  for (i = 0; i < nconnects; ++i)
  {
    if (2 < 0)
    {
      errorFound("error reading input\n");
    }
    else
    {
      u = new_sym_var(sizeof(int) * 8);
      v = new_sym_var(sizeof(int) * 8);
      
    }

    if (graphConnect(g, u, v) == 0)
    {
      errorFound("Invalid connection\n");
    }
    else
    {
      
    }

  }

  return g;
}

void calcArtPoints(Graph g, Vertex v, int *t, int *artPoints)
{
  int n;
  int i;
  int children = 0;
  Vertex u;
  Vector vertices = vertexGetConnections(v);
  vertexSetTime(v, *t);
  vertexSetLow(v, (*t)++);
  vertexAddVisit(v);
  for (i = 0; i < vectorSize(vertices); ++i)
  {
    n = vectorIndexAt(vertices, i);
    u = graphGetVertex(g, n);
    if (!vertexVisited(u))
    {
      children++;
      vertexSetParent(u, v);
      calcArtPoints(g, u, t, artPoints);
      if (vertexGetLow(v) > vertexGetLow(u))
      {
        vertexSetLow(v, vertexGetLow(u));
      }
      else
      {
        
      }

      if ((vertexVisitCount(v) == 1) && (((!vertexHasParent(v)) && (children > 1)) || (vertexHasParent(v) && (vertexGetLow(u) >= vertexGetTime(v)))))
      {
        (*artPoints)++;
        vertexAddVisit(v);
      }
      else
      {
        
      }

    }
    else
    {
      if (u != vertexGetParent(v))
      {
        if (vertexGetLow(v) > vertexGetTime(u))
        {
          vertexSetLow(v, vertexGetTime(u));
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

}

int calcSize(Graph g, Vertex v)
{
  int n;
  int i;
  int size = 1;
  Vertex u;
  Vector vertices = vertexGetConnections(v);
  vertexAddVisit(v);
  for (i = 0; i < vectorSize(vertices); ++i)
  {
    n = vectorIndexAt(vertices, i);
    u = graphGetVertex(g, n);
    if (vertexVisitCount(u) == 1)
    {
      size += calcSize(g, u);
    }
    else
    {
      
    }

  }

  return size;
}

Vector networkAnalysis(Graph g, int *artPoints, int *maxTree)
{
  int n;
  int t = 1;
  int size;
  Vertex v;
  Vector trees = vectorInit(-1);
  if (trees == 0)
  {
    errorFound("Error creating vector\n");
  }
  else
  {
    
  }

  for (n = graphSize(g); n > 0; --n)
  {
    v = graphGetVertex(g, n);
    if (!vertexVisited(v))
    {
      vectorPush(trees, n);
      calcArtPoints(g, v, &t, artPoints);
    }
    else
    {
      
    }

  }

  for (n = graphSize(g); n > 0; --n)
  {
    v = graphGetVertex(g, n);
    if (vertexVisitCount(v) == 1)
    {
      size = calcSize(g, v);
      if (size > (*maxTree))
      {
        *maxTree = size;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return trees;
}

void printOutput(Vector trees, int artPoints, int maxTree)
{
  printf("%d\n", vectorSize(trees));
  printf("%d", vectorPop(trees));
  while (vectorSize(trees) != 0)
  {
    printf(" %d", vectorPop(trees));
  }

  printf("\n%d\n%d\n", artPoints, maxTree);
}

int main(int argc, const char *argv[])
{
  Graph g = readInput();
  int artPoints = 0;
  int maxTree = 0;
  Vector trees = networkAnalysis(g, &artPoints, &maxTree);
  printOutput(trees, artPoints, maxTree);
  vectorFree(trees);
  graphFree(g);
  return 0;
}

