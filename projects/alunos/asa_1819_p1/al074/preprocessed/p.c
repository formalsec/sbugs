#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>


struct AdjListNode
{
  int dest;
  struct AdjListNode *next;
};
struct EdgesNode
{
  int u;
  int v;
  int check;
  struct EdgesNode *next;
};
struct AdjList
{
  struct AdjListNode *head;
};
struct Graph
{
  int V;
  struct AdjList *array;
};
struct Node
{
  int data;
  struct Node *link;
};
struct EdgesNode *InsertEdge(struct EdgesNode *head, int u, int v)
{
  struct EdgesNode *e = (struct EdgesNode *) malloc(sizeof(struct EdgesNode));
  e->u = u;
  e->v = v;
  e->check = 0;
  e->next = head;
  return e;
}

void FREEedges(struct EdgesNode *head)
{
  struct EdgesNode *e;
  while (head != 0)
  {
    e = head;
    head = head->next;
    free(e);
  }

}

struct EdgesNode *delete(struct EdgesNode *head, int u, int v)
{
  struct EdgesNode *t;
  struct EdgesNode *prev;
  for (t = head, prev = 0; t != 0; prev = t, t = t->next)
  {
    if (((t->u == u) && (t->v == v)) || ((t->u == v) && (t->v == u)))
    {
      if (t == head)
      {
        head = t->next;
      }
      else
      {
        prev->next = t->next;
      }

      if (t->check == 1)
      {
        free(t);
      }
      else
      {
        t->check += 1;
      }

    }
    else
    {
      
    }

  }

  return head;
}

struct Node *top;
void push(int data)
{
  struct Node *temp;
  temp = (struct Node *) malloc(sizeof(struct Node));
  temp->data = data;
  temp->link = top;
  top = temp;
}

int isEmpty()
{
  return top == 0;
}

void pop()
{
  struct Node *temp;
  if (top != 0)
  {
    temp = top;
    top = top->link;
    temp->link = 0;
    free(temp);
  }
  else
  {
    
  }

}

int peek()
{
  if (!isEmpty(top))
  {
    return top->data;
  }
  else
  {
    exit(1);
  }

}

int find(int parent[], int i)
{
  if (parent[i] <= (-1))
  {
    return i;
  }
  else
  {
    
  }

  if (parent[parent[i]] >= 0)
  {
    parent[i] = parent[parent[i]];
  }
  else
  {
    
  }

  return find(parent, parent[i]);
}

void Union(int parent[], int x, int y)
{
  int xset = find(parent, x);
  int yset = find(parent, y);
  if (xset > yset)
  {
    parent[xset] += parent[yset];
    parent[yset] = xset;
  }
  else
  {
    if (xset < yset)
    {
      parent[yset] += parent[xset];
      parent[xset] = yset;
    }
    else
    {
    }

  }

}

struct AdjListNode *NewAdjListNode(int dest)
{
  struct AdjListNode *newNode = (struct AdjListNode *) malloc(sizeof(struct AdjListNode));
  newNode->dest = dest;
  newNode->next = 0;
  return newNode;
}

struct Graph *createGraph(int V)
{
  struct Graph *graph = (struct Graph *) malloc(sizeof(struct Graph));
  graph->V = V;
  graph->array = (struct AdjList *) malloc((V + 1) * (sizeof(struct AdjList)));
  int i;
  for (i = 0; i <= V; i++)
  {
    graph->array[i].head = 0;
  }

  return graph;
}

void FREEgraph(struct Graph *g)
{
  struct AdjListNode *t;
  struct AdjListNode *prev;
  int i;
  for (i = 0; i < g->V; i++)
  {
    for (t = g->array[i].head, prev = 0; t != 0; prev = t, t = t->next)
    {
      if (prev != 0)
      {
        free(prev);
      }
      else
      {
        
      }

    }

  }

  free(g->array);
  free(g);
}

void addEdge(struct Graph *graph, int src, int dest)
{
  struct AdjListNode *newNode = NewAdjListNode(dest);
  newNode->next = graph->array[src].head;
  graph->array[src].head = newNode;
  newNode = NewAdjListNode(src);
  newNode->next = graph->array[dest].head;
  graph->array[dest].head = newNode;
}

struct EdgesNode *head;
void DFS(struct Graph *g, int u, int visited[], int disc[], int low[], int parent[], int ap[], int time)
{
  struct AdjListNode *t;
  int children = 0;
  visited[u] = 1;
  disc[u] = time + 1;
  low[u] = disc[u];
  for (t = g->array[u].head; t != 0; t = t->next)
  {
    int v = t->dest;
    if (visited[v] == 0)
    {
      children++;
      parent[v] = u;
      DFS(g, v, visited, disc, low, parent, ap, time + 1);
      if (low[u] > low[v])
      {
        low[u] = low[v];
      }
      else
      {
        
      }

      if ((parent[u] == (-1)) && (children > 1))
      {
        ap[u] = 1;
      }
      else
      {
        
      }

      if ((parent[u] != (-1)) && (low[v] >= disc[u]))
      {
        ap[u] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (v != parent[u])
      {
        if (low[u] > disc[v])
        {
          low[u] = disc[v];
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

}

void EXE(struct Graph *g, int E)
{
  int i;
  int V = g->V;
  int visited[V + 1];
  int disc[V + 1];
  int low[V + 1];
  int parent[V + 1];
  int ap[V + 1];
  struct AdjListNode *e;
  for (i = 0; i <= V; i++)
  {
    parent[i] = -1;
    visited[i] = 0;
    ap[i] = 0;
  }

  for (i = 0; i <= V; i++)
  {
    DFS(g, i, visited, disc, low, parent, ap, 0);
  }

  int *list = (int *) malloc((V + 1) * (sizeof(int)));
  memset(list, -1, (V + 1) * (sizeof(int)));
  int C = 0;
  for (i = 1; i <= V; i++)
  {
    if (ap[i] == 1)
    {
      C++;
    }
    else
    {
      for (e = g->array[i].head; e != 0; e = e->next)
      {
        if (ap[e->dest] == 0)
        {
          Union(list, i, e->dest);
        }
        else
        {
          
        }

      }

    }

  }

  printf("%d\n", C);
  int min = 0;
  for (i = 0; i < (V + 1); i++)
  {
    if (list[i] < min)
    {
      min = list[i];
    }
    else
    {
      
    }

  }

  printf("%d\n", (-1) * min);
  free(list);
}

int main()
{
  int V = 0;
  int E = 0;
  int i;
  int u;
  int v;
  int ret;
  int Sub;
  char aux[500];
  char result[10000];
  strcpy(result, "");
  ret = 1;
  V = new_sym_var(sizeof(int) * 8);
  ret = 1;
  E = new_sym_var(sizeof(int) * 8);
  int *list = (int *) malloc((V + 1) * (sizeof(int)));
  memset(list, -1, (V + 1) * (sizeof(int)));
  struct Graph *g = createGraph(V);
  for (i = 0; i < E; i++)
  {
    ret = 2;
    u = new_sym_var(sizeof(int) * 8);
    v = new_sym_var(sizeof(int) * 8);
    addEdge(g, u, v);
    Union(list, u, v);
  }

  for (i = 1, Sub = 0; i < (V + 1); i++)
  {
    if (list[i] < 0)
    {
      Sub++;
      if (i == V)
      {
        sprintf(aux, "%d", i);
      }
      else
      {
        sprintf(aux, "%d ", i);
      }

      strcat(result, aux);
    }
    else
    {
      
    }

  }

  printf("%d\n%s\n", Sub, result);
  free(list);
  EXE(g, E);
  FREEedges(head);
  FREEgraph(g);
  return ret = 0;
}

