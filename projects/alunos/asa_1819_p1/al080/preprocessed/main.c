#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct vertex
{
  int index;
  struct vertex *next;
  struct vertex *prev;
} Vertex;
typedef struct tarjan_info
{
  int d;
  int low;
  int *scc;
  unsigned int out : 1;
} TarjanInfo;
typedef struct tarjan
{
  int next_d;
  int Q_count;
  int *Q;
  int scc_count;
  int scc_arch_count;
  TarjanInfo *info;
} Tarjan;
void add_next_arch(Vertex *, int);
void add_prev_arch(Vertex *, int);
int add_unique_arch(Vertex *, int);
void Tarjan_Visit(int);
void scc_arch_count();
int N;
Vertex *graph;
Tarjan tarjan;
int main(void)
{
  int M;
  int src;
  int dest;
  int i;
  if (1 == EOF)
  {
    return 0;
  }
  else
  {
    N = new_sym_var(sizeof(int) * 8);
    
  }

  graph = (Vertex *) malloc((sizeof(struct vertex)) * N);
  tarjan.next_d = 0;
  tarjan.Q_count = 0;
  tarjan.Q = (int *) malloc((sizeof(int)) * N);
  tarjan.info = (TarjanInfo *) malloc((sizeof(struct tarjan_info)) * N);
  tarjan.scc_count = 0;
  tarjan.scc_arch_count = 0;
  for (i = 0; i < N; i++)
  {
    graph[i].index = i;
    graph[i].next = 0;
    graph[i].prev = 0;
    tarjan.info[i].d = -1;
    tarjan.info[i].low = -1;
    tarjan.info[i].scc = &i;
    tarjan.info[i].out = 0;
  }

  if (1 == EOF)
  {
    return 0;
  }
  else
  {
    M = new_sym_var(sizeof(int) * 8);
    
  }

  i = 0;
  while ((i < M) && (2 != EOF))
  {
    src = new_sym_var(sizeof(int) * 8);
    dest = new_sym_var(sizeof(int) * 8);
    add_next_arch(&graph[src - 1], dest - 1);
    i++;
  }

  for (i = 0; i < N; i++)
  {
    if (tarjan.info[i].out == 1)
    {
      continue;
    }
    else
    {
      
    }

    Tarjan_Visit(i);
  }

  scc_arch_count();
  printf("%d\n", tarjan.scc_count);
  printf("%d\n", tarjan.scc_arch_count);
  for (i = 0; i < N; i++)
  {
    Vertex *adj = graph[i].next;
    Vertex *prev_adj = 0;
    while (adj != 0)
    {
      printf("%d %d\n", i + 1, adj->index + 1);
      prev_adj = adj;
      adj = adj->next;
      free(prev_adj);
    }

  }

  free(graph);
  free(tarjan.Q);
  free(tarjan.info);
  return 0;
}

void add_next_arch(Vertex *node, int dest)
{
  if (node->index == dest)
  {
    return;
  }
  else
  {
    
  }

  Vertex *adj = (Vertex *) malloc(sizeof(struct vertex));
  adj->index = dest;
  adj->next = node->next;
  adj->prev = 0;
  node->next = adj;
}

void add_prev_arch(Vertex *node, int dest)
{
  Vertex *parent = (Vertex *) malloc(sizeof(struct vertex));
  parent->index = dest;
  parent->next = 0;
  parent->prev = node->prev;
  node->prev = parent;
}

int add_unique_arch(Vertex *node, int dest)
{
  if (node->index == dest)
  {
    return 0;
  }
  else
  {
    
  }

  Vertex *adj = (Vertex *) malloc(sizeof(struct vertex));
  adj->index = dest;
  adj->next = 0;
  adj->prev = 0;
  while (node->next != 0)
  {
    node = node->next;
    if (node->index == dest)
    {
      free(adj);
      return 0;
    }
    else
    {
      
    }

  }

  node->next = adj;
  return 1;
}

void Tarjan_Visit(int index)
{
  tarjan.info[index].d = (tarjan.info[index].low = tarjan.next_d);
  tarjan.next_d++;
  tarjan.Q[tarjan.Q_count] = index;
  tarjan.Q_count++;
  Vertex *prev_adj = 0;
  Vertex *adj = graph[index].next;
  graph[index].next = 0;
  while (adj != 0)
  {
    if ((tarjan.info[adj->index].out == 0) || (tarjan.info[adj->index].d == (-1)))
    {
      if (tarjan.info[adj->index].d == (-1))
      {
        Tarjan_Visit(adj->index);
      }
      else
      {
        
      }

      if (tarjan.info[index].low > tarjan.info[adj->index].low)
      {
        tarjan.info[index].low = tarjan.info[adj->index].low;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    if (tarjan.info[adj->index].out == 1)
    {
      add_prev_arch(&graph[*tarjan.info[adj->index].scc], index);
    }
    else
    {
      
    }

    prev_adj = adj;
    adj = adj->next;
    free(prev_adj);
  }

  if (tarjan.info[index].d == tarjan.info[index].low)
  {
    int *min = (int *) malloc(sizeof(int));
    *min = index;
    tarjan.Q_count--;
    int pop_id = tarjan.Q[tarjan.Q_count];
    tarjan.info[pop_id].scc = min;
    tarjan.info[pop_id].out = 1;
    while (pop_id != index)
    {
      if (pop_id < (*min))
      {
        *min = pop_id;
      }
      else
      {
        
      }

      tarjan.Q_count--;
      pop_id = tarjan.Q[tarjan.Q_count];
      tarjan.info[pop_id].scc = min;
      tarjan.info[pop_id].out = 1;
    }

    tarjan.scc_count++;
  }
  else
  {
    
  }

}

void scc_arch_count()
{
  int i;
  Vertex *parent;
  Vertex *prev_parent = 0;
  for (i = 0; i < N; i++)
  {
    parent = graph[i].prev;
    while (parent != 0)
    {
      tarjan.scc_arch_count += add_unique_arch(&graph[*tarjan.info[parent->index].scc], i);
      prev_parent = parent;
      parent = parent->prev;
      free(prev_parent);
    }

  }

}

