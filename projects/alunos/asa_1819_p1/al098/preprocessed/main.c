#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <assert.h>
#include <stdio.h>
#include <stdlib.h>


typedef struct key_list
{
  int i;
  struct key_list *next;
} *KeyList;
typedef struct answer
{
  int R;
  int C;
  int m;
  KeyList Keys;
} *Answer;
typedef struct vertex *Vertex;
typedef struct adj_vertex
{
  Vertex vertex;
  struct adj_vertex *next;
} *AdjVertex;
struct vertex
{
  int id;
  int discovery;
  int parent;
  int critical;
  int low;
  AdjVertex head;
};
typedef struct graph
{
  Vertex array;
  int N;
} *Graph;
int DFS(Graph g, Answer a, int v, int depth, int update)
{
  int w;
  int i = 0;
  int critical = 0;
  AdjVertex adj;
  g->array[v].discovery = (g->array[v].low = depth);
  if (g->array[v].id == (-1))
  {
    return --depth;
  }
  else
  {
    
  }

  for (adj = g->array[v].head; adj != 0; adj = adj->next)
  {
    w = adj->vertex->id;
    if (w == (-1))
    {
      continue;
    }
    else
    {
      
    }

    if (!g->array[w].discovery)
    {
      g->array[w].parent = v + 1;
      i++;
      depth = DFS(g, a, w, ++depth, update);
      if (g->array[w].low >= g->array[v].discovery)
      {
        critical = 1;
      }
      else
      {
        
      }

      g->array[v].low = (g->array[v].low < g->array[w].low) ? (g->array[v].low) : (g->array[w].low);
    }
    else
    {
      if (g->array[v].parent != (w + 1))
      {
        g->array[v].low = (g->array[v].low < g->array[w].discovery) ? (g->array[v].low) : (g->array[w].discovery);
      }
      else
      {
        
      }

    }

  }

  if (update && (((!g->array[v].parent) && (i > 1)) || (g->array[v].parent && critical)))
  {
    g->array[v].critical = 1;
    a->C++;
  }
  else
  {
    
  }

  return ++depth;
}

void removeCritical(Graph g)
{
  int i;
  for (i = 0; i < g->N; i++)
  {
    g->array[i].discovery = 0;
    if (g->array[i].critical)
    {
      g->array[i].id = -1;
    }
    else
    {
      
    }

  }

}

void link(Graph g, int a, int b)
{
  Vertex v = &g->array[a - 1];
  AdjVertex new = malloc(sizeof(struct adj_vertex));
  new->vertex = &g->array[b - 1];
  new->next = v->head;
  v->head = new;
}

void parseInput(Graph g)
{
  int a;
  int b;
  int i;
  int M;
  g->N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  g->array = calloc(g->N, sizeof(struct vertex));
  for (i = 0; i < g->N; i++)
  {
    g->array[i].head = 0;
    g->array[i].id = i;
  }

  for (i = 0; i < M; i++)
  {
    a = new_sym_var(sizeof(int) * 8);
    b = new_sym_var(sizeof(int) * 8);
    link(g, a, b);
    link(g, b, a);
  }

}

void displayResults(Answer a)
{
  KeyList aux = a->Keys;
  printf("%d\n%d", a->R, a->Keys->i);
  a->Keys = a->Keys->next;
  free(aux);
  while (a->Keys)
  {
    printf(" %d", a->Keys->i);
    aux = a->Keys;
    a->Keys = a->Keys->next;
    free(aux);
  }

  printf("\n%d\n%d\n", a->C, a->m);
}

void freeGraph(Graph g)
{
  int i;
  int N = g->N;
  AdjVertex aux;
  for (i = 0; i < N; i++)
  {
    while (g->array[i].head)
    {
      aux = g->array[i].head;
      g->array[i].head = g->array[i].head->next;
      free(aux);
    }

  }

  free(g->array);
  free(g);
}

int main(void)
{
  int i;
  int prev;
  int processed;
  Graph g = malloc(sizeof(struct graph));
  Answer a = malloc(sizeof(struct answer));
  prev = (processed = (a->R = (a->C = (a->m = 0))));
  a->Keys = 0;
  parseInput(g);
  for (i = g->N - 1; i >= 0; i--)
  {
    if (!g->array[i].discovery)
    {
      KeyList new = malloc(sizeof(struct key_list));
      new->i = i + 1;
      new->next = a->Keys;
      a->Keys = new;
      processed = DFS(g, a, i, ++processed, 1);
      a->R++;
    }
    else
    {
      
    }

  }

  removeCritical(g);
  processed = 0;
  for (i = 0; i < g->N; i++)
  {
    if (!g->array[i].discovery)
    {
      processed = DFS(g, a, i, ++processed, 0);
      a->m = (a->m > ((processed - prev) / 2)) ? (a->m) : ((processed - prev) / 2);
      prev = processed;
    }
    else
    {
      
    }

  }

  displayResults(a);
  freeGraph(g);
  free(a);
  return 0;
}

