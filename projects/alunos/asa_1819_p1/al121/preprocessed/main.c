#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h> 


typedef struct Vertex
{
  struct Node *adj;
  int id;
  int prev;
  int discovery;
  int colour;
  int low;
  int is_ap;
} Vertex;
typedef struct Node
{
  Vertex *data;
  struct Node *next;
} Node;
Node *add_element(Node *head, Vertex *v)
{
  Node *node = malloc(sizeof(Node));
  if (node == 0)
  {
    fprintf(stderr, "\nErro ao alocar memoria\n");
    return 0;
  }
  else
  {
    
  }

  node->next = head;
  node->data = v;
  return node;
}

void free_list(Node *adj)
{
  Node *to_free;
  while (adj != 0)
  {
    to_free = adj;
    adj = adj->next;
    free(to_free);
  }

}

int min(int a, int b)
{
  if (a > b)
  {
    return b;
  }
  else
  {
    
  }

  return a;
}

int maximo(int a, int b)
{
  if (a > b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

void DFS();
void dfs_visit(Vertex *v);
void DFS_ap();
void dfs_visit_ap(Vertex *v);
Vertex *graph;
int sub_redes = 0;
int nr_vertex;
int time = 1;
int ap = 0;
int max = 0;
int current = 0;
void free_Graph()
{
  int i;
  for (i = 0; i < nr_vertex; i++)
  {
    free_list(graph[i].adj);
  }

  free(graph);
}

int main()
{
  int nr_edges;
  int v;
  int u;
  int i;
  nr_vertex = new_sym_var(sizeof(int) * 8);
  if (nr_vertex < 2)
  {
    fprintf(stderr, "Argumentos inválidos");
    return -1;
  }
  else
  {
    
  }

  graph = malloc(nr_vertex * (sizeof(Vertex)));
  if (graph == 0)
  {
    fprintf(stderr, "\nErro ao alocar memoria\n");
    return -1;
  }
  else
  {
    
  }

  for (i = 0; i < nr_vertex; i++)
  {
    graph[i].id = i + 1;
    graph[i].prev = -1;
    graph[i].colour = 0;
    graph[i].adj = 0;
    graph[i].is_ap = 0;
  }

  nr_edges = new_sym_var(sizeof(int) * 8);
  if (nr_edges < 1)
  {
    fprintf(stderr, "Argumentos inválidos");
    return -1;
  }
  else
  {
    
  }

  for (i = 0; i < nr_edges; i++)
  {
    v = new_sym_var(sizeof(int) * 8);
    u = new_sym_var(sizeof(int) * 8);
    graph[v - 1].adj = add_element(graph[v - 1].adj, &graph[u - 1]);
    graph[u - 1].adj = add_element(graph[u - 1].adj, &graph[v - 1]);
  }

  DFS();
  printf("%d\n", sub_redes);
  for (i = 0; i < nr_vertex; i++)
  {
    if (graph[i].colour > 1)
    {
      if (graph[i].colour != (1 + sub_redes))
      {
        printf(" ");
      }
      else
      {
        
      }

      printf("%d", graph[i].id);
    }
    else
    {
      
    }

    graph[i].colour = 0;
  }

  DFS_ap();
  printf("\n%d\n%d\n", ap, max);
  free_Graph();
  return 0;
}

void DFS()
{
  int i;
  for (i = nr_vertex - 1; i >= 0; i--)
  {
    if (graph[i].colour == 0)
    {
      dfs_visit(&graph[i]);
      sub_redes++;
      graph[i].colour = 1 + sub_redes;
    }
    else
    {
      
    }

  }

}

void dfs_visit(Vertex *v)
{
  int children = 0;
  v->colour = 1;
  v->discovery = time;
  v->low = ++time;
  Node *adj = v->adj;
  while (adj != 0)
  {
    if (adj->data->colour == 0)
    {
      adj->data->prev = v->id;
      children++;
      dfs_visit(adj->data);
      v->low = min(v->low, adj->data->low);
      if (((v->prev == (-1)) && (children > 1)) || ((v->prev != (-1)) && (adj->data->low >= v->discovery)))
      {
        v->is_ap = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (adj->data->id != v->prev)
      {
        v->low = min(v->low, adj->data->discovery);
      }
      else
      {
        
      }

    }

    adj = adj->next;
  }

  time++;
}

void DFS_ap()
{
  int i;
  for (i = 0; i < nr_vertex; i++)
  {
    if (graph[i].is_ap == 1)
    {
      ap++;
    }
    else
    {
      if (graph[i].colour == 0)
      {
        current = 0;
        dfs_visit_ap(&graph[i]);
        max = maximo(max, current);
      }
      else
      {
        
      }

    }

  }

}

void dfs_visit_ap(Vertex *v)
{
  v->colour = 1;
  current++;
  Node *adj = v->adj;
  while (adj != 0)
  {
    if ((adj->data->colour == 0) && (adj->data->is_ap == 0))
    {
      dfs_visit_ap(adj->data);
    }
    else
    {
      
    }

    adj = adj->next;
  }

}

