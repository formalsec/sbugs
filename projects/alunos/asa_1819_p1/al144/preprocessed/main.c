#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct node
{
  int number;
  struct node *next;
} *Node;
typedef struct routers
{
  int visit;
  int low;
  Node head;
} *Routers;
typedef struct graph
{
  int numberRouters;
  Routers arrayOfRouters;
} *Graph;
typedef struct stack
{
  int top;
  int capacity;
  int *array;
} *Stack;
int countSCCs = 0;
int time = 1;
int routQuebra = 0;
int auxiliarSCCs = 0;
int biggestSCC = 0;
Stack createStack(int capacity)
{
  Stack stack = (Stack) malloc(sizeof(struct stack));
  stack->capacity = capacity;
  stack->top = -1;
  stack->array = (int *) malloc(stack->capacity * (sizeof(int)));
  return stack;
}

void push(Stack stack, int num)
{
  stack->array[++stack->top] = num;
}

int pop(Stack stack)
{
  return stack->array[stack->top--];
}

void deleteStack(Stack stack)
{
  free(stack->array);
  free(stack);
}

Graph createGraph(int routers)
{
  int i;
  Graph graph = (Graph) malloc(sizeof(struct graph));
  graph->numberRouters = routers;
  graph->arrayOfRouters = (Routers) malloc(routers * (sizeof(struct routers)));
  for (i = 0; i < routers; i++)
  {
    graph->arrayOfRouters[i].head = 0;
  }

  return graph;
}

Node createNode(int num)
{
  Node node = (Node) malloc(sizeof(struct node));
  node->number = num;
  node->next = 0;
  return node;
}

void addEdge(Graph graph, int router1, int router2)
{
  Node temp = createNode(router2);
  temp->next = graph->arrayOfRouters[router1].head;
  graph->arrayOfRouters[router1].head = temp;
}

int min(int num1, int num2)
{
  if (num1 > num2)
  {
    return num2;
  }
  else
  {
    return num1;
  }

}

void auxSCCs(Graph graph, int num, Stack stack, int inStack[], int lowToSmallestRouters[], int sccID[])
{
  push(stack, num);
  inStack[num] = 1;
  graph->arrayOfRouters[num].visit = time;
  graph->arrayOfRouters[num].low = time;
  time++;
  Node temp = graph->arrayOfRouters[num].head;
  while (temp != 0)
  {
    if (graph->arrayOfRouters[temp->number].visit == 0)
    {
      auxSCCs(graph, temp->number, stack, inStack, lowToSmallestRouters, sccID);
    }
    else
    {
      
    }

    if (inStack[temp->number] == 1)
    {
      graph->arrayOfRouters[num].low = min(graph->arrayOfRouters[num].low, graph->arrayOfRouters[temp->number].low);
    }
    else
    {
      
    }

    temp = temp->next;
  }

  if (graph->arrayOfRouters[num].visit == graph->arrayOfRouters[num].low)
  {
    int smallest = graph->numberRouters;
    int vertex;
    for (vertex = pop(stack);; vertex = pop(stack))
    {
      if (vertex > sccID[countSCCs])
      {
        sccID[countSCCs] = vertex;
      }
      else
      {
        
      }

      if (vertex < smallest)
      {
        smallest = vertex;
      }
      else
      {
        
      }

      inStack[vertex] = 0;
      graph->arrayOfRouters[vertex].low = graph->arrayOfRouters[num].low;
      if (vertex == num)
      {
        break;
      }
      else
      {
        
      }

    }

    lowToSmallestRouters[graph->arrayOfRouters[num].low] = smallest;
    countSCCs++;
  }
  else
  {
    
  }

}

void findSCCs(Graph graph, Stack stack, int inStack[], int lowToSmallestRouters[], int sccID[])
{
  int numRout = graph->numberRouters;
  int i;
  for (i = 0; i < numRout; i++)
  {
    inStack[i] = 0;
    graph->arrayOfRouters[i].low = 0;
    graph->arrayOfRouters[i].visit = 0;
  }

  for (i = 0; i < numRout; i++)
  {
    if (graph->arrayOfRouters[i].visit == 0)
    {
      auxSCCs(graph, i, stack, inStack, lowToSmallestRouters, sccID);
    }
    else
    {
      
    }

  }

  deleteStack(stack);
}

void printInOrder(int sccID[])
{
  int a;
  int i;
  int j;
  int p;
  for (i = 0; i < countSCCs; ++i)
  {
    for (j = i + 1; j < countSCCs; ++j)
    {
      if (sccID[i] > sccID[j])
      {
        a = sccID[i];
        sccID[i] = sccID[j];
        sccID[j] = a;
      }
      else
      {
        
      }

    }

  }

  for (p = 0; p < countSCCs; p++)
  {
    printf("%d ", sccID[p] + 1);
  }

  printf("\n");
}

int main()
{
  int numRouters;
  int numLigacoes;
  int router1;
  int router2;
  numRouters = new_sym_var(sizeof(int) * 8);
  numLigacoes = new_sym_var(sizeof(int) * 8);
  Graph graph = createGraph(numRouters);
  int i;
  int *sccID = (int *) malloc(numRouters * (sizeof(int)));
  for (i = 0; i < numLigacoes; i++)
  {
    router1 = new_sym_var(sizeof(int) * 8);
    router2 = new_sym_var(sizeof(int) * 8);
    addEdge(graph, router1 - 1, router2 - 1);
    addEdge(graph, router2 - 1, router1 - 1);
  }

  int inStack[numRouters];
  Stack stack = createStack(numRouters);
  int lowToSmallestRouters[numRouters];
  for (i = 0; i < numRouters; i++)
  {
    sccID[i] = -1;
  }

  findSCCs(graph, stack, inStack, lowToSmallestRouters, sccID);
  printf("%d\n", countSCCs);
  printInOrder(sccID);
  printf("%d\n", routQuebra);
  printf("%d\n", biggestSCC);
  free(sccID);
  return 0;
}

