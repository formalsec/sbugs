#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct _no
{
  long id;
  struct _no *next;
} no;
typedef struct _sr
{
  long id;
  long counter;
} sr;
void CriaMatriz(long, long, no *);
void NrSubRede(long, long *, no *, long);
void Identificadores(long *, long *, long);
void libertaLista(no *, long);
void OrdenaLista(long *, long, long);
void printLista(long *, long);
void NovoC(long, no *);
void libertaC(no *);
void marcaC(long *, no *);
void Contador(long *, long *, long);
void Tarjan(long, long, long *, long *, long *, no *, no *, long *);
int main()
{
  long N = 0;
  long M = 0;
  long i = 0;
  long R = 0;
  long Rc = 0;
  long counterc = 0;
  long j = 0;
  long visitado = 0;
  no *matriz = 0;
  long *routers = 0;
  long *routersc = 0;
  long *d = 0;
  long *low = 0;
  long *subredec = 0;
  long *subredes = 0;
  no *headc = 0;
  if (1 == 0)
  {
    exit(0);
  }
  else
  {
    N = new_sym_var(sizeof(long) * 8);
    
  }

  if (1 == 0)
  {
    exit(0);
  }
  else
  {
    M = new_sym_var(sizeof(long) * 8);
    
  }

  matriz = (no *) calloc(N, sizeof(no));
  if (matriz == 0)
  {
    exit(0);
  }
  else
  {
    
  }

  CriaMatriz(M, N, matriz);
  routers = (long *) calloc(N, sizeof(long));
  if (routers == 0)
  {
    exit(0);
  }
  else
  {
    
  }

  for (i = 0; i < N; i++)
  {
    if (routers[i] == 0)
    {
      routers[i] = ++R;
      NrSubRede(i, routers, matriz, R);
    }
    else
    {
      
    }

  }

  printf("%li\n", R);
  subredes = (long *) calloc(R, sizeof(long));
  if (subredes == 0)
  {
    exit(0);
  }
  else
  {
    
  }

  Identificadores(subredes, routers, N);
  OrdenaLista(subredes, 0, R - 1);
  printLista(subredes, R);
  headc = (no *) malloc(sizeof(no));
  headc->id = 0;
  headc->next = 0;
  low = (long *) calloc(N, sizeof(long));
  if (low == 0)
  {
    exit(0);
  }
  else
  {
    
  }

  d = (long *) calloc(N, sizeof(long));
  if (d == 0)
  {
    exit(0);
  }
  else
  {
    
  }

  for (i = 0; i < R; i++)
  {
    visitado = 1;
    j = subredes[i] - 1;
    Tarjan(j, j, &counterc, low, d, headc, matriz, &visitado);
  }

  printf("%li\n", counterc);
  routersc = (long *) calloc(N, sizeof(long));
  if (routersc == 0)
  {
    exit(0);
  }
  else
  {
    
  }

  marcaC(routersc, headc);
  for (i = 0; i < N; i++)
  {
    if (routersc[i] == 0)
    {
      routersc[i] = ++Rc;
      NrSubRede(i, routersc, matriz, Rc);
    }
    else
    {
      
    }

  }

  subredec = (long *) calloc(Rc, sizeof(long));
  if (subredec == 0)
  {
    exit(0);
  }
  else
  {
    
  }

  Contador(subredec, routersc, N);
  counterc = 0;
  for (i = 0; i < Rc; i++)
  {
    if (subredec[i] > counterc)
    {
      counterc = subredec[i];
    }
    else
    {
      
    }

  }

  printf("%li\n", counterc);
  libertaC(headc);
  libertaLista(matriz, N);
  free(matriz);
  free(routers);
  free(subredes);
  free(routersc);
  free(subredec);
  free(d);
  free(low);
  return 0;
}

void CriaMatriz(long M, long N, no *router)
{
  long i = 0;
  long u = 0;
  long v = 0;
  no *novou = 0;
  no *novov = 0;
  for (i = 0; i < M; i++)
  {
    if (1 == 0)
    {
      exit(0);
    }
    else
    {
      u = new_sym_var(sizeof(long) * 8);
      
    }

    if (1 == 0)
    {
      exit(0);
    }
    else
    {
      v = new_sym_var(sizeof(long) * 8);
      
    }

    novou = (no *) malloc(sizeof(no));
    if (novou == 0)
    {
      printf("Erro na alocacao de memoria \n");
      exit(0);
    }
    else
    {
      
    }

    novou->id = v;
    novou->next = router[u - 1].next;
    router[u - 1].next = novou;
    novov = (no *) malloc(sizeof(no));
    if (novov == 0)
    {
      printf("Erro na alocacao de memoria \n");
      exit(0);
    }
    else
    {
      
    }

    novov->id = u;
    novov->next = router[v - 1].next;
    router[v - 1].next = novov;
  }

  return;
}

void NrSubRede(long i, long *routers, no *matriz, long R)
{
  long j = 0;
  no *aux = 0;
  aux = matriz[i].next;
  while (aux != 0)
  {
    j = aux->id - 1;
    if (routers[j] == 0)
    {
      routers[j] = R;
      NrSubRede(j, routers, matriz, R);
    }
    else
    {
      
    }

    aux = aux->next;
  }

  return;
}

void Identificadores(long *subredes, long *routers, long N)
{
  long i = 0;
  long j = 0;
  for (i = 0; i < N; i++)
  {
    j = routers[i] - 1;
    if (i >= subredes[j])
    {
      subredes[j] = i + 1;
    }
    else
    {
      
    }

  }

  return;
}

void libertaLista(no *matriz, long N)
{
  int i = 0;
  no *aux;
  no *newhead = 0;
  for (i = 0; i < N; i++)
  {
    for (aux = matriz[i].next; aux != 0; aux = newhead)
    {
      newhead = aux->next;
      free(aux);
    }

  }

  return;
}

void OrdenaLista(long *subredes, long l, long r)
{
  long i;
  long j;
  long x;
  long y;
  i = l;
  j = r;
  x = subredes[(l + r) / 2];
  while (i <= j)
  {
    while ((subredes[i] < x) && (i < r))
    {
      i++;
    }

    while ((subredes[j] > x) && (j > l))
    {
      j--;
    }

    if (i <= j)
    {
      y = subredes[i];
      subredes[i] = subredes[j];
      subredes[j] = y;
      i++;
      j--;
    }
    else
    {
      
    }

  }

  if (j > l)
  {
    OrdenaLista(subredes, l, j);
  }
  else
  {
    
  }

  if (i < r)
  {
    OrdenaLista(subredes, i, r);
  }
  else
  {
    
  }

  return;
}

void printLista(long *subredes, long R)
{
  long i = 0;
  for (i = 0; i < (R - 1); i++)
  {
    printf("%li ", subredes[i]);
  }

  printf("%li\n", subredes[R - 1]);
  return;
}

void NovoC(long i, no *hc)
{
  no *novo = 0;
  novo = (no *) malloc(sizeof(no));
  if (novo == 0)
  {
    exit(0);
  }
  else
  {
    
  }

  novo->id = i;
  novo->next = hc->next;
  hc->next = novo;
  return;
}

void libertaC(no *hc)
{
  no *aux;
  no *newhead = 0;
  for (aux = hc; aux != 0; aux = newhead)
  {
    newhead = aux->next;
    free(aux);
  }

  return;
}

void marcaC(long *routersc, no *hc)
{
  no *aux = 0;
  aux = hc->next;
  while (aux != 0)
  {
    routersc[aux->id] = -1;
    aux = aux->next;
  }

  return;
}

void Contador(long *subredec, long *routersc, long N)
{
  long i = 0;
  long j = 0;
  for (i = 0; i < N; i++)
  {
    j = routersc[i] - 1;
    if (j >= 0)
    {
      subredec[j]++;
    }
    else
    {
      
    }

  }

  return;
}

void Tarjan(long u, long n, long *counterc, long *low, long *d, no *headc, no *matriz, long *visitado)
{
  long v = 0;
  long k = 0;
  long c = 0;
  no *aux = 0;
  d[u] = *visitado;
  low[u] = *visitado;
  (*visitado)++;
  aux = matriz[u].next;
  while (aux != 0)
  {
    v = aux->id - 1;
    if (d[v] == 0)
    {
      c++;
      Tarjan(v, u, counterc, low, d, headc, matriz, visitado);
      if (low[v] < low[u])
      {
        low[u] = low[v];
      }
      else
      {
        
      }

      if (((low[v] >= d[u]) && (d[u] != 1)) && (k == 0))
      {
        NovoC(u, headc);
        (*counterc)++;
        k = 1;
      }
      else
      {
        if (((d[u] == 1) && (c > 1)) && (k == 0))
        {
          NovoC(u, headc);
          (*counterc)++;
          k = 1;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (v != n)
      {
        if (d[v] < low[u])
        {
          low[u] = d[v];
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    aux = aux->next;
  }

  return;
}

