#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct 
{
  int u;
  int v;
} liga;
typedef struct 
{
  int *l;
  int cod;
  int subrede;
} router;
router *r;
int *s;
int *a;
int *b;
int N;
int M;
int m;
int w;
int x;
int y;
int z;
void visit(int z)
{
  int y;
  r[z].cod = 1;
  if ((z + 1) > m)
  {
    m = z + 1;
  }
  else
  {
    
  }

  for (y = 0; y < s[z]; y++)
  {
    if (((r[r[z].l[y] - 1].cod == 0) && (a[r[z].l[y] - 1] == 0)) && ((r[z].l[y] - 1) != x))
    {
      visit(r[z].l[y] - 1);
    }
    else
    {
      
    }

  }

  r[z].cod = 2;
}

void update()
{
  int z;
  int y;
  for (z = 0; z < N; z++)
    r[z].subrede = 0;

  for (z = 0; z < N; z++)
  {
    if (((r[z].cod == 0) && (a[z] == 0)) && (z != x))
    {
      m = z + 1;
      visit(z);
      for (y = 0; y < N; y++)
      {
        if (r[y].cod == 2)
        {
          r[y].subrede = m;
          r[y].cod = 3;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

}

int main()
{
  N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  x = N + 1;
  liga l[M];
  for (z = 0; z < M; z++)
  {
    l[z].u = new_sym_var(sizeof(int) * 8);
    l[z].v = new_sym_var(sizeof(int) * 8);
  }

  r = (router *) malloc((sizeof(router)) * N);
  s = (int *) malloc((sizeof(int)) * N);
  a = (int *) malloc((sizeof(int)) * N);
  b = (int *) malloc((sizeof(int)) * N);
  for (z = 0; z < N; z++)
    s[z] = (a[z] = (b[z] = 0));

  for (y = 1; y < (N + 1); y++)
  {
    int *p = (int *) malloc((sizeof(int)) * M);
    w = 0;
    for (z = 0; z < M; z++)
    {
      if (l[z].u == y)
      {
        p[w] = l[z].v;
        w += 1;
      }
      else
      {
        
      }

      if (l[z].v == y)
      {
        p[w] = l[z].u;
        w += 1;
      }
      else
      {
        
      }

    }

    s[y - 1] = w;
    r[y - 1].l = p;
  }

  for (z = 0; z < N; z++)
    r[z].cod = 0;

  update();
  int n = 0;
  int g[N];
  for (z = 0; z < N; z++)
    g[z] = 0;

  for (y = 0; y < N; y++)
  {
    if (g[r[y].subrede - 1] == 0)
    {
      g[r[y].subrede - 1] = r[y].subrede;
      n += 1;
    }
    else
    {
      
    }

  }

  printf("%d\n", n);
  int O = 0;
  for (z = 0; z < N; z++)
  {
    if (g[z] != 0)
    {
      if (O != 0)
      {
        printf(" %d", g[z]);
      }
      else
      {
        printf("%d", g[z]);
        O = 1;
      }

    }
    else
    {
      
    }

  }

  printf("\n");
  int C = 0;
  for (x = 0; x < N; x++)
  {
    for (z = 0; z < N; z++)
    {
      r[z].cod = 0;
    }

    r[x].cod = 3;
    update();
    int W = 0;
    int g[N];
    for (z = 0; z < N; z++)
      g[z] = 0;

    for (y = 0; y < N; y++)
    {
      if (y != x)
      {
        if (g[r[y].subrede - 1] == 0)
        {
          g[r[y].subrede - 1] = r[y].subrede;
          W += 1;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (W > n)
    {
      C += 1;
      b[x] = x + 1;
    }
    else
    {
      
    }

  }

  for (z = 0; z < N; z++)
  {
    a[z] = b[z];
  }

  printf("%d\n", C);
  x = N + 1;
  for (z = 0; z < N; z++)
    r[z].cod = 0;

  update();
  int b[N + 1];
  int m = 0;
  for (z = 0; z < (N + 1); z++)
  {
    b[z] = 0;
  }

  for (z = 0; z < N; z++)
  {
    if (a[z] == 0)
    {
      b[r[z].subrede] += 1;
    }
    else
    {
      
    }

  }

  for (x = 1; x < (N + 1); x++)
  {
    if (b[x] > m)
    {
      m = b[x];
    }
    else
    {
      
    }

  }

  printf("%d\n", m);
  free(r);
  free(s);
  return 0;
}

