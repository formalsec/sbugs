#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


struct Graph
{
  int numheads;
  struct router **heads;
};
typedef struct 
{
  int *array;
  size_t used;
  size_t size;
} Array;
struct router
{
  int routerNumber;
  int scc_id;
  int low;
  int instack;
  int discoveryTime;
  struct edge *adjVertex;
  int root;
  int min;
  int *connectionsSCC;
};
struct Stack
{
  int number;
  int top;
  int size;
  int *elements;
};
struct edge
{
  int vNumber;
  int flag;
  struct edge *nextEdge;
};
struct tpElement
{
  int *next;
};
struct connection
{
  int source;
  int destiny;
};
struct Stack *stack_aux;
static struct Graph *graph;
struct tpElement *topologicalSort;
void initTP();
void initGraph(int n);
void insertEdge(int source, int destiny);
struct router *newRouter(int number);
void SCC_Tarjan(int size);
void Tarjan_Visit(int n);
int isEmpty();
void initStack(int capacity);
void push(int router);
int pop();
void printGraph();
int testConnections(struct edge *ptr);
struct connection *newConnection(int source, int destiny);
void swap(int num1, int num2);
void initArray(Array *a, size_t initialSize);
void insertArray(Array *a, int element);
void freeArray(Array *a);
int time;
int scc;
int connections;
int idAtual;
int min;
struct connection **connectionsArray;
Array a;
int maxRouter;
void initArray(Array *a, size_t initialSize)
{
  a->array = (int *) malloc(initialSize * (sizeof(int)));
  a->used = 0;
  a->size = initialSize;
}

void insertArray(Array *a, int element)
{
  if (a->used == a->size)
  {
    a->size *= 2;
    a->array = (int *) realloc(a->array, a->size * (sizeof(int)));
  }
  else
  {
    
  }

  a->array[a->used++] = element;
}

void freeArray(Array *a)
{
  free(a->array);
  a->array = 0;
  a->used = (a->size = 0);
}

int isEmpty()
{
  return stack_aux->number == 0;
}

void initStack(int capacity)
{
  stack_aux = (struct Stack *) malloc(sizeof(struct Stack));
  stack_aux->top = -1;
  stack_aux->number = 0;
  stack_aux->size = capacity;
  stack_aux->elements = (int *) malloc((sizeof(int)) * capacity);
}

void push(int router)
{
  stack_aux->top = router;
  stack_aux->elements[stack_aux->number] = router;
  stack_aux->number++;
}

int pop()
{
  int valueRouterNumber;
  if (isEmpty())
  {
    printf("isEMPTY!\n");
    return 1;
  }
  else
  {
    
  }

  valueRouterNumber = graph->heads[stack_aux->top - 1]->routerNumber;
  if ((stack_aux->number - 2) >= 0)
  {
    stack_aux->top = stack_aux->elements[stack_aux->number - 2];
  }
  else
  {
    
  }

  stack_aux->number--;
  return valueRouterNumber;
}

void initGraph(int n)
{
  int i;
  graph = (struct Graph *) malloc(sizeof(struct Graph));
  graph->heads = (struct router **) malloc((sizeof(struct router *)) * n);
  for (i = 0; i < n; i++)
  {
    graph->heads[i] = newRouter(i + 1);
  }

}

struct connection *newConnection(int source, int destiny)
{
  struct connection *new = (struct connection *) malloc(sizeof(struct connection));
  new->source = source;
  new->destiny = destiny;
  return new;
}

struct router *newRouter(int number)
{
  struct router *new = (struct router *) malloc(sizeof(struct router));
  new->routerNumber = number;
  new->scc_id = -1;
  new->adjVertex = 0;
  new->discoveryTime = -1;
  new->instack = 0;
  new->low = -1;
  new->root = -1;
  new->min = -1;
  return new;
}

struct edge *newEdge(int number)
{
  struct edge *new = (struct edge *) malloc(sizeof(struct edge));
  new->vNumber = number;
  new->nextEdge = 0;
  new->flag = 0;
  return new;
}

void insertEdge(int source, int destiny)
{
  struct edge *newNode = newEdge(destiny);
  newNode->nextEdge = graph->heads[source - 1]->adjVertex;
  graph->heads[source - 1]->adjVertex = newNode;
}

void SCC_Tarjan(int size)
{
  int i;
  for (i = 0; i < size; i++)
  {
    if (graph->heads[i]->discoveryTime == (-1))
    {
      Tarjan_Visit(i);
      insertArray(&a, maxRouter);
      maxRouter = 0;
    }
    else
    {
      
    }

  }

}

void Tarjan_Visit(int n)
{
  graph->heads[n]->discoveryTime = time;
  graph->heads[n]->low = time;
  time++;
  push(graph->heads[n]->routerNumber);
  graph->heads[n]->instack = 1;
  struct edge *ptr = graph->heads[n]->adjVertex;
  while (ptr != 0)
  {
    int number = ptr->vNumber;
    if ((graph->heads[number - 1]->discoveryTime == (-1)) || (graph->heads[number - 1]->instack == 1))
    {
      if (graph->heads[number - 1]->discoveryTime == (-1))
      {
        Tarjan_Visit(number - 1);
      }
      else
      {
        
      }

      graph->heads[n]->low = (graph->heads[n]->low < graph->heads[number - 1]->low) ? (graph->heads[n]->low) : (graph->heads[number - 1]->low);
    }
    else
    {
      
    }

    ptr = ptr->nextEdge;
  }

  int popValue;
  if (graph->heads[n]->discoveryTime == graph->heads[n]->low)
  {
    scc++;
    int minTemp = graph->heads[n]->routerNumber;
    do
    {
      graph->heads[stack_aux->top - 1]->instack = 0;
      popValue = pop();
      if (maxRouter < popValue)
      {
        maxRouter = popValue;
      }
      else
      {
        
      }

      if (popValue < minTemp)
      {
        minTemp = popValue;
      }
      else
      {
        
      }

      graph->heads[popValue - 1]->scc_id = idAtual;
      graph->heads[popValue - 1]->root = graph->heads[n]->routerNumber;
    }
    while (popValue != graph->heads[n]->routerNumber);
    graph->heads[n]->min = minTemp;
    idAtual++;
  }
  else
  {
    
  }

}

int main()
{
  int nRouters;
  int nConnections;
  int i;
  int source;
  int destiny;
  int j;
  int unused;
  scc = 0, time = 0, connections = 0, min = 0, maxRouter = 0;
  unused = 1;
  nRouters = new_sym_var(sizeof(int) * 8);
  unused = 1;
  nConnections = new_sym_var(sizeof(int) * 8);
  initGraph(nRouters);
  initStack(nRouters);
  initArray(&a, 5);
  graph->numheads = nRouters;
  for (i = 0; i < nConnections; i++)
  {
    unused = 2;
    source = new_sym_var(sizeof(int) * 8);
    destiny = new_sym_var(sizeof(int) * 8);
    insertEdge(source, destiny);
    insertEdge(destiny, source);
  }

  SCC_Tarjan(nRouters);
  printf("%d\n", scc);
  for (j = 0; j < scc; j++)
  {
    printf("%d ", a.array[j]);
  }

  printf("\n");
  freeArray(&a);
  return 0;
}

