#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct node_s
{
  int ignore;
  int parent;
  int index;
  int low_link;
  int in_stack;
  int deg;
} node;
typedef struct stack_s
{
  int top;
  int *items;
} stack;
typedef struct scComponent_s
{
  int maxNode;
  int numComponents;
} scComponent;
typedef struct list_s
{
  scComponent *link;
  struct list_s *next;
} list;
typedef struct liist_s
{
  int numSCC;
  list *first;
} listscc;
typedef struct links
{
  int start;
  int end;
} input;
node **graph = 0;
int numNodes = 0;
int numLinks = 0;
int curr_index = 0;
int maxLinksPerNode = 0;
stack *sComponent = 0;
int **adj;
node *createNode(int id, int maxLinks)
{
  node *out = (node *) malloc(sizeof(node));
  out->ignore = 0;
  out->parent = -2;
  out->index = 0;
  out->low_link = -1;
  out->in_stack = 0;
  out->deg = 0;
  return out;
}

node **createGraph(int numNodes, int numLinks)
{
  int count;
  node **graph = (node **) malloc((sizeof(node)) * numNodes);
  for (count = 0; count < numNodes; count++)
  {
    graph[count] = createNode(count, numLinks);
  }

  return graph;
}

void resetNodes()
{
  int a;
  for (a = 0; a < numNodes; a++)
  {
    graph[a]->parent = -2;
    graph[a]->index = -1;
    graph[a]->low_link = -1;
    graph[a]->in_stack = 0;
  }

}

void addVertices(input *in)
{
  int count;
  int node1;
  int node2;
  node *startNode;
  node *endNode;
  for (count = 0; count < numNodes; count++)
  {
    adj[count] = (int *) malloc((sizeof(int)) * (graph[count]->index + 1));
  }

  for (count = 0; count < numLinks; count++)
  {
    node1 = in[count].start;
    node2 = in[count].end;
    startNode = graph[node1 - 1];
    endNode = graph[node2 - 1];
    adj[node1 - 1][startNode->deg++] = node2;
    adj[node2 - 1][endNode->deg++] = node1;
  }

  resetNodes();
}

void stack_push(int v, stack *s)
{
  s->top++;
  if (s->top < numNodes)
  {
    s->items[s->top] = v;
  }
  else
  {
    printf("Stack is full!\n");
    exit(1);
  }

}

int stack_pop(stack *s)
{
  return (s->top < 0) ? (-1) : (s->items[s->top--]);
}

stack *createStack(int size)
{
  stack *s;
  s = (stack *) malloc(sizeof(stack));
  s->top = -1;
  s->items = (int *) malloc((sizeof(int)) * size);
  return s;
}

void deleteStack(stack *s)
{
  free(s->items);
  free(s);
}

scComponent *createComponent(int numComponents, stack *s)
{
  int aux;
  int no;
  scComponent *component;
  component = (scComponent *) malloc(sizeof(scComponent));
  component->maxNode = -1;
  component->numComponents = numComponents;
  for (aux = 0; aux < numComponents; aux++)
  {
    no = stack_pop(s);
    if ((no + 1) > component->maxNode)
    {
      component->maxNode = no + 1;
    }
    else
    {
      
    }

  }

  return component;
}

listscc *addToList(listscc *sccList, scComponent *scc)
{
  list *insert;
  insert = (list *) malloc(sizeof(list));
  insert->link = scc;
  insert->next = 0;
  if (sccList->first == 0)
  {
    sccList->first = insert;
  }
  else
  {
    insert->next = sccList->first;
    sccList->first = insert;
  }

  sccList->numSCC++;
  return sccList;
}

void deleteSCC(scComponent *scc)
{
  free(scc);
}

void deleteList(listscc *l)
{
  int aux;
  list *next;
  list *laux;
  next = l->first;
  for (aux = 0; aux < l->numSCC; aux++)
  {
    deleteSCC(next->link);
    laux = next->next;
    free(next);
    next = laux;
  }

  free(l);
}

void deleteNode(node *no)
{
  free(no);
}

void deleteGraph()
{
  int aux;
  for (aux = 0; aux < numNodes; aux++)
  {
    deleteNode(graph[aux]);
  }

  free(graph);
}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

stack *strongconnect(int v)
{
  int i;
  int c;
  int n;
  graph[v]->index = curr_index;
  graph[v]->low_link = curr_index;
  ++curr_index;
  graph[v]->in_stack = 1;
  for (i = 0, c = graph[v]->deg; i < c; ++i)
  {
    if (adj[v][i] > 0)
    {
      n = adj[v][i] - 1;
      if ((n + 1) != graph[v]->parent)
      {
        if (graph[n]->index == (-1))
        {
          graph[n]->parent = v + 1;
          strongconnect(n);
          graph[v]->low_link = min(graph[v]->low_link, graph[n]->low_link);
        }
        else
        {
          if (graph[n]->in_stack)
          {
            graph[v]->low_link = min(graph[v]->low_link, graph[n]->index);
          }
          else
          {
            
          }

        }

      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  stack_push(v, sComponent);
  return sComponent;
}

listscc *tarjan(listscc *sccList)
{
  int i;
  stack *pilha;
  scComponent *scc;
  for (i = 0; i < numNodes; ++i)
  {
    if ((graph[i]->index == (-1)) && (graph[i]->ignore == 0))
    {
      pilha = strongconnect(i);
      scc = createComponent(pilha->top + 1, pilha);
      sccList = addToList(sccList, scc);
    }
    else
    {
      
    }

  }

  return sccList;
}

stack *findBridges()
{
  int n;
  int a;
  int pos;
  int currIndex;
  int lowSon;
  int sons;
  int parentAdj;
  int parent = -1;
  stack *bridges;
  bridges = createStack(numNodes);
  for (n = 0; n < numNodes; n++)
  {
    sons = 0;
    parent = graph[n]->parent - 1;
    if (parent < 0)
    {
      for (a = 0; a < graph[n]->deg; a++)
      {
        if (graph[adj[n][a] - 1]->parent == (n + 1))
        {
          sons++;
        }
        else
        {
          
        }

        if (sons > 1)
        {
          stack_push(n + 1, bridges);
          break;
        }
        else
        {
          
        }

      }

    }
    else
    {
      for (a = 0; a < graph[n]->deg; a++)
      {
        pos = adj[n][a] - 1;
        parentAdj = graph[pos]->parent;
        currIndex = graph[n]->index;
        if (parentAdj == (n + 1))
        {
          lowSon = graph[pos]->low_link;
          if (currIndex <= lowSon)
          {
            stack_push(n + 1, bridges);
            break;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

  }

  return bridges;
}

void removeFromGraph(stack *s)
{
  int current;
  int a;
  int n;
  int r;
  int *aux;
  int toRemove = s->top + 1;
  aux = (int *) malloc((sizeof(int)) * toRemove);
  a = 0;
  while ((current = stack_pop(s)) != (-1))
    aux[a++] = current;

  for (a = 0; a < toRemove; a++)
  {
    graph[aux[a] - 1]->ignore = 1;
  }

  for (a = 0; a < numNodes; a++)
  {
    if (graph[a]->ignore == 0)
    {
      for (n = 0; n < graph[a]->deg; n++)
      {
        for (r = 0; r < toRemove; r++)
        {
          if (adj[a][n] == aux[r])
          {
            adj[a][n] = -1;
          }
          else
          {
            
          }

        }

      }

    }
    else
    {
      
    }

  }

  free(aux);
}

int *sccToArray(listscc *l)
{
  int a;
  int *out = (int *) malloc((sizeof(int)) * l->numSCC);
  list *current;
  current = l->first;
  for (a = 0; a < l->numSCC; a++)
  {
    out[a] = current->link->maxNode;
    current = current->next;
  }

  return out;
}

int getMaxSize(listscc *l)
{
  int a;
  int out = -1;
  list *current;
  current = l->first;
  for (a = 0; a < l->numSCC; a++)
  {
    if (current->link->numComponents > out)
    {
      out = current->link->numComponents;
    }
    else
    {
      
    }

    current = current->next;
  }

  return out;
}

void swap(int *a, int *b)
{
  int temp;
  temp = *a;
  *a = *b;
  *b = temp;
}

int partition(int arr[], int first, int last)
{
  int pivot = arr[last];
  int low = first;
  int i = first;
  while (i <= (last - 1))
  {
    if (arr[i] < pivot)
    {
      swap(&arr[i], &arr[low]);
      low++;
    }
    else
    {
      
    }

    i++;
  }

  swap(&arr[last], &arr[low]);
  return low;
}

void quick_sort(int arr[], int first, int last)
{
  int pivot_pos;
  if (first < last)
  {
    pivot_pos = partition(arr, first, last);
    quick_sort(arr, first, pivot_pos - 1);
    quick_sort(arr, pivot_pos + 1, last);
  }
  else
  {
    
  }

}

int main(int argc, char **argv)
{
  int i;
  listscc *sccList1;
  listscc *sccList2;
  stack *bridges;
  int *sccID;
  input *inputArray;
  sccList1 = (listscc *) malloc(sizeof(listscc));
  sccList1->numSCC = 0;
  sccList2 = (listscc *) malloc(sizeof(listscc));
  sccList2->numSCC = 0;
  if (1 <= 0)
  {
    exit(1);
  }
  else
  {
    numNodes = new_sym_var(sizeof(int) * 8);
    
  }

  if (1 <= 0)
  {
    exit(1);
  }
  else
  {
    numLinks = new_sym_var(sizeof(int) * 8);
    
  }

  adj = (int **) malloc((sizeof(int *)) * numNodes);
  inputArray = (input *) malloc((sizeof(input)) * numLinks);
  sComponent = createStack(numNodes);
  graph = createGraph(numNodes, numLinks);
  for (i = 0; i < numLinks; i++)
  {
    if (2 <= 0)
    {
      exit(1);
    }
    else
    {
      inputArray[i].start = new_sym_var(sizeof(int) * 8);
      inputArray[i].end = new_sym_var(sizeof(int) * 8);
      
    }

    graph[inputArray[i].start - 1]->index++;
    graph[inputArray[i].end - 1]->index++;
  }

  addVertices(inputArray);
  free(inputArray);
  sccList1 = tarjan(sccList1);
  sccID = sccToArray(sccList1);
  printf("%d\n", sccList1->numSCC);
  quick_sort(sccID, 0, sccList1->numSCC - 1);
  for (i = 0; i < sccList1->numSCC; i++)
  {
    if ((i + 1) == sccList1->numSCC)
    {
      printf("%d\n", sccID[i]);
    }
    else
    {
      printf("%d ", sccID[i]);
    }

  }

  deleteList(sccList1);
  bridges = findBridges();
  printf("%d\n", bridges->top + 1);
  removeFromGraph(bridges);
  resetNodes();
  sccList2 = tarjan(sccList2);
  printf("%d\n", getMaxSize(sccList2));
  free(sccID);
  deleteList(sccList2);
  deleteStack(sComponent);
  deleteStack(bridges);
  deleteGraph();
  return 0;
}

