/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


typedef struct tarjanArgs tarjanArgs;
typedef struct dfsArgs dfsArgs;
typedef struct router router;
typedef struct node *node;
struct tarjanArgs
{
  router *graph;
  int tim;
  int networkId;
};
struct dfsArgs
{
  router *graph;
  int nVertex;
};
struct router
{
  char isNetworkId;
  char isBridge;
  int visitTime;
  int lowTime;
  int Pid;
  char color;
  struct node *head;
};
struct node
{
  int id;
  struct node *next;
};
node insertList(node head, int id);
void freeList(node head);
int Tarjan(router *graph, int N);
void TarjanVisit(tarjanArgs *args, int id);
int DFS(router *graph, int N);
void DFSVisit(dfsArgs *args, int id);
int main()
{
  router *network;
  int N;
  int M;
  int R;
  int C;
  int m;
  int u;
  int v;
  int i;
  char firstCh;
  if (1 != 1)
  {
    perror("scanf");
  }
  else
  {
    N = new_sym_var(sizeof(int) * 8);
    
  }

  if (1 != 1)
  {
    perror("scanf");
  }
  else
  {
    M = new_sym_var(sizeof(int) * 8);
    
  }

  network = (router *) malloc((sizeof(router)) * N);
  for (i = 0; i < N; i++)
  {
    network[i].head = 0;
  }

  for (i = 0; i < M; i++)
  {
    if (2 != 2)
    {
      perror("scanf");
    }
    else
    {
      u = new_sym_var(sizeof(int) * 8);
      v = new_sym_var(sizeof(int) * 8);
      
    }

    network[u - 1].head = insertList(network[u - 1].head, v);
    network[v - 1].head = insertList(network[v - 1].head, u);
  }

  R = Tarjan(network, N);
  printf("%d\n", R);
  C = 0;
  firstCh = 1;
  for (i = 0; i < N; i++)
  {
    if (network[i].isNetworkId)
    {
      if (firstCh)
      {
        printf("%d", i + 1);
        firstCh = !firstCh;
      }
      else
      {
        printf(" %d", i + 1);
      }

    }
    else
    {
      
    }

    if (network[i].isBridge)
    {
      C++;
    }
    else
    {
      
    }

  }

  m = DFS(network, N);
  printf("\n%d\n%d\n", C, m);
  for (i = 0; i < N; i++)
  {
    freeList(network[i].head);
  }

  free(network);
  exit(0);
}

node insertList(node head, int id)
{
  node new = (node) malloc(sizeof(struct node));
  assert(new);
  new->id = id;
  new->next = head;
  return new;
}

void freeList(node head)
{
  node i;
  node next;
  i = head;
  while (i != 0)
  {
    next = i->next;
    free(i);
    i = next;
  }

}

int Tarjan(router *graph, int N)
{
  tarjanArgs args;
  int i;
  int R = 0;
  args.graph = graph;
  for (i = 0; i < N; i++)
  {
    graph[i].color = 2;
    graph[i].Pid = 0;
    graph[i].isNetworkId = 0;
    graph[i].isBridge = 0;
  }

  args.tim = 0;
  for (i = 0; i < N; i++)
  {
    if (graph[i].color == 2)
    {
      args.networkId = i + 1;
      TarjanVisit(&args, i + 1);
      graph[args.networkId - 1].isNetworkId = 1;
      R++;
    }
    else
    {
      
    }

  }

  return R;
}

void TarjanVisit(tarjanArgs *args, int id)
{
  node i;
  router *vertex;
  router *adjacency;
  int nrChild = 0;
  if (id > args->networkId)
  {
    args->networkId = id;
  }
  else
  {
    
  }

  vertex = &args->graph[id - 1];
  args->tim++;
  vertex->color = 3;
  vertex->visitTime = args->tim;
  vertex->lowTime = args->tim;
  for (i = vertex->head; i != 0; i = i->next)
  {
    if (vertex->Pid == i->id)
    {
      continue;
    }
    else
    {
      
    }

    adjacency = &args->graph[i->id - 1];
    if (adjacency->color == 2)
    {
      adjacency->Pid = id;
      TarjanVisit(args, i->id);
      if (adjacency->lowTime < vertex->lowTime)
      {
        vertex->lowTime = adjacency->lowTime;
      }
      else
      {
        
      }

      if (!vertex->Pid)
      {
        nrChild++;
      }
      else
      {
        if (vertex->visitTime <= adjacency->lowTime)
        {
          vertex->isBridge = 1;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (adjacency->visitTime < vertex->lowTime)
      {
        vertex->lowTime = adjacency->visitTime;
      }
      else
      {
        
      }

    }

  }

  if ((!vertex->Pid) && (nrChild > 1))
  {
    vertex->isBridge = 1;
  }
  else
  {
    
  }

}

int DFS(router *graph, int N)
{
  dfsArgs args;
  int i;
  int m = 0;
  args.graph = graph;
  for (i = 0; i < N; i++)
  {
    graph[i].color = (graph[i].isBridge) ? (4) : (2);
  }

  for (i = 0; i < N; i++)
  {
    if (graph[i].color == 2)
    {
      args.nVertex = 0;
      DFSVisit(&args, i + 1);
      if (args.nVertex > m)
      {
        m = args.nVertex;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return m;
}

void DFSVisit(dfsArgs *args, int id)
{
  node i;
  router *vertex;
  vertex = &args->graph[id - 1];
  args->nVertex++;
  vertex->color = 3;
  for (i = vertex->head; i != 0; i = i->next)
  {
    if (args->graph[i->id - 1].color == 2)
    {
      DFSVisit(args, i->id);
    }
    else
    {
      
    }

  }

}

