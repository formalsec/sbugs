#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct router
{
  struct router *next;
  int id;
} router;
router **G = 0;
int *d = 0;
int *f = 0;
int *color = 0;
int n;
int time_clock = 0;
int scc = 0;
int tmp_id = -1;
int *low = 0;
int *low_tarjan = 0;
int visited;
int *parent;
int *ap;
int *sccs;
int index_g(int u)
{
  return u - 1;
}

void DFS_Visit(int u)
{
  router *v;
  tmp_id++;
  color[u] = 0;
  d[u] = time_clock;
  time_clock++;
  v = G[u];
  while (v != 0)
  {
    if (color[index_g(v->id)] == (-1))
    {
      DFS_Visit(index_g(v->id));
    }
    else
    {
      
    }

    v = v->next;
  }

  color[u] = 1;
  f[u] = time_clock;
  time_clock++;
}

void DFS()
{
  int i;
  scc = 0;
  for (i = 0; i < n; i++)
  {
    if (ap[i])
    {
      color[i] = 1;
    }
    else
    {
      color[i] = -1;
    }

    f[i] = -1;
  }

  time_clock = 1;
  for (i = 0; i < n; i++)
  {
    if (color[i] == (-1))
    {
      tmp_id = 0;
      DFS_Visit(i);
      if (tmp_id > scc)
      {
        scc = tmp_id;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

}

int min(int u, int v)
{
  return (u < v) ? (u) : (v);
}

void Tarjan_Visit(int u)
{
  router *v;
  int children = 0;
  d[index_g(u)] = (low[index_g(u)] = (low_tarjan[index_g(u)] = visited));
  visited++;
  v = G[index_g(u)];
  while (v != 0)
  {
    if (d[index_g(v->id)] == (-1))
    {
      parent[index_g(v->id)] = u;
      children++;
      Tarjan_Visit(v->id);
      low[index_g(u)] = min(low[index_g(u)], low[index_g(v->id)]);
      if ((parent[index_g(u)] == (-1)) && (children > 1))
      {
        ap[index_g(u)] = 1;
      }
      else
      {
        if ((parent[index_g(u)] != (-1)) && (low[index_g(v->id)] >= d[index_g(u)]))
        {
          ap[index_g(u)] = 1;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (v->id != parent[index_g(u)])
      {
        low[index_g(u)] = min(low[index_g(u)], d[index_g(v->id)]);
      }
      else
      {
        
      }

    }

    low_tarjan[index_g(u)] = min(low_tarjan[index_g(u)], low_tarjan[index_g(v->id)]);
    v = v->next;
  }

  if (u > tmp_id)
  {
    tmp_id = u;
  }
  else
  {
    
  }

  if (d[index_g(u)] == low_tarjan[index_g(u)])
  {
    scc++;
    sccs[index_g(tmp_id)] = tmp_id;
    tmp_id = -1;
  }
  else
  {
    
  }

}

void SCC_Tarjan()
{
  int i;
  visited = 1;
  for (i = 0; i < n; i++)
  {
    d[i] = -1;
    parent[i] = -1;
    ap[i] = 0;
    sccs[i] = -1;
  }

  for (i = 1; i <= n; i++)
  {
    if (d[index_g(i)] == (-1))
    {
      Tarjan_Visit(i);
    }
    else
    {
      
    }

  }

}

void insert(int u, int v)
{
  router *v_router;
  router *q;
  v_router = (router *) malloc(sizeof(router));
  v_router->id = v;
  v_router->next = 0;
  q = (router *) malloc(sizeof(router));
  q->id = u;
  q->next = 0;
  if (G[index_g(u)] == 0)
  {
    G[index_g(u)] = v_router;
  }
  else
  {
    v_router->next = G[index_g(u)];
    G[index_g(u)] = v_router;
  }

  if (G[index_g(v)] == 0)
  {
    G[index_g(v)] = q;
  }
  else
  {
    q->next = G[index_g(v)];
    G[index_g(v)] = q;
  }

}

void parse_graph()
{
  int i;
  int n_edges;
  int u;
  int v;
  n = new_sym_var(sizeof(int) * 8);
  G = (router **) malloc((sizeof(router *)) * n);
  for (i = 0; i < n; i++)
    G[i] = 0;

  n_edges = new_sym_var(sizeof(int) * 8);
  for (i = 0; i < n_edges; i++)
  {
    u = new_sym_var(sizeof(int) * 8);
    v = new_sym_var(sizeof(int) * 8);
    insert(u, v);
  }

}

void free_graph()
{
  int i;
  router *tmp;
  router *head;
  for (i = 0; i < n; i++)
  {
    head = G[i];
    while (head != 0)
    {
      tmp = head;
      head = head->next;
      free(tmp);
    }

  }

  free(G);
}

int main()
{
  int i;
  int tmp;
  tmp = 0;
  parse_graph();
  d = (int *) malloc(n * (sizeof(int)));
  f = (int *) malloc(n * (sizeof(int)));
  low = (int *) malloc(n * (sizeof(int)));
  low_tarjan = (int *) malloc(n * (sizeof(int)));
  parent = (int *) malloc(n * (sizeof(int)));
  ap = (int *) malloc(n * (sizeof(int)));
  sccs = (int *) malloc(n * (sizeof(int)));
  color = (int *) malloc(n * (sizeof(int)));
  SCC_Tarjan();
  printf("%d\n", scc);
  int first = 1;
  for (i = 0; i < n; i++)
  {
    if (sccs[i] != (-1))
    {
      printf((first) ? ("%d") : (" %d"), sccs[i]);
      first = 0;
    }
    else
    {
      
    }

    if (ap[i])
    {
      tmp++;
    }
    else
    {
      
    }

  }

  printf("\n");
  printf("%d\n", tmp);
  DFS();
  printf("%d\n", scc);
  free(d);
  free(f);
  free(low);
  free(low_tarjan);
  free(parent);
  free(ap);
  free(sccs);
  free(color);
  free_graph();
  return 0;
}

