#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>


typedef struct st stack;
struct st
{
  int top;
  int *items;
};
typedef struct info infoRouter;
struct info
{
  int index;
  int head;
  int lowLink;
  bool onStack;
  int scc;
  int rID;
  bool removed;
};
typedef struct r router;
struct r
{
  int id;
  router *next;
};
typedef struct l list;
struct l
{
  router *head;
};
typedef struct g graph;
struct g
{
  list *gList;
};
graph *network;
stack *tarjanStack;
infoRouter *routerInfoVec;
int N;
int M;
int totalIndex = 1;
int sccSize = 0;
int currentSCC = 0;
int nAP = 0;
int *sccHeadID;
int totalHeads = 1;
void graphInit();
void stackInit();
void routerInfoInit();
router *newRou(int id, int dest);
void newLink(int c1, int c2);
void tarjanAlgorithm();
void scc(int currentRouter);
void push(int routerID);
int pop();
void apUtil(int router, int *isVisited, int *des, int *parent, int *low, int *ap);
void AP();
void printHeads();
void removeRouter(int id);
void printG();
void freeGraph();
void freeGList();
int cmpfunc(const void *a, const void *b);
int main()
{
  int i;
  N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  int c1;
  int c2;
  sccHeadID = (int *) malloc(totalHeads * (sizeof(int)));
  graphInit();
  stackInit();
  routerInfoInit();
  for (i = 0; i < M; ++i)
  {
    c1 = new_sym_var(sizeof(int) * 8);
    c2 = new_sym_var(sizeof(int) * 8);
    newLink(c1, c2);
  }

  tarjanAlgorithm();
  printf("%d\n", currentSCC);
  printHeads();
  AP();
  sccSize = 0;
  totalIndex = 1;
  tarjanAlgorithm();
  printf("%d\n", nAP);
  printf("%d\n", sccSize);
  freeGraph();
  free(routerInfoVec);
  free(tarjanStack->items);
  free(tarjanStack);
  free(sccHeadID);
  return 0;
}

void graphInit()
{
  int i;
  network = (graph *) malloc(sizeof(struct g));
  network->gList = (list *) malloc((N + 1) * (sizeof(struct l)));
  for (i = 1; i <= N; ++i)
  {
    network->gList[i].head = 0;
  }

}

void stackInit()
{
  tarjanStack = (stack *) malloc(sizeof(struct st));
  tarjanStack->items = (int *) malloc(N * (sizeof(int)));
  tarjanStack->top = -1;
}

void routerInfoInit()
{
  int i;
  routerInfoVec = (infoRouter *) malloc((N + 1) * (sizeof(struct info)));
  for (i = 1; i <= N; ++i)
  {
    routerInfoVec[i].index = -1;
    routerInfoVec[i].head = -1;
    routerInfoVec[i].lowLink = -1;
    routerInfoVec[i].onStack = false;
    routerInfoVec[i].scc = -1;
    routerInfoVec[i].rID = -1;
    routerInfoVec[i].removed = false;
  }

}

router *newRou(int id, int dest)
{
  router *newr = (router *) malloc(sizeof(struct r));
  newr->id = id;
  newr->next = 0;
  return newr;
}

void newLink(int c1, int c2)
{
  router *newRouter = newRou(c1, c2);
  router *newRouter2 = newRou(c2, c1);
  newRouter->next = network->gList[c2].head;
  newRouter2->next = network->gList[c1].head;
  network->gList[c2].head = newRouter;
  network->gList[c1].head = newRouter2;
  routerInfoVec[c1].rID = c1;
  routerInfoVec[c2].rID = c2;
}

void tarjanAlgorithm()
{
  int j;
  int i;
  for (j = 1; j <= N; ++j)
  {
    if ((routerInfoVec[j].index == (-1)) && (!routerInfoVec[j].removed))
    {
      scc(j);
    }
    else
    {
      
    }

  }

  for (i = 1; i <= N; ++i)
  {
    routerInfoVec[i].index = -1;
    routerInfoVec[i].head = -1;
    routerInfoVec[i].lowLink = -1;
    routerInfoVec[i].scc = -1;
  }

}

void printHeads()
{
  int i;
  qsort(sccHeadID, currentSCC + 1, sizeof(int), cmpfunc);
  for (i = 1; i <= currentSCC; i++)
  {
    printf("%d", sccHeadID[i]);
    if (i != currentSCC)
    {
      printf(" ");
    }
    else
    {
      
    }

  }

  printf("\n");
}

int cmpfunc(const void *a, const void *b)
{
  return (*((int *) a)) - (*((int *) b));
}

void push(int routerID)
{
  tarjanStack->top += 1;
  if (tarjanStack->top < N)
  {
    tarjanStack->items[tarjanStack->top] = routerID;
  }
  else
  {
    printf("Tarjan stack is full\n");
    exit(1);
  }

}

int pop()
{
  if (tarjanStack->top < 0)
  {
    printf("Tarjan stack is empty\n");
    exit(1);
  }
  else
  {
    
  }

  return tarjanStack->items[tarjanStack->top--];
}

void scc(int currentRouter)
{
  int size = 0;
  int auxRouter = -1;
  router *adjacent = network->gList[currentRouter].head;
  routerInfoVec[currentRouter].index = totalIndex;
  routerInfoVec[currentRouter].lowLink = totalIndex;
  totalIndex += 1;
  push(currentRouter);
  routerInfoVec[currentRouter].onStack = true;
  while (adjacent != 0)
  {
    if ((routerInfoVec[adjacent->id].index == (-1)) && (!routerInfoVec[adjacent->id].removed))
    {
      scc(adjacent->id);
      routerInfoVec[currentRouter].lowLink = (routerInfoVec[currentRouter].lowLink < routerInfoVec[adjacent->id].lowLink) ? (routerInfoVec[currentRouter].lowLink) : (routerInfoVec[adjacent->id].lowLink);
    }
    else
    {
      if (routerInfoVec[adjacent->id].onStack)
      {
        routerInfoVec[currentRouter].lowLink = (routerInfoVec[currentRouter].lowLink < routerInfoVec[adjacent->id].lowLink) ? (routerInfoVec[currentRouter].lowLink) : (routerInfoVec[adjacent->id].lowLink);
      }
      else
      {
        
      }

    }

    adjacent = adjacent->next;
  }

  if (routerInfoVec[currentRouter].index == routerInfoVec[currentRouter].lowLink)
  {
    currentSCC += 1;
    routerInfoVec[currentRouter].scc = currentSCC;
    routerInfoVec[currentRouter].head = currentRouter;
    totalHeads++;
    sccHeadID = (int *) realloc(sccHeadID, totalHeads * (sizeof(int)));
    sccHeadID[currentSCC] = routerInfoVec[currentRouter].rID;
    while (auxRouter != currentRouter)
    {
      auxRouter = pop();
      routerInfoVec[auxRouter].scc = currentSCC;
      routerInfoVec[auxRouter].onStack = false;
      routerInfoVec[auxRouter].head = currentRouter;
      size += 1;
      if (sccHeadID[currentSCC] < routerInfoVec[auxRouter].rID)
      {
        sccHeadID[currentSCC] = routerInfoVec[auxRouter].rID;
      }
      else
      {
        
      }

    }

    if (size > sccSize)
    {
      sccSize = size;
    }
    else
    {
      
    }

    size = 0;
  }
  else
  {
    
  }

}

void apUtil(int routerID, int *isVisited, int *des, int *parent, int *low, int *ap)
{
  static int time = 0;
  int children = 0;
  router *temp = network->gList[routerID].head;
  isVisited[routerID] = 1;
  time++;
  des[routerID] = (low[routerID] = time);
  while (temp != 0)
  {
    if (!isVisited[temp->id])
    {
      children++;
      parent[temp->id] = routerID;
      apUtil(temp->id, isVisited, des, parent, low, ap);
      low[routerID] = (low[routerID] < low[temp->id]) ? (low[routerID]) : (low[temp->id]);
      if ((parent[routerID] == (-1)) && (children > 1))
      {
        ap[routerID] = 1;
      }
      else
      {
        
      }

      if ((parent[routerID] != (-1)) && (des[routerID] <= low[temp->id]))
      {
        ap[routerID] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (temp->id != parent[routerID])
      {
        low[routerID] = (low[routerID] < des[temp->id]) ? (low[routerID]) : (des[temp->id]);
      }
      else
      {
        
      }

    }

    temp = temp->next;
  }

}

void AP()
{
  int i;
  int *des = (int *) malloc(((sizeof(int)) * N) + 4);
  int *isVisited = (int *) malloc(((sizeof(int)) * N) + 4);
  int *parent = (int *) malloc(((sizeof(int)) * N) + 4);
  int *low = (int *) malloc(((sizeof(int)) * N) + 4);
  int *ap = (int *) malloc(((sizeof(int)) * N) + 4);
  for (i = 1; i <= N; i++)
  {
    isVisited[i] = 0;
    parent[i] = -1;
    ap[i] = 0;
  }

  for (i = 1; i <= N; i++)
  {
    if (isVisited[i] == 0)
    {
      apUtil(i, isVisited, des, parent, low, ap);
    }
    else
    {
      
    }

  }

  int flag = 0;
  for (i = 1; i <= N; i++)
  {
    if (ap[i] == 1)
    {
      flag = 1;
      nAP++;
      routerInfoVec[i].removed = true;
    }
    else
    {
      
    }

  }

  if (flag == 0)
  {
  }
  else
  {
    
  }

  free(des);
  free(isVisited);
  free(parent);
  free(low);
  free(ap);
}

void freeGraph()
{
  int i;
  for (i = 1; i <= N; ++i)
  {
    freeGList(network->gList[i].head);
  }

  free(network->gList);
  free(network);
}

void freeGList(router *head)
{
  router *auxiliar = 0;
  while (head)
  {
    auxiliar = head->next;
    free(head);
    head = auxiliar;
  }

}

