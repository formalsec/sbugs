#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


struct Router
{
  int id;
  struct Router *next;
};
struct Network
{
  int nRouters;
  int *visited;
  int *ap;
  int *identList;
  struct Router **adjLists;
};
int nRouters = 0;
int mLinks = 0;
int auxSRC;
int auxDEST;
int routerMax = 1;
int nRouterMax = 0;
int nRouterMaxAUX = 0;
int subNetworks = 0;
int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

struct Router *createRouter(int id)
{
  struct Router *newRouter;
  newRouter = (struct Router *) malloc(sizeof(struct Router));
  if (newRouter == 0)
  {
    printf("Error creating a new router.\n");
    exit(0);
  }
  else
  {
    
  }

  newRouter->id = id;
  newRouter->next = 0;
  return newRouter;
}

struct Network *createNetwork(int routers)
{
  struct Network *network = malloc(sizeof(struct Network));
  network->nRouters = routers;
  network->visited = malloc((routers + 1) * (sizeof(int)));
  network->adjLists = malloc((routers + 1) * (sizeof(struct Router *)));
  network->ap = (int *) malloc((sizeof(int)) * network->nRouters);
  int i;
  for (i = 1; i <= routers; i++)
  {
    network->adjLists[i] = 0;
    network->visited[i] = 0;
  }

  return network;
}

void swap(int *a, int *b)
{
  int t = *a;
  *a = *b;
  *b = t;
}

int partition(int identList[], int low, int high)
{
  int pivot = identList[high];
  int i = low - 1;
  int j;
  for (j = low; j <= (high - 1); j++)
  {
    if (identList[j] <= pivot)
    {
      i++;
      swap(&identList[i], &identList[j]);
    }
    else
    {
      
    }

  }

  swap(&identList[i + 1], &identList[high]);
  return i + 1;
}

void quickSort(int identList[], int low, int high)
{
  if (low < high)
  {
    int pi = partition(identList, low, high);
    quickSort(identList, low, pi - 1);
    quickSort(identList, pi + 1, high);
  }
  else
  {
    
  }

}

void addLink(struct Network *network, int src, int dest)
{
  struct Router *newRouter = createRouter(dest);
  newRouter->next = network->adjLists[src];
  network->adjLists[src] = newRouter;
  newRouter = createRouter(src);
  newRouter->next = network->adjLists[dest];
  network->adjLists[dest] = newRouter;
}

void printNetwork(struct Network *network)
{
  int i;
  for (i = 1; i <= network->nRouters; i++)
  {
    struct Router *auxRouter = network->adjLists[i];
    printf("----------------------------\nAdjacency list of router %d\n", i);
    while (auxRouter)
    {
      printf("%d -> ", auxRouter->id);
      auxRouter = auxRouter->next;
    }

    printf("NULL\n");
  }

  printf("----------------------------\n");
}

int DFS(struct Network *network, int router, int routerMax)
{
  struct Router *adjList = network->adjLists[router];
  struct Router *auxAdjList = adjList;
  network->visited[router] = 1;
  while (auxAdjList != 0)
  {
    int currentRouter = auxAdjList->id;
    if (currentRouter > routerMax)
    {
      routerMax = currentRouter;
    }
    else
    {
      
    }

    if ((network->visited[currentRouter] == 0) && (network->ap[currentRouter] != 1))
    {
      nRouterMaxAUX++;
      routerMax = DFS(network, currentRouter, routerMax);
    }
    else
    {
      
    }

    auxAdjList = auxAdjList->next;
  }

  return routerMax;
}

void apUtil(struct Network *network, int id, int *visited, int *des, int *parent, int *low)
{
  struct Router *auxRouter = 0;
  static int time = 0;
  int children = 0;
  auxRouter = network->adjLists[id];
  visited[id] = 1;
  time++;
  des[id] = (low[id] = time);
  while (auxRouter != 0)
  {
    if (!visited[auxRouter->id])
    {
      children++;
      parent[auxRouter->id] = id;
      apUtil(network, auxRouter->id, visited, des, parent, low);
      low[id] = min(low[id], low[auxRouter->id]);
      if ((parent[id] == (-1)) && (children > 1))
      {
        network->ap[id] = 1;
      }
      else
      {
        
      }

      if ((parent[id] != (-1)) && (des[id] <= low[auxRouter->id]))
      {
        network->ap[id] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (auxRouter->id != parent[id])
      {
        low[id] = min(low[id], des[auxRouter->id]);
      }
      else
      {
        
      }

    }

    auxRouter = auxRouter->next;
  }

}

int AP(struct Network *network)
{
  int i;
  int vertexCounter = 0;
  int *des = (int *) malloc((sizeof(int)) * network->nRouters);
  int *visited = (int *) malloc((sizeof(int)) * network->nRouters);
  int *parent = (int *) malloc((sizeof(int)) * network->nRouters);
  int *low = (int *) malloc((sizeof(int)) * network->nRouters);
  for (i = 0; i < network->nRouters; i++)
  {
    visited[i] = 0;
    parent[i] = -1;
    network->ap[i] = 0;
  }

  for (i = 0; i < network->nRouters; i++)
  {
    if (visited[i] == 0)
    {
      apUtil(network, i, visited, des, parent, low);
    }
    else
    {
      
    }

  }

  for (i = 0; i < network->nRouters; i++)
  {
    if (network->ap[i] == 1)
    {
      vertexCounter++;
    }
    else
    {
      
    }

  }

  return vertexCounter;
}

int main()
{
  int vertexCounter;
  while (nRouters < 2)
  {
    nRouters = new_sym_var(sizeof(int) * 8);
    if (nRouters < 2)
    {
      printf("ERROR:The number of routers must be greater than 2\n");
    }
    else
    {
      
    }

  }

  int identIndex = 0;
  struct Network *network = createNetwork(nRouters);
  while (mLinks < 1)
  {
    mLinks = new_sym_var(sizeof(int) * 8);
    if (mLinks < 1)
    {
      printf("ERROR:The number of links must be greater than 1\n");
    }
    else
    {
      
    }

  }

  int i;
  for (i = mLinks; i > 0; i--)
  {
    auxSRC = new_sym_var(sizeof(int) * 8);
    auxDEST = new_sym_var(sizeof(int) * 8);
    addLink(network, auxSRC, auxDEST);
  }

  for (i = 1; i <= nRouters; i++)
  {
    routerMax = 1;
    if ((network->adjLists[i] != 0) && (network->visited[i] == 0))
    {
      routerMax = DFS(network, i, routerMax);
      subNetworks++;
      network->identList = realloc(network->identList, subNetworks * (sizeof(int)));
      network->identList[identIndex] = routerMax;
      identIndex++;
    }
    else
    {
      
    }

  }

  quickSort(network->identList, 0, subNetworks - 1);
  vertexCounter = AP(network);
  printf("%d\n", subNetworks);
  for (i = 0; i < subNetworks; i++)
  {
    if (i == (subNetworks - 1))
    {
      printf("%d\n", network->identList[i]);
    }
    else
    {
      printf("%d ", network->identList[i]);
    }

  }

  printf("%d\n", vertexCounter);
  for (i = 0; i <= nRouters; i++)
  {
    network->visited[i] = 0;
  }

  nRouterMax = 0;
  for (i = 1; i <= nRouters; i++)
  {
    if (((network->adjLists[i] != 0) && (network->ap[i - 1] != 1)) && (network->visited[i] == 0))
    {
      nRouterMaxAUX = 0;
      DFS(network, i, routerMax);
      if (nRouterMaxAUX > nRouterMax)
      {
        nRouterMax = nRouterMaxAUX;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  printf("%d\n", nRouterMax + 1);
  return 0;
}

