#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct neighbour
{
  int id;
  struct neighbour *next;
} Neighbour;
typedef struct node
{
  int id;
  int low;
  int discovered;
  int articulationPoint;
  struct neighbour *first;
} Node;
typedef struct graph
{
  int numberRouters;
  int numberConnections;
  int numArticulationPoints;
  Node *nodesList;
} Graph;
int sccId = 0;
int maxSubgraphSize = 0;
Node *allocList(Graph *graph)
{
  int i;
  int size = graph->numberRouters;
  Node *nodesList = calloc(size + 1, sizeof(struct node));
  for (i = 1; i <= size; i++)
  {
    nodesList[i].id = i;
    nodesList[i].discovered = -1;
    nodesList[i].low = -1;
    nodesList[i].articulationPoint = 0;
    nodesList[i].first = 0;
  }

  return nodesList;
}

void addNode(int node1, int node2, Node *nodesList)
{
  Neighbour *newElement = (Neighbour *) malloc(sizeof(struct neighbour));
  newElement->id = node2;
  newElement->next = nodesList[node1].first;
  nodesList[node1].first = newElement;
}

void freeList(Graph *graph)
{
  int i;
  Neighbour *iter1;
  Neighbour *iter2;
  Node *nodesList = graph->nodesList;
  for (i = 0; i <= graph->numberRouters; i++)
  {
    iter1 = nodesList[i].first;
    if (iter1 == 0)
    {
      continue;
    }
    else
    {
      
    }

    while (iter1->next != 0)
    {
      iter2 = iter1->next;
      free(iter1);
      iter1 = iter2;
    }

    free(iter1);
  }

  free(nodesList);
}

int min(int n1, int n2)
{
  if (n1 < n2)
  {
    return n1;
  }
  else
  {
    
  }

  return n2;
}

int searchGraph(Graph *graph, Node *parent, Node *node, Node *nodesList)
{
  static int time = 1;
  int rootTreeEdges = 0;
  node->discovered = time++;
  node->low = node->discovered;
  Neighbour *iter = node->first;
  if (sccId < node->id)
  {
    sccId = node->id;
  }
  else
  {
    
  }

  while (iter != 0)
  {
    if (nodesList[iter->id].discovered == (-1))
    {
      rootTreeEdges++;
      searchGraph(graph, node, &nodesList[iter->id], nodesList);
      node->low = min(nodesList[iter->id].low, node->low);
      if (((nodesList[iter->id].low >= node->discovered) && (parent != 0)) && (node->articulationPoint == 0))
      {
        node->articulationPoint = 1;
        graph->numArticulationPoints++;
      }
      else
      {
        if (((rootTreeEdges > 1) && (parent == 0)) && (node->articulationPoint == 0))
        {
          node->articulationPoint = 1;
          graph->numArticulationPoints++;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (parent != 0)
      {
        if (iter->id != parent->id)
        {
          node->low = min(nodesList[iter->id].discovered, node->low);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    iter = iter->next;
  }

  return sccId;
}

int *findSCC(Graph *graph, int *outputArray)
{
  int i = 0;
  int numberSCCs = 0;
  int aux = 0;
  Node *nodesList = graph->nodesList;
  Node *parent = 0;
  for (i = 1; i <= graph->numberRouters; i++)
  {
    if (nodesList[i].discovered == (-1))
    {
      aux = searchGraph(graph, parent, &nodesList[i], nodesList);
      outputArray[aux] = 1;
      numberSCCs++;
      sccId = 0;
    }
    else
    {
      
    }

  }

  outputArray[0] = numberSCCs;
  return outputArray;
}

int exploreGraph(Node *node, Node *nodesList, int *visited)
{
  Neighbour *iter = node->first;
  while (iter != 0)
  {
    if ((visited[iter->id] != 1) && (nodesList[iter->id].articulationPoint != 1))
    {
      visited[iter->id] = 1;
      maxSubgraphSize++;
      exploreGraph(&nodesList[iter->id], nodesList, visited);
    }
    else
    {
      
    }

    iter = iter->next;
  }

  return maxSubgraphSize;
}

int maxSubgraph(Graph *graph)
{
  int i = 0;
  int max = 0;
  int aux = 0;
  Node *nodesList = graph->nodesList;
  int *visited = calloc(graph->numberRouters + 1, sizeof(int));
  for (i = 1; i < graph->numberRouters; i++)
  {
    if ((visited[i] != 1) && (nodesList[i].articulationPoint != 1))
    {
      visited[i] = 1;
      maxSubgraphSize = 1;
      aux = exploreGraph(&nodesList[i], nodesList, visited);
      if (aux > max)
      {
        max = aux;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  free(visited);
  return max;
}

void readInput(Graph *graph)
{
  int i = 0;
  int node1;
  int node2;
  while ((i++) < graph->numberConnections)
  {
    node1 = new_sym_var(sizeof(int) * 8);
    node2 = new_sym_var(sizeof(int) * 8);
    addNode(node1, node2, graph->nodesList);
    addNode(node2, node1, graph->nodesList);
  }

}

int main()
{
  int i;
  int count = 0;
  Graph *graph = (Graph *) malloc(sizeof(struct graph));
  graph->numberRouters = new_sym_var(sizeof(int) * 8);
  graph->numberConnections = new_sym_var(sizeof(int) * 8);
  Node *nodesList = allocList(graph);
  graph->nodesList = nodesList;
  graph->numArticulationPoints = 0;
  readInput(graph);
  int *outputArray = calloc(graph->numberRouters + 1, sizeof(int));
  outputArray = findSCC(graph, outputArray);
  printf("%d\n", outputArray[0]);
  i = 1;
  while (i <= graph->numberRouters)
  {
    if (outputArray[i] == 1)
    {
      if (count == 0)
      {
        printf("%d", i);
        count++;
      }
      else
      {
        printf(" %d", i);
      }

    }
    else
    {
      
    }

    i++;
  }

  printf("\n");
  printf("%d\n", graph->numArticulationPoints);
  printf("%d\n", maxSubgraph(graph));
  free(outputArray);
  freeList(graph);
  free(graph);
  return 0;
}

