#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>


enum 
{
  FALSE = 0,
  TRUE = 1
};
typedef char bool_t;
typedef struct subnetwork
{
  int *subnetwork;
  unsigned size;
} *subnetwork_t;
typedef struct list_node
{
  void *data;
  struct list_node *next;
} *list_node_t;
typedef struct list
{
  list_node_t head;
  list_node_t tail;
  unsigned size;
  unsigned amount;
  short data_size;
} *list_t;
typedef struct graph_node
{
  int id;
  unsigned size;
  unsigned amount;
  int *adjacencies;
} graph_node_t;
typedef struct graph
{
  int num_nodes;
  struct graph_node *nodes;
} *graph_t;
typedef struct queue queue_t;
struct queue
{
  long pop;
  long push;
  long capacity;
  void **elements;
};
enum config
{
  QUEUE_GROWTH_FACTOR = 2
};
subnetwork_t create_subnetwork(unsigned size)
{
  subnetwork_t new_subnetwork = malloc(sizeof(subnetwork_t));
  new_subnetwork->size = size;
  new_subnetwork->subnetwork = malloc((sizeof(int)) * size);
  return new_subnetwork;
}

void subnetwork_free(subnetwork_t sub)
{
  free(sub->subnetwork);
}

static list_node_t list_node_create(void *data, int data_size)
{
  list_node_t node = malloc(sizeof(struct list_node));
  if (!node)
  {
    fprintf(stderr, "%s\n", "Could not allocate memory for node.");
    exit(1);
  }
  else
  {
    
  }

  ;
  node->data = malloc(data_size);
  memcpy(node->data, data, data_size);
  node->next = 0;
  return node;
}

list_t list_create(int data_size)
{
  list_t list = malloc(sizeof(struct list));
  if (!list)
  {
    {
      fprintf(stderr, "%s\n", "Could not allocate memory for linked list.");
      exit(1);
    }
    ;
  }
  else
  {
    
  }

  list->data_size = data_size;
  list->head = 0;
  list->tail = 0;
  list->size = 0;
  return list;
}

long list_getSize(list_t list)
{
  return list->size;
}

void list_iter_reset(list_t list, list_node_t *node)
{
  *node = list->head;
}

int list_iter_hasNext(list_node_t *node)
{
  return ((*node) != 0) ? (1) : (0);
}

void list_iter_next(list_node_t *node)
{
  if (node != 0)
  {
    *node = (*node)->next;
  }
  else
  {
    
  }

}

void list_insert_start(list_t list, void *data)
{
  list_node_t temp;
  list_node_t node = list_node_create(data, list->data_size);
  if (list->size == 0)
  {
    list->head = node;
    list->tail = node;
  }
  else
  {
    temp = list->head;
    node->next = temp;
    list->head = node;
  }

  list->size++;
}

void list_insert(list_t list, void *data)
{
  list_node_t node = list_node_create(data, list->data_size);
  if (list->size == 0)
  {
    list->head = node;
    list->tail = node;
  }
  else
  {
    list->tail->next = node;
    list->tail = node;
  }

  list->size++;
}

static void list_node_free(list_node_t node)
{
  if (node != 0)
  {
    list_node_free(node->next);
  }
  else
  {
    
  }

  if (node != 0)
  {
    if (node->data != 0)
    {
      free(node->data);
    }
    else
    {
      
    }

    free(node);
  }
  else
  {
    
  }

}

void list_remove_start(list_t list)
{
  list_node_t head = list->head;
  list->head = head->next;
  list_node_free(head);
  list->size--;
}

void list_remove_end(list_t list)
{
  list_node_t temp;
  list_node_t prev = 0;
  temp = list->head;
  while (list_iter_hasNext(&temp->next))
  {
    prev = temp;
    temp = temp->next;
  }

  list_node_free(temp);
  if (prev)
  {
    prev->next = 0;
    list->tail = prev;
  }
  else
  {
    list->head = 0;
    list->tail = 0;
  }

  if (list->size == 1)
  {
    list->head = list->tail;
  }
  else
  {
    
  }

  list->size--;
}

void list_free(list_t list)
{
  list_node_t temp;
  list_node_t aux = list->head;
  while (aux != 0)
  {
    temp = aux->next;
    free(aux->data);
    free(aux);
    aux = temp;
  }

  free(list);
}

graph_t graph_create(int num_nodes)
{
  int i;
  graph_t graph = malloc(sizeof(struct graph));
  if (!graph)
  {
    {
      fprintf(stderr, "%s\n", "Could not allocate memory for linked list.");
      exit(1);
    }
    ;
  }
  else
  {
    
  }

  graph->num_nodes = num_nodes;
  graph->nodes = malloc(num_nodes * (sizeof(struct graph_node)));
  for (i = 0; i < num_nodes; i++)
  {
    graph->nodes[i].id = i + 1;
    graph->nodes[i].size = 15;
    graph->nodes[i].adjacencies = malloc((sizeof(int)) * 15);
    graph->nodes[i].amount = 0;
  }

  return graph;
}

int *graph_get_adjacencies(graph_t graph, int id)
{
  return graph->nodes[id - 1].adjacencies;
}

void graph_destroy(graph_t graph)
{
  int i;
  int index = graph->num_nodes;
  for (i = 0; i < index; i++)
    free(graph->nodes[i].adjacencies);

  free(graph->nodes);
  free(graph);
}

queue_t *queue_alloc(long initCapacity)
{
  queue_t *queuePtr = (queue_t *) malloc(sizeof(queue_t));
  if (queuePtr)
  {
    long capacity = (initCapacity < 2) ? (2) : (initCapacity);
    queuePtr->elements = (void **) malloc(capacity * (sizeof(void *)));
    if (queuePtr->elements == 0)
    {
      free(queuePtr);
      return 0;
    }
    else
    {
      
    }

    queuePtr->pop = capacity - 1;
    queuePtr->push = 0;
    queuePtr->capacity = capacity;
  }
  else
  {
    
  }

  return queuePtr;
}

void queue_free(queue_t *queuePtr)
{
  free(queuePtr->elements);
  free(queuePtr);
}

bool_t queue_isEmpty(queue_t *queuePtr)
{
  long pop = queuePtr->pop;
  long push = queuePtr->push;
  long capacity = queuePtr->capacity;
  return (((pop + 1) % capacity) == push) ? (TRUE) : (FALSE);
}

void queue_clear(queue_t *queuePtr)
{
  queuePtr->pop = queuePtr->capacity - 1;
  queuePtr->push = 0;
}

bool_t queue_push(queue_t *queuePtr, void *dataPtr)
{
  long pop = queuePtr->pop;
  long push = queuePtr->push;
  long capacity = queuePtr->capacity;
  assert(pop != push);
  long newPush = (push + 1) % capacity;
  if (newPush == pop)
  {
    long newCapacity = capacity + QUEUE_GROWTH_FACTOR;
    void **newElements = (void **) malloc(newCapacity * (sizeof(void *)));
    if (newElements == 0)
    {
      return FALSE;
    }
    else
    {
      
    }

    long dst = 0;
    void **elements = queuePtr->elements;
    if (pop < push)
    {
      long src;
      for (src = pop + 1; src < push; src++, dst++)
      {
        newElements[dst] = elements[src];
      }

    }
    else
    {
      long src;
      for (src = pop + 1; src < capacity; src++, dst++)
      {
        newElements[dst] = elements[src];
      }

      for (src = 0; src < push; src++, dst++)
      {
        newElements[dst] = elements[src];
      }

    }

    free(elements);
    queuePtr->elements = newElements;
    queuePtr->pop = newCapacity - 1;
    queuePtr->capacity = newCapacity;
    push = dst;
    newPush = push + 1;
  }
  else
  {
    
  }

  queuePtr->elements[push] = dataPtr;
  queuePtr->push = newPush;
  return TRUE;
}

void *queue_pop(queue_t *queuePtr)
{
  long pop = queuePtr->pop;
  long push = queuePtr->push;
  long capacity = queuePtr->capacity;
  long newPop = (pop + 1) % capacity;
  if (newPop == push)
  {
    return 0;
  }
  else
  {
    
  }

  void *dataPtr = queuePtr->elements[newPop];
  queuePtr->pop = newPop;
  return dataPtr;
}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

graph_t get_input()
{
  graph_t router_graph;
  int N;
  int M;
  int i;
  int u;
  int v;
  if (!1)
  {
    exit(1);
  }
  else
  {
    N = new_sym_var(sizeof(int) * 8);
    
  }

  if (!1)
  {
    exit(1);
  }
  else
  {
    M = new_sym_var(sizeof(int) * 8);
    
  }

  router_graph = graph_create(N);
  for (i = 0; i < M; i++)
  {
    if (!2)
    {
      exit(1);
    }
    else
    {
      u = new_sym_var(sizeof(int) * 8);
      v = new_sym_var(sizeof(int) * 8);
      
    }

    if (router_graph->nodes[u - 1].amount == router_graph->nodes[u - 1].size)
    {
      int *new = realloc(router_graph->nodes[u - 1].adjacencies, (sizeof(int)) * (router_graph->nodes[u - 1].amount + 1));
      router_graph->nodes[u - 1].adjacencies = new;
      router_graph->nodes[u - 1].amount++;
      router_graph->nodes[u - 1].size = router_graph->nodes[u - 1].amount + 1;
    }
    else
    {
      
    }

    router_graph->nodes[u - 1].adjacencies[router_graph->nodes[u - 1].amount++] = v;
    if (router_graph->nodes[v - 1].amount == router_graph->nodes[v - 1].size)
    {
      int *new = realloc(router_graph->nodes[v - 1].adjacencies, (sizeof(int)) * (router_graph->nodes[v - 1].amount + 1));
      router_graph->nodes[v - 1].adjacencies = new;
      router_graph->nodes[v - 1].amount++;
      router_graph->nodes[v - 1].size = router_graph->nodes[v - 1].amount + 1;
    }
    else
    {
      
    }

    router_graph->nodes[v - 1].adjacencies[router_graph->nodes[v - 1].amount++] = u;
  }

  return router_graph;
}

int compare_int(const void *a, const void *b)
{
  return (*((int *) a)) - (*((int *) b));
}

void apUtil(graph_t router_graph, int node, char *isVisited, int *discovery_time, int *parent, int *low_time, char *articulation_points)
{
  int *adjacencies = graph_get_adjacencies(router_graph, node + 1);
  static int time = 0;
  int children = 0;
  int length = router_graph->nodes[node].amount;
  int i;
  isVisited[node] = 1;
  time++;
  discovery_time[node] = (low_time[node] = time);
  for (i = 0; i < length; i++)
  {
    int adjacency = adjacencies[i];
    adjacency--;
    if (!isVisited[adjacency])
    {
      children++;
      parent[adjacency] = node;
      apUtil(router_graph, adjacency, isVisited, discovery_time, parent, low_time, articulation_points);
      low_time[node] = min(low_time[node], low_time[adjacency]);
      if ((parent[node] == (-1)) && (children > 1))
      {
        articulation_points[node] = 1;
      }
      else
      {
        
      }

      if ((parent[node] != (-1)) && (discovery_time[node] <= low_time[adjacency]))
      {
        articulation_points[node] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (adjacency != parent[node])
      {
        low_time[node] = min(low_time[node], discovery_time[adjacency]);
      }
      else
      {
        
      }

    }

  }

}

char *find_articulation_points(graph_t router_graph)
{
  int i;
  int amount_nodes = router_graph->num_nodes;
  int counter = 0;
  int *discovery_time = (int *) malloc((sizeof(int)) * amount_nodes);
  char *isVisited = calloc(amount_nodes, sizeof(char));
  int *parent = (int *) malloc((sizeof(int)) * amount_nodes);
  int *low_time = (int *) malloc((sizeof(int)) * amount_nodes);
  char *articulation_points = calloc(amount_nodes, sizeof(char));
  for (i = 0; i < amount_nodes; i++)
  {
    parent[i] = -1;
    articulation_points[i] = 0;
  }

  for (i = 0; i < amount_nodes; i++)
  {
    if (isVisited[i] == 0)
    {
      apUtil(router_graph, i, isVisited, discovery_time, parent, low_time, articulation_points);
    }
    else
    {
      
    }

  }

  for (i = 0; i < amount_nodes; i++)
  {
    if (articulation_points[i] == 1)
    {
      counter++;
    }
    else
    {
      
    }

  }

  free(discovery_time);
  free(isVisited);
  free(parent);
  free(low_time);
  printf("%d\n", counter);
  return articulation_points;
}

void find_subnetwork_info(graph_t router_graph)
{
  int i;
  int amount_nodes = router_graph->num_nodes;
  int counter = 0;
  list_t subnetworks = list_create(sizeof(struct subnetwork));
  char *visited = calloc(amount_nodes, sizeof(char));
  queue_t *stack = queue_alloc(2);
  for (i = 0; i < amount_nodes; i++)
  {
    if (visited[i] != 0)
    {
      continue;
    }
    else
    {
      
    }

    list_t new_subnetwork = list_create(sizeof(int));
    queue_push(stack, &i);
    while (!queue_isEmpty(stack))
    {
      int current_node_idx = *((int *) queue_pop(stack));
      int *adjacencies = router_graph->nodes[current_node_idx].adjacencies;
      int j;
      int length = router_graph->nodes[current_node_idx].amount;
      for (j = 0; j < length; j++)
      {
        int adjacency = adjacencies[j];
        adjacency--;
        if (visited[adjacency] != 0)
        {
          continue;
        }
        else
        {
          
        }

        queue_push(stack, &router_graph->nodes[adjacency - 1].id);
      }

      list_insert(new_subnetwork, &router_graph->nodes[current_node_idx].id);
      visited[current_node_idx] = 1;
    }

    subnetwork_t _subnetwork = create_subnetwork(list_getSize(new_subnetwork));
    list_node_t iter = 0;
    list_iter_reset(new_subnetwork, &iter);
    int index = 0;
    while (list_iter_hasNext(&iter))
    {
      int num = (*((int *) iter->data)) + 1;
      _subnetwork->subnetwork[index++] = num;
      list_iter_next(&iter);
    }

    list_free(new_subnetwork);
    list_insert(subnetworks, _subnetwork);
    counter++;
    queue_clear(stack);
  }

  free(visited);
  queue_free(stack);
  printf("%d\n", counter);
  list_node_t iter = 0;
  list_iter_reset(subnetworks, &iter);
  int max = 0;
  int _counter = 0;
  int *max_subnetwork = malloc((sizeof(int)) * list_getSize(subnetworks));
  unsigned j;
  while (list_iter_hasNext(&iter))
  {
    subnetwork_t sn = (subnetwork_t) iter->data;
    max = 0;
    for (j = 0; j < sn->size; j++)
      if (sn->subnetwork[j] > max)
    {
      max = sn->subnetwork[j];
    }
    else
    {
      
    }


    subnetwork_free(sn);
    max_subnetwork[_counter++] = max - 1;
    list_iter_next(&iter);
  }

  list_node_t temp;
  list_node_t aux = subnetworks->head;
  while (aux != 0)
  {
    temp = aux->next;
    free(aux->data);
    free(aux);
    aux = temp;
  }

  free(subnetworks);
  qsort(max_subnetwork, counter, sizeof(int), compare_int);
  for (i = 0; i < (counter - 1); i++)
  {
    printf("%d ", max_subnetwork[i]);
  }

  printf("%d\n", max_subnetwork[counter - 1]);
  free(max_subnetwork);
}

void find_max_router(graph_t router_graph, char *articulation_points)
{
  int i;
  int amount_nodes = router_graph->num_nodes;
  int max = 0;
  int counter = 0;
  char *visited = calloc(amount_nodes, sizeof(char));
  queue_t *stack = queue_alloc(2);
  for (i = 0; i < amount_nodes; i++)
    if (articulation_points[i] != 0)
  {
    visited[i] = 1;
  }
  else
  {
    
  }


  free(articulation_points);
  for (i = 0; i < amount_nodes; i++)
  {
    if (visited[i] != 0)
    {
      continue;
    }
    else
    {
      
    }

    queue_push(stack, &i);
    counter = 0;
    while (!queue_isEmpty(stack))
    {
      int current_node_idx = *((int *) queue_pop(stack));
      int *adjacencies = graph_get_adjacencies(router_graph, current_node_idx + 1);
      int length = router_graph->nodes[current_node_idx].amount;
      int j;
      for (j = 0; j < length; j++)
      {
        int adjacency = adjacencies[j];
        adjacency--;
        if (visited[adjacency] != 0)
        {
          continue;
        }
        else
        {
          
        }

        queue_push(stack, &router_graph->nodes[adjacency - 1].id);
      }

      if (visited[current_node_idx] != 0)
      {
        continue;
      }
      else
      {
        
      }

      counter++;
      visited[current_node_idx] = 1;
    }

    if (counter > max)
    {
      max = counter;
    }
    else
    {
      
    }

  }

  queue_free(stack);
  free(visited);
  printf("%d\n", max);
}

int main()
{
  graph_t router_graph = get_input();
  find_subnetwork_info(router_graph);
  char *articulation_points = find_articulation_points(router_graph);
  find_max_router(router_graph, articulation_points);
  graph_destroy(router_graph);
  exit(0);
}

