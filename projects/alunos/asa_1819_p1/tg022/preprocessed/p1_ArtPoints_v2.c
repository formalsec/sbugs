/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef enum 
{
  false,
  true
} bool;
typedef struct connection
{
  int n;
  int *next;
} connection;
int cmpfunc(const void *a, const void *b)
{
  return (*((int *) a)) - (*((int *) b));
}

int artPoints(int u, bool visited[], int disc[], int low[], int parent[], bool artpoint[], connection *nodes, int *time, int *size)
{
  int max = u + 1;
  int children = 0;
  int index;
  (*size)++;
  visited[u] = true;
  disc[u] = (low[u] = ++(*time));
  for (index = 0; index < nodes[u].n; index++)
  {
    int v = nodes[u].next[index];
    if ((visited[v] == false) && (artpoint[v] == false))
    {
      children++;
      parent[v] = u;
      int m = artPoints(v, visited, disc, low, parent, artpoint, nodes, time, size);
      if (m > max)
      {
        max = m;
      }
      else
      {
        
      }

      low[u] = (low[u] < low[v]) ? (low[u]) : (low[v]);
      if ((parent[u] == (-1)) && (children > 1))
      {
        artpoint[u] = true;
      }
      else
      {
        
      }

      if ((parent[u] != (-1)) && (low[v] >= disc[u]))
      {
        artpoint[u] = true;
      }
      else
      {
        
      }

    }
    else
    {
      if (v != parent[u])
      {
        low[u] = (low[u] < disc[v]) ? (low[u]) : (disc[v]);
      }
      else
      {
        
      }

    }

  }

  return max;
}

int main()
{
  connection *nodes;
  int numNodes;
  int numConnec;
  int i;
  int index = 0;
  int origin;
  int dest;
  int time = 0;
  int subs = 0;
  int size = 0;
  int size_aux = 0;
  int err = 1;
  numNodes = new_sym_var(sizeof(int) * 8);
  if (err == (-1))
  {
    printf("Error occurred.\n");
  }
  else
  {
    
  }

  err = 1;
  numConnec = new_sym_var(sizeof(int) * 8);
  if (err == (-1))
  {
    printf("Error occurred.\n");
  }
  else
  {
    
  }

  nodes = (connection *) malloc((sizeof(connection)) * numNodes);
  for (i = 0; i < numNodes; i++)
  {
    nodes[i].n = 0;
    nodes[i].next = (int *) malloc((sizeof(int)) * 0);
  }

  while (index < numConnec)
  {
    err = 2;
    origin = new_sym_var(sizeof(int) * 8);
    dest = new_sym_var(sizeof(int) * 8);
    if (err == (-1))
    {
      printf("Error occurred.\n");
    }
    else
    {
      
    }

    origin--;
    dest--;
    int originConnections = ++nodes[origin].n;
    nodes[origin].next = (int *) realloc(nodes[origin].next, (sizeof(int)) * originConnections);
    nodes[origin].next[originConnections - 1] = dest;
    int destConnections = ++nodes[dest].n;
    nodes[dest].next = (int *) realloc(nodes[dest].next, (sizeof(int)) * destConnections);
    nodes[dest].next[destConnections - 1] = origin;
    index++;
  }

  bool *visited = (bool *) malloc((sizeof(bool)) * numNodes);
  int *disc = (int *) malloc((sizeof(int)) * numNodes);
  int *low = (int *) malloc((sizeof(int)) * numNodes);
  int *parent = (int *) malloc((sizeof(int)) * numNodes);
  bool *artpoint = (bool *) malloc((sizeof(bool)) * numNodes);
  int *subnetworks = (int *) malloc((sizeof(int)) * 0);
  for (i = 0; i < numNodes; i++)
  {
    parent[i] = -1;
    visited[i] = false;
    artpoint[i] = false;
  }

  for (i = 0; i < numNodes; i++)
  {
    if (visited[i] == false)
    {
      int max = artPoints(i, visited, disc, low, parent, artpoint, nodes, &time, &size);
      subs++;
      subnetworks = realloc(subnetworks, (sizeof(int)) * subs);
      subnetworks[subs - 1] = max;
    }
    else
    {
      
    }

  }

  printf("%d\n", subs);
  qsort(subnetworks, subs, sizeof(int), cmpfunc);
  printf("%d", subnetworks[0]);
  for (i = 1; i < subs; i++)
  {
    printf(" %d", subnetworks[i]);
  }

  printf("\n");
  int numAPoints = 0;
  for (i = 0; i < numNodes; i++)
  {
    if (artpoint[i] == true)
    {
      numAPoints++;
    }
    else
    {
      
    }

  }

  printf("%d\n", numAPoints);
  for (i = 0; i < numNodes; i++)
  {
    parent[i] = -1;
    visited[i] = false;
  }

  time = 0;
  for (i = 0; i < numNodes; i++)
  {
    if ((artpoint[i] == false) && (visited[i] == false))
    {
      size = 0;
      artPoints(i, visited, disc, low, parent, artpoint, nodes, &time, &size);
      if (size_aux < size)
      {
        size_aux = size;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  printf("%d\n", size_aux);
  free(visited);
  free(disc);
  free(low);
  free(parent);
  free(artpoint);
  for (i = 0; i < numNodes; i++)
  {
    free(nodes[i].next);
  }

  free(nodes);
  exit(0);
}

