#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef unsigned char bool;
typedef int Vertex;
int cmp_vertex(const void *a, const void *b)
{
  return (*((const Vertex *) b)) - (*((const Vertex *) a));
}

typedef int Edge;
typedef struct stack
{
  size_t idx;
  Vertex *data;
  bool *in_stack;
} Stack;
void stack_new(Stack *st, size_t size)
{
  if (st == 0)
  {
    return;
  }
  else
  {
    
  }

  st->idx = 0;
  st->data = malloc(size * (sizeof(*st->data)));
  st->in_stack = calloc(size, sizeof(*st->in_stack));
}

void stack_push(Stack *st, Vertex u)
{
  if (st == 0)
  {
    return;
  }
  else
  {
    
  }

  if (st->in_stack[u])
  {
    return;
  }
  else
  {
    
  }

  st->data[++st->idx] = u;
  st->in_stack[u] = 1;
}

int stack_pop(Stack *st)
{
  Vertex u;
  if (st == 0)
  {
    return 0;
  }
  else
  {
    
  }

  u = st->data[st->idx--];
  st->in_stack[u] = 0;
  return u;
}

void stack_sort(Stack *st)
{
  if (st == 0)
  {
    return;
  }
  else
  {
    
  }

  qsort(st->data + 1, st->idx, sizeof(Vertex), cmp_vertex);
}

int stack_size(Stack *st)
{
  return st->idx;
}

bool stack_contains(Stack *st, Vertex u)
{
  return (st != 0) ? (st->in_stack[u]) : (0);
}

bool stack_is_empty(Stack *st)
{
  return st->idx == 0;
}

void stack_reset(Stack *st)
{
  memset(st->in_stack, 0, st->idx * (sizeof(*st->in_stack)));
  st->idx = 0;
}

void stack_destroy(Stack *st)
{
  if (st == 0)
  {
    return;
  }
  else
  {
    
  }

  free(st->data);
  st->data = 0;
  free(st->in_stack);
  st->in_stack = 0;
}

typedef struct graph
{
  int nr_vertices;
  int nr_edges;
  bool is_bidir;
  Edge *first;
  Vertex *vertex;
  Edge *next;
  Vertex *parent;
} Graph;
void graph_connect(Graph *g, Vertex u, Vertex v, bool undirected)
{
  g->nr_edges++;
  g->vertex[g->nr_edges] = v;
  if (g->first[u] == 0)
  {
    g->first[u] = g->nr_edges;
  }
  else
  {
    Edge adj;
    for (adj = g->first[u]; (g->next[adj] != 0) && (g->vertex[adj] != v); adj = g->next[adj])
      ;

    if (g->vertex[adj] == v)
    {
      g->vertex[g->nr_edges--] = 0;
      return;
    }
    else
    {
      
    }

    g->next[adj] = g->nr_edges;
  }

  if (undirected)
  {
    graph_connect(g, v, u, 0);
  }
  else
  {
    
  }

}

void graph_new(Graph *g, int num_v, int num_e, bool is_bidir)
{
  g->nr_vertices = num_v;
  g->nr_edges = 0;
  g->is_bidir = is_bidir;
  if (is_bidir)
  {
    num_e *= 2;
  }
  else
  {
    
  }

  g->first = calloc(num_v + 1, sizeof(*g->first));
  g->vertex = calloc(num_e + 1, sizeof(*g->vertex));
  g->next = calloc(num_e + 1, sizeof(*g->next));
  g->parent = calloc(num_v + 1, sizeof(*g->parent));
}

void graph_init(Graph *g, int num_e)
{
  while ((num_e--) > 0)
  {
    int num1;
    int num2;
    Vertex u;
    Vertex v;
    num1 = new_sym_var(sizeof(int) * 8);
    num2 = new_sym_var(sizeof(int) * 8);
    u = num1;
    v = num2;
    graph_connect(g, u, v, g->is_bidir);
  }

}

void graph_reset(Graph *g)
{
  memset(g->first, 0, (g->nr_vertices + 1) * (sizeof(*g->first)));
  memset(g->vertex, 0, (g->nr_edges + 1) * (sizeof(*g->vertex)));
  memset(g->next, 0, (g->nr_edges + 1) * (sizeof(*g->next)));
  memset(g->parent, 0, (g->nr_vertices + 1) * (sizeof(*g->parent)));
  g->nr_edges = 0;
}

void graph_destroy(Graph *g)
{
  free(g->first);
  g->first = 0;
  free(g->vertex);
  g->vertex = 0;
  free(g->next);
  g->next = 0;
  free(g->parent);
  g->parent = 0;
}

typedef struct scc_data
{
  int biggest_scc;
  Stack ids;
  Stack ap;
} SCC_data;
void SCC_new(SCC_data *scc, size_t size)
{
  scc->biggest_scc = 0;
  stack_new(&scc->ids, size);
  stack_new(&scc->ap, size);
}

void SCC_destroy(SCC_data *scc)
{
  stack_destroy(&scc->ids);
  stack_destroy(&scc->ap);
}

void SCC_print(SCC_data *scc)
{
  printf("%d\n", stack_size(&scc->ids));
  while (!stack_is_empty(&scc->ids))
  {
    Vertex u = stack_pop(&scc->ids);
    printf("%d", u);
    if (!stack_is_empty(&scc->ids))
    {
      printf(" ");
    }
    else
    {
      
    }

  }

  printf("\n");
  printf("%d\n", stack_size(&scc->ap));
  printf("%d\n", scc->biggest_scc);
}

void count_scc(Graph *g, SCC_data *scc, Stack *st, Vertex u, int *disc, int *low, int *disc_time)
{
  Edge adj;
  if (stack_contains(&scc->ap, u))
  {
    return;
  }
  else
  {
    
  }

  disc[u] = (low[u] = ++(*disc_time));
  stack_push(st, u);
  for (adj = g->first[u]; adj != 0; adj = g->next[adj])
  {
    Vertex v = g->vertex[adj];
    if (stack_contains(&scc->ap, v))
    {
      continue;
    }
    else
    {
      
    }

    if (disc[v] == 0)
    {
      count_scc(g, scc, st, v, disc, low, disc_time);
      low[u] = (low[u] > low[v]) ? (low[v]) : (low[u]);
    }
    else
    {
      if (stack_contains(st, v))
      {
        low[u] = (low[u] > disc[v]) ? (disc[v]) : (low[u]);
      }
      else
      {
        
      }

    }

  }

  if (low[u] == disc[u])
  {
    Vertex v;
    scc->biggest_scc = (scc->biggest_scc < stack_size(st)) ? (stack_size(st)) : (scc->biggest_scc);
    while ((v = stack_pop(st)) != u)
      ;

  }
  else
  {
    
  }

}

void tarjan_aux(Graph *g, SCC_data *scc, Stack *st, Vertex u, int *disc, int *low, int *disc_time)
{
  Edge adj;
  int children = 0;
  disc[u] = (low[u] = ++(*disc_time));
  stack_push(st, u);
  for (adj = g->first[u]; adj != 0; adj = g->next[adj])
  {
    Vertex v = g->vertex[adj];
    if (disc[v] == 0)
    {
      g->parent[v] = u;
      children++;
      tarjan_aux(g, scc, st, v, disc, low, disc_time);
      low[u] = (low[u] > low[v]) ? (low[v]) : (low[u]);
      if ((g->parent[u] == 0) && (children > 1))
      {
        stack_push(&scc->ap, u);
      }
      else
      {
        
      }

      if ((g->parent[u] != 0) && (low[v] >= disc[u]))
      {
        stack_push(&scc->ap, u);
      }
      else
      {
        
      }

    }
    else
    {
      if (stack_contains(st, v))
      {
        low[u] = (low[u] > disc[v]) ? (disc[v]) : (low[u]);
      }
      else
      {
        
      }

    }

  }

  if (low[u] == disc[u])
  {
    Vertex v;
    Vertex tail = u;
    while ((v = stack_pop(st)) != u)
    {
      tail = (tail < v) ? (v) : (tail);
    }

    stack_push(&scc->ids, tail);
  }
  else
  {
    
  }

}

void tarjan(Graph *g, SCC_data *scc)
{
  Vertex u;
  int *disc;
  int *low;
  int disc_time = 0;
  Stack st;
  disc = calloc(g->nr_vertices + 1, sizeof(*disc));
  low = calloc(g->nr_vertices + 1, sizeof(*low));
  stack_new(&st, g->nr_vertices + 1);
  for (u = 1; u <= g->nr_vertices; u = u + 1)
  {
    if (disc[u] == 0)
    {
      tarjan_aux(g, scc, &st, u, disc, low, &disc_time);
    }
    else
    {
      
    }

  }

  memset(disc, 0, (g->nr_vertices + 1) * (sizeof(*disc)));
  memset(low, 0, (g->nr_vertices + 1) * (sizeof(*low)));
  stack_reset(&st);
  for (u = 1; u <= g->nr_vertices; u = u + 1)
  {
    if (disc[u] == 0)
    {
      count_scc(g, scc, &st, u, disc, low, &disc_time);
    }
    else
    {
      
    }

  }

  stack_destroy(&st);
  free(disc);
  free(low);
}

void graph_find_SCCs(Graph *g)
{
  SCC_data scc;
  SCC_new(&scc, g->nr_vertices + 1);
  tarjan(g, &scc);
  stack_sort(&scc.ids);
  SCC_print(&scc);
  SCC_destroy(&scc);
}

int main(void)
{
  int num_v;
  int num_e;
  Graph g;
  num_v = new_sym_var(sizeof(int) * 8);
  num_e = new_sym_var(sizeof(int) * 8);
  graph_new(&g, num_v, num_e, 1);
  graph_init(&g, num_e);
  graph_find_SCCs(&g);
  graph_destroy(&g);
  return 0;
}

