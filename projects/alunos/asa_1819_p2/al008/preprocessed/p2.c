#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct vertex
{
  int el;
  int visited;
  int augmented;
  int parent;
  int visitedBFS;
  int height;
  int excess;
  int onQueue;
  int tipo;
  struct connection *parentEdge;
  struct list *edgesSelf;
  struct list *adj;
} *vertexLink;
typedef struct connection
{
  int vI;
  int vF;
  int flow;
  int cap;
  int inverted;
} *connectionLink;
typedef struct list
{
  connectionLink connection;
  struct list *prev;
  struct list *next;
} *ListLink;
typedef struct queueItem
{
  int value;
  struct queueItem *prev;
  struct queueItem *next;
  struct queueItem *tail;
} *QueueLink;
int parseArgs(vertexLink *fListEl, int *edges, int *capForn, int *nPost, int *nFornecedor);
void insertConnection(ListLink *listAdj, connectionLink connection);
void invertConnections(vertexLink listEl, int size, int contrary);
connectionLink *BFS(vertexLink listEl, int size, int source, int target, int markFound, int *startPath);
void relabel(vertexLink listEl, int vertex);
void pushFlow(vertexLink listEl, connectionLink edge, int vI, int vF, int rightWay);
void discharge(vertexLink listEl, int vertex);
int relabelToFront(vertexLink listEl, int source, int target, int size, int nForn);
int maximumFlow(vertexLink listEl, int size);
int findToImprove(vertexLink listEl, int size, int edges, int nPostos, int nFornecedor);
void startQueue(QueueLink *queue, QueueLink *lastEmpty);
void pushQueue(QueueLink *queue, int value, QueueLink *lastEmpty);
int popQueue(QueueLink *queue, QueueLink *lastEmpty);
int isEmptyQueue(QueueLink *queue);
void freeQueue(QueueLink *queue);
void freeVertex(vertexLink listEl, int size);
int main(int argc, char **argv)
{
  int size = 0;
  int flow = 0;
  int edges = 0;
  int capForn = 0;
  int nPostos = 0;
  int nForn = 0;
  int source = 1;
  int target = 0;
  vertexLink listEl;
  size = parseArgs(&listEl, &edges, &capForn, &nPostos, &nForn);
  flow = relabelToFront(listEl, source, target, size, nForn);
  if ((flow < capForn) || (BFS(listEl, size, source, target, 0, 0) == 0))
  {
    findToImprove(listEl, size, edges, nPostos, nForn);
  }
  else
  {
    
  }

  freeVertex(listEl, size);
  return 0;
}

int parseArgs(vertexLink *fListEl, int *edges, int *capForn, int *nPost, int *nFornecedor)
{
  int nForn;
  int nPostos;
  int nLigacoes;
  int size;
  nForn = new_sym_var(sizeof(int) * 8);
  nPostos = new_sym_var(sizeof(int) * 8);
  nLigacoes = new_sym_var(sizeof(int) * 8);
  size = ((nForn + (2 * nPostos)) + 1) + 1;
  vertexLink listEl = (vertexLink) malloc((sizeof(struct vertex)) * size);
  listEl[0].el = 0;
  listEl[0].tipo = 3;
  listEl[0].visited = 0;
  listEl[0].augmented = 0;
  listEl[0].height = size;
  listEl[0].excess = 0;
  listEl[0].onQueue = 0;
  listEl[0].edgesSelf = 0;
  listEl[0].adj = 0;
  listEl[1].el = 1;
  listEl[1].tipo = 0;
  listEl[1].visited = 0;
  listEl[1].augmented = 0;
  listEl[1].height = 0;
  listEl[1].excess = 0;
  listEl[1].onQueue = 0;
  listEl[1].edgesSelf = 0;
  listEl[1].adj = 0;
  int currentI = 2;
  int i = currentI;
  for (; i < (nForn + currentI); i++)
  {
    int cap;
    cap = new_sym_var(sizeof(int) * 8);
    *capForn += cap;
    listEl[i].el = i;
    listEl[i].tipo = 1;
    listEl[i].visited = 0;
    listEl[i].augmented = 0;
    listEl[i].excess = cap;
    listEl[i].height = 0;
    listEl[i].edgesSelf = 0;
    listEl[i].adj = 0;
    listEl[i].onQueue = 0;
    listEl[i].edgesSelf = 0;
    listEl[i].adj = 0;
    connectionLink connection = (connectionLink) malloc(sizeof(struct connection));
    connection->vF = i;
    connection->vI = 0;
    connection->cap = cap;
    connection->flow = cap;
    connection->inverted = 0;
    insertConnection(&listEl[i].adj, connection);
    insertConnection(&listEl[i].edgesSelf, connection);
  }

  currentI = i;
  listEl[0].excess = -(*capForn);
  for (; i < ((+nPostos) + currentI); i++)
  {
    int cap;
    cap = new_sym_var(sizeof(int) * 8);
    listEl[i].el = i;
    listEl[i].tipo = 2;
    listEl[i].visited = 0;
    listEl[i].augmented = 0;
    listEl[i].height = 0;
    listEl[i].excess = 0;
    listEl[i].edgesSelf = 0;
    listEl[i].adj = 0;
    listEl[i].onQueue = 0;
    listEl[i].edgesSelf = 0;
    listEl[i].adj = 0;
    listEl[i + nPostos].el = i + nPostos;
    listEl[i + nPostos].tipo = 2;
    listEl[i + nPostos].visited = 0;
    listEl[i + nPostos].augmented = 0;
    listEl[i + nPostos].excess = 0;
    listEl[i + nPostos].height = 0;
    listEl[i + nPostos].edgesSelf = 0;
    listEl[i + nPostos].adj = 0;
    listEl[i + nPostos].onQueue = 0;
    listEl[i + nPostos].edgesSelf = 0;
    listEl[i + nPostos].adj = 0;
    connectionLink connection = (connectionLink) malloc(sizeof(struct connection));
    connection->vF = i + nPostos;
    connection->vI = i;
    connection->cap = cap;
    connection->flow = 0;
    connection->inverted = 0;
    insertConnection(&listEl[i].adj, connection);
    insertConnection(&listEl[i + nPostos].edgesSelf, connection);
  }

  for (i = 0; i < nLigacoes; i++)
  {
    connectionLink connection = (connectionLink) malloc(sizeof(struct connection));
    int o;
    int d;
    int c;
    o = new_sym_var(sizeof(int) * 8);
    d = new_sym_var(sizeof(int) * 8);
    c = new_sym_var(sizeof(int) * 8);
    connection->vF = d;
    connection->vI = o;
    connection->cap = c;
    connection->flow = 0;
    connection->inverted = 0;
    if (o <= (nForn + 1))
    {
      insertConnection(&listEl[o].adj, connection);
    }
    else
    {
      connection->vI = o + nPostos;
      insertConnection(&listEl[o + nPostos].adj, connection);
    }

    insertConnection(&listEl[d].edgesSelf, connection);
  }

  *nFornecedor = nForn;
  *nPost = nPostos;
  *edges = nLigacoes;
  *fListEl = listEl;
  return size;
}

void insertConnection(ListLink *listAdj, connectionLink connection)
{
  ListLink new = (ListLink) malloc(sizeof(struct list));
  ListLink head = *listAdj;
  new->prev = 0;
  new->connection = connection;
  if (head == 0)
  {
    *listAdj = new;
    new->next = 0;
  }
  else
  {
    ListLink aux;
    ListLink last;
    for (aux = head; aux != 0; aux = aux->next)
    {
      if (aux->next == 0)
      {
        last = aux;
      }
      else
      {
        
      }

      if (aux->connection->vF > new->connection->vF)
      {
        new->next = aux;
        new->prev = aux->prev;
        if (aux->prev != 0)
        {
          aux->prev->next = new;
        }
        else
        {
          
        }

        aux->prev = new;
        if (aux == head)
        {
          *listAdj = new;
        }
        else
        {
          
        }

        break;
      }
      else
      {
        
      }

    }

    if (aux == 0)
    {
      new->next = 0;
      new->prev = last;
      last->next = new;
    }
    else
    {
      
    }

  }

}

void invertConnections(vertexLink listEl, int size, int contrary)
{
  int i;
  for (i = 0; i < size; i++)
  {
    ListLink adj = listEl[i].adj;
    while (adj != 0)
    {
      ListLink aux = adj->next;
      int el = adj->connection->vF;
      if (adj->connection->inverted == 0)
      {
        connectionLink connection = (connectionLink) malloc(sizeof(struct connection));
        connection->vI = el;
        connection->vF = i;
        connection->cap = adj->connection->cap;
        connection->flow = adj->connection->flow;
        connection->inverted = 1;
        insertConnection(&listEl[el].adj, connection);
        adj->connection->flow = adj->connection->cap - adj->connection->flow;
        adj->connection->inverted = 1;
      }
      else
      {
        
      }

      adj = aux;
    }

  }

}

connectionLink *BFS(vertexLink listEl, int size, int source, int target, int markFound, int *startPath)
{
  int i;
  int currentV = 0;
  int maxDepth = 0;
  for (i = 0; i < size; i++)
  {
    listEl[i].visitedBFS = 0;
  }

  QueueLink queue;
  QueueLink lastEmpty;
  startQueue(&queue, &lastEmpty);
  pushQueue(&queue, source, &lastEmpty);
  listEl[source].visitedBFS = 1;
  i = 0;
  while (!isEmptyQueue(&queue))
  {
    currentV = popQueue(&queue, &lastEmpty);
    ListLink adj = listEl[currentV].adj;
    while (adj != 0)
    {
      int u = adj->connection->vF;
      int res = adj->connection->cap - adj->connection->flow;
      if ((listEl[u].visitedBFS == 0) && (res != 0))
      {
        maxDepth++;
        if (markFound)
        {
          listEl[u].visited = 1;
        }
        else
        {
          
        }

        pushQueue(&queue, u, &lastEmpty);
        listEl[u].visitedBFS = 1;
        listEl[u].parent = currentV;
        listEl[u].parentEdge = adj->connection;
        if ((u == target) && (!markFound))
        {
          connectionLink *path = (connectionLink *) malloc((sizeof(connectionLink)) * (maxDepth + 1));
          while (u != source)
          {
            path[maxDepth--] = listEl[u].parentEdge;
            u = listEl[u].parent;
          }

          if (startPath != 0)
          {
            *startPath = maxDepth + 1;
          }
          else
          {
            
          }

          freeQueue(&queue);
          return path;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      adj = adj->next;
    }

  }

  freeQueue(&queue);
  return 0;
}

void relabel(vertexLink listEl, int vertex)
{
  int minH = -1;
  ListLink adj = listEl[vertex].edgesSelf;
  while (adj != 0)
  {
    int h = listEl[adj->connection->vI].height;
    if ((adj->connection->flow > 0) && ((h < minH) || (minH == (-1))))
    {
      minH = h;
    }
    else
    {
      
    }

    adj = adj->next;
  }

  adj = listEl[vertex].adj;
  while (adj != 0)
  {
    int h = listEl[adj->connection->vF].height;
    int res = adj->connection->cap - adj->connection->flow;
    if ((res > 0) && ((h < minH) || (minH == (-1))))
    {
      minH = h;
    }
    else
    {
      
    }

    adj = adj->next;
  }

  listEl[vertex].height = minH + 1;
}

void pushFlow(vertexLink listEl, connectionLink edge, int vI, int vF, int rightWay)
{
  int eU = listEl[vI].excess;
  int res = (rightWay) ? (edge->cap - edge->flow) : (edge->flow);
  int minFlow = (eU < res) ? (eU) : (res);
  if (rightWay)
  {
    edge->flow += minFlow;
  }
  else
  {
    edge->flow -= minFlow;
  }

  listEl[vI].excess -= minFlow;
  listEl[vF].excess += minFlow;
}

int relabelToFront(vertexLink listEl, int source, int target, int size, int nForn)
{
  QueueLink queue;
  QueueLink lastEmpty;
  startQueue(&queue, &lastEmpty);
  int i;
  for (i = 2; i < (2 + nForn); i++)
  {
    pushQueue(&queue, i, &lastEmpty);
  }

  int currentV = popQueue(&queue, &lastEmpty);
  while (currentV != (-1))
  {
    if (listEl[currentV].excess > 0)
    {
      int vertex = currentV;
      vertexLink currentVertex;
      while (listEl[vertex].excess > 0)
      {
        ListLink adj = listEl[vertex].edgesSelf;
        while (adj != 0)
        {
          currentVertex = &listEl[adj->connection->vI];
          if ((currentVertex->height < listEl[vertex].height) && (adj->connection->flow > 0))
          {
            pushFlow(listEl, adj->connection, vertex, currentVertex->el, 0);
            if (((currentVertex->el != 0) && (currentVertex->el != 1)) && (!listEl[currentVertex->el].onQueue))
            {
              pushQueue(&queue, currentVertex->el, &lastEmpty);
              listEl[currentVertex->el].onQueue = 1;
            }
            else
            {
              
            }

            break;
          }
          else
          {
            
          }

          adj = adj->next;
        }

        ListLink adj2 = listEl[vertex].adj;
        while (adj2 != 0)
        {
          currentVertex = &listEl[adj2->connection->vF];
          int res = adj2->connection->cap - adj2->connection->flow;
          if ((currentVertex->height < listEl[vertex].height) && (res > 0))
          {
            pushFlow(listEl, adj2->connection, vertex, currentVertex->el, 1);
            if (((currentVertex->el != 0) && (currentVertex->el != 1)) && (!listEl[currentVertex->el].onQueue))
            {
              pushQueue(&queue, currentVertex->el, &lastEmpty);
              listEl[currentVertex->el].onQueue = 1;
            }
            else
            {
              
            }

            break;
          }
          else
          {
            
          }

          adj2 = adj2->next;
        }

        if ((adj == 0) && (adj2 == 0))
        {
          relabel(listEl, vertex);
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

    listEl[currentV].onQueue = 0;
    currentV = popQueue(&queue, &lastEmpty);
  }

  printf("%d\n", listEl[1].excess);
  freeQueue(&queue);
  return listEl[1].excess;
}

int findToImprove(vertexLink listEl, int size, int edges, int nPostos, int nFornecedor)
{
  int *vertixesToAugment = (int *) malloc((sizeof(int)) * 1);
  int **edgesToAugment = (int **) malloc((sizeof(int *)) * 1);
  int vertixesPointer = 0;
  int edgesPointer = 0;
  int i;
  invertConnections(listEl, size, 1);
  listEl[1].visited = 1;
  BFS(listEl, size, 1, 0, 1, 0);
  for (i = 1; i < size; i++)
  {
    if (!listEl[i].visited)
    {
      ListLink adj = listEl[i].adj;
      while (adj != 0)
      {
        int target = adj->connection->vF;
        if (listEl[adj->connection->vF].visited == 1)
        {
          if (((i + nPostos) == target) && (target > ((nPostos + nFornecedor) + 1)))
          {
            vertixesToAugment[vertixesPointer++] = i;
            listEl[i].augmented = 1;
            vertixesToAugment = (int *) realloc(vertixesToAugment, (vertixesPointer + 1) * (sizeof(int)));
          }
          else
          {
            if (listEl[i].augmented == 0)
            {
              int source = i;
              if (i > ((nPostos + nFornecedor) + 1))
              {
                source -= nPostos;
              }
              else
              {
                
              }

              int *edges = (int *) malloc((sizeof(int)) * 2);
              edges[0] = source;
              edges[1] = target;
              edgesToAugment[edgesPointer++] = edges;
              edgesToAugment = (int **) realloc(edgesToAugment, (edgesPointer + 1) * (sizeof(int *)));
            }
            else
            {
              
            }

          }

        }
        else
        {
          
        }

        adj = adj->next;
      }

    }
    else
    {
      
    }

  }

  for (i = 0; i < vertixesPointer; i++)
  {
    if (i == (vertixesPointer - 1))
    {
      printf("%d\n", vertixesToAugment[i]);
    }
    else
    {
      printf("%d ", vertixesToAugment[i]);
    }

  }

  if (vertixesPointer == 0)
  {
    printf("\n");
  }
  else
  {
    
  }

  for (i = 0; i < edgesPointer; i++)
  {
    if ((i == (edgesPointer - 1)) && (listEl[edgesToAugment[i][0]].augmented == 0))
    {
      printf("%d %d\n", edgesToAugment[i][0], edgesToAugment[i][1]);
    }
    else
    {
      if (listEl[edgesToAugment[i][0]].augmented == 0)
      {
        printf("%d %d\n", edgesToAugment[i][0], edgesToAugment[i][1]);
      }
      else
      {
        
      }

    }

    free(edgesToAugment[i]);
  }

  free(vertixesToAugment);
  free(edgesToAugment);
  return 0;
}

void startQueue(QueueLink *queue, QueueLink *lastEmpty)
{
  *queue = (QueueLink) malloc(sizeof(struct queueItem));
  *lastEmpty = (QueueLink) malloc(sizeof(struct queueItem));
  (*queue)->next = *lastEmpty;
  (*queue)->prev = 0;
  (*queue)->value = -1;
  (*queue)->tail = *queue;
  (*lastEmpty)->next = 0;
  (*lastEmpty)->prev = *queue;
  (*lastEmpty)->value = -1;
  (*lastEmpty)->tail = *queue;
}

void pushQueue(QueueLink *queue, int value, QueueLink *lastEmpty)
{
  if ((*queue)->value == (-1))
  {
    (*queue)->value = value;
    (*queue)->tail = *queue;
  }
  else
  {
    if ((*queue)->tail->next == (*lastEmpty))
    {
      QueueLink newLastEmpty = (QueueLink) malloc(sizeof(struct queueItem));
      newLastEmpty->next = 0;
      newLastEmpty->value = -1;
      newLastEmpty->prev = *lastEmpty;
      newLastEmpty->tail = *lastEmpty;
      (*lastEmpty)->value = value;
      (*lastEmpty)->next = newLastEmpty;
      (*queue)->tail->next = *lastEmpty;
      (*queue)->tail->tail = *lastEmpty;
      (*queue)->tail = *lastEmpty;
      *lastEmpty = newLastEmpty;
    }
    else
    {
      QueueLink aux = (*queue)->tail->next;
      aux->value = value;
      (*queue)->tail->tail = aux;
      (*queue)->tail = aux;
    }

  }

}

int popQueue(QueueLink *queue, QueueLink *lastEmpty)
{
  QueueLink adj = *queue;
  int value = (*queue)->value;
  if ((*queue)->next->value == (-1))
  {
    (*queue)->value = -1;
  }
  else
  {
    *queue = adj->next;
    (*queue)->tail = adj->tail;
    (*lastEmpty)->next = adj;
    adj->value = -1;
    adj->next = 0;
    adj->prev = *lastEmpty;
    *lastEmpty = adj;
  }

  return value;
}

int isEmptyQueue(QueueLink *queue)
{
  return ((*queue)->value == (-1)) ? (1) : (0);
}

void freeQueue(QueueLink *queue)
{
  QueueLink current = *queue;
  QueueLink next;
  while (current != 0)
  {
    next = current->next;
    free(current);
    current = next;
  }

}

void freeVertex(vertexLink listEl, int size)
{
  int i;
  ListLink list;
  ListLink aux;
  for (i = 0; i < size; i++)
  {
    list = listEl[i].adj;
    while (list != 0)
    {
      aux = list->next;
      if (list->connection != 0)
      {
        free(list->connection);
      }
      else
      {
        
      }

      free(list);
      list = aux;
    }

    list = listEl[i].edgesSelf;
    while (list != 0)
    {
      aux = list->next;
      free(list);
      list = aux;
    }

  }

  free(listEl);
}

