/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>


struct Queue
{
  int front;
  int rear;
  int size;
  unsigned capacity;
  int *array;
};
struct Queue *createQueue(unsigned capacity)
{
  struct Queue *queue = (struct Queue *) malloc(sizeof(struct Queue));
  queue->capacity = capacity;
  queue->front = (queue->size = 0);
  queue->rear = capacity - 1;
  queue->array = (int *) malloc(queue->capacity * (sizeof(int)));
  return queue;
}

int isEmpty(struct Queue *queue)
{
  return queue->size == 0;
}

int isFull(struct Queue *queue)
{
  return queue->size == queue->capacity;
}

void enqueue(struct Queue *queue, int item)
{
  if (isFull(queue))
  {
    return;
  }
  else
  {
    
  }

  queue->rear = (queue->rear + 1) % queue->capacity;
  queue->array[queue->rear] = item;
  queue->size = queue->size + 1;
}

int dequeue(struct Queue *queue)
{
  if (isEmpty(queue))
  {
    return INT_MIN;
  }
  else
  {
    
  }

  int item = queue->array[queue->front];
  queue->front = (queue->front + 1) % queue->capacity;
  queue->size = queue->size - 1;
  return item;
}

int valueInQueue(struct Queue *queue, int val)
{
  int i;
  for (i = queue->front; i < (queue->front + queue->size); i++)
    if (queue->array[i] == val)
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

void freeQueue(struct Queue *queue)
{
  free(queue->array);
  free(queue);
}

typedef struct 
{
  int to;
  int cap;
  int flow;
  int next;
} edge;
void addEdge(edge *edges, int *first, int from, int to, int cap, int *edgeNum)
{
  edges[*edgeNum].to = to;
  edges[*edgeNum].cap = cap;
  edges[*edgeNum].flow = 0;
  edges[*edgeNum].next = first[from];
  first[from] = (*edgeNum)++;
  edges[*edgeNum].to = from;
  edges[*edgeNum].cap = 0;
  edges[*edgeNum].flow = 0;
  edges[*edgeNum].next = first[to];
  first[to] = (*edgeNum)++;
}

void freeGraph(edge *edges, int *first)
{
  free(edges);
  free(first);
}

void readSupplierProduction(edge *edges, int *first, int *edgeNum, int suppliers)
{
  int i;
  for (i = 2; i < (suppliers + 2); i++)
  {
    int production;
    if (1 != 1)
    {
      exit(-1);
    }
    else
    {
      production = new_sym_var(sizeof(int) * 8);
      
    }

    addEdge(edges, first, 0, i, production, edgeNum);
  }

}

void readStationsCapacity(edge *edges, int *first, int *edgeNum, int suppliers, int stations)
{
  int stationIndex = 2 + suppliers;
  int stationDestIndex = stationIndex + stations;
  int i;
  for (i = stationIndex; i < (stationIndex + stations); i++, stationDestIndex++)
  {
    int capacity;
    if (1 != 1)
    {
      exit(-1);
    }
    else
    {
      capacity = new_sym_var(sizeof(int) * 8);
      
    }

    addEdge(edges, first, i, stationDestIndex, capacity, edgeNum);
  }

}

void readConnections(edge *edges, int *first, int *edgeNum, int suppliers, int stations, int connections)
{
  int i;
  for (i = 0; i < connections; i++)
  {
    int orig;
    int dest;
    int capacity;
    if (3 != 3)
    {
      exit(-1);
    }
    else
    {
      orig = new_sym_var(sizeof(int) * 8);
      dest = new_sym_var(sizeof(int) * 8);
      capacity = new_sym_var(sizeof(int) * 8);
      
    }

    if (orig >= (2 + suppliers))
    {
      orig += stations;
    }
    else
    {
      
    }

    addEdge(edges, first, orig, dest, capacity, edgeNum);
  }

}

void push(edge *edges, int u, int index, int *excess)
{
  int diff = (excess[u] < (edges[index].cap - edges[index].flow)) ? (excess[u]) : (edges[index].cap - edges[index].flow);
  edges[index].flow += diff;
  edges[(index % 2) ? (index - 1) : (index + 1)].flow = -edges[index].flow;
  excess[u] -= diff;
  excess[edges[index].to] += diff;
}

void relabel(edge *edges, int *first, int u, int *height)
{
  int i;
  int min = 32767;
  for (i = first[u]; i != (-1); i = edges[i].next)
    if ((edges[i].cap - edges[i].flow) > 0)
  {
    min = (min < height[edges[i].to]) ? (min) : (height[edges[i].to]);
    height[u] = 1 + min;
  }
  else
  {
    
  }


}

void dfs_reverse(edge *edges, int *first, int u, int *visited)
{
  int i;
  visited[u] = 1;
  for (i = first[u]; i != (-1); i = edges[i].next)
    if ((!visited[edges[i].to]) && ((edges[(i % 2) ? (i - 1) : (i + 1)].cap - edges[(i % 2) ? (i - 1) : (i + 1)].flow) > 0))
  {
    dfs_reverse(edges, first, edges[i].to, visited);
  }
  else
  {
    
  }


}

int pushRelabel(edge *edges, int *first, int *minCutEdges, int size, int realConnections)
{
  int *excess;
  int *height;
  int i;
  struct Queue *q = createQueue(size - 2);
  excess = (int *) malloc(size * (sizeof(int)));
  height = (int *) malloc(size * (sizeof(int)));
  memset(excess, 0, size * (sizeof(int)));
  memset(height, 0, size * (sizeof(int)));
  height[0] = size;
  for (i = first[0]; i != (-1); i = edges[i].next)
  {
    edges[i].flow = edges[i].cap;
    edges[(i % 2) ? (i - 1) : (i + 1)].flow = -edges[i].cap;
    excess[edges[i].to] = edges[i].cap;
    excess[0] -= edges[i].cap;
    enqueue(q, edges[i].to);
  }

  while (!isEmpty(q))
  {
    int u = dequeue(q);
    while (excess[u] > 0)
    {
      for (i = first[u]; (i != (-1)) && (excess[u] > 0); i = edges[i].next)
        if (((edges[i].cap - edges[i].flow) > 0) && (height[u] == (height[edges[i].to] + 1)))
      {
        push(edges, u, i, excess);
        if (((edges[i].to != 1) && (edges[i].to != 0)) && (!valueInQueue(q, edges[i].to)))
        {
          enqueue(q, edges[i].to);
        }
        else
        {
          
        }

      }
      else
      {
        
      }


      if (excess[u] > 0)
      {
        relabel(edges, first, u, height);
      }
      else
      {
        
      }

    }

  }

  int *visited = (int *) malloc(size * (sizeof(int)));
  int *exists = (int *) malloc(size * (sizeof(int)));
  memset(visited, 0, size * (sizeof(int)));
  dfs_reverse(edges, first, 1, visited);
  int orig;
  int edgesIndex = 0;
  for (orig = 0; orig < size; orig++)
    if (!visited[orig])
  {
    int originCount = 0;
    memset(exists, 0, size * (sizeof(int)));
    for (i = first[orig]; i != (-1); i = edges[i].next)
      if ((visited[edges[i].to] && (edges[i].flow > 0)) && (edges[i].cap > 0))
    {
      originCount++;
      exists[edges[i].to] = 1;
    }
    else
    {
      
    }


    for (i = 0; (i < size) && (originCount > 0); i++)
      if (exists[i])
    {
      originCount--;
      minCutEdges[edgesIndex++] = orig;
      minCutEdges[edgesIndex++] = i;
    }
    else
    {
      
    }


  }
  else
  {
    
  }


  int maxflow = excess[1];
  free(exists);
  free(visited);
  freeQueue(q);
  free(height);
  free(excess);
  return maxflow;
}

int main()
{
  int suppliers;
  int stations;
  int connections;
  if (3 != 3)
  {
    exit(-1);
  }
  else
  {
    suppliers = new_sym_var(sizeof(int) * 8);
    stations = new_sym_var(sizeof(int) * 8);
    connections = new_sym_var(sizeof(int) * 8);
    
  }

  if (((suppliers <= 0) || (stations < 0)) || (connections < 0))
  {
    printf("Wrong input: Numbers must be positive\n");
    exit(-1);
  }
  else
  {
    
  }

  int size = (2 + suppliers) + (2 * stations);
  int realConnections = 2 * ((connections + suppliers) + stations);
  int edgeNum = 0;
  int *first = (int *) malloc(size * (sizeof(size)));
  int i;
  for (i = 0; i < size; ++i)
  {
    first[i] = -1;
  }

  edge *edges = (edge *) malloc(realConnections * (sizeof(edge)));
  readSupplierProduction(edges, first, &edgeNum, suppliers);
  readStationsCapacity(edges, first, &edgeNum, suppliers, stations);
  readConnections(edges, first, &edgeNum, suppliers, stations, connections);
  int *minCutEdges = (int *) malloc(realConnections * (sizeof(int)));
  memset(minCutEdges, 0, realConnections * (sizeof(int)));
  printf("%d\n", pushRelabel(edges, first, minCutEdges, size, realConnections));
  int temp = 0;
  for (i = 1; i < realConnections; i += 2)
  {
    if ((minCutEdges[i - 1] >= (2 + suppliers)) && ((minCutEdges[i - 1] + stations) == minCutEdges[i]))
    {
      if (temp == 0)
      {
        printf("%d", minCutEdges[i - 1]);
        temp = 1;
      }
      else
      {
        printf(" %d", minCutEdges[i - 1]);
      }

      minCutEdges[i] = -1;
      minCutEdges[i - 1] = -1;
    }
    else
    {
      
    }

  }

  printf("\n");
  for (i = 1; i < realConnections; i += 2)
  {
    if ((minCutEdges[i] != (-1)) && (minCutEdges[i - 1] != 0))
    {
      int orig = minCutEdges[i - 1];
      int dest = minCutEdges[i];
      if (orig >= ((2 + suppliers) + stations))
      {
        orig -= stations;
      }
      else
      {
        
      }

      if (dest >= ((2 + suppliers) + stations))
      {
        dest -= stations;
      }
      else
      {
        
      }

      printf("%d %d\n", orig, dest);
    }
    else
    {
      
    }

  }

  free(minCutEdges);
  freeGraph(edges, first);
  return 0;
}

