/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>


enum 
{
  TRUE = 1,
  FALSE = 0
};
typedef char bool_t;
typedef struct Edge
{
  int vertex;
  int capacity;
  int flux;
  struct Edge *next;
  struct Edge *backEdge;
} Edge;
typedef struct Graph
{
  int numVertices;
  Edge **adjLists;
} Graph;
Edge *createEdge(int vertex, int capacity)
{
  Edge *newEdge = (Edge *) malloc(sizeof(Edge));
  newEdge->vertex = vertex;
  newEdge->capacity = capacity;
  newEdge->flux = 0;
  newEdge->next = 0;
  return newEdge;
}

Graph *createGraph(int size)
{
  Graph *graph = (Graph *) malloc(sizeof(Graph));
  graph->numVertices = size;
  graph->adjLists = (Edge **) malloc((sizeof(Edge *)) * size);
  return graph;
}

void addEdge(Graph *graph, int v1, int v2, int capacity2)
{
  Edge *ResidualEdge = createEdge(v1, 0);
  Edge *newEdge2 = createEdge(v2, capacity2);
  Edge *current;
  Edge *before;
  ResidualEdge->backEdge = newEdge2;
  newEdge2->backEdge = ResidualEdge;
  if (graph->adjLists[v1] != 0)
  {
    current = graph->adjLists[v1]->next;
    before = graph->adjLists[v1];
    while ((current != 0) && (current->vertex < newEdge2->vertex))
    {
      before = current;
      current = current->next;
    }

    newEdge2->next = current;
    before->next = newEdge2;
  }
  else
  {
    graph->adjLists[v1] = newEdge2;
  }

  if (graph->adjLists[v2] != 0)
  {
    current = graph->adjLists[v2]->next;
    before = graph->adjLists[v2];
    while ((current != 0) && (current->vertex < ResidualEdge->vertex))
    {
      before = current;
      current = current->next;
    }

    ResidualEdge->next = current;
    before->next = ResidualEdge;
  }
  else
  {
    graph->adjLists[v2] = ResidualEdge;
  }

}

void freeList(Edge *node)
{
  Edge *current;
  if (node != 0)
  {
    while (node->next != 0)
    {
      current = node->next;
      node->next = current->next;
      free(current);
    }

    free(node);
  }
  else
  {
    
  }

}

void freeGraph(Graph *graph)
{
  int i;
  int n = graph->numVertices;
  for (i = 0; i < n; i++)
    freeList(graph->adjLists[i]);

  free(graph->adjLists);
  free(graph);
}

typedef struct queueNode
{
  int data;
  struct queueNode *next;
} QueueNode;
typedef struct 
{
  QueueNode *head;
  QueueNode *tail;
} Queue;
Queue *createQueue()
{
  Queue *queue = (Queue *) malloc(sizeof(Queue));
  queue->head = 0;
  queue->tail = 0;
  return queue;
}

QueueNode *createQueueNode(int data)
{
  QueueNode *newNode = (QueueNode *) malloc(sizeof(QueueNode));
  newNode->data = data;
  newNode->next = 0;
  return newNode;
}

void queuePop(Queue *queue)
{
  QueueNode *aux = queue->head;
  queue->head = queue->head->next;
  free(aux);
}

void queueInsert(Queue *queue, int data)
{
  if (queue->head == 0)
  {
    queue->head = createQueueNode(data);
    queue->tail = queue->head;
  }
  else
  {
    queue->tail->next = createQueueNode(data);
    queue->tail = queue->tail->next;
  }

}

void freeQueue(Queue *queue)
{
  if (queue->head != 0)
  {
    while (queue->head->next != 0)
      queuePop(queue);

    free(queue->head);
  }
  else
  {
    
  }

  free(queue);
}

void push(Edge *u, Edge *v, int excess[])
{
  int diff = (excess[u->vertex] < (v->capacity - v->flux)) ? (excess[u->vertex]) : (v->capacity - v->flux);
  v->flux += diff;
  u->flux = (-1) * v->flux;
  excess[u->vertex] -= diff;
  excess[v->vertex] += diff;
}

Edge *relabel(Graph *graph, int u, int height[])
{
  Edge *aux;
  Edge *minNeighbor = 0;
  int minHeight = 32767;
  for (aux = graph->adjLists[u]; aux != 0; aux = aux->next)
  {
    if ((aux->capacity - aux->flux) > 0)
    {
      int testHeight = height[aux->vertex];
      if ((testHeight >= height[u]) && (testHeight < minHeight))
      {
        minHeight = testHeight;
        minNeighbor = aux;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  height[u] = minHeight + 1;
  return minNeighbor;
}

void initializePreFlow(Graph *graph, int source, int height[], int excess[])
{
  Edge *aux;
  height[source] = graph->numVertices;
  for (aux = graph->adjLists[source]; aux != 0; aux = aux->next)
  {
    aux->flux = aux->capacity;
    aux->backEdge->flux = (-1) * aux->capacity;
    excess[aux->vertex] = aux->capacity;
    excess[source] -= aux->capacity;
  }

}

void discharge(Graph *graph, Queue *queue, int u, int height[], int excess[])
{
  Edge *aux = graph->adjLists[u];
  while (excess[u] > 0)
  {
    if (aux == 0)
    {
      aux = relabel(graph, u, height);
    }
    else
    {
      int resCap = aux->capacity - aux->flux;
      if ((resCap > 0) && (height[u] == (height[aux->vertex] + 1)))
      {
        int oldExcess = excess[aux->vertex];
        push(aux->backEdge, aux, excess);
        if ((oldExcess == 0) && (aux->vertex > 1))
        {
          queueInsert(queue, aux->vertex);
        }
        else
        {
          
        }

      }
      else
      {
        aux = aux->next;
      }

    }

  }

}

void relabelToFront(Graph *graph, int source, int f)
{
  Queue *queue = createQueue();
  int i;
  int height[graph->numVertices];
  int excess[graph->numVertices];
  for (i = 0; i < graph->numVertices; i++)
  {
    height[i] = 0;
    excess[i] = 0;
  }

  initializePreFlow(graph, source, height, excess);
  for (i = 2; i < (f + 2); i++)
  {
    queueInsert(queue, i);
  }

  while (queue->head != 0)
  {
    int u = queue->head->data;
    discharge(graph, queue, u, height, excess);
    queuePop(queue);
  }

  freeQueue(queue);
  printf("%d\n", excess[1]);
}

void printEdges(Graph *graph, bool_t *visited, int e, int f)
{
  Edge *aux;
  int i;
  bool_t first = TRUE;
  for (i = f + 2; i < ((f + e) + 2); i++)
  {
    if (!visited[i])
    {
      for (aux = graph->adjLists[i]; aux != 0; aux = aux->next)
      {
        if (visited[aux->vertex] && (aux->capacity > 0))
        {
          if (first)
          {
            printf("%d", i);
            first = FALSE;
          }
          else
          {
            printf(" %d", i);
          }

        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  printf("\n");
  for (i = 2; i < (f + 2); i++)
  {
    if (!visited[i])
    {
      for (aux = graph->adjLists[i]; aux != 0; aux = aux->next)
      {
        if (visited[aux->vertex] && (aux->capacity > 0))
        {
          printf("%d %d\n", i, aux->vertex);
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  for (i = (f + e) + 2; i < graph->numVertices; i++)
  {
    if (!visited[i])
    {
      for (aux = graph->adjLists[i]; aux != 0; aux = aux->next)
      {
        if (visited[aux->vertex] && (aux->capacity > 0))
        {
          printf("%d %d\n", i - e, aux->vertex);
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

}

void bfs(Graph *graph, int s, int e, int f)
{
  Queue *queue = createQueue();
  Edge *aux;
  int i;
  bool_t visited[graph->numVertices];
  for (i = 0; i < graph->numVertices; i++)
    visited[i] = FALSE;

  visited[s] = TRUE;
  queueInsert(queue, s);
  while (queue->head != 0)
  {
    i = queue->head->data;
    queuePop(queue);
    for (aux = graph->adjLists[i]; aux != 0; aux = aux->next)
    {
      if ((((aux->capacity == 0) && (aux->backEdge->flux < aux->backEdge->capacity)) || ((aux->capacity > 0) && (aux->flux > 0))) && (!visited[aux->vertex]))
      {
        visited[aux->vertex] = TRUE;
        queueInsert(queue, aux->vertex);
      }
      else
      {
        
      }

    }

  }

  freeQueue(queue);
  printEdges(graph, visited, e, f);
}

int main(int argc, const char *argv[])
{
  Graph *graph;
  int f;
  int e;
  int t;
  int size;
  int s;
  int d;
  int i = 2;
  int j;
  int capacity;
  if (3 < 0)
  {
    exit(1);
  }
  else
  {
    f = new_sym_var(sizeof(int) * 8);
    e = new_sym_var(sizeof(int) * 8);
    t = new_sym_var(sizeof(int) * 8);
    
  }

  size = (f + (2 * e)) + 2;
  graph = createGraph(size);
  for (j = 0; j < f; j++)
  {
    if (1 < 0)
    {
      exit(1);
    }
    else
    {
      capacity = new_sym_var(sizeof(int) * 8);
      
    }

    addEdge(graph, 0, i++, capacity);
    getchar();
  }

  for (j = 0; j < e; j++)
  {
    if (1 < 0)
    {
      exit(1);
    }
    else
    {
      capacity = new_sym_var(sizeof(int) * 8);
      
    }

    addEdge(graph, i, i + e, capacity);
    i++;
    getchar();
  }

  for (j = 0; j < t; j++)
  {
    if (3 < 0)
    {
      exit(1);
    }
    else
    {
      s = new_sym_var(sizeof(int) * 8);
      d = new_sym_var(sizeof(int) * 8);
      capacity = new_sym_var(sizeof(int) * 8);
      
    }

    if (s >= (f + 2))
    {
      addEdge(graph, s + e, d, capacity);
    }
    else
    {
      addEdge(graph, s, d, capacity);
    }

    getchar();
  }

  relabelToFront(graph, 0, f);
  bfs(graph, 1, e, f);
  freeGraph(graph);
  return 0;
}

