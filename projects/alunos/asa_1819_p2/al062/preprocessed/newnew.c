#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>


typedef struct Lig
{
  int weight;
  int des;
  int flow;
  struct Lig *reverse;
  struct Lig *next;
} Lig;
typedef struct Listlig
{
  int local;
  struct Listlig *next;
} Listlig;
typedef struct Listligarch
{
  int des;
  int ori;
  struct Listligarch *next;
} Listligarch;
void cria_listlig(int local, Listlig *head)
{
  Listlig *v = (Listlig *) malloc(sizeof(Listlig));
  v->local = local;
  if (head->next == 0)
  {
    head->next = v;
    return;
  }
  else
  {
    
  }

  Listlig *last;
  Listlig *current = head;
  last = head;
  while ((current->next != 0) && (current->local < local))
  {
    last = current;
    current = current->next;
  }

  if (current->local > local)
  {
    v->next = last->next;
    last->next = v;
  }
  else
  {
    last->next->next = v;
  }

}

void cria_listligarch(int des, int ori, Listligarch *head)
{
  Listligarch *v = (Listligarch *) malloc(sizeof(Listligarch));
  v->des = des;
  v->ori = ori;
  if (head->next == 0)
  {
    head->next = v;
    return;
  }
  else
  {
    
  }

  Listligarch *last;
  Listligarch *current = head;
  last = head;
  while ((current->next != 0) && (current->ori < ori))
  {
    last = current;
    current = current->next;
  }

  if (v->ori == current->ori)
  {
    while ((current->next != 0) && (current->des < des))
    {
      last = current;
      current = current->next;
    }

  }
  else
  {
    
  }

  if ((current->ori > ori) || (current->des > des))
  {
    v->next = last->next;
    last->next = v;
  }
  else
  {
    last->next->next = v;
  }

}

struct Lig *cria_lig(int weight, int des, int flow, Lig *firstOfvector, int nlig)
{
  if (nlig == 1)
  {
    firstOfvector->weight = weight;
    firstOfvector->des = des;
    firstOfvector->flow = flow;
    firstOfvector->next = 0;
    return firstOfvector;
  }
  else
  {
    
  }

  Lig *v = (Lig *) malloc(sizeof(Lig));
  v->weight = weight;
  v->des = des;
  v->flow = flow;
  v->next = 0;
  Lig *last;
  last = firstOfvector;
  while (last->next != 0)
  {
    last = last->next;
  }

  last->next = v;
  return v;
}

void moveParaPri(Listlig *anterior, Listlig *current, Listlig *v)
{
  if (anterior == 0)
  {
    return;
  }
  else
  {
    
  }

  anterior->next = current->next;
  current->next = v;
}

void push(int *vectorflow, Lig *lig_origem, int vector_ori)
{
  int deferenca;
  if (vectorflow[vector_ori - 1] < (lig_origem->weight - lig_origem->flow))
  {
    deferenca = vectorflow[vector_ori - 1];
  }
  else
  {
    deferenca = lig_origem->weight - lig_origem->flow;
  }

  lig_origem->flow = lig_origem->flow + deferenca;
  lig_origem->reverse->flow = -lig_origem->flow;
  vectorflow[vector_ori - 1] -= deferenca;
  vectorflow[lig_origem->des - 1] += deferenca;
}

void relable(Lig *matriz, int *hights, int u)
{
  Lig *v = &matriz[u - 1];
  int min = 32767;
  while (v != 0)
  {
    if (0 < (v->weight - v->flow))
    {
      if (min > hights[v->des - 1])
      {
        min = hights[v->des - 1];
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    v = v->next;
  }

  hights[u - 1] = 1 + min;
}

void discharge(Lig *matriz, int *hights, int *vectorflow, int u)
{
  Lig *v = &matriz[u - 1];
  while (vectorflow[u - 1] > 0)
  {
    if (v == 0)
    {
      relable(matriz, hights, u);
      v = &matriz[u - 1];
    }
    else
    {
      
    }

    if ((0 < (v->weight - v->flow)) && (hights[u - 1] > hights[v->des - 1]))
    {
      push(vectorflow, v, u);
    }
    else
    {
      v = v->next;
    }

  }

}

void relabel_to_front(Lig *matriz, int *vnlig, int Nparagens, int *vectorflow, int *hights)
{
  int i;
  int oldhight;
  Listlig *v;
  Listlig *current = (Listlig *) malloc(sizeof(Listlig));
  Listlig *head = current;
  current->local = 2;
  for (i = 1; i < (Nparagens - 2); i++)
  {
    v = (Listlig *) malloc(sizeof(Listlig));
    v->local = i + 2;
    current->next = v;
    current = current->next;
  }

  current = head;
  Listlig *anterior = 0;
  while (current != 0)
  {
    oldhight = hights[current->local - 1];
    discharge(matriz, hights, vectorflow, current->local);
    if (hights[current->local - 1] > oldhight)
    {
      v = head;
      head = current;
      moveParaPri(anterior, current, v);
    }
    else
    {
      
    }

    anterior = current;
    current = current->next;
  }

  ;
}

void DFSvisiter(Lig *matriz, int u, Listlig *estacoes, Listligarch *archos, int *visitado, int NFornec, int NEstAbast)
{
  visitado[u - 1] = 1;
  Lig *j = &matriz[u - 1];
  if (u != matriz[1].des)
  {
    while (j != 0)
    {
      if ((j->des == matriz[1].des) && (visitado[j->des - 1] == 0))
      {
        DFSvisiter(matriz, j->des, estacoes, archos, visitado, NFornec, NEstAbast);
      }
      else
      {
        if ((((j->reverse->weight - j->reverse->flow) == 0) && (j->flow < 0)) && (visitado[j->des - 1] == 0))
        {
        }
        else
        {
          if ((visitado[j->des - 1] == 0) && (j->flow < 0))
          {
            DFSvisiter(matriz, j->des, estacoes, archos, visitado, NFornec, NEstAbast);
          }
          else
          {
            
          }

        }

      }

      j = j->next;
    }

  }
  else
  {
    
  }

}

void Cutter(Lig *matriz, int Nparagens, Listlig *estacoes, Listligarch *archos, int NFornec, int NEstAbast, int *visitado)
{
  Lig *j = &matriz[0];
  while (j != 0)
  {
    if ((j->des == matriz[1].des) || ((j->reverse->weight - j->reverse->flow) != 0))
    {
      if (visitado[j->des - 1] == 0)
      {
        DFSvisiter(matriz, j->des, estacoes, archos, visitado, NFornec, NEstAbast);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    j = j->next;
  }

}

int main()
{
  int NFornec;
  int NEstAbast;
  int NLig;
  int i;
  int j;
  int ConOrigin;
  int ConDes;
  int ConWeight;
  NFornec = new_sym_var(sizeof(int) * 8);
  NEstAbast = new_sym_var(sizeof(int) * 8);
  NLig = new_sym_var(sizeof(int) * 8);
  int PesosFornecedores;
  int PesosEstacoes;
  int NDados = (NFornec + NEstAbast) + 1;
  int Nparagens = (NFornec + (2 * NEstAbast)) + 2;
  Lig matriz[Nparagens];
  int hights[Nparagens];
  int vectorflow[Nparagens];
  int visitado[Nparagens];
  int *vnlig;
  Lig *u;
  Lig *v;
  Listlig *estacoes = (Listlig *) malloc(sizeof(Listlig));
  Listligarch *archos = (Listligarch *) malloc(sizeof(Listligarch));
  vnlig = (int *) malloc(Nparagens * (sizeof(int)));
  for (i = 0; i < Nparagens; i++)
    vnlig[i] = 0;

  i = 0;
  if (NFornec > 1)
  {
    for (; i < (NFornec - 1); i++)
    {
      vnlig[Nparagens - 1]++;
      PesosFornecedores = new_sym_var(sizeof(int) * 8);
      v = cria_lig(PesosFornecedores, i + 2, PesosFornecedores, &matriz[Nparagens - 1], vnlig[Nparagens - 1]);
      vnlig[i + 1]++;
      u = cria_lig(0, Nparagens, -PesosFornecedores, &matriz[i + 1], vnlig[i + 1]);
      v->reverse = u;
      u->reverse = v;
    }

  }
  else
  {
    
  }

  vnlig[Nparagens - 1]++;
  PesosFornecedores = new_sym_var(sizeof(int) * 8);
  v = cria_lig(PesosFornecedores, i + 2, PesosFornecedores, &matriz[Nparagens - 1], vnlig[Nparagens - 1]);
  vnlig[i + 1]++;
  u = cria_lig(0, Nparagens, -PesosFornecedores, &matriz[i + 1], vnlig[i + 1]);
  v->reverse = u;
  u->reverse = v;
  i = 0;
  if (NEstAbast > 1)
  {
    for (; i < (NEstAbast - 1); i++)
    {
      PesosEstacoes = new_sym_var(sizeof(int) * 8);
      vnlig[i + NDados]++;
      u = cria_lig(PesosEstacoes, (i + 2) + NFornec, 0, &matriz[i + NDados], vnlig[i + NDados]);
      vnlig[(i + NFornec) + 1]++;
      v = cria_lig(0, (i + NDados) + 1, 0, &matriz[(i + NFornec) + 1], vnlig[(i + NFornec) + 1]);
      v->reverse = u;
      u->reverse = v;
    }

  }
  else
  {
    
  }

  PesosEstacoes = new_sym_var(sizeof(int) * 8);
  vnlig[i + NDados]++;
  u = cria_lig(PesosEstacoes, (i + 2) + NFornec, 0, &matriz[i + NDados], vnlig[i + NDados]);
  vnlig[(i + NFornec) + 1]++;
  v = cria_lig(0, (i + NDados) + 1, 0, &matriz[(i + NFornec) + 1], vnlig[(i + NFornec) + 1]);
  v->reverse = u;
  u->reverse = v;
  for (i = 0; i < NLig; i++)
  {
    ConOrigin = new_sym_var(sizeof(int) * 8);
    ConDes = new_sym_var(sizeof(int) * 8);
    ConWeight = new_sym_var(sizeof(int) * 8);
    if (ConDes > (NFornec + 1))
    {
      ConDes = ConDes + NEstAbast;
    }
    else
    {
      
    }

    vnlig[ConOrigin - 1]++;
    v = cria_lig(ConWeight, ConDes, 0, &matriz[ConOrigin - 1], vnlig[ConOrigin - 1]);
    vnlig[ConDes - 1]++;
    u = cria_lig(0, ConOrigin, 0, &matriz[ConDes - 1], vnlig[ConDes - 1]);
    v->reverse = u;
    u->reverse = v;
  }

  for (i = 0; i < (Nparagens - 1); i++)
  {
    vectorflow[i] = 0;
    hights[i] = 0;
  }

  vectorflow[Nparagens - 1] = 0;
  hights[Nparagens - 1] = Nparagens;
  for (i = 1; i <= vnlig[Nparagens - 1]; i++)
  {
    vectorflow[i] = -matriz[i].flow;
  }

  relabel_to_front(matriz, vnlig, Nparagens, vectorflow, hights);
  printf("%d\n", vectorflow[0]);
  visitado[0] = 1;
  for (i = 1; i < Nparagens; i++)
  {
    visitado[i] = 0;
  }

  visitado[Nparagens - 1] = 0;
  Listlig *m = estacoes;
  Listligarch *n = archos;
  Listlig *lastm = estacoes;
  Listligarch *lastn = archos;
  Cutter(matriz, Nparagens, estacoes, archos, NFornec, NEstAbast, visitado);
  for (i = 0; i < (Nparagens - 1); i++)
  {
    if (visitado[i] == 1)
    {
      v = &matriz[i];
      for (j = 0; j < vnlig[i]; j++)
      {
        if (visitado[v->des - 1] == 0)
        {
          if ((i > NFornec) && (i < NDados))
          {
            cria_listlig(i + 1, estacoes);
          }
          else
          {
            cria_listligarch(i + 1, v->des, archos);
          }

        }
        else
        {
          
        }

        v = v->next;
      }

    }
    else
    {
      
    }

  }

  if (estacoes->next != 0)
  {
    while (m->next->next != 0)
    {
      printf("%d ", m->next->local);
      lastm = m;
      m = m->next;
      free(lastm);
    }

    printf("%d\n", m->next->local);
    lastm = m;
    m = m->next;
    free(lastm);
    free(m);
  }
  else
  {
    free(estacoes);
    printf("\n");
  }

  if (n->next != 0)
  {
    while (n->next->next != 0)
    {
      printf("%d %d\n", n->next->ori, n->next->des);
      lastn = n;
      n = n->next;
      free(lastn);
    }

    printf("%d %d\n", n->next->ori, n->next->des);
    lastn = n;
    n = n->next;
    free(lastn);
    free(n);
  }
  else
  {
    free(archos);
  }

  for (i = 0; i < Nparagens; i++)
  {
    u = matriz[i].next;
    while (u != 0)
    {
      v = u;
      u = u->next;
      free(v);
    }

  }

  free(vnlig);
  return 0;
}

