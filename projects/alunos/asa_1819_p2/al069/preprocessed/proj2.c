#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct lista Lista;
typedef struct no No;
typedef struct v Vertice;
typedef struct queue Queue;
typedef struct fila Fila;
Vertice *grafo;
int nfornecedores;
int nabastecimentos;
int nligacoes;
int *infila;
int *estacoesaumenta;
int contador = 0;
Fila fila;
Fila *arestas;
struct lista
{
  No *inicio;
  No *fim;
};
struct fila
{
  Queue *inicio;
  Queue *fim;
};
struct queue
{
  int vertice;
  Queue *prox;
};
struct no
{
  long int capacidade;
  long int fluxo;
  int destino;
  No *prox;
};
struct v
{
  Lista arestas;
  long int excesso;
  int altura;
};
Queue *NovoQueue(int vertice)
{
  Queue *x = (Queue *) malloc(sizeof(struct queue));
  x->vertice = vertice;
  x->prox = 0;
  return x;
}

Queue *insereFimQueue(Queue *fim, int vertice, Queue **inicio)
{
  if (fim == 0)
  {
    *inicio = NovoQueue(vertice);
    return *inicio;
  }
  else
  {
    
  }

  fim->prox = NovoQueue(vertice);
  fim = fim->prox;
  return fim;
}

Queue *insereAresta(Queue *fim, int vertice, Queue **inicio)
{
  Queue *x = *inicio;
  Queue *anterior = 0;
  Queue *aux;
  if (fim == 0)
  {
    *inicio = NovoQueue(vertice);
    return *inicio;
  }
  else
  {
    
  }

  while ((x != 0) && (x->vertice < vertice))
  {
    anterior = x;
    x = x->prox;
  }

  if ((x == 0) && (anterior != 0))
  {
    fim->prox = NovoQueue(vertice);
    fim = fim->prox;
    return fim;
  }
  else
  {
    if ((x != 0) && (anterior == 0))
    {
      aux = *inicio;
      *inicio = NovoQueue(vertice);
      (*inicio)->prox = aux;
      return fim;
    }
    else
    {
      anterior->prox = NovoQueue(vertice);
      anterior->prox->prox = x;
      return fim;
    }

  }

}

No *Novo(int destino, long int capacidade, long int fluxo)
{
  No *x = (No *) malloc(sizeof(struct no));
  x->capacidade = capacidade;
  x->destino = destino;
  x->fluxo = fluxo;
  x->prox = 0;
  return x;
}

No *insereFim(No *fim, int destino, long int capacidade, long int fluxo, No **inicio)
{
  if (fim == 0)
  {
    *inicio = Novo(destino, capacidade, fluxo);
    return *inicio;
  }
  else
  {
    
  }

  fim->prox = Novo(destino, capacidade, fluxo);
  fim = fim->prox;
  return fim;
}

void Push(int origem, No *destino)
{
  int d = grafo[origem].excesso;
  No *x = grafo[destino->destino].arestas.inicio;
  if (grafo[origem].excesso > (destino->capacidade - destino->fluxo))
  {
    d = destino->capacidade - destino->fluxo;
  }
  else
  {
    
  }

  while ((x != 0) && (x->destino != origem))
    x = x->prox;

  destino->fluxo += d;
  x->fluxo -= d;
  grafo[origem].excesso -= d;
  grafo[destino->destino].excesso += d;
  if ((destino->destino > 1) && (!infila[destino->destino]))
  {
    fila.fim = insereFimQueue(fila.fim, destino->destino, &fila.inicio);
  }
  else
  {
    
  }

}

void Discharge(int vertice)
{
  No *viz = grafo[vertice].arestas.inicio;
  int min = grafo[viz->destino].altura;
  while (grafo[vertice].excesso > 0)
  {
    if (viz == 0)
    {
      if (grafo[vertice].altura < (min + 1))
      {
        grafo[vertice].altura = min + 1;
      }
      else
      {
        
      }

      viz = grafo[vertice].arestas.inicio;
      while (viz->fluxo == viz->capacidade)
        viz = viz->prox;

      min = grafo[viz->destino].altura;
    }
    else
    {
      if ((viz->fluxo < viz->capacidade) && (grafo[vertice].altura == (grafo[viz->destino].altura + 1)))
      {
        Push(vertice, viz);
      }
      else
      {
        viz = viz->prox;
        if (((viz != 0) && (min > grafo[viz->destino].altura)) && (viz->fluxo < viz->capacidade))
        {
          min = grafo[viz->destino].altura;
        }
        else
        {
          
        }

      }

    }

  }

}

void DFSvisit(int vertice)
{
  No *x;
  infila[vertice] = true;
  for (x = grafo[vertice].arestas.inicio; x != 0; x = x->prox)
  {
    if (x->destino > 0)
    {
      if (infila[x->destino] == false)
      {
        if ((x->capacidade - x->fluxo) != x->capacidade)
        {
          DFSvisit(x->destino);
        }
        else
        {
          if ((vertice > ((nfornecedores + nabastecimentos) + 1)) && (x->destino == (vertice - nabastecimentos)))
          {
            estacoesaumenta[(x->destino - nfornecedores) - 2] = 1;
          }
          else
          {
            if (x->destino > ((nfornecedores + nabastecimentos) + 1))
            {
              arestas[x->destino - nabastecimentos].fim = insereAresta(arestas[x->destino - nabastecimentos].fim, vertice, &arestas[x->destino - nabastecimentos].inicio);
            }
            else
            {
              arestas[x->destino].fim = insereAresta(arestas[x->destino].fim, vertice, &arestas[x->destino].inicio);
            }

          }

        }

      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

}

void DFS()
{
  int i;
  for (i = 0; i < ((nfornecedores + (2 * nabastecimentos)) + 2); i++)
  {
    infila[i] = false;
  }

  DFSvisit(1);
}

int relabelToFront()
{
  int fluxo = 0;
  Queue *u = fila.inicio;
  while (u != 0)
  {
    Discharge(u->vertice);
    infila[u->vertice] = false;
    fila.inicio = fila.inicio->prox;
    free(u);
    u = fila.inicio;
  }

  fluxo = grafo[1].excesso;
  return fluxo;
}

int main()
{
  int producao = 0;
  int capacidade = 0;
  int origem;
  int destino;
  int capacidadelig = 0;
  int fluxomaximo;
  int pos_source = 0;
  int i = 0;
  int flaglinda = 0;
  Queue *x;
  fila.fim = 0;
  fila.inicio = 0;
  if (3)
  {
    nfornecedores = new_sym_var(sizeof(int) * 8);
    nabastecimentos = new_sym_var(sizeof(int) * 8);
    nligacoes = new_sym_var(sizeof(int) * 8);
    if (((nfornecedores > 0) && (nabastecimentos >= 0)) && (nligacoes >= 0))
    {
      grafo = (Vertice *) malloc((sizeof(Vertice)) * ((nfornecedores + (2 * nabastecimentos)) + 2));
      infila = (int *) malloc((sizeof(int)) * ((nfornecedores + (2 * nabastecimentos)) + 2));
      grafo[pos_source].altura = (nfornecedores + (2 * nabastecimentos)) + 2;
      grafo[1].excesso = 0;
      grafo[1].altura = 0;
      for (i = 0; i < ((nfornecedores + (nabastecimentos * 2)) + 2); i++)
      {
        grafo[i].arestas.fim = 0;
        grafo[i].arestas.inicio = 0;
        infila[i] = false;
      }

      for (i = 2; i <= (nfornecedores + 1); i++)
      {
        if (1 && (producao >= 0))
        {
          grafo[i].excesso = producao;
          grafo[i].altura = 0;
          grafo[pos_source].excesso -= producao;
          grafo[i].arestas.fim = insereFim(grafo[i].arestas.fim, pos_source, producao, 0, &grafo[i].arestas.inicio);
          grafo[pos_source].arestas.fim = insereFim(grafo[pos_source].arestas.fim, i, producao, producao, &grafo[pos_source].arestas.inicio);
          fila.fim = insereFimQueue(fila.fim, i, &fila.inicio);
          infila[i] = true;
        }
        else
        {
          producao = new_sym_var(sizeof(int) * 8);
          
        }

      }

      for (; i < ((nfornecedores + nabastecimentos) + 2); i++)
      {
        if (1 && (capacidade >= 0))
        {
          grafo[i].arestas.fim = insereFim(grafo[i].arestas.fim, i + nabastecimentos, capacidade, 0, &grafo[i].arestas.inicio);
          grafo[i + nabastecimentos].arestas.fim = insereFim(grafo[i + nabastecimentos].arestas.fim, i, capacidade, capacidade, &grafo[i + nabastecimentos].arestas.inicio);
          grafo[i + nabastecimentos].excesso = 0;
          grafo[i + nabastecimentos].altura = 0;
          grafo[i].excesso = 0;
          grafo[i].altura = 0;
        }
        else
        {
          capacidade = new_sym_var(sizeof(int) * 8);
          
        }

      }

      for (i = 0; i < nligacoes; i++)
      {
        if (3)
        {
          origem = new_sym_var(sizeof(int) * 8);
          destino = new_sym_var(sizeof(int) * 8);
          capacidadelig = new_sym_var(sizeof(int) * 8);
          if (origem > (nfornecedores + 1))
          {
            origem += nabastecimentos;
          }
          else
          {
            
          }

          grafo[origem].arestas.fim = insereFim(grafo[origem].arestas.fim, destino, capacidadelig, 0, &grafo[origem].arestas.inicio);
          grafo[destino].arestas.fim = insereFim(grafo[destino].arestas.fim, origem, capacidadelig, capacidadelig, &grafo[destino].arestas.inicio);
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

    fluxomaximo = relabelToFront();
    printf("%d\n", fluxomaximo);
    estacoesaumenta = (int *) malloc((sizeof(int)) * nabastecimentos);
    arestas = (Fila *) malloc((sizeof(Fila)) * ((nabastecimentos + nfornecedores) + 2));
    for (i = 0; i < ((nabastecimentos + nfornecedores) + 2); i++)
    {
      arestas[i].inicio = 0;
      arestas[i].fim = 0;
    }

    DFS();
    for (i = 0; i < nabastecimentos; i++)
    {
      if ((infila[(nfornecedores + 2) + i] == false) && (estacoesaumenta[i] == 1))
      {
        if (flaglinda == 0)
        {
          flaglinda = 1;
        }
        else
        {
          printf(" ");
        }

        printf("%d", (nfornecedores + 2) + i);
      }
      else
      {
        
      }

    }

    printf("\n");
    for (i = 0; i < ((nabastecimentos + nfornecedores) + 2); i++)
    {
      if ((infila[i] == false) && (arestas[i].inicio != 0))
      {
        for (x = arestas[i].inicio; x != 0; x = x->prox)
        {
          printf("%d %d\n", i, x->vertice);
        }

      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  return 0;
}

