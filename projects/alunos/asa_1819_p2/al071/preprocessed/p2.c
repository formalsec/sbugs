#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct 
{
  int from;
  int to;
  int flow;
  int capacity;
} Edge;
typedef struct 
{
  int *edgeID;
  int capacityArray;
  int size;
} List;
typedef struct 
{
  List *adjList;
  Edge *edges;
  int *arrayLevel;
  int counterVertex;
  int size;
} Graph;
typedef struct NodeQueue
{
  int value;
  struct NodeQueue *pNext;
} NodeQueue;
typedef struct 
{
  NodeQueue *pStart;
  NodeQueue *pEnd;
  int size;
} Queue;
int compare_abst(const void *p, const void *q)
{
  int x = *((const int *) p);
  int y = *((const int *) q);
  if (x < y)
  {
    return -1;
  }
  else
  {
    if (x > y)
    {
      return 1;
    }
    else
    {
      
    }

  }

  return 0;
}

int compare_edges(const void *p, const void *q)
{
  Edge *e1 = (Edge *) p;
  Edge *e2 = (Edge *) q;
  int x1 = e1->to;
  int y1 = e1->from;
  int x2 = e2->to;
  int y2 = e2->from;
  if (x1 < x2)
  {
    return -1;
  }
  else
  {
    if (x1 > x2)
    {
      return 1;
    }
    else
    {
      if (y1 < y2)
      {
        return -1;
      }
      else
      {
        if (y1 > y2)
        {
          return 1;
        }
        else
        {
          
        }

      }

    }

  }

  return 0;
}

void initList(List *pList)
{
  pList->capacityArray = 10;
  pList->edgeID = (int *) malloc(pList->capacityArray * (sizeof(int)));
  pList->size = 0;
}

void addEdgeIdToList(List *pList, int item)
{
  if (pList->size == pList->capacityArray)
  {
    pList->capacityArray *= 2;
    pList->edgeID = (int *) realloc(pList->edgeID, pList->capacityArray * (sizeof(int)));
  }
  else
  {
    
  }

  pList->edgeID[pList->size++] = item;
}

void freeList(List *pList)
{
  free(pList->edgeID);
}

Edge makeEdge(int from, int to, int flow, int capacity)
{
  Edge edge;
  edge.from = from;
  edge.to = to;
  edge.flow = flow;
  edge.capacity = capacity;
  return edge;
}

void addEdge(Graph *graph, int from, int to, int capacity)
{
  Edge forwardEdge = makeEdge(from, to, 0, capacity);
  Edge backEdge = makeEdge(to, from, 0, 0);
  addEdgeIdToList(&graph->adjList[from], graph->counterVertex);
  graph->edges[graph->counterVertex++] = forwardEdge;
  addEdgeIdToList(&graph->adjList[to], graph->counterVertex);
  graph->edges[graph->counterVertex++] = backEdge;
}

void initGraph(Graph *graph, int numVertices, int numArestas)
{
  graph->size = numVertices;
  graph->counterVertex = 0;
  graph->adjList = (List *) malloc(numVertices * (sizeof(List)));
  graph->arrayLevel = (int *) malloc(numVertices * (sizeof(int)));
  graph->edges = (Edge *) malloc((numArestas * 2) * (sizeof(Edge)));
  int i = 0;
  List *adjList;
  while (i < numVertices)
  {
    adjList = &graph->adjList[i];
    initList(adjList);
    i++;
  }

}

void freeGraph(Graph *graph)
{
  free(graph->arrayLevel);
  free(graph->edges);
  int i = 0;
  while (i < graph->size)
  {
    List adjList = graph->adjList[i];
    freeList(&adjList);
    i++;
  }

  free(graph->adjList);
}

void initQueue(Queue *pQueue)
{
  pQueue->pStart = 0;
  pQueue->size = 0;
}

int isQueueEmpty(Queue *pQueue)
{
  return pQueue->size == 0;
}

void enqueue(Queue *pQueue, int item)
{
  NodeQueue *pNodeQueue = (NodeQueue *) malloc(sizeof(NodeQueue));
  if (isQueueEmpty(pQueue))
  {
    pQueue->pStart = pNodeQueue;
  }
  else
  {
    pQueue->pEnd->pNext = pNodeQueue;
  }

  pNodeQueue->value = item;
  pNodeQueue->pNext = 0;
  pQueue->pEnd = pNodeQueue;
  pQueue->size++;
}

NodeQueue *dequeue(Queue *pQueue)
{
  if (isQueueEmpty(pQueue))
  {
    return 0;
  }
  else
  {
    
  }

  NodeQueue *pNodeQueue = pQueue->pStart;
  pQueue->pStart = pNodeQueue->pNext;
  pQueue->size--;
  return pNodeQueue;
}

void freeQueue(Queue *pQueue)
{
  NodeQueue *pNodeQueue = 0;
  while ((pNodeQueue = dequeue(pQueue)) != 0)
  {
    free(pNodeQueue);
  }

}

int moreFlow(Graph *graph, int source, int sink)
{
  int *level = graph->arrayLevel;
  int i;
  for (i = 0; i < graph->size; i++)
  {
    level[i] = -1;
  }

  level[source] = 0;
  Queue queue;
  initQueue(&queue);
  enqueue(&queue, source);
  while (!isQueueEmpty(&queue))
  {
    NodeQueue *pNodeQueue = dequeue(&queue);
    int id = pNodeQueue->value;
    free(pNodeQueue);
    for (i = 0; i < graph->adjList[id].size; i++)
    {
      Edge *edge = &graph->edges[graph->adjList[id].edgeID[i]];
      if ((level[edge->to] < 0) && (edge->flow < edge->capacity))
      {
        level[edge->to] = level[id] + 1;
        enqueue(&queue, edge->to);
      }
      else
      {
        
      }

    }

  }

  freeQueue(&queue);
  return level[sink] != (-1);
}

int sendFlow(Graph *graph, int counterVertex, int currentFlow, int sink, int *visited)
{
  if (counterVertex == sink)
  {
    return currentFlow;
  }
  else
  {
    
  }

  int sizeAdjList = (&graph->adjList[counterVertex])->size;
  int *level = graph->arrayLevel;
  while (visited[counterVertex] < sizeAdjList)
  {
    int v = graph->adjList[counterVertex].edgeID[visited[counterVertex]];
    Edge *edge = &graph->edges[v];
    if ((level[edge->to] == (level[counterVertex] + 1)) && (edge->flow < edge->capacity))
    {
      int minFlow = currentFlow;
      if ((edge->capacity - edge->flow) < minFlow)
      {
        minFlow = edge->capacity - edge->flow;
      }
      else
      {
        
      }

      int tempFlow = sendFlow(graph, edge->to, minFlow, sink, visited);
      if (tempFlow > 0)
      {
        edge->flow += tempFlow;
        graph->edges[v + 1].flow -= tempFlow;
        return tempFlow;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    visited[counterVertex]++;
  }

  return 0;
}

int getMaxFlow(Graph *graph, int source, int sink)
{
  if (source == sink)
  {
    return -1;
  }
  else
  {
    
  }

  int i;
  int flow;
  int maxFlow = 0;
  int visited[graph->size + 1];
  while (moreFlow(graph, source, sink))
  {
    i = 0;
    while (i <= graph->size)
    {
      visited[i] = 0;
      i++;
    }

    while ((flow = sendFlow(graph, source, 2147483647, sink, visited)) != 0)
    {
      maxFlow += flow;
    }

  }

  return maxFlow;
}

void getMinCut(Graph *graph, int forn, int abst, int arestas)
{
  int i;
  int j;
  int cont1 = 0;
  int cont2 = 0;
  int *res1 = (int *) malloc(abst * (sizeof(int)));
  Edge *res2 = (Edge *) malloc(arestas * (sizeof(Edge)));
  int visited[graph->size + 1];
  for (i = 0; i <= graph->size; i++)
  {
    visited[i] = 0;
  }

  visited[1] = 1;
  Queue queue;
  initQueue(&queue);
  enqueue(&queue, 1);
  while (!isQueueEmpty(&queue))
  {
    NodeQueue *pNodeQueue = dequeue(&queue);
    int u = pNodeQueue->value;
    free(pNodeQueue);
    for (i = 0; i < graph->adjList[u].size; i++)
    {
      Edge *edge = &graph->edges[graph->adjList[u].edgeID[i]];
      if ((visited[edge->to] == 0) && (edge->flow < edge->capacity))
      {
        visited[edge->to] = 1;
        enqueue(&queue, edge->to);
      }
      else
      {
        
      }

    }

  }

  freeQueue(&queue);
  for (i = 1; i < graph->size; i++)
  {
    if (visited[i] == 1)
    {
      j = 0;
      for (j = 0; j < graph->adjList[i].size; j++)
      {
        Edge *edge = &graph->edges[graph->adjList[i].edgeID[j]];
        if (((visited[edge->to] == 0) && (edge->to != 0)) && (edge->flow > 0))
        {
          if ((edge->from > ((forn + 1) + abst)) && (edge->to == (edge->from - abst)))
          {
            res1[cont1++] = edge->to;
          }
          else
          {
            if (edge->from > ((forn + abst) + 1))
            {
              edge->from -= abst;
            }
            else
            {
              
            }

            if (edge->to > ((forn + abst) + 1))
            {
              edge->to -= abst;
            }
            else
            {
              
            }

            res2[cont2++] = *edge;
          }

        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  qsort(res1, cont1, sizeof(*res1), &compare_abst);
  qsort(res2, cont2, sizeof(*res2), &compare_edges);
  if (cont1 > 0)
  {
    printf("%d", res1[0]);
    for (i = 1; i < cont1; i++)
    {
      printf(" %d", res1[i]);
    }

  }
  else
  {
    
  }

  printf("\n");
  if (cont2 > 0)
  {
    for (i = 0; i < cont2; i++)
    {
      printf("%d %d\n", res2[i].to, res2[i].from);
    }

  }
  else
  {
    
  }

}

int main(int argc, const char *argv[])
{
  int forn;
  int abst;
  int arestas;
  forn = new_sym_var(sizeof(int) * 8);
  abst = new_sym_var(sizeof(int) * 8);
  arestas = new_sym_var(sizeof(int) * 8);
  Graph grafo;
  initGraph(&grafo, (forn + (2 * abst)) + 2, (arestas + forn) + abst);
  int forn_val;
  int abst_value;
  int i = 0;
  while (i < forn)
  {
    forn_val = new_sym_var(sizeof(int) * 8);
    addEdge(&grafo, i + 2, 0, forn_val);
    i++;
  }

  i = 0;
  while (i < abst)
  {
    abst_value = new_sym_var(sizeof(int) * 8);
    addEdge(&grafo, ((forn + i) + 2) + abst, (forn + i) + 2, abst_value);
    i++;
  }

  int o;
  int d;
  int c;
  i = 0;
  while (i < arestas)
  {
    o = new_sym_var(sizeof(int) * 8);
    d = new_sym_var(sizeof(int) * 8);
    c = new_sym_var(sizeof(int) * 8);
    if (o > (forn + 1))
    {
      o = o + abst;
    }
    else
    {
      
    }

    addEdge(&grafo, d, o, c);
    i++;
  }

  printf("%d\n", getMaxFlow(&grafo, 1, 0));
  getMinCut(&grafo, forn, abst, arestas);
  freeGraph(&grafo);
  return 0;
}

