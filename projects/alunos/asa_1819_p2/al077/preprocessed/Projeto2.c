#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>


typedef struct vector
{
  int *capacity;
  int *destination;
  int elems;
  int size;
} Vector;
typedef struct normalVector
{
  int *data;
  int elems;
  int size;
} NormalVector;
typedef struct edge
{
  int source;
  int destination;
} Edge;
typedef struct edgeVector
{
  Edge *minCut;
  int elems;
  int size;
} EdgeVector;
typedef struct graph
{
  int vertexes;
  Vector *origin;
} Graph;
typedef struct node
{
  int data;
  int priority;
  struct node *next;
} QueueNode;
void graphInit(Graph *g, int v);
void addConnectionToGraph(Graph *g, int o, int d, int c);
void vectorInit(Vector *v);
void vectorPushback(Vector *v, int d, int c);
int queueGetValue(QueueNode **head);
void queuePop(QueueNode **head);
QueueNode *newQueueNode(int d, int p);
void queuePush(QueueNode **head, int d, int p);
bool bfs(Graph *g, int s, int d, int *parents);
int searchConnectionGraph(Graph *g, int u, int v);
int edmondsKarp(Graph *g, int s, int d);
void findExpandingPoints(Graph *g, int supCount, int staCount);
void getMinCut(Graph *g, int s, int d, bool *visited);
void normalVectorInit(NormalVector *v);
void normalVectorPushback(NormalVector *v, int d);
void edgeVectorInit(EdgeVector *v);
void edgeVectorPushback(EdgeVector *v, int s, int d);
void insertionSort(EdgeVector *minCut, int n);
void freeVector(Vector *head);
void freeEdgeVector(EdgeVector *v);
void freeGraph(Graph *g);
void freeNormalVector(NormalVector *v);
int main()
{
  int supplierCount;
  int stationCount;
  int connectionCount;
  int i;
  int origin;
  int destination;
  int c;
  int j;
  int maxFlow;
  int vertexCount;
  Graph *g = (Graph *) malloc(sizeof(Graph));
  Graph *gRes = (Graph *) malloc(sizeof(Graph));
  if (3 < 0)
  {
    perror("erro no scanf\n");
  }
  else
  {
    supplierCount = new_sym_var(sizeof(int) * 8);
    stationCount = new_sym_var(sizeof(int) * 8);
    connectionCount = new_sym_var(sizeof(int) * 8);
    
  }

  vertexCount = (2 + supplierCount) + (2 * stationCount);
  graphInit(g, vertexCount);
  graphInit(gRes, vertexCount);
  for (i = 0; i < supplierCount; i++)
  {
    if (1 < 0)
    {
      perror("erro no scanf\n");
    }
    else
    {
      c = new_sym_var(sizeof(int) * 8);
      
    }

    addConnectionToGraph(g, 0, i + 2, c);
    addConnectionToGraph(gRes, 0, i + 2, c);
    addConnectionToGraph(gRes, i + 2, 0, 0);
  }

  for (i = 0; i < stationCount; i++)
  {
    if (1 < 0)
    {
      perror("erro no scanf\n");
    }
    else
    {
      c = new_sym_var(sizeof(int) * 8);
      
    }

    addConnectionToGraph(g, (i + supplierCount) + 2, ((i + supplierCount) + 2) + stationCount, c);
    addConnectionToGraph(gRes, (i + supplierCount) + 2, ((i + supplierCount) + 2) + stationCount, c);
    addConnectionToGraph(gRes, ((i + supplierCount) + 2) + stationCount, (i + supplierCount) + 2, 0);
  }

  for (i = 0; i < connectionCount; i++)
  {
    if (3 < 0)
    {
      perror("erro no scanf\n");
    }
    else
    {
      origin = new_sym_var(sizeof(int) * 8);
      destination = new_sym_var(sizeof(int) * 8);
      c = new_sym_var(sizeof(int) * 8);
      
    }

    if (origin >= (supplierCount + 2))
    {
      origin += stationCount;
    }
    else
    {
      
    }

    addConnectionToGraph(g, origin, destination, c);
    addConnectionToGraph(gRes, origin, destination, c);
    addConnectionToGraph(gRes, destination, origin, 0);
  }

  maxFlow = edmondsKarp(gRes, 0, 1);
  printf("%d\n", maxFlow);
  bool *visited = (bool *) malloc((sizeof(bool)) * vertexCount);
  Graph *gT = (Graph *) malloc(sizeof(Graph));
  graphInit(gT, vertexCount);
  for (i = 0; i < vertexCount; i++)
  {
    for (j = 0; j < gRes->origin[i].elems; j++)
    {
      addConnectionToGraph(gT, gRes->origin[i].destination[j], i, gRes->origin[i].capacity[j]);
    }

  }

  getMinCut(gT, 1, 0, visited);
  NormalVector expandingStations;
  normalVectorInit(&expandingStations);
  EdgeVector cut;
  edgeVectorInit(&cut);
  for (i = 0; i < vertexCount; i++)
  {
    for (j = 0; j < g->origin[i].elems; j++)
    {
      if (visited[g->origin[i].destination[j]] && (!visited[i]))
      {
        if ((i >= (supplierCount + 2)) && (g->origin[i].destination[j] == (i + stationCount)))
        {
          normalVectorPushback(&expandingStations, i);
        }
        else
        {
          if (i)
          {
            if (i >= (supplierCount + 2))
            {
              edgeVectorPushback(&cut, i - stationCount, g->origin[i].destination[j]);
            }
            else
            {
              edgeVectorPushback(&cut, i, g->origin[i].destination[j]);
            }

          }
          else
          {
            
          }

        }

      }
      else
      {
        
      }

    }

  }

  if (expandingStations.elems > 0)
  {
    for (i = 0; i < (expandingStations.elems - 1); i++)
    {
      printf("%d ", expandingStations.data[i]);
    }

    printf("%d\n", expandingStations.data[i]);
  }
  else
  {
    printf("\n");
  }

  insertionSort(&cut, cut.elems);
  for (i = 0; i < cut.elems; i++)
  {
    printf("%d %d\n", cut.minCut[i].source, cut.minCut[i].destination);
  }

  free(visited);
  freeGraph(g);
  freeGraph(gRes);
  freeGraph(gT);
  freeEdgeVector(&cut);
  freeNormalVector(&expandingStations);
  return 0;
}

void insertionSort(EdgeVector *minCut, int n)
{
  int i;
  int j;
  Edge key;
  for (i = 1; i < n; i++)
  {
    key = minCut->minCut[i];
    j = i - 1;
    while (((j >= 0) && (minCut->minCut[j].destination > key.destination)) && (minCut->minCut[j].source == key.source))
    {
      minCut->minCut[j + 1] = minCut->minCut[j];
      j--;
    }

    minCut->minCut[j + 1] = key;
  }

}

int edmondsKarp(Graph *g, int s, int d)
{
  int *parents = (int *) malloc((sizeof(int)) * g->vertexes);
  int u;
  int v;
  int i;
  int maxFlow = 0;
  while (bfs(g, s, d, parents))
  {
    int pFlow = 0x7fffffff;
    for (v = d; v != s; v = parents[v])
    {
      u = parents[v];
      i = searchConnectionGraph(g, u, v);
      pFlow = (pFlow < g->origin[u].capacity[i]) ? (pFlow) : (g->origin[u].capacity[i]);
    }

    for (v = d; v != s; v = parents[v])
    {
      u = parents[v];
      i = searchConnectionGraph(g, u, v);
      g->origin[u].capacity[i] -= pFlow;
      i = searchConnectionGraph(g, v, u);
      g->origin[v].capacity[i] += pFlow;
    }

    maxFlow += pFlow;
  }

  free(parents);
  return maxFlow;
}

bool bfs(Graph *g, int s, int d, int *parents)
{
  int p = 0;
  int i;
  QueueNode *head = newQueueNode(s, p);
  parents[s] = -1;
  ;
  bool result;
  bool *visited = (bool *) malloc((sizeof(bool)) * g->vertexes);
  memset(visited, 0, (sizeof(bool)) * g->vertexes);
  visited[s] = true;
  while (head != 0)
  {
    int var = queueGetValue(&head);
    queuePop(&head);
    p++;
    for (i = 0; i < g->origin[var].elems; i++)
    {
      if ((!visited[g->origin[var].destination[i]]) && (g->origin[var].capacity[i] > 0))
      {
        queuePush(&head, g->origin[var].destination[i], p);
        parents[g->origin[var].destination[i]] = var;
        visited[g->origin[var].destination[i]] = true;
      }
      else
      {
        
      }

    }

  }

  result = visited[d];
  free(visited);
  return result == true;
}

void getMinCut(Graph *g, int s, int d, bool *visited)
{
  int p = 0;
  int i;
  QueueNode *head = newQueueNode(s, p);
  memset(visited, 0, (sizeof(bool)) * g->vertexes);
  visited[s] = true;
  while (head != 0)
  {
    int var = queueGetValue(&head);
    queuePop(&head);
    p++;
    for (i = 0; i < g->origin[var].elems; i++)
    {
      if ((!visited[g->origin[var].destination[i]]) && (g->origin[var].capacity[i] > 0))
      {
        queuePush(&head, g->origin[var].destination[i], p);
        visited[g->origin[var].destination[i]] = true;
      }
      else
      {
        
      }

    }

  }

}

int searchConnectionGraph(Graph *g, int u, int v)
{
  int i;
  for (i = 0; i < g->origin[u].elems; i++)
  {
    if (g->origin[u].destination[i] == v)
    {
      return i;
    }
    else
    {
      
    }

  }

  return 0;
}

void graphInit(Graph *g, int v)
{
  g->vertexes = v;
  g->origin = (Vector *) malloc((sizeof(Vector)) * v);
  int i;
  for (i = 0; i < v; i++)
  {
    vectorInit(&g->origin[i]);
  }

}

void addConnectionToGraph(Graph *g, int o, int d, int c)
{
  vectorPushback(&g->origin[o], d, c);
}

void edgeVectorInit(EdgeVector *v)
{
  v->elems = 0;
  v->size = 20;
  v->minCut = (Edge *) malloc((sizeof(Edge)) * 20);
}

void edgeVectorPushback(EdgeVector *v, int s, int d)
{
  if (v->elems == v->size)
  {
    v->size *= 2;
    v->minCut = realloc(v->minCut, (sizeof(Edge)) * v->size);
  }
  else
  {
    
  }

  Edge newEdge;
  newEdge.source = s;
  newEdge.destination = d;
  v->minCut[v->elems++] = newEdge;
}

void normalVectorInit(NormalVector *v)
{
  v->elems = 0;
  v->size = 20;
  v->data = (int *) malloc((sizeof(int)) * 20);
}

void normalVectorPushback(NormalVector *v, int d)
{
  if (v->elems == v->size)
  {
    v->size *= 2;
    v->data = realloc(v->data, (sizeof(int)) * v->size);
  }
  else
  {
    
  }

  v->data[v->elems++] = d;
}

void vectorInit(Vector *v)
{
  v->elems = 0;
  v->size = 20;
  v->capacity = (int *) malloc((sizeof(int)) * 20);
  v->destination = (int *) malloc((sizeof(int)) * 20);
}

void vectorPushback(Vector *v, int d, int c)
{
  if (v->elems == v->size)
  {
    v->size *= 2;
    v->capacity = realloc(v->capacity, (sizeof(int)) * v->size);
    v->destination = realloc(v->destination, (sizeof(int)) * v->size);
  }
  else
  {
    
  }

  v->destination[v->elems] = d;
  v->capacity[v->elems++] = c;
}

QueueNode *newQueueNode(int d, int p)
{
  QueueNode *n = (QueueNode *) malloc(sizeof(QueueNode));
  n->data = d;
  n->priority = p;
  n->next = 0;
  return n;
}

void queuePop(QueueNode **head)
{
  QueueNode *n = *head;
  *head = (*head)->next;
  free(n);
}

int queueGetValue(QueueNode **head)
{
  return (*head)->data;
}

void queuePush(QueueNode **head, int d, int p)
{
  QueueNode *n = newQueueNode(d, p);
  QueueNode *i = *head;
  if ((*head) == 0)
  {
    *head = n;
  }
  else
  {
    if ((*head)->priority > p)
    {
      n->next = *head;
      *head = n;
    }
    else
    {
      while ((i->next != 0) && (i->priority < p))
      {
        i = i->next;
      }

      n->next = i->next;
      i->next = n;
    }

  }

}

void freeVector(Vector *v)
{
  free(v->capacity);
  free(v->destination);
}

void freeGraph(Graph *g)
{
  int i;
  for (i = 0; i < g->vertexes; i++)
    freeVector(&g->origin[i]);

  free(g->origin);
  free(g);
}

void freeEdgeVector(EdgeVector *v)
{
  free(v->minCut);
}

void freeNormalVector(NormalVector *v)
{
  free(v->data);
}

