/*File generated by PreProcessor.py*/


#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>


typedef struct vertex *Vertex;
typedef struct node
{
  int u;
  struct node *next;
} *Node;
typedef struct queue
{
  Node head;
  Node tail;
} *Queue;
typedef struct edge
{
  int u;
  int v;
  int capacity_forward;
  int flow_forward;
  int flow_back;
  struct edge *next_in;
  struct edge *next_out;
} *Edge;
typedef struct vertex
{
  Edge in;
  Edge out;
} *Vertex;
typedef struct graph
{
  Vertex V;
  int f;
  int e;
  int t;
} *Graph;
int isStation(Graph g, int u)
{
  return (u >= (g->f + 2)) && (u < (((g->f + (2 * g->e)) + 2) - g->e));
}

void displayOutput(Graph g, char *discovery, int flow)
{
  int u;
  int v;
  int print = 0;
  char *upgrade = calloc(g->e, sizeof(char));
  Edge adj;
  printf("%d\n", flow);
  for (u = g->f + 2; u < (((g->f + (2 * g->e)) + 2) - g->e); u++)
  {
    v = u + g->e;
    if ((!discovery[u]) && discovery[v])
    {
      if (print)
      {
        printf(" %d", (v >= (((g->f + (2 * g->e)) + 2) - g->e)) ? (v - g->e) : (v));
      }
      else
      {
        printf("%d", (v >= (((g->f + (2 * g->e)) + 2) - g->e)) ? (v - g->e) : (v));
        print = 1;
      }

      upgrade[(u - g->f) - 2] = 1;
    }
    else
    {
      
    }

  }

  printf("\n");
  for (u = 2; u < ((g->f + (2 * g->e)) + 2); u++)
  {
    for (adj = g->V[u].out; adj != 0; adj = adj->next_out)
    {
      v = adj->v;
      if ((!u) || (!v))
      {
        continue;
      }
      else
      {
        if (isStation(g, u) && upgrade[(u - g->f) - 2])
        {
          continue;
        }
        else
        {
          if (isStation(g, v) && upgrade[(v - g->f) - 2])
          {
            continue;
          }
          else
          {
            
          }

        }

      }

      if ((!discovery[u]) && discovery[v])
      {
        printf("%d %d\n", (u >= (((g->f + (2 * g->e)) + 2) - g->e)) ? (u - g->e) : (u), (v >= (((g->f + (2 * g->e)) + 2) - g->e)) ? (v - g->e) : (v));
      }
      else
      {
        
      }

    }

  }

  free(upgrade);
}

void pushNode(Queue queue, int u)
{
  Node node = (Node) malloc(sizeof(struct node));
  node->u = u;
  node->next = 0;
  if (!queue->head)
  {
    queue->head = (queue->tail = node);
  }
  else
  {
    queue->tail->next = node;
    queue->tail = node;
  }

}

int selectVertex(Queue overflown)
{
  int u;
  Node aux = overflown->head;
  if (!aux)
  {
    return 0;
  }
  else
  {
    
  }

  u = aux->u;
  overflown->head = overflown->head->next;
  free(aux);
  return u;
}

void DFS(Graph g, char *discovery, int u)
{
  int v;
  Edge adj;
  discovery[u] = 1;
  for (adj = g->V[u].in; adj != 0; adj = adj->next_in)
  {
    v = adj->u;
    if ((adj->capacity_forward - adj->flow_forward) && (!discovery[v]))
    {
      DFS(g, discovery, v);
    }
    else
    {
      
    }

  }

  for (adj = g->V[u].out; adj != 0; adj = adj->next_out)
  {
    v = adj->v;
    if ((-adj->flow_back) && (!discovery[v]))
    {
      DFS(g, discovery, v);
    }
    else
    {
      
    }

  }

}

void insertIn(Graph g, Edge head, Edge new)
{
  Edge iter;
  if ((!head) || (head->v >= new->u))
  {
    new->next_in = g->V[new->v].in;
    g->V[new->v].in = new;
    return;
  }
  else
  {
    
  }

  iter = g->V[new->v].in;
  while (iter->next_in && (iter->next_in->v < new->u))
    iter = iter->next_in;

  new->next_in = iter->next_in;
  iter->next_in = new;
}

void insertOut(Graph g, Edge head, Edge new)
{
  Edge iter;
  if ((!head) || (head->v >= new->v))
  {
    new->next_out = g->V[new->u].out;
    g->V[new->u].out = new;
    return;
  }
  else
  {
    
  }

  iter = g->V[new->u].out;
  while (iter->next_out && (iter->next_out->v < new->v))
    iter = iter->next_out;

  new->next_out = iter->next_out;
  iter->next_out = new;
}

void link(Graph g, int a, int b, int capacity)
{
  Edge new = (Edge) malloc(sizeof(struct edge));
  new->u = a;
  new->v = b;
  new->flow_forward = (new->flow_back = 0);
  new->capacity_forward = capacity;
  new->next_in = (new->next_out = 0);
  insertOut(g, g->V[a].out, new);
  insertIn(g, g->V[b].in, new);
}

void parseInput(Graph g)
{
  int a;
  int b;
  int i;
  int capacity;
  g->f = new_sym_var(sizeof(int) * 8);
  g->e = new_sym_var(sizeof(int) * 8);
  g->t = new_sym_var(sizeof(int) * 8);
  g->V = (Vertex) malloc((sizeof(struct vertex)) * ((g->f + (2 * g->e)) + 2));
  for (i = 0; i < ((g->f + (2 * g->e)) + 2); i++)
  {
    g->V[i].in = 0;
    g->V[i].out = 0;
  }

  for (i = 2; i <= (g->f + 1); i++)
  {
    capacity = new_sym_var(sizeof(int) * 8);
    link(g, 0, i, capacity);
  }

  for (i = g->f + 2; i < (((g->f + (2 * g->e)) + 2) - g->e); i++)
  {
    capacity = new_sym_var(sizeof(int) * 8);
    link(g, i, i + g->e, capacity);
  }

  for (i = 0; i < g->t; i++)
  {
    a = new_sym_var(sizeof(int) * 8);
    b = new_sym_var(sizeof(int) * 8);
    capacity = new_sym_var(sizeof(int) * 8);
    if (((g->f + 1) < a) && (b == 1))
    {
      link(g, a + g->e, 1, capacity);
    }
    else
    {
      if ((g->f + 1) < a)
      {
        link(g, a + g->e, b, capacity);
      }
      else
      {
        link(g, a, b, capacity);
      }

    }

  }

}

void freeGraph(Graph g)
{
  int i;
  Edge aux;
  for (i = 0; i < ((g->f + (2 * g->e)) + 2); i++)
    while (g->V[i].out)
  {
    aux = g->V[i].out;
    g->V[i].out = g->V[i].out->next_out;
    free(aux);
  }


  free(g->V);
  free(g);
}

int push(Graph g, Edge edge, int u, int v, int *e, Queue overflown, char back)
{
  int df;
  if (!back)
  {
    df = (e[u] < (edge->capacity_forward - edge->flow_forward)) ? (e[u]) : (edge->capacity_forward - edge->flow_forward);
    edge->flow_forward += df;
    edge->flow_back -= df;
    e[u] -= df;
    e[v] += df;
  }
  else
  {
    df = (e[u] < (-edge->flow_back)) ? (e[u]) : (-edge->flow_back);
    edge->flow_forward -= df;
    edge->flow_back += df;
    e[u] -= df;
    e[v] += df;
  }

  if (v && (v != 1))
  {
    pushNode(overflown, edge->v);
  }
  else
  {
    
  }

  return 1;
}

void relabel(Graph g, int u, int *h)
{
  int min = 32767;
  Edge adj;
  for (adj = g->V[u].out; adj != 0; adj = adj->next_out)
  {
    if (!(adj->capacity_forward - adj->flow_forward))
    {
      continue;
    }
    else
    {
      
    }

    min = (min < h[adj->v]) ? (min) : (h[adj->v]);
  }

  for (adj = g->V[u].in; adj != 0; adj = adj->next_in)
  {
    if (!(-adj->flow_back))
    {
      continue;
    }
    else
    {
      
    }

    min = (min < h[adj->u]) ? (min) : (h[adj->u]);
  }

  h[u] = 1 + min;
}

void discharge(Graph g, int u, int *h, int *e, Queue overflown)
{
  char pushed;
  Edge adj;
  while (e[u])
  {
    pushed = 0;
    for (adj = g->V[u].out; adj != 0; adj = adj->next_out)
      if ((adj->capacity_forward - adj->flow_forward) && (h[u] == (h[adj->v] + 1)))
    {
      pushed = push(g, adj, adj->u, adj->v, e, overflown, 0);
    }
    else
    {
      
    }


    for (adj = g->V[u].in; adj != 0; adj = adj->next_in)
    {
      if ((-adj->flow_back) && (h[u] == (h[adj->u] + 1)))
      {
        pushed = push(g, adj, adj->v, adj->u, e, overflown, 1);
      }
      else
      {
        
      }

    }

    if (!pushed)
    {
      relabel(g, u, h);
    }
    else
    {
      
    }

  }

}

void initializePreflow(Graph g, int *h, int *e, Queue overflown)
{
  int v;
  Edge adj;
  h[0] = (g->f + (2 * g->e)) + 2;
  for (adj = g->V[0].out; adj != 0; adj = adj->next_out)
  {
    v = adj->v;
    adj->flow_forward = adj->capacity_forward;
    adj->flow_back = -adj->capacity_forward;
    e[v] += adj->flow_forward;
    pushNode(overflown, v);
  }

}

int pushRelabel(Graph g)
{
  int u;
  int *h = (int *) calloc((g->f + (2 * g->e)) + 2, sizeof(int));
  int *e = (int *) calloc((g->f + (2 * g->e)) + 2, sizeof(int));
  Queue overflown = (Queue) malloc(sizeof(struct queue));
  overflown->head = (overflown->tail = 0);
  initializePreflow(g, h, e, overflown);
  while (u = selectVertex(overflown))
    discharge(g, u, h, e, overflown);

  u = e[1];
  free(h);
  free(e);
  free(overflown);
  return u;
}

int main(void)
{
  int flow;
  char *discovery;
  Graph g = (Graph) malloc(sizeof(struct graph));
  parseInput(g);
  flow = pushRelabel(g);
  discovery = (char *) calloc((g->f + (2 * g->e)) + 2, sizeof(char));
  DFS(g, discovery, 1);
  displayOutput(g, discovery, flow);
  free(discovery);
  freeGraph(g);
  return 0;
}

