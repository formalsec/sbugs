/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>


typedef struct link
{
  int node;
  int cap;
  struct link *next;
} Link;
typedef Link *LINK;
static int f;
static int e;
static int t;
static int n;
static int *abast;
static int *parent;
static Link **graph;
static Link **rGraph;
static char *visited;
static void add(LINK *n, int x, int y, int cap)
{
  register Link *l = malloc(sizeof(Link));
  l->cap = cap;
  l->node = y;
  l->next = n[x];
  n[x] = l;
}

static int get(LINK *n, int x, int y)
{
  register Link *l;
  for (l = n[x]; l; l = l->next)
    if (l->node == y)
  {
    return l->cap;
  }
  else
  {
    
  }


  return 0;
}

static void set(LINK *n, int x, int y, int cap)
{
  register Link *l;
  for (l = n[x]; l; l = l->next)
    if (l->node == y)
  {
    l->cap += cap;
    return;
  }
  else
  {
    
  }


  add(n, x, y, cap);
}

static void input()
{
  register int i;
  int orig;
  int dest;
  int cap;
  f = new_sym_var(sizeof(int) * 8);
  e = new_sym_var(sizeof(int) * 8);
  t = new_sym_var(sizeof(int) * 8);
  n = (2 + f) + e;
  abast = malloc((sizeof(int)) * (n + e));
  memset(abast, 0, (sizeof(int)) * (n + e));
  for (i = 0; i < (n + e); i++)
    abast[i] = i;

  parent = malloc((sizeof(int)) * (n + e));
  memset(parent, 0, (sizeof(int)) * (n + e));
  visited = malloc((sizeof(int)) * (n + e));
  memset(visited, 0, (sizeof(int)) * (n + e));
  graph = malloc((sizeof(Link *)) * (n + e));
  memset(graph, 0, (sizeof(Link *)) * (n + e));
  rGraph = malloc((sizeof(Link *)) * (n + e));
  memset(rGraph, 0, (sizeof(Link *)) * (n + e));
  for (i = 0; i < f; i++)
  {
    cap = new_sym_var(sizeof(int) * 8);
    add(graph, 0, i + 2, cap);
    add(rGraph, 0, i + 2, cap);
  }

  while (i < (f + e))
  {
    cap = new_sym_var(sizeof(int) * 8);
    i++;
    add(graph, i + 1, n, cap);
    add(rGraph, i + 1, n, cap);
    abast[i + 1] = n;
    n++;
  }

  for (i = 0; i < t; i++)
  {
    orig = new_sym_var(sizeof(int) * 8);
    dest = new_sym_var(sizeof(int) * 8);
    cap = new_sym_var(sizeof(int) * 8);
    add(graph, abast[orig], dest, cap);
    add(rGraph, abast[orig], dest, cap);
  }

}

static void clean(LINK *v, int n)
{
  register int i;
  register Link *l;
  register Link *next;
  for (i = 0; i < n; i++)
  {
    for (l = v[i]; l; l = next)
    {
      next = l->next;
      free(l);
    }

  }

  free(v);
}

static int *q;
static int bfs(LINK *rGraph, int n, int s, int t, int *parent, int flow)
{
  int ret;
  int qn = 0;
  memset(visited, 0, n);
  visited[s] = 1;
  if (!q)
  {
    q = malloc((sizeof(int)) * n);
  }
  else
  {
    
  }

  q[0] = 0;
  q[qn++] = s;
  parent[s] = -1;
  while (qn)
  {
    int u = q[--qn];
    register Link *l;
    for (l = rGraph[u]; l; l = l->next)
      if ((visited[l->node] == 0) && (l->cap > 0))
    {
      if (l->cap < flow)
      {
        flow = l->cap;
      }
      else
      {
        
      }

      q[qn++] = l->node;
      parent[l->node] = u;
      visited[l->node] = 1;
    }
    else
    {
      
    }


  }

  ret = visited[t] == 1;
  return (ret) ? (flow) : (0);
}

static void dfs(LINK *rGraph, int n, int s, char *visited)
{
  register int i;
  register Link *l;
  visited[s] = 1;
  for (i = 0; i < n; i++)
    for (l = rGraph[i]; l; l = l->next)
    if (((l->node == s) && l->cap) && (!visited[i]))
  {
    dfs(rGraph, n, i, visited);
  }
  else
  {
    
  }



}

static int cmpab(const void *a, const void *b)
{
  return (*((int *) a)) - (*((int *) b));
}

static int cmpno(const void *a, const void *b)
{
  register int **x = (int **) a;
  register int **y = (int **) b;
  if (x[0][0] != y[0][0])
  {
    return x[0][0] - y[0][0];
  }
  else
  {
    
  }

  return x[0][1] - y[0][1];
}

static void minCut(LINK *graph, int n, int s, int d, int *abast)
{
  register Link *l;
  register int u;
  register int v;
  int path_flow;
  int max_flow = 0;
  int *ab = malloc((sizeof(int)) * e);
  int abn = 0;
  int **no = malloc((sizeof(int *)) * t);
  int non = 0;
  while (path_flow = bfs(rGraph, n, s, d, parent, 32767))
  {
    int path_flow = 32767;
    for (v = d; v != s; v = parent[v])
    {
      int cap;
      u = parent[v];
      cap = get(rGraph, u, v);
      path_flow = (path_flow > cap) ? (cap) : (path_flow);
    }

    for (v = d; v != s; v = parent[v])
    {
      u = parent[v];
      set(rGraph, u, v, -path_flow);
      set(rGraph, v, u, path_flow);
    }

    max_flow += path_flow;
  }

  memset(visited, 0, (sizeof(int)) * n);
  dfs(rGraph, n, d, visited);
  for (v = 0; v < n; v++)
    for (l = graph[v]; l; l = l->next)
  {
    u = l->node;
    if ((visited[u] && (!visited[v])) && l->cap)
    {
      int i;
      int x = u;
      int y = v;
      if (x > (f + e))
      {
        for (i = f; i < x; i++)
          if (abast[i] == x)
        {
          x = i;
          break;
        }
        else
        {
          
        }


      }
      else
      {
        
      }

      if (y > (f + e))
      {
        for (i = f; i < y; i++)
          if (abast[i] == y)
        {
          y = i;
          break;
        }
        else
        {
          
        }


      }
      else
      {
        
      }

      if (y == 0)
      {
        ;
      }
      else
      {
        if (x == y)
        {
          ab[abn++] = x;
        }
        else
        {
          no[non] = malloc(2 * (sizeof(int)));
          no[non][0] = y;
          no[non++][1] = x;
        }

      }

    }
    else
    {
      
    }

  }


  qsort(ab, abn, sizeof(int), cmpab);
  qsort(no, non, sizeof(int *), cmpno);
  printf("%d\n", max_flow);
  for (u = 0; u < abn; u++)
    printf("%s%d", (u) ? (" ") : (""), ab[u]);

  printf("\n");
  for (u = 0; u < non; u++)
    printf("%d %d\n", no[u][0], no[u][1]);

  free(ab);
  for (u = 0; u < non; u++)
    free(no[u]);

  free(no);
}

int main()
{
  input();
  minCut(graph, n, 0, 1, abast);
  free(abast);
  free(parent);
  free(visited);
  clean(graph, n);
  clean(rGraph, n);
  free(q);
  return 0;
}

