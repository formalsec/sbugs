#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h> 


typedef struct Vertex
{
  struct Edge *adj;
  int h;
  int e;
  int id;
  int isMinCut;
  int isVisited;
  struct Node *qNode;
  int inQ;
} Vertex;
typedef struct Edge
{
  Vertex *u;
  Vertex *v;
  int flow;
  int cap;
  struct Edge *next;
  struct Edge *vu;
  int isMinCut;
} Edge;
typedef struct Node
{
  Vertex *v;
  struct Node *next;
} Node;
Vertex *graph;
int nr_vertex;
int change;
int nr_fornecedores;
int minimo(int a, int b)
{
  if (a > b)
  {
    return b;
  }
  else
  {
    
  }

  return a;
}

Node *createNode(Vertex *v)
{
  Node *node = malloc(sizeof(Node));
  node->v = v;
  node->next = 0;
  return node;
}

Node *addToFifo(Node *last, Node *node)
{
  node->v->inQ = 1;
  last->next = node;
  node->next = 0;
  return node;
}

Node *rmvFromFifo(Node *head)
{
  head->v->inQ = 0;
  Node *temp = head->next;
  head->next = 0;
  return temp;
}

void addEdge(int u, int v, int cap)
{
  Edge *edge = malloc(sizeof(Edge));
  Edge *inverse = malloc(sizeof(Edge));
  edge->u = &graph[u];
  edge->v = &graph[v];
  inverse->u = &graph[v];
  inverse->v = &graph[u];
  edge->vu = inverse;
  inverse->vu = edge;
  if (u == 0)
  {
    edge->flow = cap;
    inverse->flow = -cap;
    graph[v].e = cap;
    graph[0].e -= cap;
  }
  else
  {
    edge->flow = 0;
    inverse->flow = 0;
  }

  edge->cap = cap;
  inverse->cap = 0;
  edge->isMinCut = 0;
  inverse->isMinCut = 0;
  edge->next = graph[u].adj;
  inverse->next = graph[v].adj;
  graph[u].adj = edge;
  graph[v].adj = inverse;
}

void push(Edge *uv)
{
  int f = minimo(uv->u->e, uv->cap - uv->flow);
  uv->flow += f;
  uv->vu->flow -= f;
  uv->u->e -= f;
  uv->v->e += f;
}

void relabel(Vertex *v)
{
  Edge *uv = v->adj;
  int min = -1;
  while (uv != 0)
  {
    if (uv->cap > uv->flow)
    {
      if (min == (-1))
      {
        min = uv->v->h;
      }
      else
      {
        min = minimo(min, uv->v->h);
      }

    }
    else
    {
      
    }

    uv = uv->next;
  }

  if (min != (-1))
  {
    v->h = min + 1;
  }
  else
  {
    
  }

}

Node *discharge(Vertex *v, Node *last)
{
  Edge *current = v->adj;
  while (v->e > 0)
  {
    if (current == 0)
    {
      relabel(v);
      current = v->adj;
    }
    else
    {
      if ((current->cap > current->flow) && (v->h == (current->v->h + 1)))
      {
        push(current);
        if ((current->v->inQ == 0) && (current->v->id > 1))
        {
          last = addToFifo(last, current->v->qNode);
        }
        else
        {
          
        }

      }
      else
      {
        current = current->next;
      }

    }

  }

  return last;
}

void relabelToFront()
{
  int i;
  Node *queue = graph[2].qNode;
  Node *last = queue;
  for (i = 2; i < (nr_fornecedores + 2); i++)
  {
    last = addToFifo(last, graph[i].qNode);
  }

  while (queue != 0)
  {
    last = discharge(queue->v, last);
    queue = rmvFromFifo(queue);
  }

}

void DFS(Vertex *v)
{
  v->isVisited = 1;
  Edge *e = v->adj;
  while (e != 0)
  {
    if ((!e->v->isVisited) && (e->vu->cap > e->vu->flow))
    {
      DFS(e->v);
    }
    else
    {
      
    }

    e = e->next;
  }

}

void findMinCut()
{
  DFS(&graph[1]);
  int i;
  for (i = 0; i < nr_vertex; i++)
  {
    Edge *e = graph[i].adj;
    while (e != 0)
    {
      if ((graph[i].isVisited != e->v->isVisited) && (e->flow == e->cap))
      {
        if ((e->v->id == 1) || (i == 1))
        {
          e->isMinCut = 1;
        }
        else
        {
          if (abs((e->v->id - i) == change))
          {
            graph[minimo(e->v->id, i)].isMinCut = 1;
          }
          else
          {
            e->isMinCut = 1;
          }

        }

      }
      else
      {
        
      }

      e = e->next;
    }

  }

}

int main()
{
  int i;
  int j;
  int capacity;
  int origem;
  int destino;
  int nr_abastecimento;
  int nr_ligacoes;
  nr_fornecedores = new_sym_var(sizeof(int) * 8);
  nr_abastecimento = new_sym_var(sizeof(int) * 8);
  nr_ligacoes = new_sym_var(sizeof(int) * 8);
  nr_vertex = ((nr_fornecedores + nr_abastecimento) + 1) * 2;
  change = nr_fornecedores + nr_abastecimento;
  graph = malloc(nr_vertex * (sizeof(Vertex)));
  for (i = 0; i < nr_vertex; i++)
  {
    graph[i].adj = 0;
    graph[i].id = i;
    graph[i].h = 0;
    graph[i].e = 0;
    graph[i].isMinCut = 0;
    graph[i].isVisited = 0;
    graph[i].qNode = createNode(&graph[i]);
    graph[i].inQ = 0;
  }

  graph[0].h = nr_vertex;
  for (i = 0; i < nr_fornecedores; i++)
  {
    capacity = new_sym_var(sizeof(int) * 8);
    addEdge(i + 2, (i + 2) + change, capacity);
    addEdge(0, i + 2, capacity + 1);
  }

  for (i = 0; i < nr_abastecimento; i++)
  {
    capacity = new_sym_var(sizeof(int) * 8);
    addEdge((i + 2) + nr_fornecedores, ((i + 2) + nr_fornecedores) + change, capacity);
  }

  for (i = 0; i < nr_ligacoes; i++)
  {
    origem = new_sym_var(sizeof(int) * 8);
    destino = new_sym_var(sizeof(int) * 8);
    capacity = new_sym_var(sizeof(int) * 8);
    addEdge(origem + change, destino, capacity);
  }

  relabelToFront();
  findMinCut();
  int isFirst = 1;
  printf("%d\n", graph[1].e);
  for (i = 2 + nr_fornecedores; i < ((2 + nr_fornecedores) + nr_abastecimento); i++)
  {
    if (graph[i].isMinCut == 1)
    {
      if (!isFirst)
      {
        printf(" ");
      }
      else
      {
        
      }

      isFirst = 0;
      printf("%d", i);
    }
    else
    {
      
    }

  }

  printf("\n");
  int *minCut = malloc(nr_vertex * (sizeof(int)));
  for (i = 1; i < nr_vertex; i++)
  {
    Edge *e = graph[i].adj;
    while (e != 0)
    {
      if ((e->cap > 0) && (e->isMinCut == 1))
      {
        minCut[e->v->id] = 1;
      }
      else
      {
        
      }

      e = e->next;
    }

    for (j = 0; j < nr_vertex; j++)
    {
      if (minCut[j] == 1)
      {
        printf("%d %d\n", i - change, j);
      }
      else
      {
        
      }

      minCut[j] = 0;
    }

  }

  return 0;
}

