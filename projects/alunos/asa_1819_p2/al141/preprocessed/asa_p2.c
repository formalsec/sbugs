#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>


typedef struct Link
{
  int data;
  struct Link *next;
} *Link_t;
typedef struct Queue
{
  Link_t head;
  Link_t tail;
} *Queue_t;
typedef struct Edge
{
  int from_node;
  int to_node;
  long capacity;
  long flow;
  struct Edge *reverse;
} *Edge_t;
typedef struct Vector
{
  int size;
  int capacity;
  Edge_t *elements;
} *Vector_t;
typedef struct Graph
{
  Vector_t *adj_list;
  int num_nodes;
  long max_flow;
  Vector_t mincut_e;
  Vector_t mincut_f;
} *Graph_t;
Queue_t queue_alloc()
{
  Queue_t q = (Queue_t) malloc(sizeof(struct Queue));
  q->head = 0;
  q->tail = 0;
  return q;
}

bool queue_isEmpty(Queue_t queue)
{
  return queue->head == 0;
}

Link_t new_node(int data, Link_t next)
{
  Link_t x = (Link_t) malloc(sizeof(struct Link));
  x->data = data;
  x->next = next;
  return x;
}

void queue_push(Queue_t queue, int data)
{
  if (queue->head == 0)
  {
    queue->head = (queue->tail = new_node(data, queue->head));
    return;
  }
  else
  {
    
  }

  queue->tail->next = new_node(data, queue->tail->next);
  queue->tail = queue->tail->next;
}

int queue_pop(Queue_t queue)
{
  int data = queue->head->data;
  Link_t x = queue->head->next;
  free(queue->head);
  queue->head = x;
  return data;
}

Edge_t newEdge(int from_node, int to_node, long capacity)
{
  Edge_t e = (Edge_t) malloc(sizeof(struct Edge));
  e->from_node = from_node;
  e->to_node = to_node;
  e->capacity = capacity;
  e->flow = 0;
  return e;
}

long excessCapacity(Edge_t edge)
{
  return edge->capacity - edge->flow;
}

void augmentEdge(Edge_t edge, long bottle_neck)
{
  edge->flow += bottle_neck;
  edge->reverse->flow -= bottle_neck;
}

int qsort_compare(const void *a, const void *b)
{
  Edge_t x = *((Edge_t *) a);
  Edge_t y = *((Edge_t *) b);
  if (x->from_node != y->from_node)
  {
    return x->from_node - y->from_node;
  }
  else
  {
    
  }

  return x->to_node - y->to_node;
}

Vector_t vector_alloc(int init_capacity)
{
  Vector_t v = (Vector_t) malloc(sizeof(struct Vector));
  int capacity = (init_capacity > 1) ? (init_capacity) : (1);
  ;
  v->size = 0;
  v->capacity = capacity;
  v->elements = (Edge_t *) malloc(capacity * (sizeof(Edge_t)));
  return v;
}

Edge_t vector_get(Vector_t vector, int index)
{
  if ((index < 0) || (index >= vector->size))
  {
    return 0;
  }
  else
  {
    
  }

  return vector->elements[index];
}

void vector_pushBack(Vector_t vector, Edge_t data)
{
  if (vector->size == vector->capacity)
  {
    int i;
    int new_capacity = vector->capacity * 2;
    Edge_t *new_elements = (Edge_t *) malloc(new_capacity * (sizeof(Edge_t)));
    vector->capacity = new_capacity;
    for (i = 0; i < vector->size; i++)
    {
      new_elements[i] = vector->elements[i];
    }

    free(vector->elements);
    vector->elements = new_elements;
  }
  else
  {
    
  }

  vector->elements[vector->size++] = data;
}

void vector_free(Vector_t vector)
{
  free(vector->elements);
  free(vector);
}

Graph_t graph_alloc(int num_nodes)
{
  int i;
  Graph_t g = (Graph_t) malloc(sizeof(struct Graph));
  g->num_nodes = num_nodes;
  g->max_flow = 0;
  g->adj_list = (Vector_t *) malloc(num_nodes * (sizeof(Vector_t)));
  g->mincut_e = vector_alloc(10);
  g->mincut_f = vector_alloc(10);
  for (i = 0; i < num_nodes; i++)
  {
    g->adj_list[i] = vector_alloc(5);
  }

  return g;
}

void insertEdge(Graph_t graph, int from_node, int to_node, long capacity)
{
  Edge_t e = newEdge(from_node, to_node, capacity);
  Edge_t r = newEdge(to_node, from_node, 0);
  e->reverse = r;
  r->reverse = e;
  vector_pushBack(graph->adj_list[from_node], e);
  vector_pushBack(graph->adj_list[to_node], r);
}

void graph_free(Graph_t graph)
{
  int i;
  int j;
  int size;
  int num_nodes = graph->num_nodes;
  for (i = 0; i < num_nodes; i++)
  {
    size = graph->adj_list[i]->size;
    for (j = 0; j < size; j++)
    {
      free(graph->adj_list[i]->elements[j]);
    }

    vector_free(graph->adj_list[i]);
  }

  vector_free(graph->mincut_e);
  vector_free(graph->mincut_f);
  free(graph->adj_list);
  free(graph);
}

bool bfs(Graph_t graph, int *level)
{
  int i;
  int size;
  int n = graph->num_nodes;
  int node;
  long excess;
  Queue_t queue = queue_alloc();
  Edge_t e;
  for (i = 0; i < n; i++)
    level[i] = -1;

  queue_push(queue, 0);
  level[0] = 0;
  while (!queue_isEmpty(queue))
  {
    node = queue_pop(queue);
    size = graph->adj_list[node]->size;
    for (i = 0; i < size; i++)
    {
      e = vector_get(graph->adj_list[node], i);
      excess = excessCapacity(e);
      if ((excess > 0) && (level[e->to_node] == (-1)))
      {
        level[e->to_node] = level[node] + 1;
        queue_push(queue, e->to_node);
      }
      else
      {
        
      }

    }

  }

  free(queue);
  return level[1] != (-1);
}

long dfs(Graph_t graph, int current_node, int *next, int *level, long flow)
{
  int num_edges;
  Edge_t e;
  long excess;
  long bottle_neck;
  long min;
  if (current_node == 1)
  {
    return flow;
  }
  else
  {
    
  }

  num_edges = graph->adj_list[current_node]->size;
  for (; next[current_node] < num_edges; next[current_node]++)
  {
    e = vector_get(graph->adj_list[current_node], next[current_node]);
    excess = excessCapacity(e);
    if ((excess > 0) && (level[e->to_node] == (level[current_node] + 1)))
    {
      min = (flow < excess) ? (flow) : (excess);
      ;
      bottle_neck = dfs(graph, e->to_node, next, level, min);
      if (bottle_neck > 0)
      {
        augmentEdge(e, bottle_neck);
        return bottle_neck;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return 0;
}

void dinic(Graph_t graph)
{
  int n = graph->num_nodes;
  int *next = (int *) malloc(n * (sizeof(int)));
  int *level = (int *) malloc(n * (sizeof(int)));
  long flow;
  memset(next, 0, n * (sizeof(int)));
  while (bfs(graph, level))
  {
    memset(next, 0, n * (sizeof(int)));
    while ((flow = dfs(graph, 0, next, level, LONG_MAX / 2)) != 0)
      graph->max_flow += flow;

  }

  free(next);
  free(level);
}

void reverse_bfs(Graph_t graph, bool *can_reach)
{
  int i;
  int size;
  int node;
  long excess;
  Queue_t queue = queue_alloc();
  Edge_t edge;
  Edge_t e;
  Edge_t r;
  queue_push(queue, 1);
  can_reach[1] = true;
  while (!queue_isEmpty(queue))
  {
    node = queue_pop(queue);
    size = graph->adj_list[node]->size;
    for (i = 0; i < size; i++)
    {
      edge = vector_get(graph->adj_list[node], i);
      if (edge->capacity == 0)
      {
        e = edge->reverse;
        r = edge;
      }
      else
      {
        e = edge;
        r = edge->reverse;
      }

      excess = excessCapacity(e);
      if (((edge->capacity == 0) && (excess > 0)) && (!can_reach[r->to_node]))
      {
        can_reach[r->to_node] = true;
        queue_push(queue, r->to_node);
      }
      else
      {
        if (((edge->capacity != 0) && (e->flow > 0)) && (!can_reach[e->to_node]))
        {
          can_reach[e->to_node] = true;
          queue_push(queue, e->to_node);
        }
        else
        {
          
        }

      }

    }

  }

  free(queue);
}

void min_cut(Graph_t graph, int out_min)
{
  int i;
  int size;
  int n = graph->num_nodes;
  int node;
  bool *can_reach = (bool *) malloc(n * (sizeof(bool)));
  bool *visited = (bool *) malloc(n * (sizeof(bool)));
  Queue_t queue = queue_alloc();
  Edge_t edge;
  Edge_t e;
  Edge_t r;
  memset(can_reach, false, n * (sizeof(bool)));
  reverse_bfs(graph, can_reach);
  memset(visited, false, n * (sizeof(bool)));
  visited[1] = true;
  queue_push(queue, 1);
  while (!queue_isEmpty(queue))
  {
    node = queue_pop(queue);
    size = graph->adj_list[node]->size;
    for (i = 0; i < size; i++)
    {
      edge = vector_get(graph->adj_list[node], i);
      if (edge->capacity == 0)
      {
        e = edge->reverse;
        r = edge;
      }
      else
      {
        e = edge;
        r = edge->reverse;
      }

      if (edge->capacity == 0)
      {
        if (can_reach[r->from_node] && (!can_reach[r->to_node]))
        {
          if (e->from_node != 0)
          {
            if (e->to_node >= out_min)
            {
              vector_pushBack(graph->mincut_e, e);
            }
            else
            {
              vector_pushBack(graph->mincut_f, e);
            }

          }
          else
          {
            
          }

        }
        else
        {
          if (((!visited[edge->to_node]) && can_reach[r->from_node]) && can_reach[r->to_node])
          {
            visited[edge->to_node] = true;
            queue_push(queue, r->to_node);
          }
          else
          {
            
          }

        }

      }
      else
      {
        
      }

    }

  }

  free(queue);
  free(can_reach);
  free(visited);
}

int main(int argc, char **argv)
{
  int i;
  int size;
  int num_nodes;
  int num_f;
  int f_min;
  int f_max;
  int num_e;
  int e_min;
  int e_max;
  int out_min;
  int out;
  int num_t;
  int from_node;
  int to_node;
  long capacity;
  Graph_t graph;
  num_f = new_sym_var(sizeof(int) * 8);
  num_e = new_sym_var(sizeof(int) * 8);
  num_t = new_sym_var(sizeof(int) * 8);
  num_nodes = ((1 + num_f) + (2 * num_e)) + 1;
  graph = graph_alloc(num_nodes);
  f_min = 2;
  f_max = (f_min + num_f) - 1;
  for (i = f_min; i <= f_max; i++)
  {
    capacity = new_sym_var(sizeof(long) * 8);
    insertEdge(graph, 0, i, capacity);
  }

  e_min = f_max + 1;
  e_max = (e_min + num_e) - 1;
  out_min = e_max + 1;
  out = out_min;
  for (i = e_min; i <= e_max; i++)
  {
    capacity = new_sym_var(sizeof(long) * 8);
    insertEdge(graph, i, out++, capacity);
  }

  for (i = 1; i <= num_t; i++)
  {
    from_node = new_sym_var(sizeof(int) * 8);
    to_node = new_sym_var(sizeof(int) * 8);
    capacity = new_sym_var(sizeof(long) * 8);
    if (from_node >= e_min)
    {
      insertEdge(graph, from_node + num_e, to_node, capacity);
    }
    else
    {
      insertEdge(graph, from_node, to_node, capacity);
    }

  }

  dinic(graph);
  printf("%ld\n", graph->max_flow);
  min_cut(graph, out_min);
  size = graph->mincut_e->size;
  qsort(graph->mincut_e->elements, size, sizeof(Edge_t), qsort_compare);
  if (size > 0)
  {
    printf("%d", graph->mincut_e->elements[0]->from_node);
  }
  else
  {
    
  }

  for (i = 1; i < size; i++)
  {
    printf(" %d", graph->mincut_e->elements[i]->from_node);
  }

  printf("\n");
  size = graph->mincut_f->size;
  qsort(graph->mincut_f->elements, size, sizeof(Edge_t), qsort_compare);
  for (i = 0; i < size; i++)
  {
    if (graph->mincut_f->elements[i]->from_node >= out_min)
    {
      printf("%d %d\n", graph->mincut_f->elements[i]->from_node - num_e, graph->mincut_f->elements[i]->to_node);
    }
    else
    {
      printf("%d %d\n", graph->mincut_f->elements[i]->from_node, graph->mincut_f->elements[i]->to_node);
    }

  }

  graph_free(graph);
  return 0;
}

