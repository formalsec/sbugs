/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct 
{
  int o;
  int d;
  int c;
  int f;
  int c2;
  int f2;
  int r;
} liga;
typedef struct 
{
  int e;
  int h;
  int n;
  int v;
  int *l;
  int col;
} vertice;
vertice *V;
liga *T;
int f;
int e;
int t;
int z;
int y;
int x;
int o;
int d;
int c;
int n;
int w;
int kl;
char *X;
void Remover(int n)
{
  for (z = 0; z < ((t + f) + e); z++)
  {
    if ((T[z].o == n) || (T[z].d == n))
    {
      T[z].r = 0;
    }
    else
    {
      
    }

  }

}

void Visit(int n, int m[])
{
  Remover(n);
  V[n].col = 1;
  int s;
  for (s = 0; s < m[n]; s++)
  {
    if (T[V[n].l[s]].o == n)
    {
      if (((T[V[n].l[s]].c - T[V[n].l[s]].f) > 0) && (V[T[V[n].l[s]].d].col == 0))
      {
        Visit(T[V[n].l[s]].d, m);
      }
      else
      {
        if (((T[V[n].l[s]].c - T[V[n].l[s]].f) == 0) && (V[T[V[n].l[s]].d].col == 0))
        {
          T[V[n].l[s]].r = 1;
          kl += 1;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

    if (T[V[n].l[s]].d == n)
    {
      if (((T[V[n].l[s]].c2 - T[V[n].l[s]].f2) > 0) && (V[T[V[n].l[s]].o].col == 0))
      {
        Visit(T[V[n].l[s]].o, m);
      }
      else
      {
        if (((T[V[n].l[s]].c2 - T[V[n].l[s]].f2) == 0) && (V[T[V[n].l[s]].o].col == 0))
        {
          T[V[n].l[s]].r = 1;
          kl += 1;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  V[n].col = 2;
}

int main()
{
  f = new_sym_var(sizeof(int) * 8);
  e = new_sym_var(sizeof(int) * 8);
  t = new_sym_var(sizeof(int) * 8);
  n = (f + (2 * e)) + 2;
  V = (vertice *) malloc((sizeof(vertice)) * ((f + (2 * e)) + 2));
  T = (liga *) malloc((sizeof(liga)) * ((t + f) + e));
  for (z = 0; z < ((f + (2 * e)) + 2); z++)
  {
    V[z].n = z;
    V[z].e = 0;
    V[z].h = 0;
    V[z].col = 0;
  }

  int m[(f + (2 * e)) + 2];
  int k[(f + (2 * e)) + 2];
  for (z = 0; z < ((f + (2 * e)) + 2); z++)
  {
    m[z] = 0;
    k[z] = z;
  }

  for (z = 2; z <= (f + 1); z++)
  {
    x = new_sym_var(sizeof(int) * 8);
    V[z].n = z;
    V[z].e = x;
    V[z].h = 0;
    V[0].e -= x;
    m[0] += 1;
    m[z] += 1;
    T[(t + z) - 2].o = 0;
    T[(t + z) - 2].d = z;
    T[(t + z) - 2].c = x;
    T[(t + z) - 2].f = x;
    T[(t + z) - 2].c2 = 0;
    T[(t + z) - 2].f2 = -x;
  }

  for (z = f + 2; z <= ((f + e) + 1); z++)
  {
    x = new_sym_var(sizeof(int) * 8);
    V[z].n = z;
    V[z].e = 0;
    V[z].h = 0;
    m[z] = 1;
    V[z + e].n = z + e;
    V[z + e].e = 0;
    V[z + e].h = 0;
    m[z + e] = 1;
    T[(t + z) - 2].o = z;
    T[(t + z) - 2].d = z + e;
    T[(t + z) - 2].c = x;
    T[(t + z) - 2].f = 0;
    T[(t + z) - 2].c2 = x;
    T[(t + z) - 2].f2 = 0;
  }

  for (z = 0; z < t; z++)
  {
    o = new_sym_var(sizeof(int) * 8);
    d = new_sym_var(sizeof(int) * 8);
    c = new_sym_var(sizeof(int) * 8);
    if (o > (f + 1))
    {
      m[o + e] += 1;
      T[z].o = o + e;
    }
    else
    {
      m[o] += 1;
      T[z].o = o;
    }

    m[d] += 1;
    T[z].d = d;
    T[z].c = c;
    T[z].f = 0;
    T[z].c2 = 0;
    T[z].f2 = 0;
  }

  for (z = 0; z < ((f + (2 * e)) + 2); z++)
  {
    V[z].v = 0;
    if (m[z] != 0)
    {
      V[z].l = (int *) malloc((sizeof(int)) * m[z]);
      m[z] = 0;
    }
    else
    {
      
    }

  }

  for (z = 0; z < ((t + f) + e); z++)
  {
    T[z].r = 0;
    V[T[z].o].l[m[T[z].o]] = z;
    m[T[z].o] += 1;
  }

  for (z = 0; z < ((t + f) + e); z++)
  {
    V[T[z].d].l[m[T[z].d]] = z;
    m[T[z].d] += 1;
  }

  V[0].h = (f + (2 * e)) + 2;
  w = 2;
  while (w < ((f + (2 * e)) + 2))
  {
    int oldh = V[k[w]].h;
    while (V[k[w]].e > 0)
    {
      int q = V[k[w]].v;
      if (m[k[w]] == q)
      {
        o = 1000000;
        if ((k[w] == T[V[k[w]].l[0]].o) && ((T[V[k[w]].l[0]].c - T[V[k[w]].l[0]].f) > 0))
        {
          o = V[T[V[k[w]].l[0]].d].h;
        }
        else
        {
          
        }

        if ((k[w] == T[V[k[w]].l[0]].d) && ((T[V[k[w]].l[0]].c2 - T[V[k[w]].l[0]].f2) > 0))
        {
          o = V[T[V[k[w]].l[0]].o].h;
        }
        else
        {
          
        }

        for (z = 0; z < q; z++)
        {
          if ((k[w] == T[V[k[w]].l[z]].o) && ((T[V[k[w]].l[z]].c - T[V[k[w]].l[z]].f) > 0))
          {
            if (o > V[T[V[k[w]].l[z]].d].h)
            {
              o = V[T[V[k[w]].l[z]].d].h;
            }
            else
            {
              
            }

          }
          else
          {
            
          }

          if ((k[w] == T[V[k[w]].l[z]].d) && ((T[V[k[w]].l[z]].c2 - T[V[k[w]].l[z]].f2) > 0))
          {
            if (o > V[T[V[k[w]].l[z]].o].h)
            {
              o = V[T[V[k[w]].l[z]].o].h;
            }
            else
            {
              
            }

          }
          else
          {
            
          }

        }

        V[k[w]].h = 1 + o;
        V[k[w]].v = 0;
      }
      else
      {
        if (k[w] == T[V[k[w]].l[q]].o)
        {
          if (((T[V[k[w]].l[q]].c - T[V[k[w]].l[q]].f) > 0) && (V[k[w]].h == (V[T[V[k[w]].l[q]].d].h + 1)))
          {
            d = V[k[w]].e;
            if (d > (T[V[k[w]].l[q]].c - T[V[k[w]].l[q]].f))
            {
              d = T[V[k[w]].l[q]].c - T[V[k[w]].l[q]].f;
            }
            else
            {
              
            }

            T[V[k[w]].l[q]].f += d;
            T[V[k[w]].l[q]].f2 = -T[V[k[w]].l[q]].f;
            V[k[w]].e -= d;
            V[T[V[k[w]].l[q]].d].e += d;
          }
          else
          {
            V[k[w]].v += 1;
          }

        }
        else
        {
          
        }

        if (k[w] == T[V[k[w]].l[q]].d)
        {
          if (((T[V[k[w]].l[q]].c2 - T[V[k[w]].l[q]].f2) > 0) && (V[k[w]].h == (V[T[V[k[w]].l[q]].o].h + 1)))
          {
            d = V[k[w]].e;
            if (d > (T[V[k[w]].l[q]].c2 - T[V[k[w]].l[q]].f2))
            {
              d = T[V[k[w]].l[q]].c2 - T[V[k[w]].l[q]].f2;
            }
            else
            {
              
            }

            T[V[k[w]].l[q]].f2 += d;
            T[V[k[w]].l[q]].f = -T[V[k[w]].l[q]].f2;
            V[k[w]].e -= d;
            V[T[V[k[w]].l[q]].o].e += d;
          }
          else
          {
            V[k[w]].v += 1;
          }

        }
        else
        {
          
        }

      }

    }

    if (V[k[w]].h > oldh)
    {
      int a = k[w];
      for (z = w; z > 1; z--)
      {
        k[z] = k[z - 1];
      }

      k[2] = a;
      w = 2;
    }
    else
    {
      
    }

    w += 1;
  }

  printf("%d\n", V[1].e);
  kl = 0;
  for (z = 0; z < ((t + f) + e); z++)
  {
    int d = T[z].f;
    T[z].f = T[z].f2;
    T[z].f2 = d;
    d = T[z].c;
    T[z].c = T[z].c2;
    T[z].c2 = d;
  }

  Visit(1, m);
  int ky = 0;
  int ke[kl];
  int ke2[kl];
  int ke3[kl];
  int pr = 0;
  for (z = 0; z < ((t + f) + e); z++)
  {
    if ((T[z].r != 0) && (T[z].o != 0))
    {
      if ((T[z].o > (1 + f)) && (T[z].d > ((f + e) + 1)))
      {
        ky = 1;
        ke[pr] = T[z].o;
        pr += 1;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  if (ky != 0)
  {
    for (z = 0; z < (pr - 1); z++)
    {
      for (y = 0; y < ((pr - z) - 1); y++)
      {
        if (ke[y] > ke[y + 1])
        {
          x = ke[y];
          ke[y] = ke[y + 1];
          ke[y + 1] = x;
        }
        else
        {
          
        }

      }

    }

    printf("%d", ke[0]);
    for (z = 1; z < pr; z++)
    {
      printf(" %d", ke[z]);
    }

  }
  else
  {
    
  }

  printf("\n");
  int pr2 = 0;
  for (z = 0; z < ((t + f) + e); z++)
  {
    if ((T[z].r != 0) && (T[z].o != 0))
    {
      if (T[z].o > ((f + e) + 1))
      {
        ke2[pr2] = T[z].o - e;
        ke3[pr2] = T[z].d;
        pr2 += 1;
      }
      else
      {
        
      }

      if ((T[z].o > 1) && (T[z].o < (f + 2)))
      {
        ke2[pr2] = T[z].o;
        ke3[pr2] = T[z].d;
        pr2 += 1;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  for (z = 0; z < (pr2 - 1); z++)
  {
    for (y = 0; y < ((pr2 - z) - 1); y++)
    {
      if (ke2[y] > ke2[y + 1])
      {
        x = ke2[y];
        w = ke3[y];
        ke2[y] = ke2[y + 1];
        ke3[y] = ke3[y + 1];
        ke2[y + 1] = x;
        ke3[y + 1] = w;
      }
      else
      {
        
      }

      if ((ke2[y] == ke2[y + 1]) && (ke3[y] > ke3[y + 1]))
      {
        x = ke3[y];
        ke3[y] = ke3[y + 1];
        ke3[y + 1] = x;
      }
      else
      {
        
      }

    }

  }

  for (z = 0; z < pr2; z++)
  {
    x = 0;
    for (y = 0; y < pr; y++)
    {
      if ((ke[y] == ke2[z]) || (ke[y] == ke3[z]))
      {
        x = 1;
      }
      else
      {
        
      }

    }

    if (x == 0)
    {
      printf("%d %d\n", ke2[z], ke3[z]);
    }
    else
    {
      
    }

  }

  return 0;
}

