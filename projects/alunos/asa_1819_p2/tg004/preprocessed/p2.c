#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>


typedef struct lst_iitem_arch
{
  int source;
  int destination;
  int capacity;
  int flow;
  struct lst_iitem_arch *reverse;
  struct lst_iitem_arch *next;
} lst_iitem_edge;
typedef struct 
{
  lst_iitem_edge *first;
} list_edge;
typedef struct lst_iitem_node
{
  int id;
  int numLinks;
  int inCut;
  int visited;
  list_edge *edges;
} node;
typedef struct stack_s
{
  int top;
  int size;
  int *items;
} stack;
node *readInput(node *graph, list_edge *edgeList, int *edges, int *links, int *suppliers, int *processors, int *firstPostId, int *originalNodes, int *totalNodes);
lst_iitem_edge *createEdge(int source, int destination, int capacity);
void printEdge(lst_iitem_edge *edge);
list_edge *lst_new();
void lst_print(list_edge *list);
void insert_new_edge(node *graph, int source, int destination, int capacity);
int min(int a, int b);
void edmondsKarp(node *nodes, int totalNodes);
void stack_push(int v, stack *s);
int stack_pop(stack *s);
stack *createStack(int size);
void deleteStack(stack *s);
void add_to_list(list_edge *list, lst_iitem_edge *item);
node *findMinCut(node *nodes, int totalNodes);
void printAugments(node *nodes, int totalNodes, int processors, int suppliers, int originalNodes);
int isPostLink(int source, int destination, int totalNodes, int originalNodes, int suppliers, int processors);
void bubbleSort(list_edge *edgeList);
void swap(lst_iitem_edge *a, lst_iitem_edge *b);
int main(int argc, const char *argv[])
{
  int edges;
  int links;
  int suppliers;
  int processors;
  int firstPostId;
  int originalNodes;
  int totalNodes;
  node *nodes;
  list_edge *edgeList;
  edges = (links = (suppliers = (processors = 0)));
  originalNodes = (totalNodes = 0);
  firstPostId = 0;
  nodes = 0;
  edgeList = lst_new();
  nodes = readInput(nodes, edgeList, &edges, &links, &suppliers, &processors, &firstPostId, &originalNodes, &totalNodes);
  edmondsKarp(nodes, totalNodes);
  nodes = findMinCut(nodes, totalNodes);
  printAugments(nodes, totalNodes, processors, suppliers, originalNodes);
  return 0;
}

node *readInput(node *graph, list_edge *edgeList, int *edges, int *link, int *suppliers, int *processors, int *firstPostId, int *originalNodes, int *totalNodes)
{
  int count;
  int source;
  int destination;
  int src;
  int dst;
  int capacity;
  int firstPostAux;
  if (3 == 0)
  {
    fprintf(stderr, "Error reading input\n");
  }
  else
  {
    for (int suppliers_index = 0; suppliers_index < 10; suppliers_index++)
    {
      suppliers[suppliers_index] = new_sym_var(sizeof(int) * 8);
    }

    for (int processors_index = 0; processors_index < 10; processors_index++)
    {
      processors[processors_index] = new_sym_var(sizeof(int) * 8);
    }

    for (int link_index = 0; link_index < 10; link_index++)
    {
      link[link_index] = new_sym_var(sizeof(int) * 8);
    }

    
  }

  *firstPostId = (*suppliers) + 2;
  *originalNodes = (1 + (*suppliers)) + (*processors);
  *totalNodes = ((*originalNodes) + (*processors)) + 1;
  firstPostAux = (*originalNodes) + 1;
  graph = (node *) malloc((sizeof(node)) * (*totalNodes));
  for (count = 0; count < (*totalNodes); count++)
  {
    graph[count].id = count + 1;
    graph[count].numLinks = 0;
    graph[count].inCut = 0;
    graph[count].edges = lst_new();
  }

  for (count = 0; count < (*suppliers); count++)
  {
    source = 2 + count;
    destination = *totalNodes;
    if (1 == 0)
    {
      fprintf(stderr, "Error reading input\n");
    }
    else
    {
      capacity = new_sym_var(sizeof(int) * 8);
      
    }

    insert_new_edge(graph, source, destination, capacity);
  }

  getchar();
  for (count = 0; count < (*processors); count++)
  {
    source = firstPostAux + count;
    destination = (*firstPostId) + count;
    if (1 == 0)
    {
      fprintf(stderr, "Error reading input\n");
    }
    else
    {
      capacity = new_sym_var(sizeof(int) * 8);
      
    }

    insert_new_edge(graph, source, destination, capacity);
  }

  for (count = 0; count < (*link); count++)
  {
    if (3 == 0)
    {
      fprintf(stderr, "Error reading input\n");
    }
    else
    {
      src = new_sym_var(sizeof(int) * 8);
      dst = new_sym_var(sizeof(int) * 8);
      capacity = new_sym_var(sizeof(int) * 8);
      
    }

    source = dst;
    destination = src;
    if (src >= (*firstPostId))
    {
      destination = (src + ((*originalNodes) - (*firstPostId))) + 1;
      insert_new_edge(graph, source, destination, capacity);
    }
    else
    {
      insert_new_edge(graph, source, destination, capacity);
    }

  }

  return graph;
}

lst_iitem_edge *createEdge(int source, int destination, int capacity)
{
  lst_iitem_edge *newEdge;
  newEdge = (lst_iitem_edge *) malloc(sizeof(lst_iitem_edge));
  newEdge->source = source;
  newEdge->destination = destination;
  newEdge->capacity = capacity;
  newEdge->flow = 0;
  newEdge->reverse = (lst_iitem_edge *) malloc(sizeof(lst_iitem_edge));
  newEdge->reverse->source = destination;
  newEdge->reverse->destination = source;
  newEdge->reverse->capacity = 0;
  newEdge->reverse->reverse = newEdge;
  newEdge->reverse->next = 0;
  newEdge->next = 0;
  return newEdge;
}

void printEdge(lst_iitem_edge *edge)
{
  int source;
  int destination;
  source = edge->source + 1;
  destination = edge->destination + 1;
  printf("%d %d\n", source, destination);
  return;
}

void edmondsKarp(node *nodes, int totalNodes)
{
  int source = 0;
  int sink = totalNodes - 1;
  int dest;
  int count;
  int pushFlow;
  int maxFlow;
  int curr;
  lst_iitem_edge *edge;
  stack *queue;
  lst_iitem_edge **parents;
  parents = (lst_iitem_edge **) malloc((sizeof(lst_iitem_edge *)) * totalNodes);
  maxFlow = 0;
  curr = -1;
  while (1)
  {
    for (count = 0; count < totalNodes; count++)
    {
      parents[count] = 0;
    }

    queue = createStack(totalNodes);
    stack_push(source, queue);
    while (queue->top != (-1))
    {
      curr = stack_pop(queue);
      edge = nodes[curr].edges->first;
      for (count = 0; count < nodes[curr].numLinks; count++)
      {
        dest = edge->destination;
        if (((parents[dest] == 0) && (dest != source)) && (edge->capacity > edge->flow))
        {
          parents[dest] = edge;
          stack_push(dest, queue);
        }
        else
        {
          
        }

        edge = edge->next;
      }

    }

    if (parents[sink] == 0)
    {
      break;
    }
    else
    {
      
    }

    pushFlow = 32767;
    edge = parents[sink];
    while (edge != 0)
    {
      pushFlow = min(pushFlow, edge->capacity - edge->flow);
      edge = parents[edge->source];
    }

    edge = parents[sink];
    while (edge != 0)
    {
      edge->flow += pushFlow;
      edge->reverse->flow -= pushFlow;
      edge = parents[edge->source];
    }

    maxFlow += pushFlow;
    deleteStack(queue);
  }

  printf("%d\n", maxFlow);
}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

node *findMinCut(node *nodes, int totalNodes)
{
  int count;
  int curr;
  int source;
  int dest;
  stack *queue;
  lst_iitem_edge *edge;
  queue = createStack(totalNodes + 1);
  source = 0;
  curr = -1;
  stack_push(source, queue);
  nodes[source].inCut = 1;
  while (queue->top != (-1))
  {
    curr = stack_pop(queue);
    edge = nodes[curr].edges->first;
    for (count = 0; count < nodes[curr].numLinks; count++)
    {
      dest = edge->destination;
      if ((((dest != source) && ((edge->capacity - edge->flow) > 0)) && (nodes[dest].visited == 0)) && ((edge->flow >= 0) || (edge->reverse->flow != 0)))
      {
        nodes[dest].inCut = 1;
        nodes[dest].visited = 1;
        stack_push(dest, queue);
      }
      else
      {
        
      }

      edge = edge->next;
    }

  }

  return nodes;
}

void printAugments(node *nodes, int totalNodes, int processors, int suppliers, int originalNodes)
{
  lst_iitem_edge *item;
  stack *postsToAugment;
  list_edge *edgeList;
  int count;
  int isPost;
  int sourcePos;
  int destinationPos;
  postsToAugment = createStack(suppliers + 1);
  edgeList = lst_new();
  for (count = totalNodes - 1; count >= 0; count--)
  {
    item = nodes[count].edges->first;
    while (item != 0)
    {
      if ((((nodes[item->source].inCut != nodes[item->destination].inCut) && (item->destination != count)) && (item->capacity > 0)) && ((item->capacity - item->flow) == 0))
      {
        sourcePos = item->destination;
        destinationPos = item->source;
        isPost = isPostLink(sourcePos, destinationPos, totalNodes, originalNodes, suppliers, processors);
        if (((sourcePos + 1) != totalNodes) && ((destinationPos + 1) != totalNodes))
        {
          if (isPost == 1)
          {
            stack_push(sourcePos + 1, postsToAugment);
            item = item->next;
            isPost = 0;
            continue;
          }
          else
          {
            
          }

          if (isPost == (-1))
          {
            stack_push(destinationPos + 1, postsToAugment);
            item = item->next;
            isPost = 0;
            continue;
          }
          else
          {
            
          }

          if ((sourcePos >= originalNodes) && ((sourcePos + 1) != totalNodes))
          {
            add_to_list(edgeList, createEdge(sourcePos - processors, destinationPos, 0));
            item = item->next;
            continue;
          }
          else
          {
            
          }

          if ((destinationPos >= originalNodes) && ((destinationPos + 1) != totalNodes))
          {
            add_to_list(edgeList, createEdge(sourcePos, destinationPos - processors, 0));
            item = item->next;
            continue;
          }
          else
          {
            
          }

          add_to_list(edgeList, createEdge(sourcePos, destinationPos, 0));
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      item = item->next;
    }

  }

  if (postsToAugment->top > 0)
  {
    printf("%d", stack_pop(postsToAugment));
    while (postsToAugment->top > 0)
    {
      printf(" %d", stack_pop(postsToAugment));
    }

    printf(" %d", stack_pop(postsToAugment));
  }
  else
  {
    
  }

  if (postsToAugment->top == 0)
  {
    printf("%d", stack_pop(postsToAugment));
  }
  else
  {
    
  }

  printf("\n");
  deleteStack(postsToAugment);
  bubbleSort(edgeList);
  lst_print(edgeList);
}

void bubbleSort(list_edge *edgeList)
{
  int swapped;
  lst_iitem_edge *start = edgeList->first;
  lst_iitem_edge *ptr1;
  lst_iitem_edge *lptr = 0;
  if (start == 0)
  {
    return;
  }
  else
  {
    
  }

  do
  {
    swapped = 0;
    ptr1 = start;
    while (ptr1->next != lptr)
    {
      if ((ptr1->source > ptr1->next->source) || ((ptr1->source == ptr1->next->source) && (ptr1->destination > ptr1->next->destination)))
      {
        swap(ptr1, ptr1->next);
        swapped = 1;
      }
      else
      {
        
      }

      ptr1 = ptr1->next;
    }

    lptr = ptr1;
  }
  while (swapped);
}

void swap(lst_iitem_edge *a, lst_iitem_edge *b)
{
  int sourceAux;
  int destinationAux;
  sourceAux = a->source;
  destinationAux = a->destination;
  a->source = b->source;
  a->destination = b->destination;
  b->source = sourceAux;
  b->destination = destinationAux;
}

int isPostLink(int source, int destination, int totalNodes, int originalNodes, int suppliers, int processors)
{
  if ((((source == 0) || (destination == 0)) || ((source + 1) == totalNodes)) || ((destination + 1) == totalNodes))
  {
    return 0;
  }
  else
  {
    if (((source <= originalNodes) && (destination == (source + processors))) && (source >= suppliers))
    {
      return 1;
    }
    else
    {
      
    }

    if (((destination <= originalNodes) && (source == (destination + processors))) && (destination >= suppliers))
    {
      return -1;
    }
    else
    {
      
    }

  }

  return 0;
}

list_edge *lst_new()
{
  list_edge *list;
  list = (list_edge *) malloc(sizeof(list_edge));
  list->first = 0;
  return list;
}

void lst_destroy(list_edge *list)
{
  struct lst_iitem_arch *item;
  struct lst_iitem_arch *nextitem;
  item = list->first;
  while (item != 0)
  {
    nextitem = item->next;
    free(item);
    item = nextitem;
  }

  free(list);
}

void lst_print(list_edge *list)
{
  lst_iitem_edge *item;
  item = list->first;
  while (item != 0)
  {
    printEdge(item);
    item = item->next;
  }

}

void insert_new_edge(node *graph, int source, int destination, int capacity)
{
  lst_iitem_edge *item;
  item = createEdge(source - 1, destination - 1, capacity);
  add_to_list(graph[source - 1].edges, item);
  add_to_list(graph[destination - 1].edges, item->reverse);
  graph[source - 1].numLinks++;
  graph[destination - 1].numLinks++;
}

void add_to_list(list_edge *list, lst_iitem_edge *item)
{
  if (list->first != 0)
  {
    item->next = list->first;
  }
  else
  {
    
  }

  list->first = item;
}

void stack_push(int v, stack *s)
{
  s->top++;
  if (s->top < s->size)
  {
    s->items[s->top] = v;
  }
  else
  {
    printf("Stack is full!\n");
    exit(1);
  }

}

int stack_pop(stack *s)
{
  return (s->top < 0) ? (-1) : (s->items[s->top--]);
}

stack *createStack(int size)
{
  stack *s;
  s = (stack *) malloc(sizeof(stack));
  s->top = -1;
  s->size = size;
  s->items = (int *) malloc((sizeof(int)) * size);
  return s;
}

void deleteStack(stack *s)
{
  free(s->items);
  free(s);
}

