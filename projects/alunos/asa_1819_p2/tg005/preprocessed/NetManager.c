#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <assert.h>


typedef struct vNode *vNode;
typedef struct eNode *eNode;
typedef struct vertex *vertex;
typedef struct edge *edge;
typedef struct vQueue vQueue;
typedef struct vStack vStack;
struct vNode
{
  vertex item;
  vNode next;
};
struct eNode
{
  edge item;
  eNode next;
};
struct vertex
{
  eNode adjHead;
  eNode adjTail;
  int height;
  int excess;
};
struct edge
{
  vertex from;
  vertex to;
  edge dual;
  int capacity;
  int flow;
};
struct vQueue
{
  vNode head;
  vNode tail;
};
struct vStack
{
  int nHeights;
  vNode *list;
};
int readValue(int minValue);
eNode createENode(edge item, eNode next);
void freeENodes(eNode head);
edge createEdge(vertex from, vertex to, int capacity, int flow, edge dual);
void addEdge(edge eItem);
void freeEdges(int nVerts);
vNode createVNode(vertex item, vNode next);
void freeVNodes(vNode head);
void vListInit(int nVerts);
void addToQueue(vertex item);
void popQueue();
void stackInit(int nHeights);
void addToStack(vertex item);
void stackClimb(vertex item);
void stackSweep(int height);
void freeStack();
void preflow(vertex src);
void relax(edge link, int flow);
void relable(vertex item);
void pushRelable();
int cmpTo(const void *x, const void *y);
int cmpFrom(const void *x, const void *y);
vertex vList;
vQueue queue;
vStack stack;
int main()
{
  int i;
  int fromId;
  int toId;
  int capacity;
  vertex to;
  edge link;
  vNode joiNode;
  eNode adjNode;
  int nProviders = readValue(1);
  int nStations = readValue(0);
  int nLinks = readValue(0);
  int nVerts = (nProviders + (2 * nStations)) + 2;
  char flag;
  int cutLen = 0;
  edge *cutLinks;
  vListInit(nVerts);
  stackInit(nVerts);
  vList[1].height = stack.nHeights;
  for (i = 0; i < nVerts; i++)
  {
    addToStack(vList + i);
  }

  for (i = 2; i < (nVerts - nStations); i++)
  {
    capacity = readValue(1);
    if (i > (nProviders + 1))
    {
      addEdge(createEdge((vList + i) + nStations, vList + i, capacity, 0, 0));
    }
    else
    {
      addEdge(createEdge(vList + i, vList + 0, capacity, 0, 0));
    }

  }

  for (i = 0; i < nLinks; i++)
  {
    toId = readValue(2);
    fromId = readValue(1);
    capacity = readValue(1);
    if (toId > (nProviders + 1))
    {
      toId += nStations;
    }
    else
    {
      
    }

    addEdge(createEdge(vList + fromId, vList + toId, capacity, 0, 0));
  }

  pushRelable();
  printf("%d\n", (vList + 0)->excess);
  cutLinks = (edge *) malloc((sizeof(edge)) * nLinks);
  assert(cutLinks);
  for (joiNode = stack.list[stack.nHeights]; joiNode != 0; joiNode = joiNode->next)
  {
    for (adjNode = joiNode->item->adjHead; adjNode != 0; adjNode = adjNode->next)
    {
      link = adjNode->item;
      if (link->capacity == 0)
      {
        break;
      }
      else
      {
        
      }

      if ((link->to->height < stack.nHeights) && (link->to != (vList + 0)))
      {
        cutLinks[cutLen++] = link;
      }
      else
      {
        
      }

    }

  }

  qsort(cutLinks, cutLen, sizeof(edge), cmpFrom);
  qsort(cutLinks, cutLen, sizeof(edge), cmpTo);
  for (i = 0, flag = 0; i < cutLen; i++)
  {
    if (cutLinks[i]->from < ((vList + nVerts) - nStations))
    {
      continue;
    }
    else
    {
      
    }

    printf("%s%ld", (flag) ? (" ") : (""), cutLinks[i]->to - vList);
    if (flag == 0)
    {
      flag = 1;
    }
    else
    {
      
    }

    cutLinks[i] = 0;
  }

  printf("\n");
  for (i = 0; i < cutLen; i++)
  {
    if (cutLinks[i] == 0)
    {
      continue;
    }
    else
    {
      
    }

    to = cutLinks[i]->to - ((cutLinks[i]->to < ((vList + nVerts) - nStations)) ? (0) : (nStations));
    printf("%ld %ld\n", to - vList, cutLinks[i]->from - vList);
  }

  free(cutLinks);
  freeEdges(nVerts);
  freeStack();
  free(vList);
  exit(0);
}

int readValue(int minValue)
{
  int value;
  if (1 != 1)
  {
    perror("scanf");
    exit(1);
  }
  else
  {
    value = new_sym_var(sizeof(int) * 8);
    
  }

  if (value < minValue)
  {
    fprintf(stderr, "Invalid input\n");
    exit(1);
  }
  else
  {
    
  }

  return value;
}

eNode createENode(edge item, eNode next)
{
  eNode new = (eNode) malloc(sizeof(struct eNode));
  assert(new);
  new->item = item;
  new->next = next;
  return new;
}

void freeENodes(eNode head)
{
  eNode next;
  while (head != 0)
  {
    next = head->next;
    free(head->item);
    free(head);
    head = next;
  }

}

edge createEdge(vertex from, vertex to, int capacity, int flow, edge dual)
{
  edge new = (edge) malloc(sizeof(struct edge));
  assert(new);
  new->to = to;
  new->from = from;
  new->capacity = capacity;
  new->flow = flow;
  new->dual = dual;
  return new;
}

void addEdge(edge link)
{
  eNode new = createENode(link, 0);
  if (link->from->adjHead == 0)
  {
    link->from->adjHead = new;
    link->from->adjTail = new;
    return;
  }
  else
  {
    
  }

  link->from->adjTail->next = new;
  link->from->adjTail = new;
}

void freeEdges(int nVerts)
{
  int i;
  for (i = 0; i < nVerts; i++)
  {
    freeENodes((vList + i)->adjHead);
  }

}

vNode createVNode(vertex item, vNode next)
{
  vNode new = (vNode) malloc(sizeof(struct vNode));
  assert(new);
  new->item = item;
  new->next = next;
  return new;
}

void freeVNodes(vNode head)
{
  vNode next;
  while (head != 0)
  {
    next = head->next;
    free(head);
    head = next;
  }

}

void vListInit(int nVerts)
{
  int i;
  vList = (vertex) malloc((sizeof(struct vertex)) * nVerts);
  assert(vList);
  for (i = 0; i < nVerts; i++)
  {
    vList[i].adjHead = 0;
    vList[i].adjTail = 0;
    vList[i].excess = 0;
    vList[i].height = 0;
  }

}

void addToQueue(vertex item)
{
  vNode new = createVNode(item, 0);
  if (queue.head == 0)
  {
    queue.head = new;
    queue.tail = new;
    return;
  }
  else
  {
    
  }

  queue.tail->next = new;
  queue.tail = new;
}

void popQueue()
{
  vNode head = queue.head;
  queue.head = head->next;
  free(head);
}

void stackInit(int nHeights)
{
  int i;
  stack.nHeights = nHeights;
  stack.list = (vNode *) malloc((sizeof(vNode)) * (nHeights + 1));
  assert(stack.list);
  for (i = 0; i <= nHeights; stack.list[i++] = 0)
    ;

}

void addToStack(vertex item)
{
  stack.list[item->height] = createVNode(item, stack.list[item->height]);
}

void stackClimb(vertex item)
{
  vNode node = stack.list[item->height];
  if (node->item != item)
  {
    vNode prev = node;
    while (prev->next->item != item)
    {
      prev = prev->next;
    }

    node = prev->next;
    prev->next = node->next;
  }
  else
  {
    stack.list[item->height] = node->next;
  }

  item->height++;
  node->next = stack.list[item->height];
  stack.list[item->height] = node;
}

void stackSweep(int height)
{
  int i;
  vNode node;
  for (i = height; stack.list[i] != 0; i++)
  {
    for (node = stack.list[i]; node->next != 0; node = node->next)
    {
      node->item->height = stack.nHeights + 1;
    }

    node->item->height = stack.nHeights + 1;
    node->next = stack.list[stack.nHeights];
    stack.list[stack.nHeights] = stack.list[i];
    stack.list[i] = 0;
  }

}

void freeStack()
{
  int i;
  for (i = 0; i <= stack.nHeights; i++)
  {
    freeVNodes(stack.list[i]);
  }

  free(stack.list);
}

void preflow(vertex src)
{
  eNode adjNode;
  edge link;
  for (adjNode = src->adjHead; adjNode != 0; adjNode = adjNode->next)
  {
    link = adjNode->item;
    relax(link, link->capacity);
    if (link->to != (vList + 0))
    {
      addToQueue(link->to);
    }
    else
    {
      
    }

  }

}

void relax(edge link, int flow)
{
  link->from->excess -= flow;
  link->flow += flow;
  link->to->excess += flow;
  if (link->dual != 0)
  {
    link->dual->flow -= flow;
    return;
  }
  else
  {
    
  }

  link->dual = createEdge(link->to, link->from, 0, -flow, link);
  addEdge(link->dual);
}

void relable(vertex item)
{
  if (item->height < stack.nHeights)
  {
    if (stack.list[item->height]->next == 0)
    {
      stackSweep(item->height);
    }
    else
    {
      stackClimb(item);
    }

  }
  else
  {
    item->height++;
  }

}

void pushRelable()
{
  int flow;
  vertex vItem;
  edge eItem;
  eNode adjNode;
  preflow(vList + 1);
  while (queue.head != 0)
  {
    vItem = queue.head->item;
    for (adjNode = vItem->adjHead; adjNode != 0; adjNode = adjNode->next)
    {
      eItem = adjNode->item;
      if (vItem->height != (eItem->to->height + 1))
      {
        continue;
      }
      else
      {
        
      }

      flow = (vItem->excess < (eItem->capacity - eItem->flow)) ? (vItem->excess) : (eItem->capacity - eItem->flow);
      if (flow > 0)
      {
        relax(eItem, flow);
        if ((eItem->to->excess == flow) && (eItem->to != (vList + 0)))
        {
          addToQueue(eItem->to);
        }
        else
        {
          
        }

        if (vItem->excess == 0)
        {
          break;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (vItem->excess > 0)
    {
      relable(vItem);
      continue;
    }
    else
    {
      
    }

    popQueue();
  }

}

int cmpTo(const void *x, const void *y)
{
  return (int) ((*((edge *) x))->to - (*((edge *) y))->to);
}

int cmpFrom(const void *x, const void *y)
{
  return (int) ((*((edge *) x))->from - (*((edge *) y))->from);
}

