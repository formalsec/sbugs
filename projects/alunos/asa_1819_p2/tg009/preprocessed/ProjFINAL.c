#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int head;
int tail;
struct Graph
{
  int vertices;
  int f;
  int e;
  int t;
  int countEst;
  int countLig;
  int *visited;
  int *arrayEst;
  int *color;
  int *pred;
  int *q;
  int **capacity;
  int **transp;
  int **flow;
};
struct ArrayLig
{
  int origin;
  int dest;
};
struct Graph *alloca_Graph(int v, int f, int e, int t)
{
  int i;
  int j;
  struct Graph *Grafo = (struct Graph *) malloc(sizeof(struct Graph));
  Grafo->capacity = (int **) malloc((sizeof(int *)) * v);
  for (i = 0; i < v; i++)
  {
    Grafo->capacity[i] = (int *) malloc((sizeof(int)) * v);
  }

  Grafo->flow = (int **) malloc((sizeof(int *)) * v);
  for (i = 0; i < v; i++)
  {
    Grafo->flow[i] = (int *) malloc((sizeof(int)) * v);
  }

  Grafo->transp = (int **) malloc((sizeof(int *)) * v);
  for (i = 0; i < v; i++)
  {
    Grafo->transp[i] = (int *) malloc((sizeof(int)) * v);
  }

  Grafo->visited = (int *) malloc((sizeof(int)) * v);
  Grafo->arrayEst = (int *) malloc((sizeof(int)) * e);
  Grafo->color = (int *) malloc((sizeof(int)) * v);
  Grafo->pred = (int *) malloc((sizeof(int)) * v);
  Grafo->q = (int *) malloc((sizeof(int)) * v);
  Grafo->f = f;
  Grafo->e = e;
  Grafo->t = t;
  Grafo->vertices = v;
  for (i = 0; i < v; i++)
  {
    for (j = 0; j < v; j++)
    {
      Grafo->capacity[i][j] = 0;
    }

  }

  for (i = 0; i < v; i++)
  {
    for (j = 0; j < v; j++)
    {
      Grafo->transp[i][j] = 0;
    }

  }

  for (i = 0; i < v; i++)
  {
    for (j = 0; j < v; j++)
    {
      Grafo->flow[i][j] = 0;
    }

  }

  for (i = 0; i < v; i++)
  {
    Grafo->visited[i] = 0;
  }

  return Grafo;
}

void free_Graph(struct Graph *Grafo, int v, int f, int e, int t)
{
  int i;
  for (i = 0; i < v; i++)
  {
    int *capacity = Grafo->capacity[i];
    free(capacity);
  }

  free(Grafo->capacity);
  for (i = 0; i < v; i++)
  {
    int *flow = Grafo->flow[i];
    free(flow);
  }

  free(Grafo->flow);
  for (i = 0; i < v; i++)
  {
    int *transp = Grafo->transp[i];
    free(transp);
  }

  free(Grafo->transp);
  free(Grafo->visited);
  free(Grafo->arrayEst);
  free(Grafo->color);
  free(Grafo->pred);
  free(Grafo->q);
}

int min(int x, int y)
{
  return (x < y) ? (x) : (y);
}

void enqueue(struct Graph *grafo, int x)
{
  grafo->q[tail] = x;
  tail++;
  grafo->color[x] = 1;
}

int dequeue(struct Graph *grafo)
{
  int x = grafo->q[head];
  head++;
  grafo->color[x] = 2;
  return x;
}

int bfs(struct Graph *grafo, int start, int target)
{
  int u;
  int v;
  int cont = 0;
  for (u = 0; u < grafo->vertices; u++)
  {
    grafo->color[u] = 0;
  }

  head = (tail = 0);
  enqueue(grafo, start);
  grafo->pred[start] = -1;
  while (head != tail)
  {
    u = dequeue(grafo);
    for (v = 0; v < grafo->vertices; v++)
    {
      if ((grafo->color[v] == 0) && ((grafo->capacity[u][v] - grafo->flow[u][v]) > 0))
      {
        enqueue(grafo, v);
        grafo->pred[v] = u;
      }
      else
      {
        
      }

    }

    cont++;
  }

  return grafo->color[target] == 2;
}

int max_flow(struct Graph *grafo, int source, int sink)
{
  int u;
  int max_flow = 0;
  while (bfs(grafo, source, sink))
  {
    int increment = 1000000000;
    for (u = sink; grafo->pred[u] >= 0; u = grafo->pred[u])
    {
      increment = min(increment, grafo->capacity[grafo->pred[u]][u] - grafo->flow[grafo->pred[u]][u]);
    }

    for (u = sink; grafo->pred[u] >= 0; u = grafo->pred[u])
    {
      grafo->flow[grafo->pred[u]][u] += increment;
      grafo->flow[u][grafo->pred[u]] -= increment;
    }

    max_flow += increment;
  }

  return max_flow;
}

void DFS(struct Graph *grafo, int i)
{
  int j;
  grafo->visited[i] = 1;
  for (j = 0; j < grafo->vertices; j++)
    if ((grafo->visited[j] != 1) && (grafo->transp[i][j] != grafo->flow[j][i]))
  {
    DFS(grafo, j);
  }
  else
  {
    
  }


}

int cmpfunc(const void *a, const void *b)
{
  const struct ArrayLig *ca = a;
  const struct ArrayLig *cb = b;
  if (ca->origin == cb->origin)
  {
    return ca->dest - cb->dest;
  }
  else
  {
    
  }

  return ca->origin - cb->origin;
}

void swap(int *a, int *b)
{
  int t = *a;
  *a = *b;
  *b = t;
}

int partition(int *arr, int low, int high)
{
  int j;
  int pivot = arr[high];
  int i = low - 1;
  for (j = low; j <= (high - 1); j++)
  {
    if (arr[j] <= pivot)
    {
      i++;
      swap(&arr[i], &arr[j]);
    }
    else
    {
      
    }

  }

  swap(&arr[i + 1], &arr[high]);
  return i + 1;
}

void quickSort(int *arr, int low, int high)
{
  if (low < high)
  {
    int pi = partition(arr, low, high);
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
  else
  {
    
  }

}

int read_input_fornecedores()
{
  int f;
  f = new_sym_var(sizeof(int) * 8);
  return f;
}

int read_input_estacoes()
{
  int e;
  e = new_sym_var(sizeof(int) * 8);
  return e;
}

int read_input_ligacoes()
{
  int t;
  t = new_sym_var(sizeof(int) * 8);
  return t;
}

void read_input_capFron(struct Graph *grafo, int f)
{
  int i;
  for (i = 2; i < (f + 2); i++)
  {
    grafo->capacity[0][i] = new_sym_var(sizeof(int) * 8);
  }

}

void read_input_capEst(struct Graph *grafo, int f, int e)
{
  int i;
  for (i = f + 2; i < ((e + f) + 2); i++)
  {
    grafo->capacity[i][i + e] = new_sym_var(sizeof(int) * 8);
  }

}

void read_input_fluxo(struct Graph *grafo, int f, int e, int t)
{
  int a;
  int b;
  int c;
  int i;
  for (i = 0; i < t; i++)
  {
    a = new_sym_var(sizeof(int) * 8);
    b = new_sym_var(sizeof(int) * 8);
    c = new_sym_var(sizeof(int) * 8);
    if (a >= (f + 2))
    {
      grafo->capacity[a + e][b] = c;
    }
    else
    {
      grafo->capacity[a][b] = c;
    }

  }

}

void printMatrix(struct Graph *grafo)
{
  int i;
  int j;
  for (i = 0; i < grafo->vertices; i++)
  {
    for (j = 0; j < grafo->vertices; j++)
    {
      printf("%3d ", grafo->capacity[i][j]);
    }

    printf("\n");
  }

  printf("\n");
}

void transpMatrix(struct Graph *grafo)
{
  int i;
  int j;
  for (i = 0; i < grafo->vertices; i++)
  {
    for (j = 0; j < grafo->vertices; j++)
    {
      grafo->transp[j][i] = grafo->capacity[i][j];
    }

  }

}

void printTransp(struct Graph *grafo)
{
  int i;
  int j;
  for (i = 0; i < grafo->vertices; i++)
  {
    for (j = 0; j < grafo->vertices; j++)
    {
      printf("%3d ", grafo->transp[i][j]);
    }

    printf("\n");
  }

  printf("\n");
}

void getMinCut(struct Graph *grafo, struct ArrayLig *arrayLig)
{
  int i;
  int j;
  int Est;
  grafo->countEst = 0;
  grafo->countLig = 0;
  for (i = 0; i < grafo->vertices; i++)
  {
    if (grafo->visited[i] == 1)
    {
      for (j = 0; j < grafo->vertices; j++)
      {
        if ((grafo->transp[i][j] != 0) && (grafo->visited[j] != 1))
        {
          if (((i > (grafo->f + 1)) && (j > (grafo->f + 1))) && (abs(j - i) == grafo->e))
          {
            Est = min(i, j);
            grafo->arrayEst[grafo->countEst] = Est;
            grafo->countEst++;
          }
          else
          {
            if (j != 0)
            {
              if (i > ((grafo->e + grafo->f) + 1))
              {
                arrayLig[grafo->countLig].dest = i - grafo->e;
                arrayLig[grafo->countLig].origin = j;
                grafo->countLig++;
              }
              else
              {
                if (j > ((grafo->e + grafo->f) + 1))
                {
                  arrayLig[grafo->countLig].dest = i;
                  arrayLig[grafo->countLig].origin = j - grafo->e;
                  grafo->countLig++;
                }
                else
                {
                  arrayLig[grafo->countLig].dest = i;
                  arrayLig[grafo->countLig].origin = j;
                  grafo->countLig++;
                }

              }

            }
            else
            {
              
            }

          }

        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

}

int main()
{
  int i;
  int j;
  int f = read_input_fornecedores();
  int e = read_input_estacoes();
  int t = read_input_ligacoes();
  int vertices = (2 + f) + (2 * e);
  struct Graph *newGrafo = alloca_Graph(vertices, f, e, t);
  struct ArrayLig *arrayLig = (struct ArrayLig *) malloc(sizeof(struct ArrayLig));
  read_input_capFron(newGrafo, f);
  read_input_capEst(newGrafo, f, e);
  read_input_fluxo(newGrafo, f, e, t);
  printf("%d\n", max_flow(newGrafo, 0, 1));
  transpMatrix(newGrafo);
  DFS(newGrafo, 1);
  getMinCut(newGrafo, arrayLig);
  quickSort(newGrafo->arrayEst, 0, newGrafo->countEst - 1);
  for (i = 0; i < newGrafo->countEst; i++)
  {
    if ((newGrafo->countEst - 1) == i)
    {
      printf("%d", newGrafo->arrayEst[i]);
    }
    else
    {
      printf("%d ", newGrafo->arrayEst[i]);
    }

  }

  printf("\n");
  qsort(arrayLig, newGrafo->countLig, sizeof(struct ArrayLig), cmpfunc);
  for (j = 0; j < newGrafo->countLig; j++)
  {
    printf("%d ", arrayLig[j].origin);
    printf("%d\n", arrayLig[j].dest);
  }

  free_Graph(newGrafo, vertices, f, e, t);
  free(newGrafo);
  free(arrayLig);
  return 0;
}

