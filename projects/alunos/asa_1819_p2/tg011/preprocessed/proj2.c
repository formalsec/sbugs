/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int fSupliers = 0;
int eStations = 0;
int tLinks = 0;
int nVertex = 0;
struct Vertex
{
  int id;
  int type;
  int capacity;
  struct Vertex *next;
};
struct Link
{
  int source;
  int destination;
  int linkCapacity;
  struct Link *nextLink;
};
struct Network
{
  int nVertex;
  int tLinks;
  struct Vertex **vertexList;
};
struct Vertex *createVertex(int id)
{
  struct Vertex *newVertex;
  newVertex = (struct Vertex *) malloc(sizeof(struct Vertex));
  if (newVertex == 0)
  {
    printf("Error creating a new Vertex.\n");
    exit(0);
  }
  else
  {
    
  }

  newVertex->id = id;
  if (id == 1)
  {
    newVertex->type = 0;
  }
  else
  {
    if ((id > 2) && (id <= (fSupliers + 1)))
    {
      newVertex->type = 1;
    }
    else
    {
      if ((id > (fSupliers + 1)) && (id <= nVertex))
      {
        newVertex->type = 2;
      }
      else
      {
        
      }

    }

  }

  newVertex->capacity = 0;
  newVertex->next = 0;
  return newVertex;
}

struct Network *createNetwork(int nVertex, int tLinks)
{
  struct Network *network = malloc(sizeof(struct Network));
  network->nVertex = nVertex;
  network->tLinks = tLinks;
  network->vertexList = malloc((nVertex + 1) * (sizeof(struct Vertex *)));
  int i;
  for (i = 1; i <= (nVertex + 1); i++)
  {
    struct Vertex *newVertex = createVertex(i);
    network->vertexList[i] = newVertex;
  }

  return network;
}

void printNetwork(struct Network *network)
{
  int i;
  printf("\t------------------------------\n");
  for (i = 1; i <= network->nVertex; i++)
  {
    struct Vertex *auxVertex = network->vertexList[i];
    if ((1 < i) && (i <= (fSupliers + 1)))
    {
      printf("\n\t[SUPLIER] ");
    }
    else
    {
      if (i > (fSupliers + 1))
      {
        printf("\n\t[STATION] ");
      }
      else
      {
        printf("\n\t[HIPER] ");
      }

    }

    printf("Adjacency list of vertex %d\n\t", i);
    while (auxVertex)
    {
      printf("%d -> ", auxVertex->id);
      auxVertex = auxVertex->next;
    }

    printf("NULL\n");
  }

  printf("\t------------------------------\n");
}

void printLinksINFO(struct Link *head)
{
  while (head)
  {
    printf("\tLink de %d para %d com capacidade %d\n", head->source, head->destination, head->linkCapacity);
    head = head->nextLink;
  }

}

void addLink(struct Network *network, int src, int dest, int cap)
{
  struct Vertex *newVertex = createVertex(dest);
  struct Vertex *auxVertex = network->vertexList[src];
  while (auxVertex->next != 0)
  {
    auxVertex = auxVertex->next;
  }

  auxVertex->next = newVertex;
}

struct Link *getLink(int src, int dest)
{
}

int getCapacity(int src, int dest)
{
  return getLink(src, dest)->linkCapacity;
}

int main()
{
  fSupliers = new_sym_var(sizeof(int) * 8);
  eStations = new_sym_var(sizeof(int) * 8);
  tLinks = new_sym_var(sizeof(int) * 8);
  nVertex = (fSupliers + eStations) + 1;
  struct Network *network = createNetwork(nVertex, tLinks);
  struct Link *head = 0;
  if (((fSupliers <= 0) || (eStations < 0)) || (tLinks < 0))
  {
    exit(1);
  }
  else
  {
    
  }

  int i;
  for (i = 2; i <= (fSupliers + 1); i++)
  {
    if (i < (fSupliers + 1))
    {
      network->vertexList[i]->capacity = new_sym_var(sizeof(int) * 8);
    }
    else
    {
      if (i == (fSupliers + 1))
      {
        network->vertexList[i]->capacity = new_sym_var(sizeof(int) * 8);
      }
      else
      {
        
      }

    }

  }

  for (i = fSupliers + 2; i <= nVertex; i++)
  {
    if (i < nVertex)
    {
      network->vertexList[i]->capacity = new_sym_var(sizeof(int) * 8);
    }
    else
    {
      if (i == nVertex)
      {
        network->vertexList[i]->capacity = new_sym_var(sizeof(int) * 8);
      }
      else
      {
        
      }

    }

  }

  int auxSRC;
  int auxDEST;
  int auxCAP;
  for (i = 1; i <= tLinks; i++)
  {
    auxSRC = new_sym_var(sizeof(int) * 8);
    auxDEST = new_sym_var(sizeof(int) * 8);
    auxCAP = new_sym_var(sizeof(int) * 8);
    addLink(network, auxSRC, auxDEST, auxCAP);
    struct Link *newLink = malloc(sizeof(struct Link));
    newLink->source = auxSRC;
    newLink->destination = auxDEST;
    newLink->linkCapacity = auxCAP;
    newLink->nextLink = head;
    head = newLink;
  }

  return 0;
}

