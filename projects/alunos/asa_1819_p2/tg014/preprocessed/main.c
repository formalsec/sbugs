#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>


typedef struct item
{
  int element;
  struct item *next;
} Item;
typedef struct queue
{
  Item *head;
  Item *tail;
} Queue;
typedef struct cutEdge
{
  int from;
  int to;
} CutEdge;
typedef struct edge
{
  int from;
  int to;
  int capacity;
  int flow;
  struct edge *next;
} Edge;
typedef struct node
{
  int excess;
  int height;
  Edge *firstEdge;
} Node;
Node *G = 0;
Queue *queue = 0;
int sizeCutEdgesArray = 20;
int supliers;
int refillStations;
int numberEdges;
int *visited;
int *criticalStation;
int indexCutEdge = 0;
CutEdge *cutEdges;
Queue *allocQueue()
{
  Queue *q = malloc(sizeof(struct queue));
  q->tail = 0;
  q->head = 0;
  return q;
}

int isEmpty(Queue *q)
{
  if (q->head == 0)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void push(Queue *q, int element)
{
  Item *help;
  Item *newItem = malloc(sizeof(struct item));
  if (isEmpty(q))
  {
    newItem->element = element;
    newItem->next = 0;
    q->tail = newItem;
    q->head = newItem;
    return;
  }
  else
  {
    
  }

  newItem->element = element;
  newItem->next = 0;
  help = q->tail;
  help->next = newItem;
  q->tail = newItem;
}

int pop(Queue *q)
{
  Item *help;
  int element;
  if (q->head == 0)
  {
    return -1;
  }
  else
  {
    
  }

  help = q->head;
  element = help->element;
  if (q->head == q->tail)
  {
    q->head = 0;
    q->tail = 0;
  }
  else
  {
    q->head = q->head->next;
  }

  free(help);
  return element;
}

void freeQueue(Queue *q)
{
  Item *help = q->head;
  while (help != 0)
  {
    Item *help2 = help->next;
    if (help2 == 0)
    {
      free(help);
      break;
    }
    else
    {
      
    }

    free(help);
    help = help2;
    help2 = help->next;
  }

  free(q);
}

int residualCapacity(int cap, int flow)
{
  return cap - flow;
}

int indexGraph(int index)
{
  return index - 2;
}

int isStation(int index)
{
  if (index > (supliers + 1))
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void addEdge(int origin, int dest, int capacity)
{
  Edge *newEdge = malloc(sizeof(struct edge));
  Edge *residualEdge = malloc(sizeof(struct edge));
  if (isStation(origin))
  {
    origin = origin + refillStations;
  }
  else
  {
    
  }

  newEdge->from = origin;
  newEdge->to = dest;
  newEdge->capacity = capacity;
  newEdge->flow = 0;
  newEdge->next = 0;
  residualEdge->from = dest;
  residualEdge->to = origin;
  residualEdge->capacity = capacity;
  residualEdge->flow = residualCapacity(capacity, 0);
  residualEdge->next = 0;
  if (G[origin].firstEdge == 0)
  {
    G[origin].firstEdge = newEdge;
  }
  else
  {
    newEdge->next = G[origin].firstEdge;
    G[origin].firstEdge = newEdge;
  }

  if (G[dest].firstEdge == 0)
  {
    G[dest].firstEdge = residualEdge;
  }
  else
  {
    residualEdge->next = G[dest].firstEdge;
    G[dest].firstEdge = residualEdge;
  }

}

void addStationEdge(int origin, int dest, int capacity)
{
  Edge *newEdge = malloc(sizeof(struct edge));
  Edge *residualEdge = malloc(sizeof(struct edge));
  newEdge->from = origin;
  newEdge->to = dest;
  newEdge->capacity = capacity;
  newEdge->flow = 0;
  newEdge->next = 0;
  residualEdge->from = dest;
  residualEdge->to = origin;
  residualEdge->capacity = capacity;
  residualEdge->flow = residualCapacity(capacity, 0);
  residualEdge->next = 0;
  if (G[origin].firstEdge == 0)
  {
    G[origin].firstEdge = newEdge;
  }
  else
  {
    newEdge->next = G[origin].firstEdge;
    G[origin].firstEdge = newEdge;
  }

  if (G[dest].firstEdge == 0)
  {
    G[dest].firstEdge = residualEdge;
  }
  else
  {
    residualEdge->next = G[dest].firstEdge;
    G[dest].firstEdge = residualEdge;
  }

}

void addTarget(int size)
{
  size += refillStations + 1;
  G[size].excess = 0;
  G[size].height = 0;
  G[size].firstEdge = 0;
}

void parseGraph()
{
  int i;
  int size;
  int origin;
  int dest;
  int capacity;
  supliers = new_sym_var(sizeof(int) * 8);
  refillStations = new_sym_var(sizeof(int) * 8);
  numberEdges = new_sym_var(sizeof(int) * 8);
  size = (1 + supliers) + refillStations;
  G = (Node *) malloc((sizeof(Node)) * ((size + refillStations) + 2));
  addTarget(size);
  for (i = 2; i < (size + 1); i++)
  {
    capacity = new_sym_var(sizeof(int) * 8);
    G[i].excess = 0;
    G[i].height = 0;
    G[i].firstEdge = 0;
    if (i < (2 + supliers))
    {
      addEdge(i, (size + refillStations) + 1, capacity);
    }
    else
    {
      G[i + refillStations].firstEdge = 0;
      G[i + refillStations].height = 0;
      G[i + refillStations].excess = 0;
      addStationEdge(i, i + refillStations, capacity);
    }

  }

  for (i = 0; i < numberEdges; i++)
  {
    origin = new_sym_var(sizeof(int) * 8);
    dest = new_sym_var(sizeof(int) * 8);
    capacity = new_sym_var(sizeof(int) * 8);
    addEdge(dest, origin, capacity);
  }

}

void updateReverseEdgeFlow(int origin, int dest, int flow)
{
  Edge *edge = G[origin].firstEdge;
  while (edge != 0)
  {
    if (edge->to == dest)
    {
      edge->flow -= flow;
      return;
    }
    else
    {
      
    }

    edge = edge->next;
  }

}

int min(int a, int b)
{
  if (a == (-1))
  {
    return b;
  }
  else
  {
    
  }

  if (b == (-1))
  {
    return a;
  }
  else
  {
    
  }

  if (a < b)
  {
    return a;
  }
  else
  {
    return b;
  }

}

void InitializePreFlow()
{
  Edge *sourceEdge = G[1].firstEdge;
  G[1].height = (supliers + (refillStations * 2)) + 2;
  G[1].excess = 0;
  while (sourceEdge != 0)
  {
    sourceEdge->flow = sourceEdge->capacity;
    updateReverseEdgeFlow(sourceEdge->to, sourceEdge->from, sourceEdge->flow);
    G[sourceEdge->to].excess = sourceEdge->flow;
    G[sourceEdge->from].excess -= sourceEdge->flow;
    push(queue, sourceEdge->to);
    sourceEdge = sourceEdge->next;
  }

}

int isOverflowed(Edge *edge)
{
  if (edge->capacity == edge->flow)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

int tryPush(int nodeId)
{
  int flowPushed;
  Edge *edge = G[nodeId].firstEdge;
  while (edge != 0)
  {
    if (edge->flow == edge->capacity)
    {
      edge = edge->next;
      continue;
    }
    else
    {
      
    }

    if (G[nodeId].height > G[edge->to].height)
    {
      flowPushed = min(G[nodeId].excess, residualCapacity(edge->capacity, edge->flow));
      if ((G[edge->to].excess == 0) && (edge->to != (((2 + supliers) + refillStations) + refillStations)))
      {
        push(queue, edge->to);
      }
      else
      {
        
      }

      G[nodeId].excess -= flowPushed;
      edge->flow += flowPushed;
      G[edge->to].excess += flowPushed;
      updateReverseEdgeFlow(edge->to, edge->from, flowPushed);
      return 1;
    }
    else
    {
      
    }

    edge = edge->next;
  }

  return 0;
}

void relabel(int nodeId)
{
  Edge *edge = G[nodeId].firstEdge;
  int minHeight = 32767;
  while (edge != 0)
  {
    if (isOverflowed(edge))
    {
      edge = edge->next;
      continue;
    }
    else
    {
      
    }

    if (G[edge->to].height < minHeight)
    {
      minHeight = G[edge->to].height + 1;
    }
    else
    {
      
    }

    edge = edge->next;
  }

  G[nodeId].height = minHeight;
}

void discharge(int nodeId)
{
  while (G[nodeId].excess > 0)
  {
    if (!tryPush(nodeId))
    {
      relabel(nodeId);
    }
    else
    {
      
    }

  }

}

void pushRelabel()
{
  int nodeId;
  queue = allocQueue();
  InitializePreFlow();
  while (!isEmpty(queue))
  {
    nodeId = pop(queue);
    discharge(nodeId);
  }

  freeQueue(queue);
  printf("%d\n", G[(2 + (refillStations * 2)) + supliers].excess);
}

void DFS(int nodeId)
{
  visited[nodeId] = 1;
  Edge *edge = G[nodeId].firstEdge;
  while (edge != 0)
  {
    if ((!visited[edge->to]) && (residualCapacity(edge->capacity, edge->flow) > 0))
    {
      DFS(edge->to);
    }
    else
    {
      
    }

    edge = edge->next;
  }

}

void addCutEdge(int from, int to)
{
  CutEdge edge;
  edge.from = from;
  edge.to = to;
  cutEdges[indexCutEdge++] = edge;
  sizeCutEdgesArray += 20;
  if ((indexCutEdge % 20) > 18)
  {
    cutEdges = realloc(cutEdges, (sizeof(struct cutEdge)) * sizeCutEdgesArray);
  }
  else
  {
    
  }

}

void findMinCutEdges(int nodeId)
{
  Edge *edge = G[nodeId].firstEdge;
  int size = (2 + supliers) + (2 * refillStations);
  while (edge != 0)
  {
    if ((edge->to == size) || (edge->from == size))
    {
      edge = edge->next;
      continue;
    }
    else
    {
      
    }

    if (visited[nodeId] && (!visited[edge->to]))
    {
      if (nodeId >= ((supliers + refillStations) + 2))
      {
        addCutEdge(edge->to, nodeId - refillStations);
      }
      else
      {
        addCutEdge(edge->to, nodeId);
      }

    }
    else
    {
      
    }

    edge = edge->next;
  }

}

int compare(const void *edge1, const void *edge2)
{
  if (((struct cutEdge *) edge1)->from == ((struct cutEdge *) edge2)->from)
  {
    return ((struct cutEdge *) edge1)->to - ((struct cutEdge *) edge2)->to;
  }
  else
  {
    
  }

  return ((struct cutEdge *) edge1)->from - ((struct cutEdge *) edge2)->from;
}

void findMinCut()
{
  int i;
  int size = ((2 + supliers) + refillStations) + refillStations;
  int first = 1;
  visited = malloc((sizeof(int)) * size);
  criticalStation = malloc((sizeof(int)) * (size + 2));
  cutEdges = malloc((sizeof(struct cutEdge)) * 20);
  memset(criticalStation, 0, (sizeof(int)) * (size + 2));
  DFS(1);
  for (i = 1; i < (size + 1); i++)
  {
    if ((i > (1 + supliers)) && (i <= ((supliers + refillStations) + 1)))
    {
      if (visited[i] != visited[i + refillStations])
      {
        criticalStation[i] = 1;
        continue;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    findMinCutEdges(i);
  }

  for (i = 0; i < (size + 1); i++)
  {
    if (criticalStation[i] == 1)
    {
      if (first)
      {
        printf("%d", i);
        first = 0;
      }
      else
      {
        printf(" %d", i);
      }

    }
    else
    {
      
    }

  }

  printf("\n");
  qsort((void *) cutEdges, indexCutEdge, sizeof(struct cutEdge), compare);
  for (i = 0; i < indexCutEdge; i++)
  {
    printf("%d %d\n", cutEdges[i].from, cutEdges[i].to);
  }

  free(criticalStation);
  free(visited);
  free(cutEdges);
}

void freeGraph(Node *G)
{
  int i;
  int size = (2 + supliers) + (refillStations * 2);
  Edge *edge;
  Edge *help;
  for (i = 1; i < (size + 1); i++)
  {
    edge = G[i].firstEdge;
    while (edge != 0)
    {
      help = edge;
      edge = edge->next;
      free(help);
    }

  }

  free(G);
}

int main()
{
  parseGraph();
  pushRelabel();
  findMinCut();
  freeGraph(G);
  return 0;
}

