#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <limits.h>


typedef enum 
{
  false,
  true
} bool;
typedef struct linkList
{
  int n;
  struct linkList *next;
} linkList;
typedef struct connection
{
  int n;
  int cap;
  int flux;
  struct connection *dual;
  struct connection *next;
} connection;
typedef struct coordinates
{
  int origin;
  int destination;
} coordinates;
typedef struct node
{
  int height;
  int overflow;
  bool suplier;
  bool src;
  struct connection *current;
  struct connection *next;
} node;
void freeAll(node *nodes, int numNodes, int *abastecimentos, coordinates *caminhos, int *src_trg, int *heights)
{
  connection *link;
  connection *aux;
  int i;
  for (i = 0; i < numNodes; i++)
  {
    link = nodes[i].next;
    while (link != 0)
    {
      aux = link;
      link = link->next;
      free(aux);
    }

  }

  free(nodes);
  free(abastecimentos);
  free(caminhos);
  free(src_trg);
  free(heights);
}

int cmpfunc(const void *a, const void *b)
{
  return (*((int *) a)) - (*((int *) b));
}

int cmpfunc2(const void *a, const void *b)
{
  coordinates *pa = (coordinates *) a;
  coordinates *pb = (coordinates *) b;
  if (pa->origin != pb->origin)
  {
    return pa->origin - pb->origin;
  }
  else
  {
    return pa->destination - pb->destination;
  }

}

void addToQueue(linkList **init, linkList **fin, int n)
{
  if ((*init) == 0)
  {
    *init = (linkList *) malloc(sizeof(linkList));
    (*init)->n = n;
    (*init)->next = 0;
    *fin = *init;
  }
  else
  {
    (*fin)->next = (linkList *) malloc(sizeof(linkList));
    *fin = (*fin)->next;
    (*fin)->n = n;
    (*fin)->next = 0;
  }

}

int removeFromQueue(linkList **init)
{
  int num;
  linkList *aux = *init;
  *init = (*init)->next;
  num = aux->n;
  free(aux);
  return num;
}

void fluxoInicial(int s, int V, node *nodes, linkList **init, linkList **fin)
{
  nodes[s].height = V;
  connection *link = nodes[s].next;
  while (link != 0)
  {
    link->flux = link->cap;
    nodes[link->n].overflow = link->flux;
    link->dual->flux = -link->flux;
    addToQueue(init, fin, link->n);
    link = link->next;
  }

}

void relabel(node *nodes, int u)
{
  int maxH = 32767;
  connection *link = nodes[u].next;
  while (link != 0)
  {
    if (((link->flux == link->cap) && (link->cap > 0)) || ((link->flux == 0) && (link->cap < 0)))
    {
      link = link->next;
      continue;
    }
    else
    {
      
    }

    if (nodes[link->n].height < maxH)
    {
      maxH = nodes[link->n].height;
      nodes[u].height = maxH + 1;
    }
    else
    {
      
    }

    link = link->next;
  }

}

void push(node *nodes, int u, linkList **init, linkList **fin)
{
  int flux;
  if (nodes[u].current == 0)
  {
    nodes[u].current = nodes[u].next;
  }
  else
  {
    
  }

  while (nodes[u].current != 0)
  {
    if ((nodes[u].current->flux == nodes[u].current->cap) && (nodes[u].current->cap > 0))
    {
      nodes[u].current = nodes[u].current->next;
      continue;
    }
    else
    {
      
    }

    if ((nodes[u].height > nodes[nodes[u].current->n].height) && (nodes[u].current->cap > 0))
    {
      flux = ((nodes[u].current->cap - nodes[u].current->flux) < nodes[u].overflow) ? (nodes[u].current->cap - nodes[u].current->flux) : (nodes[u].overflow);
      nodes[u].overflow -= flux;
      if (((nodes[nodes[u].current->n].overflow == 0) && (nodes[u].current->n != 1)) && (nodes[u].current->n != 0))
      {
        addToQueue(init, fin, nodes[u].current->n);
      }
      else
      {
        
      }

      nodes[nodes[u].current->n].overflow += flux;
      nodes[u].current->flux += flux;
      nodes[u].current->dual->flux -= flux;
      if (nodes[u].overflow == 0)
      {
        return;
      }
      else
      {
        
      }

    }
    else
    {
      if (nodes[u].height > nodes[nodes[u].current->n].height)
      {
        flux = (((nodes[u].current->flux > 0) ? (nodes[u].current->flux) : (-nodes[u].current->flux)) < nodes[u].overflow) ? ((nodes[u].current->flux > 0) ? (nodes[u].current->flux) : (-nodes[u].current->flux)) : (nodes[u].overflow);
        nodes[u].overflow -= flux;
        if (((nodes[nodes[u].current->n].overflow == 0) && (nodes[u].current->n != 1)) && (nodes[u].current->n != 0))
        {
          addToQueue(init, fin, nodes[u].current->n);
        }
        else
        {
          
        }

        nodes[nodes[u].current->n].overflow += flux;
        nodes[u].current->flux += flux;
        nodes[u].current->dual->flux -= flux;
        if (nodes[u].overflow == 0)
        {
          return;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    nodes[u].current = nodes[u].current->next;
  }

  return;
}

void fluxoMaximo(node *nodes, linkList **init, linkList **fin)
{
  while ((*init) != 0)
  {
    int u = removeFromQueue(init);
    while (1)
    {
      push(nodes, u, init, fin);
      if (nodes[u].overflow != 0)
      {
        relabel(nodes, u);
      }
      else
      {
        break;
      }

    }

  }

}

void calculateAux(node *nodes, int s, int numNodes, int **src_trg, int *vctr_size)
{
  int i;
  for (i = 1; i < numNodes; i++)
  {
    connection *link = nodes[i].next;
    while (link != 0)
    {
      if (((nodes[i].src == true) && (nodes[link->n].src == false)) && (link->cap > 0))
      {
        *vctr_size += 2;
        *src_trg = (int *) realloc(*src_trg, (sizeof(int)) * (*vctr_size));
        (*src_trg)[(*vctr_size) - 2] = i;
        (*src_trg)[(*vctr_size) - 1] = link->n;
      }
      else
      {
        
      }

      link = link->next;
    }

  }

}

int main()
{
  int vctr_size = 0;
  int *src_trg = (int *) malloc((sizeof(int)) * vctr_size);
  node *nodes;
  linkList *init = 0;
  linkList *fin = 0;
  int numFornecedores;
  int numAbastecimento;
  int numLigacoes;
  int numNodes;
  int index = 0;
  int i;
  int j;
  int abastecimentos_size;
  int *abastecimentos;
  int cut;
  int err;
  int max;
  int maxi;
  int *heights;
  int origin;
  int dest;
  int cap;
  err = 3;
  numFornecedores = new_sym_var(sizeof(int) * 8);
  numAbastecimento = new_sym_var(sizeof(int) * 8);
  numLigacoes = new_sym_var(sizeof(int) * 8);
  if (err == (-1))
  {
    printf("Error occurred.\n");
  }
  else
  {
    
  }

  numNodes = (numFornecedores + (numAbastecimento * 2)) + 2;
  nodes = (node *) malloc((sizeof(node)) * numNodes);
  for (i = 0; i < numNodes; i++)
  {
    nodes[i].height = 0;
    nodes[i].overflow = 0;
    nodes[i].current = 0;
    nodes[i].next = 0;
    nodes[i].suplier = false;
  }

  nodes[1].height = numNodes;
  nodes[0].next = (connection *) malloc(sizeof(connection));
  nodes[0].next->n = 0;
  nodes[0].next->cap = 0;
  nodes[0].next->flux = 0;
  for (index = 2; index < (numFornecedores + 2); index++)
  {
    err = 1;
    cap = new_sym_var(sizeof(int) * 8);
    if (err == (-1))
    {
      printf("Error occurred.\n");
    }
    else
    {
      
    }

    nodes[index].suplier = true;
    nodes[index].next = (connection *) malloc(sizeof(connection));
    connection *link = nodes[index].next;
    link->n = 0;
    link->cap = cap;
    link->flux = 0;
    link->next = 0;
    link->dual = nodes[0].next;
  }

  for (index = numFornecedores + 2; index < (numNodes - numAbastecimento); index++)
  {
    err = 1;
    cap = new_sym_var(sizeof(int) * 8);
    if (err == (-1))
    {
      printf("Error occurred.\n");
    }
    else
    {
      
    }

    nodes[index].suplier = false;
    nodes[index].next = (connection *) malloc(sizeof(connection));
    connection *link = nodes[index].next;
    link->n = index + numAbastecimento;
    link->cap = cap;
    link->flux = 0;
    link->next = 0;
    nodes[index + numAbastecimento].suplier = false;
    nodes[index + numAbastecimento].next = (connection *) malloc(sizeof(connection));
    connection *link2 = nodes[index + numAbastecimento].next;
    link2->n = index;
    link2->cap = -cap;
    link2->flux = 0;
    link2->next = 0;
    link->dual = link2;
    link2->dual = link;
  }

  index = 0;
  while (index < numLigacoes)
  {
    err = 3;
    origin = new_sym_var(sizeof(int) * 8);
    dest = new_sym_var(sizeof(int) * 8);
    cap = new_sym_var(sizeof(int) * 8);
    if (err == (-1))
    {
      printf("Error occurred.\n");
    }
    else
    {
      
    }

    if ((nodes[dest].suplier == false) && (dest >= (2 + numFornecedores)))
    {
      dest += numAbastecimento;
    }
    else
    {
      
    }

    connection *previous = nodes[origin].next;
    nodes[origin].next = (connection *) malloc(sizeof(connection));
    nodes[origin].next->n = dest;
    nodes[origin].next->cap = -cap;
    nodes[origin].next->flux = 0;
    nodes[origin].next->next = previous;
    previous = nodes[dest].next;
    nodes[dest].next = (connection *) malloc(sizeof(connection));
    nodes[dest].next->n = origin;
    nodes[dest].next->cap = cap;
    nodes[dest].next->flux = 0;
    nodes[dest].next->next = previous;
    nodes[origin].next->dual = nodes[dest].next;
    nodes[dest].next->dual = nodes[origin].next;
    index++;
  }

  fluxoInicial(1, numNodes, nodes, &init, &fin);
  fluxoMaximo(nodes, &init, &fin);
  max = nodes[0].overflow;
  printf("%d\n", max);
  maxi = numNodes + 1;
  heights = (int *) malloc((sizeof(int)) * (maxi + 1));
  for (i = 0; i < maxi; i++)
    heights[i] = 0;

  for (i = 0; i < numNodes; i++)
  {
    if (nodes[i].height >= (numNodes + 1))
    {
      heights[maxi]++;
    }
    else
    {
      heights[nodes[i].height]++;
    }

  }

  cut = numNodes;
  while (heights[cut] != 0)
  {
    cut--;
  }

  nodes[1].src = true;
  nodes[0].src = false;
  for (i = 2; i < numNodes; i++)
  {
    if (nodes[i].height > cut)
    {
      nodes[i].src = true;
    }
    else
    {
      nodes[i].src = false;
    }

  }

  calculateAux(nodes, 1, numNodes, &src_trg, &vctr_size);
  abastecimentos_size = 0;
  abastecimentos = (int *) malloc((sizeof(int)) * numAbastecimento);
  coordinates *caminhos = (coordinates *) malloc((sizeof(coordinates)) * (vctr_size / 2));
  j = 0;
  for (i = 0; i < vctr_size; i += 2)
  {
    if (src_trg[i] >= (numNodes - numAbastecimento))
    {
      src_trg[i] -= numAbastecimento;
    }
    else
    {
      if (src_trg[i + 1] >= (numNodes - numAbastecimento))
      {
        src_trg[i + 1] -= numAbastecimento;
      }
      else
      {
        
      }

    }

    if ((src_trg[i] == 1) || (src_trg[i + 1] == 1))
    {
      caminhos[j].origin = src_trg[i + 1];
      caminhos[j++].destination = src_trg[i];
    }
    else
    {
      if (((nodes[src_trg[i]].suplier == false) && (nodes[src_trg[i + 1]].suplier == false)) && (src_trg[i + 1] == src_trg[i]))
      {
        abastecimentos_size = abastecimentos_size + 1;
        abastecimentos[abastecimentos_size - 1] = src_trg[i];
      }
      else
      {
        if (nodes[src_trg[i]].suplier == false)
        {
          caminhos[j].origin = src_trg[i + 1];
          caminhos[j++].destination = src_trg[i];
        }
        else
        {
          
        }

      }

    }

  }

  qsort(abastecimentos, abastecimentos_size, sizeof(int), cmpfunc);
  if (abastecimentos_size >= 1)
  {
    printf("%d", abastecimentos[0]);
    for (i = 1; i <= (abastecimentos_size - 1); i++)
    {
      printf(" %d", abastecimentos[i]);
    }

  }
  else
  {
    
  }

  printf("\n");
  qsort(caminhos, j, sizeof(coordinates), cmpfunc2);
  for (i = 0; i < j; i++)
  {
    printf("%d %d\n", caminhos[i].origin, caminhos[i].destination);
  }

  freeAll(nodes, numNodes, abastecimentos, caminhos, src_trg, heights);
  return 0;
}

