/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


typedef unsigned char bool;
typedef int Vertex;
void vertex_print(Vertex u)
{
  (u == 0) ? (printf("s")) : ((u == 1) ? (printf("t")) : (printf("%d", u)));
}

int cmp_vertex(const void *a, const void *b)
{
  return (*((const Vertex *) a)) - (*((const Vertex *) b));
}

typedef int Edge;
typedef struct queue
{
  int front;
  int rear;
  Vertex *data;
  bool *in_queue;
} Queue;
void queue_new(Queue *q, size_t size, bool refcount)
{
  q->data = malloc((size + 1) * (sizeof(*q->data)));
  q->in_queue = (refcount) ? (calloc(size + 1, sizeof(*q->in_queue))) : (0);
  q->front = (q->rear = 0);
}

void queue_destroy(Queue *q)
{
  free(q->data);
  q->data = 0;
  free(q->in_queue);
  q->in_queue = 0;
}

bool queue_in_queue(Queue *q, Vertex u)
{
  return (q->in_queue) ? (q->in_queue[u]) : (0);
}

void queue_push(Queue *q, Vertex u)
{
  if (queue_in_queue(q, u))
  {
    return;
  }
  else
  {
    
  }

  q->data[q->rear++] = u;
  if (q->in_queue)
  {
    q->in_queue[u] = 1;
  }
  else
  {
    
  }

}

Vertex queue_pop(Queue *q)
{
  Vertex u = q->data[q->front++];
  if (q->in_queue)
  {
    q->in_queue[u] = 0;
  }
  else
  {
    
  }

  return u;
}

int queue_size(Queue *q)
{
  return q->rear - q->front;
}

bool queue_is_empty(Queue *q)
{
  return q->front == q->rear;
}

void queue_reset(Queue *q)
{
  if (q->in_queue)
  {
    memset(q->in_queue, 0, q->rear * (sizeof(*q->in_queue)));
  }
  else
  {
    
  }

  q->front = (q->rear = 0);
}

void queue_sort(Queue *q)
{
  int size = queue_size(q);
  qsort(q->data, size, sizeof(*q->data), cmp_vertex);
}

typedef struct graph
{
  int nr_vertices;
  int nr_edges;
  Edge *first;
  Vertex *vertex;
  Edge *next;
  Edge *prev;
  int *flow;
  int *capacity;
  int *v_minimum;
} Graph;
Edge graph_find_next_edge(Graph *g, Vertex u, Vertex v)
{
  Edge e = g->first[u];
  while ((g->next[e] != 0) && (g->vertex[e] != v))
    e = g->next[e];

  return e;
}

Edge graph_find_edge(Graph *g, Vertex u, Vertex v)
{
  Edge e = g->first[u];
  while ((e != 0) && (g->vertex[e] != v))
    e = g->next[e];

  return e;
}

void graph_find_vertices(Graph *g, Vertex *u, Vertex *v, Edge e)
{
  *u = g->vertex[e];
  *v = g->vertex[g->prev[e]];
}

Edge graph_connect(Graph *g, Vertex u, Vertex v)
{
  Edge edge = ++g->nr_edges;
  g->vertex[edge] = v;
  if (g->first[u] == 0)
  {
    g->first[u] = edge;
  }
  else
  {
    Edge adj = graph_find_next_edge(g, u, v);
    if (g->vertex[adj] == v)
    {
      g->vertex[g->nr_edges--] = -1;
      return adj;
    }
    else
    {
      
    }

    g->next[adj] = edge;
  }

  return edge;
}

void graph_add_edge(Graph *g, Vertex u, Vertex v)
{
  int num;
  Edge e = graph_connect(g, u, v);
  num = new_sym_var(sizeof(int) * 8);
  g->capacity[e] = num;
  g->prev[e] = graph_connect(g, v, u);
  g->prev[g->prev[e]] = e;
}

void graph_new(Graph *g, int num_v, int num_e)
{
  g->nr_vertices = num_v;
  g->nr_edges = 0;
  num_e *= 2;
  g->first = calloc(num_v + 1, sizeof(*g->first));
  g->vertex = malloc((num_e + 1) * (sizeof(*g->vertex)));
  memset(g->vertex, -1, (num_e + 1) * (sizeof(*g->vertex)));
  g->next = calloc(num_e + 1, sizeof(*g->next));
  g->prev = calloc(num_e + 1, sizeof(*g->prev));
  g->flow = calloc(num_e + 1, sizeof(*g->flow));
  g->capacity = calloc(num_e + 1, sizeof(*g->capacity));
  g->v_minimum = calloc(num_v + 1, sizeof(*g->v_minimum));
}

void graph_init(Graph *g, int num_e)
{
  while ((num_e--) > 0)
  {
    int num1;
    int num2;
    Vertex u;
    Vertex v;
    num1 = new_sym_var(sizeof(int) * 8);
    num2 = new_sym_var(sizeof(int) * 8);
    u = num1;
    v = num2;
    graph_add_edge(g, u, v);
  }

}

void graph_add_sources(Graph *g, int vertices, Vertex v)
{
  Vertex u = 0;
  int i;
  for (i = 0, v = v + 1; i < vertices; v = v + 1, i++)
  {
    graph_add_edge(g, u, v);
  }

}

void graph_add_stops(Graph *g, int vertices, Vertex v)
{
  int i;
  for (i = 0, v = v + 1; i < vertices; v = v + 1, i++)
  {
    int num;
    num = new_sym_var(sizeof(int) * 8);
    g->v_minimum[v] = num;
  }

}

void graph_print(Graph *g)
{
  Vertex u;
  Edge adj;
  for (u = 0; u <= g->nr_vertices; u = u + 1)
    for (adj = g->first[u]; adj != 0; adj = g->next[adj])
  {
    Vertex v = g->vertex[adj];
    if ((adj % 2) == 0)
    {
      continue;
    }
    else
    {
      
    }

    vertex_print(u);
    printf(" -- %3d --> ", g->capacity[adj]);
    vertex_print(v);
    if (g->v_minimum[v] != 0)
    {
      printf(" -- %3d --> ", g->v_minimum[v]);
      vertex_print(v);
      printf("'");
    }
    else
    {
      
    }

    printf("\n");
  }


}

void graph_destroy(Graph *g)
{
  free(g->first);
  g->first = 0;
  free(g->vertex);
  g->vertex = 0;
  free(g->next);
  g->next = 0;
  free(g->prev);
  g->prev = 0;
  free(g->flow);
  g->flow = 0;
  free(g->capacity);
  g->capacity = 0;
  free(g->v_minimum);
  g->v_minimum = 0;
}

typedef struct 
{
  int value;
  int *level;
  Queue q_data;
  Queue *q;
  Queue q_stations;
  Queue *stations;
  Queue q_edges;
  Queue *edges;
} MaxFlow;
void maxflow_new(MaxFlow *mf, Graph *g)
{
  mf->value = 0;
  mf->level = malloc((g->nr_vertices + 1) * (sizeof(*mf->level)));
  mf->q = &mf->q_data;
  mf->stations = &mf->q_stations;
  mf->edges = &mf->q_edges;
  queue_new(mf->q, g->nr_vertices + 1, 1);
  queue_new(mf->stations, g->nr_vertices + 1, 1);
  queue_new(mf->edges, g->nr_edges + 1, 1);
}

void maxflow_output(MaxFlow *mf, Graph *g)
{
  int i;
  int size;
  Vertex *edges[2];
  printf("%d\n", mf->value);
  size = queue_size(mf->stations);
  queue_sort(mf->stations);
  for (i = 0; i < size; i++)
  {
    Vertex u = queue_pop(mf->stations);
    printf("%d", u);
    if ((i + 1) < size)
    {
      printf(" ");
    }
    else
    {
      
    }

  }

  printf("\n");
  size = queue_size(mf->edges);
  edges[0] = calloc(size, sizeof(*edges[0]));
  edges[1] = calloc(size, sizeof(*edges[1]));
  for (i = 0; i < size; i++)
  {
    Vertex u;
    Vertex v;
    Edge e = queue_pop(mf->edges);
    graph_find_vertices(g, &u, &v, e);
    edges[0][i] = u;
    edges[1][i] = v;
  }

  qsort(edges[0], size, sizeof(*edges[0]), cmp_vertex);
  qsort(edges[1], size, sizeof(*edges[0]), cmp_vertex);
  for (i = 0; i < size; i++)
  {
    Vertex u = edges[0][i];
    Vertex v = edges[1][i];
    if (u == 0)
    {
      continue;
    }
    else
    {
      
    }

    printf("%d %d\n", u, v);
  }

  free(edges[0]);
  free(edges[1]);
}

void maxflow_destroy(MaxFlow *mf)
{
  free(mf->level);
  mf->level = 0;
  queue_destroy(mf->q);
  mf->q = 0;
  queue_destroy(mf->stations);
  mf->stations = 0;
  queue_destroy(mf->edges);
  mf->edges = 0;
}

bool bfs_minimum_cut(Graph *g, MaxFlow *mf, Vertex start)
{
  int max_flow = 0;
  queue_reset(mf->q);
  queue_push(mf->q, start);
  while (!queue_is_empty(mf->q))
  {
    Edge adj;
    Vertex u = queue_pop(mf->q);
    for (adj = g->first[u]; adj > 0; adj = g->next[adj])
    {
      Vertex v = g->vertex[adj];
      Edge e = g->prev[adj];
      int cap;
      int flow;
      if ((adj % 2) != 0)
      {
        continue;
      }
      else
      {
        
      }

      cap = g->capacity[e];
      flow = g->flow[e];
      if (flow)
      {
        if (flow == cap)
        {
          queue_push(mf->edges, adj);
          max_flow += flow;
        }
        else
        {
          if (flow == g->v_minimum[v])
          {
            queue_push(mf->stations, v);
            max_flow += flow;
          }
          else
          {
            queue_push(mf->q, v);
          }

        }

      }
      else
      {
        
      }

      if (max_flow == mf->value)
      {
        return 1;
      }
      else
      {
        
      }

    }

  }

  if (max_flow != mf->value)
  {
    queue_reset(mf->edges);
  }
  else
  {
    
  }

  return max_flow == mf->value;
}

bool bfs_update_level(Graph *g, MaxFlow *mf)
{
  queue_reset(mf->q);
  memset(mf->level, -1, (g->nr_vertices + 1) * (sizeof(*mf->level)));
  queue_push(mf->q, 0);
  mf->level[0] = 0;
  while (!queue_is_empty(mf->q))
  {
    Edge adj;
    Vertex u = queue_pop(mf->q);
    for (adj = g->first[u]; adj > 0; adj = g->next[adj])
    {
      Vertex v = g->vertex[adj];
      int cap = (g->v_minimum[u] != 0) ? ((g->v_minimum[u] > g->capacity[adj]) ? (g->capacity[adj]) : (g->v_minimum[u])) : (g->capacity[adj]);
      cap -= g->flow[adj];
      if ((mf->level[v] < 0) && (0 < cap))
      {
        mf->level[v] = mf->level[u] + 1;
        queue_push(mf->q, v);
      }
      else
      {
        
      }

    }

  }

  return mf->level[1] >= 0;
}

int send_flow(Graph *g, Vertex u, int flow, MaxFlow *mf)
{
  Edge adj;
  if (u == 1)
  {
    return flow;
  }
  else
  {
    
  }

  for (adj = g->first[u]; adj != 0; adj = g->next[adj])
  {
    Vertex v = g->vertex[adj];
    int cap = (g->v_minimum[u] != 0) ? ((g->v_minimum[u] > g->capacity[adj]) ? (g->capacity[adj]) : (g->v_minimum[u])) : (g->capacity[adj]);
    cap -= g->flow[adj];
    if ((mf->level[v] == (mf->level[u] + 1)) && (0 < cap))
    {
      int curr_flow = (flow > cap) ? (cap) : (flow);
      int temp_flow = send_flow(g, v, curr_flow, mf);
      if (temp_flow > 0)
      {
        Edge rev = g->prev[adj];
        g->flow[adj] += temp_flow;
        g->flow[rev] -= temp_flow;
        return temp_flow;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return 0;
}

int dinic(Graph *g, MaxFlow *mf)
{
  while (bfs_update_level(g, mf))
  {
    int flow;
    while (flow = send_flow(g, 0, 0x7fffffff, mf))
    {
      mf->value += flow;
    }

  }

  bfs_minimum_cut(g, mf, 1);
  return mf->value;
}

void apply(Graph *g)
{
  MaxFlow mf;
  maxflow_new(&mf, g);
  dinic(g, &mf);
  maxflow_output(&mf, g);
  maxflow_destroy(&mf);
}

int main(void)
{
  int f;
  int e;
  int t;
  Graph g;
  f = new_sym_var(sizeof(int) * 8);
  e = new_sym_var(sizeof(int) * 8);
  t = new_sym_var(sizeof(int) * 8);
  graph_new(&g, (f + e) + 1, f + t);
  graph_add_sources(&g, f, 1);
  graph_add_stops(&g, e, f + 1);
  graph_init(&g, t);
  apply(&g);
  graph_destroy(&g);
  return 0;
}

