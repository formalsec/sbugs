#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stdio.h>


int NODES;
int INFINITO = 999999;
int INFINITE;
int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

void push(int **C, int **F, int *excess, int u, int v)
{
  int send = min(excess[u], C[u][v] - F[u][v]);
  F[u][v] += send;
  F[v][u] -= send;
  excess[u] -= send;
  excess[v] += send;
}

void relabel(int **C, int **F, int *height, int u)
{
  int v;
  int min_height = INFINITE;
  for (v = 0; v < NODES; v++)
  {
    if ((C[u][v] - F[u][v]) > 0)
    {
      min_height = min(min_height, height[v]);
      height[u] = min_height + 1;
    }
    else
    {
      
    }

  }

}

void discharge(int **C, int **F, int *excess, int *height, int *seen, int u)
{
  while (excess[u] > 0)
  {
    if (seen[u] < NODES)
    {
      int v = seen[u];
      if (((C[u][v] - F[u][v]) > 0) && (height[u] > height[v]))
      {
        push(C, F, excess, u, v);
      }
      else
      {
        seen[u] += 1;
      }

    }
    else
    {
      relabel(C, F, height, u);
      seen[u] = 0;
    }

  }

}

void moveToFront(int i, int *A)
{
  int temp = A[i];
  int n;
  for (n = i; n > 0; n--)
  {
    A[n] = A[n - 1];
  }

  A[0] = temp;
}

int pushRelabel(int **C, int **F, int source, int sink, int inf)
{
  int *excess;
  int *height;
  int *list;
  int *seen;
  int i;
  int p;
  int maxflow = 0;
  INFINITE = inf;
  excess = (int *) calloc(NODES, sizeof(int));
  height = (int *) calloc(NODES, sizeof(int));
  seen = (int *) calloc(NODES, sizeof(int));
  list = (int *) calloc(NODES - 2, sizeof(int));
  for (i = 0, p = 0; i < NODES; i++)
  {
    if ((i != source) && (i != sink))
    {
      list[p] = i;
      p++;
    }
    else
    {
      
    }

  }

  height[source] = NODES;
  excess[source] = INFINITE;
  for (i = 0; i < NODES; i++)
    push(C, F, excess, source, i);

  p = 0;
  while (p < (NODES - 2))
  {
    int u = list[p];
    int old_height = height[u];
    discharge(C, F, excess, height, seen, u);
    if (height[u] > old_height)
    {
      moveToFront(p, list);
      p = 0;
    }
    else
    {
      p += 1;
    }

  }

  for (i = 0; i < NODES; i++)
    maxflow += F[source][i];

  free(list);
  free(seen);
  free(height);
  free(excess);
  return maxflow;
}

int main()
{
  int i;
  int j;
  int k = 0;
  int f;
  int e;
  int t;
  int origin;
  int destination;
  int cap;
  int *hi;
  int *hiAux;
  int *hiFinal;
  int *aumentarOrig;
  int *aumentarDest;
  int *abast;
  int **flow;
  int **capacities;
  int a;
  f = new_sym_var(sizeof(int) * 8);
  e = new_sym_var(sizeof(int) * 8);
  t = new_sym_var(sizeof(int) * 8);
  NODES = (f + e) + 1;
  flow = (int **) calloc(NODES, sizeof(int *));
  capacities = (int **) calloc(NODES, sizeof(int *));
  for (i = 0; i < NODES; i++)
  {
    flow[i] = (int *) calloc(NODES, sizeof(int));
    capacities[i] = (int *) calloc(NODES, sizeof(int));
  }

  hi = (int *) calloc(NODES, sizeof(int *));
  hiAux = (int *) calloc(NODES, sizeof(int *));
  hiFinal = (int *) calloc(NODES, sizeof(int *));
  abast = (int *) calloc(e, sizeof(int *));
  aumentarOrig = (int *) calloc(t, sizeof(int *));
  aumentarDest = (int *) calloc(t, sizeof(int *));
  for (i = 0; i < f; i++)
  {
    hi[1 + i] = new_sym_var(sizeof(int) * 8);
    hiAux[1 + i] = hi[1 + i];
    hiFinal[1 + i] = 0;
  }

  for (i = 0; i < e; i++)
  {
    hi[(f + 1) + i] = new_sym_var(sizeof(int) * 8);
    hiAux[(f + 1) + i] = hi[(f + 1) + i];
    hiFinal[(f + 1) + i] = 0;
  }

  for (i = 0; i < t; i++)
  {
    origin = new_sym_var(sizeof(int) * 8);
    destination = new_sym_var(sizeof(int) * 8);
    cap = new_sym_var(sizeof(int) * 8);
    capacities[origin - 1][destination - 1] = cap;
  }

  hi[0] = 0;
  hiAux[0] = 0;
  hiFinal[0] = 0;
  for (i = 1; i < (f + 1); i++)
  {
    for (j = 0; j < NODES; j++)
    {
      if (capacities[i][j] > 0)
      {
        if (j == 0)
        {
          hi[j] = hi[j] + min(hi[i], capacities[i][j]);
          hiAux[j] = 0;
          if ((hi[i] > capacities[i][j]) || (hi[i] == capacities[i][j]))
          {
            aumentarOrig[k] = i + 1;
            aumentarDest[k] = j + 1;
            k = k + 1;
          }
          else
          {
            
          }

        }
        else
        {
          a = min(pushRelabel(capacities, flow, i, j, hi[i]), hiAux[j]);
          if (j >= (e + 1))
          {
            if ((hi[i] > capacities[i][j]) && (capacities[i][j] > hiAux[j]))
            {
              abast[(j - f) - 1] = j + 1;
            }
            else
            {
              
            }

          }
          else
          {
            
          }

          hiAux[j] = hiAux[j] - a;
          if (((hi[i] - a) > 0) && (hiAux[j] > 0))
          {
            aumentarOrig[k] = i + 1;
            aumentarDest[k] = j + 1;
            k = k + 1;
          }
          else
          {
            
          }

          hiFinal[j] = hiFinal[j] + a;
        }

      }
      else
      {
        
      }

    }

  }

  for (i = f + 1; i < NODES; i++)
  {
    for (j = 0; j < NODES; j++)
    {
      if (capacities[i][j] > 0)
      {
        if (j == 0)
        {
          hi[j] = hi[j] + min(hiFinal[i], capacities[i][j]);
          hiAux[j] = 0;
          if ((hi[i] > capacities[i][j]) || (hi[i] == capacities[i][j]))
          {
            aumentarOrig[k] = i + 1;
            aumentarDest[k] = j + 1;
            k = k + 1;
          }
          else
          {
            
          }

        }
        else
        {
          a = min(pushRelabel(capacities, flow, i, j, hiFinal[i]), hiAux[j]);
          hiAux[j] = hiAux[j] - a;
        }

      }
      else
      {
        
      }

    }

  }

  printf("%d\n", hi[0]);
  for (i = 0; i < e; i++)
  {
    if (abast[i] > 0)
    {
      printf("%d", abast[i]);
      if (i != (e - 1))
      {
        printf(" ");
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  printf("\n");
  for (i = 0; i < t; i++)
  {
    if ((aumentarOrig[i] > 0) && (aumentarDest[i] > 0))
    {
      printf("%d %d\n", aumentarOrig[i], aumentarDest[i]);
    }
    else
    {
      
    }

  }

  free(hi);
  free(hiAux);
  free(hiFinal);
  free(abast);
  free(aumentarOrig);
  free(aumentarDest);
  return 0;
}

