#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stdio.h>


typedef struct List
{
  struct Node *node;
  struct List *next;
} List;
typedef struct Node
{
  int grade;
  int visited;
  struct List *head;
} Node;
typedef struct Graph
{
  int n_students;
  int n_friendships;
  Node *lst_Nodes;
} Graph;
Graph *creategraph()
{
  Graph *new_graph = malloc(sizeof(Graph));
  new_graph->n_students = new_sym_var(sizeof(int) * 8);
  new_graph->n_friendships = new_sym_var(sizeof(int) * 8);
  new_graph->lst_Nodes = calloc(new_graph->n_students, sizeof(Node));
  return new_graph;
}

void create_students(Graph *graph)
{
  int i;
  for (i = 0; i < graph->n_students; i++)
  {
    Node *student = &graph->lst_Nodes[i];
    student->grade = new_sym_var(sizeof(int) * 8);
    student->visited = -1;
    student->head = 0;
  }

}

void read_friendships(Graph *graph)
{
  int i;
  int i_student1;
  int i_student2;
  for (i = 0; i < graph->n_friendships; i++)
  {
    i_student1 = new_sym_var(sizeof(int) * 8);
    i_student2 = new_sym_var(sizeof(int) * 8);
    i_student1 = i_student1 - 1;
    i_student2 = i_student2 - 1;
    Node *student1 = &graph->lst_Nodes[i_student1];
    Node *student2 = &graph->lst_Nodes[i_student2];
    if (student1->head)
    {
      List *adj = (List *) malloc(sizeof(List));
      adj->next = student1->head;
      student1->head = adj;
      student1->head->node = student2;
    }
    else
    {
      student1->head = (List *) malloc(sizeof(List));
      ;
      student1->head->node = student2;
    }

  }

}

void print_grades(Graph *graph)
{
  int i;
  for (i = 0; i < graph->n_students; i++)
  {
    Node *student = &graph->lst_Nodes[i];
    printf("%d\n", student->grade);
  }

}

int DFS_UTIL(Graph *graph, Node *student)
{
  if (student->visited == (-1))
  {
    student->visited = 1;
    List *adj = student->head;
    while (adj)
    {
      student->grade = (student->grade > DFS_UTIL(graph, adj->node)) ? (student->grade) : (DFS_UTIL(graph, adj->node));
      adj = adj->next;
    }

  }
  else
  {
    
  }

  return student->grade;
}

void DFS(Graph *graph)
{
  int i;
  for (i = 0; i < graph->n_students; i++)
  {
    Node *student = &graph->lst_Nodes[i];
    if (student->visited != 1)
    {
      student->visited = 1;
      List *adj = student->head;
      while (adj)
      {
        student->grade = (student->grade > DFS_UTIL(graph, adj->node)) ? (student->grade) : (DFS_UTIL(graph, adj->node));
        adj = adj->next;
      }

    }
    else
    {
      
    }

  }

}

void free_graph(Graph *graph)
{
  int i;
  for (i = 0; i < graph->n_students; i++)
  {
    Node *student = &graph->lst_Nodes[i];
    List *adj = student->head;
    List *next;
    while (adj)
    {
      next = adj->next;
      free(adj);
      adj = next;
    }

  }

  free(graph->lst_Nodes);
  free(graph);
}

int main()
{
  Graph *graph = creategraph();
  create_students(graph);
  read_friendships(graph);
  DFS(graph);
  print_grades(graph);
  free_graph(graph);
  return 0;
}

