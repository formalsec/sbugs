/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int *stack;
int top = 0;
int scc = 0;
typedef struct stack
{
  int key;
  struct stack *next;
} *Stack;
typedef struct vertex *Vertex;
typedef struct adj_vertex
{
  Vertex vertex;
  struct adj_vertex *next;
} *AdjVertex;
struct vertex
{
  int id;
  int grade;
  int discovery;
  int parent;
  int low;
  AdjVertex head;
};
typedef struct graph
{
  Vertex array;
  int N;
} *Graph;
void push(int i)
{
  stack[top] = i;
  top++;
}

int pop()
{
  if (top > 0)
  {
    top--;
    return stack[top];
  }
  else
  {
    
  }

  return -1;
}

int stackTop()
{
  if (top > 0)
  {
    return stack[top - 1];
  }
  else
  {
    
  }

  return -1;
}

int tarjan(Graph g, int v, int time)
{
  int w;
  int i = 0;
  int j;
  int vertex_index;
  int max_grade = -1;
  int maxStackIndex = -1;
  AdjVertex adj;
  time++;
  g->array[v].discovery = (g->array[v].low = time);
  push(v);
  for (adj = g->array[v].head; adj != 0; adj = adj->next)
  {
    w = adj->vertex->id;
    if (g->array[w].discovery == (-1))
    {
      g->array[v].grade = (g->array[v].grade > g->array[w].grade) ? (g->array[v].grade) : (g->array[w].grade);
      g->array[w].parent = v;
      i++;
      time = tarjan(g, w, time);
      g->array[v].low = (g->array[v].low < g->array[w].low) ? (g->array[v].low) : (g->array[w].low);
    }
    else
    {
      if (g->array[v].parent != w)
      {
        g->array[v].low = (g->array[v].low < g->array[w].discovery) ? (g->array[v].low) : (g->array[w].discovery);
      }
      else
      {
        if (g->array[v].parent == w)
        {
          g->array[v].low = (g->array[v].low < g->array[w].low) ? (g->array[v].low) : (g->array[w].low);
        }
        else
        {
          
        }

      }

    }

    g->array[v].grade = (g->array[v].grade > g->array[w].grade) ? (g->array[v].grade) : (g->array[w].grade);
  }

  if (g->array[v].discovery == g->array[v].low)
  {
    while ((vertex_index = pop()) != (-1))
    {
      if (vertex_index == v)
      {
        maxStackIndex = (maxStackIndex > top) ? (maxStackIndex) : (top);
        max_grade = (max_grade > g->array[vertex_index].grade) ? (max_grade) : (g->array[vertex_index].grade);
        for (j = top; j <= maxStackIndex; j++)
        {
          g->array[stack[j]].grade = (g->array[stack[j]].grade > max_grade) ? (g->array[stack[j]].grade) : (max_grade);
        }

        break;
      }
      else
      {
        maxStackIndex = (maxStackIndex > top) ? (maxStackIndex) : (top);
        max_grade = (max_grade > g->array[vertex_index].grade) ? (max_grade) : (g->array[vertex_index].grade);
      }

    }

  }
  else
  {
    
  }

  return ++time;
}

void link(Graph g, int a, int b)
{
  Vertex v = &g->array[a - 1];
  AdjVertex new = malloc(sizeof(struct adj_vertex));
  new->vertex = &g->array[b - 1];
  new->next = v->head;
  v->head = new;
}

void parseInput(Graph g)
{
  int u;
  int v;
  int i;
  int M;
  g->N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  stack = calloc(g->N, sizeof(int));
  g->array = calloc(g->N, sizeof(struct vertex));
  for (i = 0; i < g->N; i++)
  {
    g->array[i].grade = new_sym_var(sizeof(int) * 8);
    g->array[i].id = i;
    g->array[i].discovery = -1;
    g->array[i].parent = -1;
    g->array[i].head = 0;
  }

  for (i = 0; i < M; i++)
  {
    u = new_sym_var(sizeof(int) * 8);
    v = new_sym_var(sizeof(int) * 8);
    link(g, u, v);
  }

}

void displayResults(Graph g)
{
  int i;
  for (i = 0; i < g->N; i++)
    printf("%d\n", g->array[i].grade);

}

void freeGraph(Graph g)
{
  int i;
  int N = g->N;
  AdjVertex aux;
  for (i = 0; i < N; i++)
  {
    while (g->array[i].head)
    {
      aux = g->array[i].head;
      g->array[i].head = g->array[i].head->next;
      free(aux);
    }

  }

  free(g->array);
  free(g);
}

int main(void)
{
  int i;
  int time = 0;
  Graph g = malloc(sizeof(struct graph));
  parseInput(g);
  for (i = g->N - 1; i >= 0; i--)
  {
    if (g->array[i].discovery == (-1))
    {
      time = tarjan(g, i, time);
    }
    else
    {
      
    }

  }

  displayResults(g);
  freeGraph(g);
  return 0;
}

