#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>


typedef struct adj_node
{
  int edge_to;
  struct adj_node *next;
} *adj_node_ptr;
typedef struct graph
{
  int order;
  adj_node_ptr *adjacency_list;
} graph;
adj_node_ptr *adj_init(int number_of_nodes)
{
  if (number_of_nodes > 0)
  {
    int i = 0;
    adj_node_ptr *adj_list = malloc((sizeof(adj_node_ptr)) * number_of_nodes);
    if (adj_list != 0)
    {
      while (i < number_of_nodes)
      {
        adj_list[i] = 0;
        i++;
      }

    }
    else
    {
      
    }

    return adj_list;
  }
  else
  {
    
  }

  return 0;
}

adj_node_ptr adj_delete_node(adj_node_ptr head)
{
  if (head != 0)
  {
    adj_node_ptr new_head = head->next;
    free(head);
    head = new_head;
  }
  else
  {
    
  }

  return head;
}

void adj_delete_list(adj_node_ptr *list, int number_of_vertices)
{
  if ((list != 0) && (number_of_vertices > 0))
  {
    int i = 0;
    while (i < number_of_vertices)
    {
      while (list[i] != 0)
        list[i] = adj_delete_node(list[i]);

      i++;
    }

    free(list);
  }
  else
  {
    
  }

}

adj_node_ptr adj_get_next_edge(adj_node_ptr current)
{
  if (current != 0)
  {
    return current->next;
  }
  else
  {
    
  }

  return 0;
}

adj_node_ptr adj_new_entry(int edge_to)
{
  adj_node_ptr new_entry = malloc(sizeof(struct adj_node));
  if (new_entry != 0)
  {
    new_entry->edge_to = edge_to;
    new_entry->next = 0;
  }
  else
  {
    
  }

  return new_entry;
}

adj_node_ptr adj_add_edge(adj_node_ptr head, int edge_to)
{
  if (edge_to >= 0)
  {
    adj_node_ptr new_edge = adj_new_entry(edge_to);
    new_edge->next = head;
    return new_edge;
  }
  else
  {
    
  }

  return 0;
}

graph *graph_create(int number_of_vertices)
{
  if (number_of_vertices > 0)
  {
    graph *g = malloc(sizeof(graph));
    if (g != 0)
    {
      g->order = number_of_vertices;
      g->adjacency_list = adj_init(number_of_vertices);
    }
    else
    {
      
    }

    return g;
  }
  else
  {
    
  }

  return 0;
}

void graph_delete(graph *g)
{
  if (g != 0)
  {
    adj_delete_list(g->adjacency_list, g->order);
    free(g);
  }
  else
  {
    
  }

}

adj_node_ptr graph_get_node_edges(graph *g, int vertex_index)
{
  return ((g != 0) && (vertex_index < g->order)) ? (g->adjacency_list[vertex_index]) : (0);
}

int graph_get_order(graph *g)
{
  if (g != 0)
  {
    return g->order;
  }
  else
  {
    
  }

  return -1;
}

void graph_add_edge(graph *g, int u, int v)
{
  if (((((g != 0) && (u < g->order)) && (v < g->order)) && (v >= 0)) && (u >= 0))
  {
    adj_node_ptr *vertex_head = &g->adjacency_list[u];
    *vertex_head = adj_add_edge(*vertex_head, v);
  }
  else
  {
    
  }

}

int tarjan_visit(int i, graph *relations, int *grades, int *ids)
{
  ids[i] = 1;
  adj_node_ptr adj_list = 0;
  for (adj_list = graph_get_node_edges(relations, i); adj_list != 0; adj_list = adj_get_next_edge(adj_list))
  {
    if (ids[adj_list->edge_to] == 100)
    {
      grades[i] = (grades[i] > tarjan_visit(adj_list->edge_to, relations, grades, ids)) ? (grades[i]) : (tarjan_visit(adj_list->edge_to, relations, grades, ids));
    }
    else
    {
      
    }

    grades[i] = (grades[i] > grades[adj_list->edge_to]) ? (grades[i]) : (grades[adj_list->edge_to]);
  }

  return grades[i];
}

void tarjan(graph *relations, int *grades, int n_students)
{
  int *ids = (int *) malloc((sizeof(int)) * n_students);
  adj_node_ptr adj_list = 0;
  int i = 0;
  for (i = 0; i < n_students; i++)
  {
    ids[i] = 100;
  }

  for (i = 0; i < n_students; i++)
  {
    tarjan_visit(i, relations, grades, ids);
  }

  for (i = 0; i < n_students; i++)
  {
    ids[i] = 100;
  }

  for (i = n_students - 1; i >= 0; i--)
  {
    tarjan_visit(i, relations, grades, ids);
  }

  for (i = 0; i < n_students; i++)
  {
    for (adj_list = graph_get_node_edges(relations, i); adj_list != 0; adj_list = adj_get_next_edge(adj_list))
    {
      grades[i] = (grades[i] > grades[adj_list->edge_to]) ? (grades[i]) : (grades[adj_list->edge_to]);
    }

  }

  for (i = n_students - 1; i >= 0; i--)
  {
    for (adj_list = graph_get_node_edges(relations, i); adj_list != 0; adj_list = adj_get_next_edge(adj_list))
    {
      grades[i] = (grades[i] > grades[adj_list->edge_to]) ? (grades[i]) : (grades[adj_list->edge_to]);
    }

  }

  free(ids);
}

int main()
{
  int n_students = 0;
  int n_relations = 0;
  int *grades = 0;
  graph *relations = 0;
  int i = 0;
  n_students = new_sym_var(sizeof(int) * 8);
  n_relations = new_sym_var(sizeof(int) * 8);
  grades = (int *) malloc((sizeof(int)) * n_students);
  for (i = 0; i < n_students; i++)
  {
    grades[i] = new_sym_var(sizeof(int) * 8);
  }

  relations = graph_create(n_students);
  for (i = 0; i < n_relations; i++)
  {
    int student;
    int friend;
    student = new_sym_var(sizeof(int) * 8);
    friend = new_sym_var(sizeof(int) * 8);
    graph_add_edge(relations, student - 1, friend - 1);
  }

  tarjan(relations, grades, n_students);
  for (i = 0; i < n_students; i++)
  {
    printf("%d\n", grades[i]);
  }

  free(grades);
  graph_delete(relations);
  return 0;
}

