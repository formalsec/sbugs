#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct node
{
  int vertex_index;
  struct node *next;
  struct node *prev;
} node;
typedef node *link;
typedef struct AdjListElement
{
  int stackPresence;
  int grade;
  int scc_index;
  link listHead;
  link listTail;
} adj_list_element;
typedef adj_list_element *adj_link;
typedef struct AdjList
{
  int size;
  adj_link *head;
} adj_list;
adj_list *adjList;
typedef struct TarjanStack
{
  int size;
  int max_size;
  link head;
} Tarjan_stack;
typedef enum color
{
  WHITE,
  GRAY,
  BLACK
} color;
int time_v = 0;
int *discovery;
int *low;
color *colour;
int *pred;
int *scc_disc;
int *end;
typedef struct SCCListNode
{
  int scc_index;
  struct SCCListNode *next;
  struct SCCListNode *prev;
} SCCAdjListNode;
typedef struct SCCListNode *SCC_link;
typedef struct SCCAdjListElement
{
  int max;
  SCC_link head;
  SCC_link tail;
} SCCAdjListElement;
typedef SCCAdjListElement *SCC_adj_link;
typedef struct SCCAdjList
{
  int size;
  SCC_adj_link *vec;
} SCCAdjList;
SCCAdjList *scc_adj_list;
SCC_link newSCCNode(int index)
{
  SCC_link t = (SCC_link) malloc(sizeof(SCCAdjListNode));
  t->scc_index = index;
  t->prev = (t->next = 0);
  return t;
}

void deleteSCCNode(SCC_link node)
{
  if (node->prev != 0)
  {
    node->prev->next = node->next;
  }
  else
  {
    
  }

  if (node->next != 0)
  {
    node->next->prev = node->prev;
  }
  else
  {
    
  }

  free(node);
}

void freeSCCAdjListElemAdjacencies(SCC_link head)
{
  SCC_link t = head;
  while (head != 0)
  {
    t = t->next;
    free(head);
    head = t;
  }

}

void freeSCCAdjListElement(SCC_adj_link e)
{
  freeSCCAdjListElemAdjacencies(e->head);
  free(e);
}

link newNode(int vertex)
{
  link t = (link) malloc(sizeof(node));
  t->vertex_index = vertex;
  t->next = (t->prev = 0);
  return t;
}

void deleteNode(link node)
{
  if (node->prev != 0)
  {
    node->prev->next = node->next;
  }
  else
  {
    
  }

  if (node->next != 0)
  {
    node->next->prev = node->prev;
  }
  else
  {
    
  }

  free(node);
}

void freeVertexList(link head)
{
  link t = head;
  while (head != 0)
  {
    t = t->next;
    free(head);
    head = t;
  }

}

adj_link newAdjListElement(int grade)
{
  adj_link t = (adj_link) malloc(sizeof(adj_list_element));
  t->grade = grade;
  t->scc_index = -1;
  t->stackPresence = 0;
  t->listHead = 0;
  t->listTail = 0;
  return t;
}

void freeAdjListElement(adj_link t)
{
  freeVertexList(t->listHead);
  free(t);
}

int AdjListInit(int size)
{
  int i = 0;
  adjList = (adj_list *) malloc(sizeof(adj_list));
  if (adjList == 0)
  {
    exit(1);
  }
  else
  {
    
  }

  adjList->size = size;
  adjList->head = (adj_link *) malloc((sizeof(adj_link)) * size);
  if (adjList->head == 0)
  {
    exit(1);
  }
  else
  {
    
  }

  for (i = 0; i < size; i++)
    adjList->head[i] = newAdjListElement(0);

  return 1;
}

void freeAdjList()
{
  int i = 0;
  for (i = 0; i < adjList->size; i++)
    freeAdjListElement(adjList->head[i]);

  free(adjList->head);
  free(adjList);
}

void createEdge(int u, int v)
{
  link t;
  if ((((v >= adjList->size) || (u >= adjList->size)) || (u < 0)) || (v < 0))
  {
    printf("Invalid Vertex\n");
    return;
  }
  else
  {
    
  }

  t = newNode(v);
  if (adjList->head[u]->listHead == 0)
  {
    adjList->head[u]->listHead = t;
    adjList->head[u]->listTail = t;
  }
  else
  {
    adjList->head[u]->listTail->next = t;
    t->prev = adjList->head[u]->listTail;
    adjList->head[u]->listTail = t;
  }

}

SCC_adj_link newSCCAdjListElement()
{
  SCC_adj_link t = (SCC_adj_link) malloc(sizeof(SCCAdjListElement));
  t->max = 0;
  t->head = 0;
  t->tail = 0;
  return t;
}

void sccAdjList_init()
{
  scc_adj_list = (SCCAdjList *) malloc(sizeof(SCCAdjList));
  scc_adj_list->vec = 0;
  scc_adj_list->size = 0;
}

void freeSCCAdjList()
{
  int i = 0;
  for (i = 0; i < scc_adj_list->size; i++)
  {
    freeSCCAdjListElement(scc_adj_list->vec[i]);
  }

  free(scc_adj_list->vec);
  free(scc_adj_list);
}

void stack_init(Tarjan_stack *stack)
{
  stack->size = 0;
  stack->max_size = adjList->size;
  stack->head = 0;
}

void freeStack(Tarjan_stack *stack)
{
  freeVertexList(stack->head);
  free(stack);
}

void push_st(int ind, Tarjan_stack *stack)
{
  link t;
  if (stack->max_size < (stack->size + 1))
  {
    exit(1);
  }
  else
  {
    
  }

  t = newNode(ind);
  adjList->head[ind]->stackPresence = 1;
  if (stack->head == 0)
  {
    stack->head = t;
    stack->size++;
    return;
  }
  else
  {
    
  }

  t->next = stack->head;
  stack->head->prev = t;
  stack->head = t;
  stack->size++;
}

link pop_stack(Tarjan_stack *stack)
{
  link t;
  if (stack->size == 0)
  {
    exit(1);
  }
  else
  {
    
  }

  t = stack->head;
  if (stack->head->next != 0)
  {
    stack->head = stack->head->next;
    t->next = 0;
    stack->head->prev = 0;
    stack->size--;
  }
  else
  {
    stack->head = 0;
    stack->size--;
  }

  adjList->head[t->vertex_index]->stackPresence = 0;
  return t;
}

int isOnStack(link v)
{
  return adjList->head[v->vertex_index]->stackPresence;
}

void sccAdd(SCC_adj_link scc)
{
  scc_adj_list->vec = (SCC_adj_link *) realloc(scc_adj_list->vec, (scc_adj_list->size * (sizeof(SCC_adj_link))) + (sizeof(SCC_adj_link)));
  scc_adj_list->vec[scc_adj_list->size] = scc;
  scc_adj_list->size++;
}

void Tarjan_Visit(int u, Tarjan_stack *stack)
{
  link v;
  discovery[u] = time_v;
  low[u] = time_v;
  time_v++;
  push_st(u, stack);
  v = adjList->head[u]->listHead;
  while (v != 0)
  {
    if ((discovery[v->vertex_index] == (-1)) || (isOnStack(v) == 1))
    {
      if (discovery[v->vertex_index] == (-1))
      {
        Tarjan_Visit(v->vertex_index, stack);
      }
      else
      {
        
      }

      (low[u] > low[v->vertex_index]) ? (low[u] = low[v->vertex_index]) : (low[u]);
    }
    else
    {
      
    }

    v = v->next;
  }

  if (discovery[u] == low[u])
  {
    SCC_adj_link scc = newSCCAdjListElement();
    v = pop_stack(stack);
    while (u != v->vertex_index)
    {
      adjList->head[v->vertex_index]->scc_index = scc_adj_list->size;
      if (adjList->head[v->vertex_index]->grade > scc->max)
      {
        scc->max = adjList->head[v->vertex_index]->grade;
      }
      else
      {
        
      }

      deleteNode(v);
      v = pop_stack(stack);
    }

    adjList->head[v->vertex_index]->scc_index = scc_adj_list->size;
    if (adjList->head[v->vertex_index]->grade > scc->max)
    {
      scc->max = adjList->head[v->vertex_index]->grade;
    }
    else
    {
      
    }

    deleteNode(v);
    sccAdd(scc);
  }
  else
  {
    
  }

}

void SCC_Tarjan()
{
  int vertex = 0;
  Tarjan_stack *stack = (Tarjan_stack *) malloc(sizeof(Tarjan_stack));
  stack_init(stack);
  sccAdjList_init();
  discovery = (int *) malloc((sizeof(int)) * adjList->size);
  low = (int *) malloc((sizeof(int)) * adjList->size);
  for (vertex = 0; vertex < adjList->size; vertex++)
  {
    discovery[vertex] = -1;
  }

  for (vertex = 0; vertex < adjList->size; vertex++)
  {
    if (discovery[vertex] == (-1))
    {
      Tarjan_Visit(vertex, stack);
    }
    else
    {
      
    }

  }

  freeStack(stack);
  free(discovery);
  free(low);
}

int searchSCCAdj(int scc_u, int scc_v)
{
  SCC_link t = scc_adj_list->vec[scc_u]->head;
  while (t != 0)
  {
    if (t->scc_index == scc_v)
    {
      return 1;
    }
    else
    {
      
    }

    t = t->next;
  }

  return 0;
}

void findSCCEdges()
{
  int u = 0;
  for (u = 0; u < adjList->size; u++)
  {
    int scc_u = adjList->head[u]->scc_index;
    int scc_v;
    link t = adjList->head[u]->listHead;
    while (t != 0)
    {
      scc_v = adjList->head[t->vertex_index]->scc_index;
      if (scc_u != scc_v)
      {
        if (scc_adj_list->vec[scc_u]->head == 0)
        {
          scc_adj_list->vec[scc_u]->head = (scc_adj_list->vec[scc_u]->tail = newSCCNode(scc_v));
        }
        else
        {
          if (!searchSCCAdj(scc_u, scc_v))
          {
            SCC_link w = newSCCNode(scc_v);
            w->prev = scc_adj_list->vec[scc_u]->tail;
            scc_adj_list->vec[scc_u]->tail->next = w;
            scc_adj_list->vec[scc_u]->tail = w;
          }
          else
          {
            
          }

        }

      }
      else
      {
        
      }

      t = t->next;
    }

  }

}

void setVertexGrade(int vertex, int val)
{
  if (val > adjList->head[vertex]->grade)
  {
    adjList->head[vertex]->grade = val;
  }
  else
  {
    
  }

}

void DFS_Visit(int u)
{
  SCC_link v = scc_adj_list->vec[u]->head;
  colour[u] = GRAY;
  scc_disc[u] = time_v;
  time_v++;
  while (v != 0)
  {
    if (colour[v->scc_index] == WHITE)
    {
      pred[v->scc_index] = u;
      DFS_Visit(v->scc_index);
    }
    else
    {
      
    }

    if (scc_adj_list->vec[v->scc_index]->max > scc_adj_list->vec[u]->max)
    {
      scc_adj_list->vec[u]->max = scc_adj_list->vec[v->scc_index]->max;
    }
    else
    {
      
    }

    v = v->next;
  }

  if (pred[u] != (-1))
  {
    if (scc_adj_list->vec[u]->max > scc_adj_list->vec[pred[u]]->max)
    {
      scc_adj_list->vec[pred[u]]->max = scc_adj_list->vec[u]->max;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  colour[u] = BLACK;
  end[u] = time_v;
  time_v++;
}

void DFS()
{
  int u = 0;
  colour = (color *) malloc((sizeof(color)) * scc_adj_list->size);
  pred = (int *) malloc((sizeof(int)) * scc_adj_list->size);
  end = (int *) malloc((sizeof(int)) * scc_adj_list->size);
  scc_disc = (int *) malloc((sizeof(int)) * scc_adj_list->size);
  for (u = 0; u < scc_adj_list->size; u++)
  {
    colour[u] = WHITE;
    pred[u] = -1;
  }

  time_v = 1;
  for (u = 0; u < scc_adj_list->size; u++)
  {
    if (colour[u] == WHITE)
    {
      DFS_Visit(u);
    }
    else
    {
      
    }

  }

  free(colour);
  free(pred);
  free(end);
  free(scc_disc);
}

void propagateSCCGrades()
{
  DFS();
}

void printVertexGrades()
{
  int i = 0;
  for (i = 0; i < adjList->size; i++)
  {
    printf("%d\n", scc_adj_list->vec[adjList->head[i]->scc_index]->max);
  }

}

void processInput()
{
  char line[100];
  int line_index = 1;
  int n_vertex = 0;
  int n_edges = 0;
  while (fgets(line, 100, stdin))
  {
    if (line_index == 1)
    {
      int n;
      n_vertex = new_sym_var(sizeof(int) * 8);
      n_edges = new_sym_var(sizeof(int) * 8);
      line_index++;
      if (n_vertex < 2)
      {
        exit(1);
      }
      else
      {
        
      }

      if (n_edges < 1)
      {
        exit(1);
      }
      else
      {
        
      }

      n = AdjListInit(n_vertex);
      if (n != 1)
      {
        exit(1);
      }
      else
      {
        
      }

    }
    else
    {
      if (line_index <= (n_vertex + 1))
      {
        int grade = atoi(line);
        setVertexGrade(line_index - 2, grade);
        line_index++;
      }
      else
      {
        if (line_index <= ((n_vertex + n_edges) + 1))
        {
          int u = 0;
          int v = 0;
          u = new_sym_var(sizeof(int) * 8);
          v = new_sym_var(sizeof(int) * 8);
          line_index++;
          if ((u > n_vertex) || (v > n_vertex))
          {
            exit(1);
          }
          else
          {
            
          }

          createEdge(u - 1, v - 1);
        }
        else
        {
          
        }

      }

    }

  }

}

void free_all()
{
  freeSCCAdjList();
  freeAdjList();
}

int main()
{
  processInput();
  SCC_Tarjan();
  findSCCEdges();
  propagateSCCGrades();
  printVertexGrades();
  free_all();
  return 0;
}

