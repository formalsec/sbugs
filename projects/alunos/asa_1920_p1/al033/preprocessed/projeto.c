#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


struct student_t;
typedef struct adjListNode_t
{
  struct student_t *dest;
  struct adjListNode_t *next;
} Friendship_t;
typedef struct student_t
{
  int grade;
  int id;
  int d;
  int sccID;
  Friendship_t *head;
} Student_t;
typedef struct stack_t
{
  int capacity;
  int top;
  Student_t **items;
} Stack_t;
typedef struct graph_t
{
  int num;
  Student_t **vertex;
} Graph_t;
typedef struct node_t
{
  Student_t *student;
  struct node_t *next;
} Node_t;
typedef struct list_t
{
  Node_t *head;
} List_t;
Stack_t *newStack(int v);
void push(Stack_t *stackPtr, Student_t *vertex);
Student_t *pop(Stack_t *stackPtr);
int isInStack(Stack_t *stack, int item);
Student_t *createNewStudent(int grade, int id);
Graph_t *createGraph(int n);
void addFriendship(Graph_t *g, int uID, int vID);
void removeFriendship(int uID, int vID);
void tarjanVisit(Graph_t *graph, Student_t *vertex);
void SCC_tarjan(Graph_t *graph, int n);
int max(int a, int b);
int min(int a, int b);
void processInput();
void displayGrades();
void removeAllSccEdges();
void add_Node(Student_t *new_student);
Graph_t *graphScc();
Graph_t *graph;
Graph_t *SccGraph;
int numberStudents = 0;
int numberRelations = 0;
int visited = 0;
Stack_t *stack;
Stack_t *auxStack;
void processInput()
{
  numberStudents = new_sym_var(sizeof(int) * 8);
  numberRelations = new_sym_var(sizeof(int) * 8);
  int i;
  int grade;
  graph = createGraph(numberStudents);
  for (i = 1; i <= numberStudents; i++)
  {
    grade = new_sym_var(sizeof(int) * 8);
    graph->vertex[i] = createNewStudent(grade, i);
  }

  if (numberStudents > 0)
  {
    for (i = 0; i < numberRelations; i++)
    {
      int u;
      int v;
      u = new_sym_var(sizeof(int) * 8);
      v = new_sym_var(sizeof(int) * 8);
      addFriendship(graph, u, v);
    }

  }
  else
  {
    
  }

}

void displayGrades()
{
  int i;
  for (i = 1; i <= numberStudents; i++)
    printf("%d\n", graph->vertex[i]->grade);

}

Stack_t *newStack(int v)
{
  Stack_t *stackPtr = (Stack_t *) malloc(sizeof(Stack_t));
  int i;
  ;
  stackPtr->capacity = v;
  stackPtr->top = -1;
  stackPtr->items = (Student_t **) malloc((sizeof(Student_t)) * v);
  for (i = 0; i < v; i++)
  {
    stackPtr->items[i] = 0;
  }

  return stackPtr;
}

void push(Stack_t *stackPtr, Student_t *vertex)
{
  stackPtr->items[++stackPtr->top] = vertex;
}

Student_t *pop(Stack_t *stackPtr)
{
  if (stackPtr->top >= 0)
  {
    return stackPtr->items[stackPtr->top--];
  }
  else
  {
    
  }

  return 0;
}

int isInStack(Stack_t *stack, int id)
{
  int i;
  for (i = 0; i < stack->capacity; i++)
  {
    if ((stack->top < 0) || (stack->items[i] == 0))
    {
      return 0;
    }
    else
    {
      if (stack->items[i]->id == id)
      {
        return 1;
      }
      else
      {
        
      }

    }

  }

  return 0;
}

Student_t *createNewStudent(int grade, int id)
{
  Student_t *newStudent = (Student_t *) malloc(sizeof(Student_t));
  newStudent->grade = grade;
  newStudent->id = id;
  newStudent->head = 0;
  return newStudent;
}

Graph_t *createGraph(int n)
{
  int i;
  Graph_t *graph = (Graph_t *) malloc(sizeof(Graph_t));
  graph->num = n;
  graph->vertex = (Student_t **) malloc((n * (sizeof(Student_t))) + 1);
  for (i = 0; i <= n; i++)
  {
    graph->vertex[i] = 0;
  }

  return graph;
}

void addFriendship(Graph_t *g, int uID, int vID)
{
  Friendship_t *newEdge = (Friendship_t *) malloc(sizeof(Friendship_t));
  newEdge->dest = g->vertex[vID];
  newEdge->next = 0;
  if (g->vertex[uID]->head == 0)
  {
    g->vertex[uID]->head = newEdge;
    return;
  }
  else
  {
    
  }

  Friendship_t *aux = g->vertex[uID]->head;
  while (aux->next != 0)
    aux = aux->next;

  aux->next = newEdge;
}

int min(int a, int b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

int max(int a, int b)
{
  if (a > b)
  {
    return a;
  }
  else
  {
    return b;
  }

}

void tarjanVisit(Graph_t *graph, Student_t *vertex)
{
  Friendship_t *friends = vertex->head;
  Student_t *friend = 0;
  Student_t *v = 0;
  vertex->d = (vertex->sccID = visited++);
  if (friends == 0)
  {
    return;
  }
  else
  {
    push(stack, vertex);
    while (friends != 0)
    {
      friend = friends->dest;
      if ((0 != isInStack(stack, friend->id)) || (friend->d == (-1)))
      {
        if (friend->d == (-1))
        {
          tarjanVisit(graph, friend);
        }
        else
        {
          
        }

        vertex->sccID = min(vertex->sccID, friend->sccID);
      }
      else
      {
        
      }

      vertex->grade = max(vertex->grade, friend->grade);
      friends = friends->next;
    }

    if (vertex->d == vertex->sccID)
    {
      v = pop(stack);
      while ((v != 0) && (v->id != vertex->id))
      {
        push(auxStack, v);
        v = pop(stack);
      }

      push(auxStack, vertex);
    }
    else
    {
      
    }

  }

}

int isInAdjList(Friendship_t *f, int id)
{
  Friendship_t *aux = f->next;
  while (aux != 0)
  {
    if (aux->dest->id == id)
    {
      return 0;
    }
    else
    {
      
    }

    aux = aux->next;
  }

  return 1;
}

void SCC_tarjan(Graph_t *graph, int n)
{
  int i;
  int j = 0;
  stack = newStack(n);
  auxStack = newStack(n);
  Student_t *v = 0;
  Friendship_t *friends;
  for (i = 1; i <= n; i++)
    graph->vertex[i]->d = -1;

  for (i = 1; i <= n; i++)
  {
    if (graph->vertex[i]->d == (-1))
    {
      tarjanVisit(graph, graph->vertex[i]);
    }
    else
    {
      
    }

  }

  for (v = auxStack->items[j]; v != 0; v = auxStack->items[++j])
  {
    friends = v->head;
    while (friends != 0)
    {
      v->grade = max(friends->dest->grade, v->grade);
      friends = friends->next;
    }

  }

}

int main()
{
  processInput();
  if (numberRelations != 0)
  {
    SCC_tarjan(graph, numberStudents);
  }
  else
  {
    
  }

  displayGrades();
  return 0;
}

