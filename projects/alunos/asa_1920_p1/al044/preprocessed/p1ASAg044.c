#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h> 


typedef struct Node
{
  int value;
  struct Node *next;
} node;
typedef struct student
{
  node *relationshipsHead;
  node *relationshipsCurrent;
  bool finale;
  int grade;
} Student;
int findBest();
void dfs(int a, int b);
Student *student;
int bestStudent = -1;
int bestGrade = -1;
int numStudents;
int numRelationships;
int main(int argc, char *argv[])
{
  int giver;
  int receiver;
  int i;
  numStudents = new_sym_var(sizeof(int) * 8);
  numRelationships = new_sym_var(sizeof(int) * 8);
  student = malloc(numStudents * (sizeof(Student)));
  for (i = 0; i < numStudents; i++)
  {
    student[i].grade = new_sym_var(sizeof(int) * 8);
    student[i].finale = false;
    student[i].relationshipsHead = malloc(sizeof(node));
    student[i].relationshipsHead->value = -1;
    student[i].relationshipsHead->next = 0;
    student[i].relationshipsCurrent = student[i].relationshipsHead;
  }

  for (i = 0; i < numRelationships; i++)
  {
    receiver = new_sym_var(sizeof(int) * 8);
    giver = new_sym_var(sizeof(int) * 8);
    if (student[giver - 1].relationshipsCurrent->value == (-1))
    {
      student[giver - 1].relationshipsCurrent->value = receiver - 1;
    }
    else
    {
      student[giver - 1].relationshipsCurrent->next = malloc(sizeof(node));
      student[giver - 1].relationshipsCurrent = student[giver - 1].relationshipsCurrent->next;
      student[giver - 1].relationshipsCurrent->value = receiver - 1;
      student[giver - 1].relationshipsCurrent->next = 0;
    }

  }

  for (i = 0; i < numStudents; i++)
  {
    student[i].relationshipsCurrent = student[i].relationshipsHead;
  }

  while (findBest() != (-1))
  {
    dfs(bestStudent, bestGrade);
    bestStudent = -1;
    bestGrade = -1;
  }

  for (i = 0; i < numStudents; i++)
  {
    printf("%d\n", student[i].grade);
  }

  return 0;
}

void dfs(int a, int b)
{
  student[a].finale = true;
  if (student[a].relationshipsHead->value == (-1))
  {
    return;
  }
  else
  {
    
  }

  while (student[a].relationshipsCurrent != 0)
  {
    if (student[student[a].relationshipsCurrent->value].finale == false)
    {
      student[student[a].relationshipsCurrent->value].grade = b;
      dfs(student[a].relationshipsCurrent->value, b);
    }
    else
    {
      
    }

    student[a].relationshipsCurrent = student[a].relationshipsCurrent->next;
  }

  return;
}

int findBest()
{
  int i;
  for (i = 0; i < numStudents; i++)
  {
    if (student[i].finale == false)
    {
      if (student[i].grade > bestGrade)
      {
        bestStudent = i;
        bestGrade = student[i].grade;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return bestStudent;
}

