/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int N = 0;
int M = 0;
typedef struct 
{
  int v;
  int w;
} Edge;
typedef struct graph *Graph;
typedef struct node *link;
struct node
{
  int v;
  link next;
};
struct graph
{
  int V;
  int E;
  int *visited;
  int *closed;
  int *grades;
  link *adj;
};
int maximum(int a, int b)
{
  return (a > b) ? (a) : (b);
}

void printGraph(Graph G)
{
  int i;
  for (i = 1; i <= N; i++)
  {
    struct node *temp = G->adj[i];
    printf("Vertex: %d\n ", i);
    while (temp)
    {
      printf("%d -> ", temp->v);
      temp = temp->next;
    }

    printf("\n");
  }

}

link insertBegin(int v, link head)
{
  link x = malloc(sizeof(struct node));
  x->v = v;
  x->next = head;
  return x;
}

void insertEdge(Graph G, Edge e)
{
  int v = e.v;
  int w = e.w;
  G->adj[v] = insertBegin(w, G->adj[v]);
  G->E++;
}

Edge createEdge(int x, int y)
{
  Edge e;
  e.v = x;
  e.w = y;
  return e;
}

Graph initializeGraph(int V)
{
  int v;
  Graph G = malloc(sizeof(struct graph));
  G->V = V;
  G->E = 0;
  G->adj = malloc((V + 2) * (sizeof(link)));
  G->visited = malloc((V + 2) * (sizeof(int)));
  G->closed = malloc((V + 2) * (sizeof(int)));
  G->grades = malloc((V + 2) * (sizeof(int)));
  for (v = 0; v <= (V + 1); v++)
  {
    G->adj[v] = 0;
    G->visited[v] = 0;
    G->closed[v] = 0;
    G->grades[v] = 0;
  }

  return G;
}

void insertGrades(Graph G)
{
  int i;
  int v;
  for (i = 1; i < (N + 1); i++)
  {
    v = new_sym_var(sizeof(int) * 8);
    G->grades[i] = v;
  }

}

void insertFriends(Graph G)
{
  int i;
  int v;
  int w;
  for (i = 0; i < M; i++)
  {
    v = new_sym_var(sizeof(int) * 8);
    w = new_sym_var(sizeof(int) * 8);
    insertEdge(G, createEdge(v, w));
  }

}

int DFSVisit(Graph G, int v, int *visited)
{
  struct node *adjList = G->adj[v];
  struct node *temp = adjList;
  int max;
  visited[v] = 1;
  max = G->grades[v];
  while (temp != 0)
  {
    int connectedVertex = temp->v;
    if (G->closed[connectedVertex] == 1)
    {
      max = maximum(max, G->grades[connectedVertex]);
    }
    else
    {
      if (visited[connectedVertex] == 0)
      {
        max = maximum(max, DFSVisit(G, connectedVertex, visited));
      }
      else
      {
        
      }

    }

    temp = temp->next;
  }

  return max;
}

int DFS(Graph G, int v)
{
  struct node *adjList = G->adj[v];
  struct node *temp = adjList;
  int i;
  int max;
  G->visited[v] = 1;
  max = G->grades[v];
  while (temp != 0)
  {
    int connectedVertex = temp->v;
    if (G->visited[connectedVertex] == 0)
    {
      max = maximum(max, DFS(G, connectedVertex));
    }
    else
    {
      if (G->closed[connectedVertex] == 1)
      {
        max = maximum(max, G->grades[connectedVertex]);
      }
      else
      {
        int *visitedAux;
        visitedAux = malloc((N + 2) * (sizeof(int)));
        for (i = 1; i < (N + 1); i++)
        {
          visitedAux[i] = 0;
        }

        max = DFSVisit(G, v, visitedAux);
        free(visitedAux);
      }

    }

    temp = temp->next;
  }

  G->grades[v] = max;
  G->closed[v] = 1;
  return max;
}

void printGrades(Graph G)
{
  int i;
  for (i = 1; i < (N + 1); i++)
  {
    printf("%d\n", G->grades[i]);
  }

}

void freeGraph(Graph G)
{
  free(G->adj);
  free(G->visited);
  free(G->closed);
  free(G->grades);
  free(G);
}

int main()
{
  int i;
  Graph G;
  N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  G = initializeGraph(N);
  insertGrades(G);
  insertFriends(G);
  for (i = 1; i < (N + 1); i++)
  {
    if (G->visited[i] == 0)
    {
      DFS(G, i);
    }
    else
    {
      
    }

  }

  printGrades(G);
  freeGraph(G);
  return 0;
}

