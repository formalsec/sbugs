#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct node *link;
struct node
{
  int v;
  link next;
};
typedef struct graph
{
  int V;
  link *adj;
} *Graph;
Graph g;
int *notas;
Graph redes;
link stack;
int nrede = 0;
link NEW(int v)
{
  link x = (link) malloc(sizeof(struct node));
  x->v = v;
  x->next = 0;
  return x;
}

int pop(bool *onStack)
{
  int aux = stack->v;
  onStack[aux] = false;
  link aux_l = stack;
  stack = stack->next;
  free(aux_l);
  return aux;
}

void push(int n, bool *onStack)
{
  link x = stack;
  stack = NEW(n);
  stack->next = x;
  onStack[n] = true;
}

Graph GRAPHinit(int V)
{
  Graph G = malloc(sizeof(struct graph));
  G->adj = (link *) malloc((sizeof(link)) * V);
  G->V = V;
  return G;
}

void GRAPHinsertE(int v1, int v2)
{
  link x;
  if (g->adj[v1] == 0)
  {
    g->adj[v1] = NEW(v2);
  }
  else
  {
    for (x = g->adj[v1]; x->next != 0; x = x->next)
    {
      ;
    }

    x->next = NEW(v2);
  }

}

void read_input()
{
  int nAlunos;
  int nRelacoes;
  if (1 == 0)
  {
    exit(1);
  }
  else
  {
    nAlunos = new_sym_var(sizeof(int) * 8);
    
  }

  getchar();
  if (nAlunos < 2)
  {
    exit(1);
  }
  else
  {
    
  }

  g = GRAPHinit(nAlunos);
  notas = (int *) malloc(nAlunos * (sizeof(int)));
  if (1 == 0)
  {
    exit(1);
  }
  else
  {
    nRelacoes = new_sym_var(sizeof(int) * 8);
    
  }

  getchar();
  int i = 0;
  for (; nAlunos > 0; nAlunos--)
  {
    int nota;
    if (1 == 0)
    {
      exit(1);
    }
    else
    {
      nota = new_sym_var(sizeof(int) * 8);
      
    }

    getchar();
    notas[i] = nota;
    i++;
  }

  for (; nRelacoes > 0; nRelacoes--)
  {
    int r1;
    int r2;
    if (2 == 0)
    {
      exit(1);
    }
    else
    {
      r1 = new_sym_var(sizeof(int) * 8);
      r2 = new_sym_var(sizeof(int) * 8);
      
    }

    getchar();
    GRAPHinsertE(r1 - 1, r2 - 1);
  }

}

void tarjan_aux(int node, int *dist, bool *onStack, int *low)
{
  static int distance = 0;
  link aux = g->adj[node];
  distance++;
  dist[node] = (low[node] = distance);
  push(node, onStack);
  while (aux != 0)
  {
    if (dist[aux->v] == (-1))
    {
      tarjan_aux(aux->v, dist, onStack, low);
      low[node] = (low[node] < low[aux->v]) ? (low[node]) : (low[aux->v]);
    }
    else
    {
      if (onStack[aux->v])
      {
        low[node] = (low[node] < dist[aux->v]) ? (low[node]) : (dist[aux->v]);
      }
      else
      {
        
      }

    }

    aux = aux->next;
  }

  if (low[node] == dist[node])
  {
    int maxNota = 0;
    while (stack->v != node)
    {
      if (notas[stack->v] > maxNota)
      {
        maxNota = notas[stack->v];
      }
      else
      {
        
      }

      if (redes->adj[nrede] == 0)
      {
        redes->adj[nrede] = NEW(stack->v);
      }
      else
      {
        link aux = redes->adj[nrede];
        redes->adj[nrede] = NEW(stack->v);
        redes->adj[nrede]->next = aux;
      }

      pop(onStack);
    }

    if (notas[stack->v] > maxNota)
    {
      maxNota = notas[stack->v];
    }
    else
    {
      
    }

    if (redes->adj[nrede] == 0)
    {
      redes->adj[nrede] = NEW(stack->v);
    }
    else
    {
      link aux = redes->adj[nrede];
      redes->adj[nrede] = NEW(stack->v);
      redes->adj[nrede]->next = aux;
    }

    pop(onStack);
    link x;
    for (x = redes->adj[nrede]; x != 0; x = x->next)
    {
      notas[x->v] = maxNota;
    }

  }
  else
  {
    
  }

  nrede++;
}

void print_notas()
{
  int i = 0;
  for (; i < g->V; i++)
  {
    printf("%d\n", notas[i]);
  }

}

bool rede_check(int nrede, int n)
{
  link el_rede;
  for (el_rede = redes->adj[nrede]; el_rede != 0; el_rede = el_rede->next)
  {
    if (el_rede->v == n)
    {
      return true;
    }
    else
    {
      
    }

  }

  return false;
}

void change_notas_rede(int nrede, int nota)
{
  link el_rede;
  for (el_rede = redes->adj[nrede]; el_rede != 0; el_rede = el_rede->next)
  {
    notas[el_rede->v] = nota;
  }

}

void tarjan()
{
  int i;
  int *dist = (int *) malloc((sizeof(int)) * g->V);
  bool *onStack = (bool *) malloc((sizeof(bool)) * g->V);
  int *low = (int *) malloc((sizeof(int)) * g->V);
  redes = GRAPHinit(g->V);
  for (i = 0; i < g->V; i++)
  {
    dist[i] = -1;
    onStack[i] = false;
  }

  for (i = 0; i < g->V; i++)
  {
    if (dist[i] == (-1))
    {
      tarjan_aux(i, dist, onStack, low);
    }
    else
    {
      
    }

  }

  int nrede;
  for (nrede = 0; nrede < g->V; nrede++)
  {
    link el_rede;
    for (el_rede = redes->adj[nrede]; el_rede != 0; el_rede = el_rede->next)
    {
      link el_adj;
      for (el_adj = g->adj[el_rede->v]; el_adj != 0; el_adj = el_adj->next)
      {
        if (!rede_check(nrede, el_adj->v))
        {
          if (notas[el_adj->v] > notas[el_rede->v])
          {
            change_notas_rede(nrede, notas[el_adj->v]);
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

  }

}

int main(int argc, char *argv[])
{
  read_input();
  tarjan();
  print_notas();
  return 0;
}

