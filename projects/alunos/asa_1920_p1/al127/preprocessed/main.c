#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


struct friends
{
  int idNumber;
  struct friends *next;
};
struct student
{
  int mark;
  int discoveryTime;
  int low;
  int SCC;
  struct friends *friend;
};
struct Stack
{
  int *idNumber;
  int top;
};
struct SCC
{
  int color;
  int internalMark;
  int FinalMark;
  struct friends *next;
  struct friends *friend;
};
int numberStudents;
int numberFriendships;
int visited = 0;
int numSCC = 0;
struct Stack *stack;
struct student **students;
struct SCC **SCC;
void err_dump(char *msg)
{
  fprintf(stderr, msg);
  exit(1);
}

void processInput()
{
  char buffer[128];
  char *token;
  int i;
  if (fgets(buffer, sizeof(buffer), stdin) != 0)
  {
    if ((token = strtok(buffer, ",")) != 0)
    {
      numberStudents = atoi(token);
      if (numberStudents < 0)
      {
        err_dump("Failed to process Number of Students\n");
      }
      else
      {
        
      }

      token = strtok(0, ",");
      numberFriendships = atoi(token);
      if (numberFriendships < 0)
      {
        err_dump("Failed to process Number of Friendships\n");
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }
  else
  {
    
  }

  students = malloc((sizeof(struct student *)) * numberStudents);
  if (!students)
  {
    err_dump("Fail to allocate memory!\n");
  }
  else
  {
    
  }

  SCC = malloc((sizeof(struct SCC *)) * numberStudents);
  if (!SCC)
  {
    err_dump("Fail to allocate memory!\n");
  }
  else
  {
    
  }

  for (i = 0; i < numberStudents; i++)
  {
    students[i] = malloc(sizeof(struct student));
    if (!students[i])
    {
      err_dump("Fail to allocate memory!\n");
    }
    else
    {
      
    }

    students[i]->friend = 0;
    students[i]->discoveryTime = -1;
    students[i]->low = -1;
    if (fgets(buffer, sizeof(buffer), stdin) != 0)
    {
      students[i]->mark = atoi(buffer);
      if (students[i]->mark < 0)
      {
        err_dump("Failed to process student mark\n");
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    SCC[i] = malloc(sizeof(struct SCC));
    if (!SCC[i])
    {
      err_dump("Fail to allocate memory!\n");
    }
    else
    {
      
    }

    SCC[i]->friend = 0;
  }

  for (i = 0; i < numberFriendships; i++)
  {
    int idNumber;
    int friendNumber;
    struct friends *friend;
    if (fgets(buffer, sizeof(buffer), stdin) != 0)
    {
      if ((token = strtok(buffer, " ")) != 0)
      {
        idNumber = atoi(token);
        if (idNumber < 1)
        {
          err_dump("Failed to read Student Number\n");
        }
        else
        {
          
        }

        token = strtok(0, " ");
        friendNumber = atoi(token);
        if (friendNumber < 1)
        {
          err_dump("Failed to read Friend Number\n");
        }
        else
        {
          
        }

        idNumber--;
        friendNumber--;
        friend = malloc(sizeof(struct friends));
        if (!friend)
        {
          err_dump("Failed to allocate memory\n");
        }
        else
        {
          
        }

        friend->idNumber = friendNumber;
        friend->next = students[idNumber]->friend;
        students[idNumber]->friend = friend;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

}

void initStack()
{
  stack = malloc(sizeof(struct Stack));
  stack->idNumber = malloc((sizeof(int)) * numberStudents);
  stack->top = -1;
}

void freeStack()
{
  free(stack->idNumber);
  free(stack);
}

void push(int idNumber)
{
  stack->idNumber[++stack->top] = idNumber;
}

int pop()
{
  int value;
  if (stack->top == (-1))
  {
    return -1;
  }
  else
  {
    
  }

  value = stack->idNumber[stack->top];
  stack->top--;
  return value;
}

int hasElement(int idNumber)
{
  int i;
  for (i = 0; i <= stack->top; i++)
    if (idNumber == stack->idNumber[i])
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

int min(int n1, int n2)
{
  if (n1 < n2)
  {
    return n1;
  }
  else
  {
    
  }

  return n2;
}

void visit(struct student *s, int idNumber)
{
  struct friends *f = s->friend;
  int v = -2;
  s->discoveryTime = (s->low = visited);
  visited++;
  if (idNumber >= 0)
  {
    push(idNumber);
  }
  else
  {
    
  }

  for (; f && (f->idNumber >= 0); f = f->next)
  {
    if (students[f->idNumber]->discoveryTime == (-1))
    {
      visit(students[f->idNumber], f->idNumber);
      students[idNumber]->low = min(students[idNumber]->low, students[f->idNumber]->low);
    }
    else
    {
      if (hasElement(f->idNumber))
      {
        students[idNumber]->low = min(students[idNumber]->low, students[f->idNumber]->discoveryTime);
      }
      else
      {
        
      }

    }

  }

  if (students[idNumber]->discoveryTime == students[idNumber]->low)
  {
    while (idNumber != v)
    {
      v = pop();
      f = malloc(sizeof(struct friends));
      f->idNumber = v;
      f->next = SCC[numSCC]->friend;
      SCC[numSCC]->friend = f;
      students[v]->SCC = numSCC;
    }

    numSCC++;
  }
  else
  {
    
  }

}

int max(int n1, int n2)
{
  if (n1 > n2)
  {
    return n1;
  }
  else
  {
    
  }

  return n2;
}

int fastVisit(struct SCC *component)
{
  struct friends *f = component->next;
  if (component->color == 2)
  {
    return component->FinalMark;
  }
  else
  {
    
  }

  if (!f)
  {
    component->color = 2;
    component->FinalMark = component->internalMark;
    return component->FinalMark;
  }
  else
  {
    
  }

  if (component->color == 0)
  {
    component->color = 1;
    for (; f; f = f->next)
    {
      component->FinalMark = max(component->FinalMark, component->internalMark);
      component->FinalMark = max(component->FinalMark, fastVisit(SCC[f->idNumber]));
    }

  }
  else
  {
    
  }

  component->color = 2;
  return component->FinalMark;
}

void inspectFriendships()
{
  struct friends *f;
  struct friends *aux;
  struct friends *temp;
  int i;
  for (i = 0; i < numberStudents; i++)
    if (students[i]->discoveryTime == (-1))
  {
    visit(students[i], i);
  }
  else
  {
    
  }


  for (i = 0; i < numSCC; i++)
  {
    SCC[i]->internalMark = -1;
    SCC[i]->FinalMark = -1;
    SCC[i]->color = 0;
    SCC[i]->next = 0;
    f = SCC[i]->friend;
    for (; f && (f->idNumber >= 0); f = f->next)
    {
      SCC[i]->internalMark = max(SCC[i]->internalMark, students[f->idNumber]->mark);
      temp = students[f->idNumber]->friend;
      for (; temp && (temp->idNumber != (-1)); temp = temp->next)
        if (students[temp->idNumber]->SCC != i)
      {
        aux = malloc(sizeof(struct friends));
        aux->idNumber = students[temp->idNumber]->SCC;
        aux->next = SCC[i]->next;
        SCC[i]->next = aux;
      }
      else
      {
        
      }


    }

  }

  for (i = 0; i < numSCC; i++)
  {
    if (SCC[i]->color == 0)
    {
      SCC[i]->FinalMark = fastVisit(SCC[i]);
    }
    else
    {
      
    }

  }

}

void freeStuff()
{
  int i;
  struct friends *aux;
  for (i = 0; i < numberStudents; i++)
  {
    if (students[i]->friend)
    {
      aux = students[i]->friend->next;
      for (; aux; students[i]->friend = aux, aux = aux->next)
        free(students[i]->friend);

      free(students[i]->friend);
    }
    else
    {
      
    }

    free(students[i]);
    if (SCC[i]->friend)
    {
      aux = SCC[i]->friend->next;
      for (; aux; SCC[i]->friend = aux, aux = aux->next)
        free(SCC[i]->friend);

      free(SCC[i]->friend);
    }
    else
    {
      
    }

    if (SCC[i]->next)
    {
      aux = SCC[i]->next->next;
      for (; aux; SCC[i]->next = aux, aux = aux->next)
        free(SCC[i]->next);

      free(SCC[i]->next);
    }
    else
    {
      
    }

    free(SCC[i]);
  }

  free(SCC);
  free(students);
  freeStack();
}

void printResult()
{
  int i;
  for (i = 0; i < numberStudents; i++)
    fprintf(stdout, "%d\n", SCC[students[i]->SCC]->FinalMark);

}

int main()
{
  processInput();
  initStack();
  inspectFriendships();
  printResult();
  freeStuff();
  exit(0);
}

