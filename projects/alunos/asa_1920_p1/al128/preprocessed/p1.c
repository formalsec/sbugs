#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct graphNode
{
  int d_DFS;
  int d_SCC;
  int src;
  int grade;
  int *adj;
  int num_adj;
  int on_stack;
  int low;
  int SCC;
} graphNode;
int *gradesSCCs;
int num_SCCS = 0;
int num_students = 0;
int time = 0;
int *stack;
int stack_size = 0;
graphNode *nodes;
void push(int v)
{
  stack[stack_size++] = v;
}

int pop()
{
  int v = stack[stack_size - 1];
  stack_size--;
  return v;
}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

int max(int a, int b)
{
  return (a > b) ? (a) : (b);
}

void freeMemory()
{
  int i = 0;
  for (i = 0; i < num_students; i++)
  {
    free(nodes[i].adj);
  }

  free(stack);
  free(nodes);
  free(gradesSCCs);
}

void printGrades()
{
  int v = 0;
  for (v = 0; v < num_students; v++)
  {
    printf("%d\n", gradesSCCs[nodes[v].SCC]);
  }

}

void processInput()
{
  int num_friendships = 0;
  int grade = 0;
  int i = 0;
  int j = 0;
  int v = 0;
  num_students = new_sym_var(sizeof(int) * 8);
  num_friendships = new_sym_var(sizeof(int) * 8);
  stack = (int *) malloc((sizeof(int)) * num_students);
  nodes = (graphNode *) malloc((sizeof(graphNode)) * num_students);
  for (v = 0; v < num_students; v++)
  {
    grade = new_sym_var(sizeof(int) * 8);
    nodes[v].adj = 0;
    nodes[v].num_adj = 0;
    nodes[v].grade = grade;
    nodes[v].src = -1;
    nodes[v].d_DFS = 0;
    nodes[v].d_SCC = 0;
    nodes[v].on_stack = 0;
    nodes[v].low = -1;
    nodes[v].SCC = -1;
  }

  for (v = 0; v < num_friendships; v++)
  {
    i = new_sym_var(sizeof(int) * 8);
    j = new_sym_var(sizeof(int) * 8);
    nodes[i - 1].num_adj++;
    nodes[i - 1].adj = (int *) realloc(nodes[i - 1].adj, (sizeof(int)) * nodes[i - 1].num_adj);
    nodes[i - 1].adj[nodes[i - 1].num_adj - 1] = j - 1;
  }

}

void SCCS_VISIT(int v)
{
  int i = 0;
  int adj;
  time++;
  nodes[v].d_SCC = time;
  nodes[v].low = time;
  nodes[v].on_stack = 1;
  push(v);
  for (i = 0; i < nodes[v].num_adj; i++)
  {
    adj = nodes[v].adj[i];
    if (nodes[adj].d_SCC == 0)
    {
      SCCS_VISIT(adj);
    }
    else
    {
      
    }

    if (nodes[adj].on_stack)
    {
      nodes[v].low = min(nodes[v].low, nodes[adj].low);
    }
    else
    {
      
    }

  }

  if (nodes[v].low == nodes[v].d_SCC)
  {
    gradesSCCs = (int *) realloc(gradesSCCs, (sizeof(int)) * (num_SCCS + 1));
    gradesSCCs[num_SCCS] = 0;
    while (1)
    {
      i = pop();
      gradesSCCs[num_SCCS] = max(gradesSCCs[num_SCCS], nodes[i].grade);
      nodes[i].on_stack = 0;
      nodes[i].SCC = num_SCCS;
      if (i == v)
      {
        break;
      }
      else
      {
        
      }

    }

    num_SCCS++;
  }
  else
  {
    
  }

}

void SCCS()
{
  int v = 0;
  for (v = 0; v < num_students; v++)
  {
    if (nodes[v].d_SCC == 0)
    {
      SCCS_VISIT(v);
    }
    else
    {
      
    }

  }

}

void DFS_VISIT(int v)
{
  int i = 0;
  int adj;
  time++;
  nodes[v].d_DFS = time;
  for (i = 0; i < nodes[v].num_adj; i++)
  {
    adj = nodes[v].adj[i];
    gradesSCCs[nodes[v].SCC] = max(gradesSCCs[nodes[v].SCC], gradesSCCs[nodes[adj].SCC]);
    if (nodes[adj].d_DFS == 0)
    {
      nodes[adj].src = v;
      DFS_VISIT(adj);
    }
    else
    {
      
    }

  }

  if (nodes[v].src >= 0)
  {
    int v_src_SCC = nodes[nodes[v].src].SCC;
    gradesSCCs[v_src_SCC] = max(gradesSCCs[v_src_SCC], gradesSCCs[nodes[v].SCC]);
  }
  else
  {
    
  }

}

void DFS()
{
  int v = 0;
  for (v = 0; v < num_students; v++)
  {
    if (nodes[v].d_DFS == 0)
    {
      DFS_VISIT(v);
    }
    else
    {
      
    }

  }

}

int main()
{
  processInput();
  SCCS();
  time = 0;
  DFS();
  printGrades();
  freeMemory();
  return 0;
}

