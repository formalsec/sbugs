#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct lstNode
{
  int numAluno;
  struct lstNode *nextNode;
} LstNode;
int indexScc = 0;
int *Sccs;
int numComponents = 0;
int min(int num1, int num2)
{
  return (num1 > num2) ? (num2) : (num1);
}

int max(int num1, int num2)
{
  return (num1 > num2) ? (num1) : (num2);
}

int isStackEmpty(int *top)
{
  if ((*top) == (-1))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int isStackFull(int *top, int size)
{
  if ((*top) == (size - 1))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int popStack(int *top, int *stack)
{
  int data;
  if (!isStackEmpty(top))
  {
    data = stack[*top];
    *top -= 1;
    return data;
  }
  else
  {
    
  }

  return 0;
}

void pushStack(int data, int *top, int *stack, int size)
{
  if (!isStackFull(top, size))
  {
    *top += 1;
    stack[*top] = data;
  }
  else
  {
    
  }

}

int isInStack(int data, int *top, int *stack)
{
  int i;
  if (!isStackEmpty(top))
  {
    for (i = 0; i <= (*top); i++)
    {
      if (stack[i] == data)
      {
        return 1;
      }
      else
      {
        
      }

    }

    return 0;
  }
  else
  {
    
  }

  return 0;
}

LstNode *newNode(int numAluno)
{
  LstNode *p = malloc(sizeof(LstNode));
  if (0 != p)
  {
    p->numAluno = numAluno;
    p->nextNode = 0;
  }
  else
  {
    
  }

  return p;
}

void insertNode(LstNode **lstAdjacencias, int numAluno, LstNode *node)
{
  LstNode *auxNode = 0;
  if (lstAdjacencias[numAluno] == 0)
  {
    lstAdjacencias[numAluno] = node;
    return;
  }
  else
  {
    for (auxNode = lstAdjacencias[numAluno]; auxNode->nextNode != 0; auxNode = auxNode->nextNode)
      ;

    auxNode->nextNode = node;
    return;
  }

}

void freeList(LstNode *head)
{
  LstNode *auxNode = 0;
  LstNode *nextNodeAux = 0;
  if (head == 0)
  {
    return;
  }
  else
  {
    
  }

  auxNode = head;
  nextNodeAux = auxNode->nextNode;
  while (nextNodeAux != 0)
  {
    free(auxNode);
    auxNode = nextNodeAux;
    nextNodeAux = nextNodeAux->nextNode;
  }

  free(auxNode);
}

void freeLstAdjacencias(LstNode **lstAdjacencias, int size)
{
  int i;
  for (i = 0; i < size; i++)
  {
    freeList(lstAdjacencias[i]);
  }

  free(lstAdjacencias);
}

void DFSUpdate(int *lstEstimativas, int aluno, int visitante, int numAlunos)
{
  if (lstEstimativas[visitante] < lstEstimativas[aluno])
  {
    lstEstimativas[visitante] = lstEstimativas[aluno];
  }
  else
  {
    
  }

}

void DFSVisit(LstNode **lstAdjacencias, int *lstEstimativas, int *color, int *pai, int max, int aluno, int numAlunos)
{
  LstNode *auxNode = 0;
  int maxAux;
  maxAux = lstEstimativas[aluno];
  color[aluno] = 1;
  for (auxNode = lstAdjacencias[aluno]; auxNode != 0; auxNode = auxNode->nextNode)
  {
    if (color[auxNode->numAluno - 1] == 0)
    {
      pai[auxNode->numAluno - 1] = aluno;
      DFSVisit(lstAdjacencias, lstEstimativas, color, pai, maxAux, auxNode->numAluno - 1, numAlunos);
      maxAux = lstEstimativas[aluno];
    }
    else
    {
      if (color[auxNode->numAluno - 1] == 2)
      {
        DFSUpdate(lstEstimativas, auxNode->numAluno - 1, aluno, numAlunos);
        maxAux = lstEstimativas[aluno];
      }
      else
      {
        
      }

    }

  }

  if ((maxAux > max) && (pai[aluno] != (-1)))
  {
    lstEstimativas[pai[aluno]] = maxAux;
  }
  else
  {
    
  }

  color[aluno] = 2;
}

void DFS(LstNode **lstAdjacencias, int *lstEstimativas, int numAlunos)
{
  int i;
  int *color;
  int *pai;
  int maxVal = 0;
  color = (int *) malloc((sizeof(int)) * numAlunos);
  pai = (int *) malloc((sizeof(int)) * numAlunos);
  for (i = 0; i < numAlunos; i++)
  {
    color[i] = 0;
    pai[i] = -1;
  }

  for (i = 0; i < numAlunos; i++)
  {
    if (color[i] == 0)
    {
      DFSVisit(lstAdjacencias, lstEstimativas, color, pai, maxVal, i, numAlunos);
    }
    else
    {
      
    }

  }

  free(color);
  free(pai);
}

void findMaxInComponents(int *lstEstimativas, int numComponents, int *maxComponents)
{
  int i;
  int component = 0;
  for (i = 0; i < indexScc; i++)
  {
    if (Sccs[i] == 0)
    {
      component++;
    }
    else
    {
      if (lstEstimativas[Sccs[i] - 1] > maxComponents[component])
      {
        maxComponents[component] = lstEstimativas[Sccs[i] - 1];
      }
      else
      {
        
      }

    }

  }

}

void associateComponentVertix(LstNode **ComponentsVertix)
{
  int i;
  int component = 0;
  LstNode *node;
  for (i = 0; i < indexScc; i++)
  {
    if (Sccs[i] == 0)
    {
      component++;
      continue;
    }
    else
    {
      
    }

    node = newNode(Sccs[i]);
    if (0 != node)
    {
      insertNode(ComponentsVertix, component, node);
    }
    else
    {
      
    }

  }

}

void associateVertixComponent(int *vertixComponents)
{
  int i;
  int component = 1;
  for (i = 0; i < indexScc; i++)
  {
    if (Sccs[i] == 0)
    {
      component++;
      continue;
    }
    else
    {
      
    }

    vertixComponents[Sccs[i] - 1] = component;
  }

}

void tarjanVisit(int aluno, int numAlunos, int *d, int *low, int *stack, int *top, int visited, LstNode **lstAdjacencias)
{
  LstNode *auxNode = 0;
  int v;
  d[aluno - 1] = (low[aluno - 1] = visited);
  visited++;
  pushStack(aluno, top, stack, numAlunos);
  for (auxNode = lstAdjacencias[aluno - 1]; auxNode != 0; auxNode = auxNode->nextNode)
  {
    if ((d[auxNode->numAluno - 1] == (-1)) || isInStack(auxNode->numAluno, top, stack))
    {
      if (d[auxNode->numAluno - 1] == (-1))
      {
        tarjanVisit(auxNode->numAluno, numAlunos, d, low, stack, top, visited, lstAdjacencias);
      }
      else
      {
        
      }

      low[aluno - 1] = min(low[aluno - 1], low[auxNode->numAluno - 1]);
    }
    else
    {
      
    }

  }

  if (d[aluno - 1] == low[aluno - 1])
  {
    v = popStack(top, stack);
    Sccs[indexScc++] = v;
    while (aluno != v)
    {
      v = popStack(top, stack);
      Sccs[indexScc++] = v;
    }

    Sccs[indexScc++] = 0;
    numComponents++;
  }
  else
  {
    
  }

}

void executeTarjan(LstNode **lstAdjacencias, int numAlunos)
{
  int *d;
  int *low;
  int *stack;
  int *topP;
  int top = -1;
  int visited = 0;
  int i;
  d = (int *) malloc((sizeof(int)) * numAlunos);
  low = (int *) malloc((sizeof(int)) * numAlunos);
  stack = (int *) malloc((sizeof(int)) * numAlunos);
  topP = &top;
  for (i = 0; i < numAlunos; i++)
  {
    d[i] = -1;
  }

  for (i = 0; i < numAlunos; i++)
  {
    if (d[i] == (-1))
    {
      tarjanVisit(i + 1, numAlunos, d, low, stack, topP, visited, lstAdjacencias);
    }
    else
    {
      
    }

  }

  free(d);
  free(low);
  free(stack);
}

void associateComponents(LstNode **lstAdjacencias, LstNode **ComponentsVertix, int *vertixComponents, int numComponents, int numAlunos, LstNode **lstAdjacenciasCmp)
{
  int k;
  int i;
  int *components;
  LstNode *auxNode = 0;
  LstNode *node = 0;
  LstNode *auxNode2 = 0;
  components = (int *) malloc((sizeof(int)) * numComponents);
  for (i = 0; i < numComponents; i++)
  {
    components[i] = 0;
  }

  for (k = 0; k < numComponents; k++)
  {
    for (auxNode = ComponentsVertix[k]; auxNode != 0; auxNode = auxNode->nextNode)
    {
      for (auxNode2 = lstAdjacencias[auxNode->numAluno - 1]; auxNode2 != 0; auxNode2 = auxNode2->nextNode)
      {
        if ((components[vertixComponents[auxNode2->numAluno - 1] - 1] != 1) && ((vertixComponents[auxNode2->numAluno - 1] - 1) != k))
        {
          components[vertixComponents[auxNode2->numAluno - 1] - 1] = 1;
          node = newNode(vertixComponents[auxNode2->numAluno - 1]);
          if (0 != node)
          {
            insertNode(lstAdjacenciasCmp, k, node);
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    for (auxNode = ComponentsVertix[k]; auxNode != 0; auxNode = auxNode->nextNode)
    {
      for (auxNode2 = lstAdjacencias[auxNode->numAluno - 1]; auxNode2 != 0; auxNode2 = auxNode2->nextNode)
      {
        components[vertixComponents[auxNode2->numAluno - 1] - 1] = 0;
      }

    }

  }

  free(components);
}

int main()
{
  int i = 0;
  int input[2];
  int numAlunos;
  int numLigacoes;
  int *lstEstimativas;
  int *maxComponents;
  int *vertixComponents;
  char stringInput[100];
  char *pt;
  LstNode **lstAdjacencias;
  LstNode **lstAdjacenciasCmp;
  LstNode **ComponentsVertix;
  for (int stringInput_index = 0; stringInput_index < 10; stringInput_index++)
  {
    stringInput[stringInput_index] = new_sym_var(sizeof(char) * 8);
  }

  stringInput[10 - 1] = '\0';
  pt = strtok(stringInput, ",");
  while (pt != 0)
  {
    int a = atoi(pt);
    input[i++] = a;
    pt = strtok(0, ",");
  }

  numAlunos = input[0];
  numLigacoes = input[1];
  if ((numAlunos < 2) && (numLigacoes < 1))
  {
    return 0;
  }
  else
  {
    
  }

  lstEstimativas = (int *) malloc(numAlunos * (sizeof(int)));
  lstAdjacencias = (LstNode **) malloc((sizeof(LstNode *)) * numAlunos);
  for (i = 0; i < numAlunos; i++)
  {
    lstAdjacencias[i] = 0;
  }

  for (i = 0; i < numAlunos; i++)
  {
    int est;
    if (1 != 1)
    {
      return -1;
    }
    else
    {
      est = new_sym_var(sizeof(int) * 8);
      
    }

    lstEstimativas[i] = est;
  }

  Sccs = (int *) malloc((sizeof(int)) * (numAlunos * 2));
  for (i = 0; i < numLigacoes; i++)
  {
    int al1;
    int al2;
    LstNode *node;
    if (((((2 != 2) || (al1 <= 0)) || (al1 > numAlunos)) || (al2 <= 0)) || (al2 > numAlunos))
    {
      return -1;
    }
    else
    {
      al1 = new_sym_var(sizeof(int) * 8);
      al2 = new_sym_var(sizeof(int) * 8);
      
    }

    node = newNode(al2);
    if (0 != node)
    {
      insertNode(lstAdjacencias, al1 - 1, node);
    }
    else
    {
      
    }

  }

  executeTarjan(lstAdjacencias, numAlunos);
  lstAdjacenciasCmp = (LstNode **) malloc((sizeof(LstNode *)) * numComponents);
  ComponentsVertix = (LstNode **) malloc((sizeof(LstNode *)) * numComponents);
  maxComponents = (int *) malloc((sizeof(int)) * numComponents);
  vertixComponents = (int *) malloc((sizeof(int)) * numAlunos);
  for (i = 0; i < numComponents; i++)
  {
    maxComponents[i] = 0;
    ComponentsVertix[i] = 0;
    lstAdjacenciasCmp[i] = 0;
  }

  findMaxInComponents(lstEstimativas, numComponents, maxComponents);
  associateComponentVertix(ComponentsVertix);
  associateVertixComponent(vertixComponents);
  associateComponents(lstAdjacencias, ComponentsVertix, vertixComponents, numComponents, numAlunos, lstAdjacenciasCmp);
  DFS(lstAdjacenciasCmp, maxComponents, numComponents);
  for (i = 0; i < numAlunos; i++)
  {
    lstEstimativas[i] = maxComponents[vertixComponents[i] - 1];
  }

  for (i = 0; i < numAlunos; i++)
  {
    printf("%d\n", lstEstimativas[i]);
  }

  free(maxComponents);
  free(vertixComponents);
  free(Sccs);
  free(lstEstimativas);
  freeLstAdjacencias(lstAdjacencias, numAlunos);
  freeLstAdjacencias(lstAdjacenciasCmp, numComponents);
  freeLstAdjacencias(ComponentsVertix, numComponents);
  return 0;
}

