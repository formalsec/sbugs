#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct stack
{
  int maxsize;
  int top;
  int *items;
} Stack;
typedef struct Node
{
  int vertexNum;
  int data;
  struct Node *next;
} Node;
typedef struct List
{
  Node *head;
} List;
typedef struct Amizade
{
  int indiceum;
  int indicedois;
} Amizade;
List **adjlist;
void addNode(int s, int s_data, int d, int d_data)
{
  Node *dest;
  Node *tmp;
  Node *src;
  if (adjlist[s]->head == 0)
  {
    src = (Node *) malloc(sizeof(Node));
    src->vertexNum = s;
    src->data = s_data;
    src->next = 0;
    adjlist[s]->head = src;
  }
  else
  {
    
  }

  dest = (Node *) malloc(sizeof(Node));
  dest->vertexNum = d;
  dest->data = d_data;
  dest->next = 0;
  tmp = adjlist[s]->head;
  while (tmp->next != 0)
    tmp = tmp->next;

  tmp->next = dest;
}

struct stack *newStack(int capacity)
{
  struct stack *pt = (struct stack *) malloc(sizeof(struct stack));
  pt->maxsize = capacity;
  pt->top = -1;
  pt->items = (int *) malloc((sizeof(int)) * capacity);
  return pt;
}

int isEmpty(struct stack *pt)
{
  return pt->top == (-1);
}

int isFull(struct stack *pt)
{
  return pt->top == (pt->maxsize - 1);
}

int size(struct stack *pt)
{
  return pt->top + 1;
}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

int max(int aa, int b)
{
  return (aa > b) ? (aa) : (b);
}

void push(struct stack *pt, int x)
{
  if (isFull(pt))
  {
    printf("OverFlow\nProgram Terminated\n");
    exit(1);
  }
  else
  {
    
  }

  pt->items[++pt->top] = x;
}

int peek(struct stack *pt)
{
  if (!isEmpty(pt))
  {
    return pt->items[pt->top];
  }
  else
  {
    exit(1);
  }

}

int pop(struct stack *pt)
{
  if (isEmpty(pt))
  {
    printf("UnderFlow\nProgram Terminated\n");
    exit(1);
  }
  else
  {
    
  }

  return pt->items[pt->top--];
}

void findComponent(int u, int array_notas[], int disc[], int low[], int length, Stack *stk, bool stkItem[])
{
  static int time = 0;
  int v;
  Node *temp;
  disc[u] = (low[u] = ++time);
  push(stk, u);
  stkItem[u] = true;
  if (adjlist[u]->head != 0)
  {
    for (v = 0; v < length; v++)
    {
      temp = adjlist[u]->head->next;
      while (temp != 0)
      {
        if (v == temp->vertexNum)
        {
          if (disc[v] == (-1))
          {
            findComponent(v, array_notas, disc, low, length, stk, stkItem);
            low[u] = min(low[u], low[v]);
            if (adjlist[v]->head != 0)
            {
              adjlist[u]->head->data = max(adjlist[u]->head->data, adjlist[v]->head->data);
            }
            else
            {
              adjlist[u]->head->data = max(adjlist[u]->head->data, array_notas[v]);
            }

          }
          else
          {
            if (stkItem[v])
            {
              low[u] = min(low[u], low[v]);
              if (adjlist[v]->head != 0)
              {
                adjlist[u]->head->data = max(adjlist[u]->head->data, adjlist[v]->head->data);
              }
              else
              {
                adjlist[u]->head->data = max(adjlist[u]->head->data, array_notas[v]);
              }

            }
            else
            {
              
            }

          }

        }
        else
        {
          
        }

        temp = temp->next;
      }

    }

  }
  else
  {
    
  }

  int poppedItem = 0;
  if (low[u] == disc[u])
  {
    while (peek(stk) != u)
    {
      poppedItem = peek(stk);
      stkItem[poppedItem] = false;
      pop(stk);
    }

    poppedItem = peek(stk);
    stkItem[poppedItem] = false;
    pop(stk);
  }
  else
  {
    
  }

}

void strongConComponent(int length, int array_notas[])
{
  int disc[length];
  int low[length];
  int i;
  bool stkItem[length];
  Stack *stk = newStack(length);
  for (i = 0; i < length; i++)
  {
    disc[i] = (low[i] = -1);
    stkItem[i] = false;
  }

  for (i = 0; i < length; i++)
  {
    if (disc[i] == (-1))
    {
      findComponent(i, array_notas, disc, low, length, stk, stkItem);
    }
    else
    {
      
    }

  }

}

int main()
{
  char *token;
  char aux[10];
  char auxdois[10];
  char input[10];
  Amizade *array_amizades = (Amizade *) malloc(sizeof(Amizade));
  int *array_notas = (int *) malloc(sizeof(int));
  int nalunos = 0;
  int namizades = 15;
  int contador = -1;
  int contador_aux = 0;
  int i;
  int h;
  while (!(contador_aux >= namizades))
  {
    for (int input_index = 0; input_index < 10; input_index++)
    {
      input[input_index] = new_sym_var(sizeof(char) * 8);
    }

    input[10 - 1] = '\0';
    if (contador == (-1))
    {
      token = strtok(input, ",");
      strcpy(aux, token);
      nalunos = atoi(aux);
      token = strtok(0, "\0");
      strcpy(aux, token);
      namizades = atoi(aux);
      array_notas = (int *) realloc(array_notas, (sizeof(int)) * nalunos);
      array_amizades = (Amizade *) realloc(array_amizades, (sizeof(Amizade)) * namizades);
      contador++;
    }
    else
    {
      if (contador < nalunos)
      {
        token = strtok(input, "\0");
        strcpy(aux, token);
        array_notas[contador] = atoi(aux);
        contador++;
      }
      else
      {
        if (contador_aux < namizades)
        {
          token = strtok(input, " ");
          strcpy(aux, token);
          token = strtok(0, "\0");
          strcpy(auxdois, token);
          array_amizades[contador_aux].indiceum = atoi(aux) - 1;
          array_amizades[contador_aux].indicedois = atoi(auxdois) - 1;
          contador_aux++;
        }
        else
        {
          
        }

      }

    }

  }

  adjlist = (List **) malloc((sizeof(List *)) * nalunos);
  for (i = 0; i < nalunos; i++)
  {
    adjlist[i] = (List *) malloc(sizeof(List));
    adjlist[i]->head = 0;
  }

  for (h = 0; h < namizades; h++)
  {
    int index_p = array_amizades[h].indiceum;
    int index_s = array_amizades[h].indicedois;
    addNode(index_p, array_notas[index_p], index_s, array_notas[index_s]);
  }

  strongConComponent(nalunos, array_notas);
  for (i = 0; i < nalunos; i++)
  {
    if (adjlist[i]->head != 0)
    {
      printf("%d\n", adjlist[i]->head->data);
    }
    else
    {
      printf("%d\n", array_notas[i]);
    }

  }

  return 0;
}

