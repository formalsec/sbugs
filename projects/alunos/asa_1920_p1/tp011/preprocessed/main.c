#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct Person
{
  int grade;
  int pos;
  int i_pos;
  int n_friends;
  int current_friend;
  int color;
  struct Person **friends;
} person;
typedef struct Dummy
{
  int grade;
  int pos;
} dummy;
int get_next_node(int, person *);
int close_node(int, person *);
int search(int, int, person *, dummy *);
void heapify(dummy *array, int, int);
int main(int argc, char *argv[])
{
  int n_nodes;
  int n_c;
  int current;
  int i;
  int p;
  int c;
  int stack_size;
  int next;
  int n_dummies;
  person *array;
  person *stack;
  dummy *dummyArray;
  dummy aux;
  n_nodes = new_sym_var(sizeof(int) * 8);
  n_c = new_sym_var(sizeof(int) * 8);
  array = malloc((sizeof(person)) * (n_nodes + 1));
  dummyArray = malloc((sizeof(dummy)) * (n_nodes + 1));
  stack = malloc(sizeof(person));
  for (i = 1; i <= n_nodes; i++)
  {
    array[i].grade = new_sym_var(sizeof(int) * 8);
    array[i].pos = i;
    array[i].i_pos = i;
    array[i].n_friends = 0;
    array[i].current_friend = 0;
    array[i].color = 1000;
    array[i].friends = malloc(sizeof(person *));
    dummyArray[i - 1].grade = array[i].grade;
    dummyArray[i - 1].pos = i;
  }

  for (i = 0; i < n_c; i++)
  {
    p = new_sym_var(sizeof(int) * 8);
    c = new_sym_var(sizeof(int) * 8);
    array[p].friends = realloc(array[p].friends, (sizeof(person **)) * (array[p].n_friends + 1));
    array[p].friends[array[p].n_friends] = &array[c];
    array[p].n_friends++;
  }

  n_dummies = (sizeof(dummyArray)) / (sizeof(dummy));
  for (i = (n_dummies / 2) - 1; i >= 0; i--)
  {
    heapify(dummyArray, n_dummies, i);
  }

  for (i = n_nodes - 1; i >= 0; i--)
  {
    aux = dummyArray[i];
    dummyArray[i] = dummyArray[0];
    dummyArray[0] = aux;
    heapify(dummyArray, i, 0);
  }

  current = 0;
  stack_size = 1;
  stack[0] = array[dummyArray[0].pos];
  array[dummyArray[0].pos].color = 1001;
  while (1 == 1)
  {
    next = get_next_node(stack[stack_size - 1].pos, array);
    if (next == (-1))
    {
      close_node(stack[stack_size - 1].pos, array);
      stack = realloc(stack, (sizeof(person)) * (stack_size - 1));
      stack_size--;
    }
    else
    {
      stack = realloc(stack, (sizeof(person)) * (stack_size + 1));
      stack[stack_size] = array[next];
      stack_size++;
    }

    if (stack_size == 0)
    {
      current = search(current, n_nodes, array, dummyArray);
      if (current != (-1))
      {
        stack = realloc(stack, (sizeof(person)) * (stack_size + 1));
        stack[stack_size] = array[dummyArray[current].pos];
        array[dummyArray[current].pos].color = 1001;
        stack_size++;
      }
      else
      {
        break;
      }

    }
    else
    {
      
    }

  }

  for (i = 1; i <= n_nodes; i++)
  {
    printf("%d\n", array[i].grade);
  }

  for (i = 1; i <= n_nodes; i++)
  {
    free(array[i].friends);
  }

  free(array);
  return 0;
}

void heapify(dummy *array, int n_node, int i)
{
  int largest = i;
  int l = (2 * i) + 1;
  int r = (2 * i) + 2;
  dummy aux;
  if ((l < n_node) && (array[l].grade < array[largest].grade))
  {
    largest = l;
  }
  else
  {
    
  }

  if ((r < n_node) && (array[r].grade < array[largest].grade))
  {
    largest = r;
  }
  else
  {
    
  }

  if (largest != i)
  {
    aux = array[i];
    array[i] = array[largest];
    array[largest] = aux;
    heapify(array, n_node, largest);
  }
  else
  {
    
  }

}

int get_next_node(int pos, person *array)
{
  int i;
  int current;
  int limit;
  current = array[pos].current_friend;
  limit = array[pos].n_friends;
  for (i = current; i < limit; i++)
  {
    if (array[pos].friends[i]->color == 1000)
    {
      array[pos].current_friend = i;
      if (array[pos].friends[i]->grade > array[pos].grade)
      {
        array[pos].grade = array[pos].friends[i]->grade;
      }
      else
      {
        
      }

      array[pos].friends[i]->color = 1001;
      return array[pos].friends[i]->pos;
    }
    else
    {
      
    }

  }

  return -1;
}

int close_node(int pos, person *array)
{
  int i;
  for (i = 0; i < array[pos].n_friends; i++)
  {
    if (array[pos].friends[i]->grade > array[pos].grade)
    {
      array[pos].grade = array[pos].friends[i]->grade;
    }
    else
    {
      
    }

  }

  array[pos].color = 1002;
  return 0;
}

int search(int current, int n_nodes, person *array, dummy *dummyArray)
{
  int i;
  for (i = current; i < n_nodes; i++)
  {
    if (array[dummyArray[i].pos].color == 1000)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

