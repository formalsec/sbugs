/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct item
{
  int n;
  struct item *prox;
} Item;
int nV;
int nE;
int Vorig;
int Vdest;
Item list[1000000 + 1];
int pi[1000000 + 1];
int d[1000000 + 1];
int low[1000000 + 1];
int color[1000000 + 1];
int t;
int w[1000000 + 1];
void addEdge(Item *list, int u, int v)
{
  Item *aux;
  Item *tmp;
  aux = (Item *) malloc((int) (sizeof(Item)));
  aux->n = v;
  aux->prox = 0;
  list[u].n++;
  if (list[u].prox == 0)
  {
    list[u].prox = aux;
  }
  else
  {
    tmp = list[u].prox;
    if (tmp->n > v)
    {
      aux->prox = tmp;
      list[u].prox = aux;
    }
    else
    {
      if (tmp->prox == 0)
      {
        aux->prox = tmp->prox;
        tmp->prox = aux;
      }
      else
      {
        while ((tmp->prox != 0) && (tmp->prox->n < v))
          tmp = tmp->prox;

        aux->prox = tmp->prox;
        tmp->prox = aux;
      }

    }

  }

}

int min(int a, int b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

int max(int a, int b)
{
  if (a > b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

void DFSutil(int u)
{
  Item *v;
  v = (Item *) malloc((int) (sizeof(Item)));
  color[u] = 1;
  int nChild = 0;
  d[u] = (low[u] = ++t);
  for (v = list[u].prox; v != 0; v = v->prox)
  {
    if (color[v->n] == 0)
    {
      nChild++;
      pi[v->n] = u;
      DFSutil(v->n);
      low[u] = min(low[u], low[v->n]);
    }
    else
    {
      if (v->n != pi[u])
      {
        low[u] = min(low[u], d[v->n]);
      }
      else
      {
        
      }

    }

    w[u] = max(w[u], w[v->n]);
  }

}

void DFS(Item l)
{
  int i;
  for (i = 1; i <= nV; i++)
  {
    color[i] = 0;
    pi[i] = -1;
  }

  t = 0;
  for (i = 1; i <= nV; i++)
  {
    if (color[i] == 0)
    {
      DFSutil(i);
    }
    else
    {
      
    }

  }

}

int main(int argc, char *argv[])
{
  nV = new_sym_var(sizeof(int) * 8);
  nE = new_sym_var(sizeof(int) * 8);
  int i;
  int j;
  int k;
  for (j = 1; j <= nV; j++)
  {
    w[j] = new_sym_var(sizeof(int) * 8);
  }

  for (i = 1; i <= nV; i++)
  {
    list[i].n = 0;
    list[i].prox = 0;
  }

  for (j = 1; j <= nE; j++)
  {
    Vorig = new_sym_var(sizeof(int) * 8);
    Vdest = new_sym_var(sizeof(int) * 8);
    addEdge(list, Vorig, Vdest);
  }

  DFS(*list);
  int printed = 0;
  for (k = 1; k <= nV; k++)
  {
    if (printed)
    {
      printf("\n%d", w[k]);
    }
    else
    {
      printed++;
      printf("%d", w[k]);
    }

  }

  printf("\n");
  return 0;
}

