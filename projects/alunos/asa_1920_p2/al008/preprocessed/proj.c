#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>


struct Node
{
  int dest;
  struct Node *next;
  int key;
};
struct Graph
{
  int V;
  struct Node **array;
  int *visited;
  int *parent;
};
struct Queue
{
  int *items;
  int front;
  int size;
};
struct Node *newNode(int dest);
struct Graph *createGraph(int V);
void addEdge(struct Graph *graph, int src, int dest);
void deleteEdge(struct Graph *graph, int src, int neighbor);
void addSuperMarket(int numSMark, int t, int numAvn, struct Graph *graph);
void addCitzen(int numCitzen, int numAvn, int numSt, struct Graph *graph);
void connectNeighbors(struct Graph *graph, int numAvn, int numSt);
void freeList(struct Node *head);
struct Queue *createQueue();
void freeQueue(struct Queue *queue);
int isEmpty(struct Queue *q);
void enqueue(struct Queue *q, int value);
int dequeue(struct Queue *q);
int bfs(struct Graph *graph, int startVertex, int sink, int n);
int edmondsKarp(struct Graph *graph, int s, int t, int n);
struct Node *newNode(int dest)
{
  struct Node *node = (struct Node *) malloc(sizeof(struct Node));
  node->dest = dest;
  node->next = 0;
  return node;
}

struct Graph *createGraph(int V)
{
  int i;
  struct Graph *graph = (struct Graph *) malloc(sizeof(struct Graph));
  graph->V = V;
  graph->array = (struct Node **) calloc(V, sizeof(struct Node *));
  graph->visited = (int *) calloc(V, sizeof(int));
  graph->parent = (int *) calloc(V, sizeof(int));
  for (i = 0; i < V; i++)
  {
    graph->array[i] = (struct Node *) calloc(1, sizeof(struct Node));
    graph->parent[i] = -1;
  }

  return graph;
}

void addEdge(struct Graph *graph, int src, int dest)
{
  struct Node *node = newNode(dest);
  if (graph->array[src] == 0)
  {
    graph->array[src] = node;
  }
  else
  {
    struct Node *temp = graph->array[src];
    while (temp->next)
    {
      temp = temp->next;
    }

    temp->next = node;
  }

}

void deleteEdge(struct Graph *graph, int src, int neighbor)
{
  struct Node *current = graph->array[src];
  struct Node *temp;
  while (current)
  {
    if (current->dest == neighbor)
    {
      graph->array[src] = current->next;
      free(current);
      break;
    }
    else
    {
      if (current->next == 0)
      {
        return;
      }
      else
      {
        if (current->next->dest == neighbor)
        {
          temp = current->next;
          current->next = temp->next;
          free(temp);
          break;
        }
        else
        {
          
        }

      }

    }

    current = current->next;
  }

}

void addSuperMarket(int numSMark, int t, int numAvn, struct Graph *graph)
{
  int i;
  int index;
  int av;
  int st;
  char buffer[100];
  for (i = 0; i < numSMark; i++)
  {
    fgets(buffer, 100, stdin);
    av = new_sym_var(sizeof(int) * 8);
    st = new_sym_var(sizeof(int) * 8);
    index = 2 * (((st - 1) * numAvn) + av);
    addEdge(graph, index, t);
    graph->array[index]->key = 1;
    graph->array[index - 1]->key = 1;
  }

}

void addCitzen(int numCitzen, int s, int numAvn, struct Graph *graph)
{
  int i;
  int index;
  int av;
  int st;
  char buffer[100];
  for (i = 0; i < numCitzen; i++)
  {
    fgets(buffer, 100, stdin);
    av = new_sym_var(sizeof(int) * 8);
    st = new_sym_var(sizeof(int) * 8);
    index = (2 * (((st - 1) * numAvn) + av)) - 1;
    addEdge(graph, s, index);
    graph->array[index]->key = 2;
    graph->array[index + 1]->key = 2;
  }

}

void connectNeighbors(struct Graph *graph, int numAvn, int numSt)
{
  int i;
  int total = (2 * numAvn) * numSt;
  for (i = 1; i < (graph->V - 1); i++)
  {
    if ((graph->array[i]->key == 1) && ((i % 2) != 0))
    {
      addEdge(graph, i, i + 1);
    }
    else
    {
      
    }

    if (graph->array[i]->key != 1)
    {
      if ((i % 2) != 0)
      {
        addEdge(graph, i, i + 1);
      }
      else
      {
        if (i > (2 * numAvn))
        {
          addEdge(graph, i, (i - (2 * numAvn)) - 1);
        }
        else
        {
          
        }

        if ((i > 3) && (((i - 2) % numAvn) != 0))
        {
          addEdge(graph, i, i - 3);
        }
        else
        {
          
        }

        if ((i == 2) || ((i % (numAvn * 2)) != 0))
        {
          addEdge(graph, i, i + 1);
        }
        else
        {
          
        }

        if (i <= (total - (2 * numAvn)))
        {
          addEdge(graph, i, (i + (2 * numAvn)) - 1);
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

}

void freeList(struct Node *head)
{
  struct Node *tmp;
  while (head != 0)
  {
    tmp = head;
    head = head->next;
    free(tmp);
  }

}

struct Queue *createQueue()
{
  struct Queue *q = malloc(sizeof(struct Queue));
  q->front = 0;
  q->size = 0;
  q->items = 0;
  return q;
}

void freeQueue(struct Queue *queue)
{
  free(queue->items);
  free(queue);
}

int isEmpty(struct Queue *q)
{
  return q->size == q->front;
}

void enqueue(struct Queue *q, int value)
{
  q->size += 1;
  q->items = realloc(q->items, q->size * (sizeof(int)));
  q->items[q->size - 1] = value;
}

int dequeue(struct Queue *q)
{
  if (isEmpty(q))
  {
    return -1;
  }
  else
  {
    
  }

  int value = q->items[q->front];
  q->front += 1;
  return value;
}

int bfs(struct Graph *graph, int startVertex, int sink, int n)
{
  struct Queue *q = createQueue();
  memset(graph->parent, -1, graph->V * (sizeof(int)));
  memset(graph->visited, 0, graph->V * (sizeof(int)));
  graph->visited[startVertex] = 1;
  enqueue(q, startVertex);
  while (!isEmpty(q))
  {
    int currentVertex = dequeue(q);
    struct Node *temp = graph->array[currentVertex];
    while (temp != 0)
    {
      int adjVertex = temp->dest;
      if (graph->visited[adjVertex] == 0)
      {
        enqueue(q, adjVertex);
        graph->visited[adjVertex] = 1;
        graph->parent[adjVertex] = currentVertex;
      }
      else
      {
        
      }

      temp = temp->next;
    }

  }

  freeQueue(q);
  if (graph->visited[sink] == 1)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int edmondsKarp(struct Graph *graph, int s, int t, int n)
{
  int flow = 0;
  int j;
  while (bfs(graph, s, t, n))
  {
    for (j = t; graph->parent[j] != (-1); j = graph->parent[j])
    {
      deleteEdge(graph, graph->parent[j], j);
      addEdge(graph, j, graph->parent[j]);
    }

    flow++;
  }

  return flow;
}

int main()
{
  int numSt;
  int numAvn;
  int numSMark;
  int numCitzen;
  char buffer[100];
  int i;
  int s;
  int t;
  fgets(buffer, 100, stdin);
  numAvn = new_sym_var(sizeof(int) * 8);
  numSt = new_sym_var(sizeof(int) * 8);
  fgets(buffer, 100, stdin);
  numSMark = new_sym_var(sizeof(int) * 8);
  numCitzen = new_sym_var(sizeof(int) * 8);
  s = 0;
  t = (2 * (numAvn * numSt)) + 1;
  struct Graph *graph = createGraph(((numAvn * numSt) * 2) + 2);
  addSuperMarket(numSMark, t, numAvn, graph);
  addCitzen(numCitzen, s, numAvn, graph);
  connectNeighbors(graph, numAvn, numSt);
  for (i = 0; i < graph->V; i++)
  {
    deleteEdge(graph, i, 0);
  }

  printf("%d\n", edmondsKarp(graph, s, t, numCitzen));
  for (i = 0; i < graph->V; i++)
  {
    freeList(graph->array[i]);
  }

  free(graph->parent);
  free(graph->visited);
  free(graph->array);
  free(graph);
  return 0;
}

