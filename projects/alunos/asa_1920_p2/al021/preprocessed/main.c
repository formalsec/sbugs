#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>


typedef int **adj_matrix;
typedef struct ll_node
{
  int i;
  int capacity;
  struct ll_node *reverse;
  struct ll_node *next;
} *ll_node_ptr;
typedef struct graph
{
  int order;
  ll_node_ptr *llacency_list;
} graph;
typedef struct circ_list_struct
{
  int item;
  struct circ_list_struct *next;
  struct circ_list_struct *prev;
} circ_list;
int c_list_is_empty(circ_list **root)
{
  return (*root) == 0;
}

void c_list_add_last(circ_list **root, int item)
{
  circ_list *new = (circ_list *) malloc(sizeof(circ_list));
  circ_list *last = 0;
  new->item = item;
  if (c_list_is_empty(root))
  {
    *root = new;
    new->prev = new;
    new->next = new;
  }
  else
  {
    last = (*root)->prev;
    new->item = item;
    last->next = new;
    new->prev = last;
    (*root)->prev = new;
    new->next = *root;
  }

}

int c_list_pop(circ_list **root)
{
  int item = -1;
  circ_list *aux = *root;
  struct circ_list_struct *prev = 0;
  struct circ_list_struct *next = 0;
  if (!c_list_is_empty(root))
  {
    item = (*root)->item;
    if ((*root) != (*root)->next)
    {
      item = (*root)->item;
      *root = (*root)->next;
      prev = aux->prev;
      next = aux->next;
      prev->next = next;
      next->prev = prev;
      free(aux);
    }
    else
    {
      free(*root);
      *root = 0;
    }

    return item;
  }
  else
  {
    return -1;
  }

}

void c_list_free(circ_list **root)
{
  if (!c_list_is_empty(root))
  {
    while ((*root) != 0)
      c_list_pop(root);

  }
  else
  {
    
  }

}

int c_list_is_in(circ_list *root, int i)
{
  circ_list *aux = root;
  while (aux->next != root)
  {
    if (aux->item == i)
    {
      return 1;
    }
    else
    {
      
    }

    aux = aux->next;
  }

  if (aux->item == i)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

ll_node_ptr *ll_adj_init(int number_of_nodes)
{
  int i = 0;
  ll_node_ptr *ll_list = malloc((sizeof(ll_node_ptr)) * number_of_nodes);
  while (i < number_of_nodes)
  {
    ll_list[i] = 0;
    i++;
  }

  return ll_list;
}

ll_node_ptr ll_delete_node(ll_node_ptr head)
{
  ll_node_ptr new_head = head->next;
  free(head);
  head = new_head;
  return head;
}

void ll_delete_list(ll_node_ptr *list, int number_of_vertices)
{
  int i = 0;
  while (i < number_of_vertices)
  {
    while (list[i] != 0)
      list[i] = ll_delete_node(list[i]);

    i++;
  }

  free(list);
}

ll_node_ptr ll_get_next_node(ll_node_ptr current)
{
  return current->next;
}

int ll_get_i(ll_node_ptr node)
{
  return node->i;
}

ll_node_ptr ll_new_entry(int edge_to, int capacity)
{
  ll_node_ptr new_entry = malloc(sizeof(struct ll_node));
  new_entry->i = edge_to;
  new_entry->capacity = capacity;
  new_entry->next = 0;
  new_entry->reverse = 0;
  return new_entry;
}

int get_edge_cap(ll_node_ptr node)
{
  return node->capacity;
}

void set_edge_cap(ll_node_ptr node, int new_cap)
{
  node->capacity = new_cap;
}

ll_node_ptr get_reverse_edge(ll_node_ptr edge)
{
  return edge->reverse;
}

void set_reverse_edge(ll_node_ptr edge_1, ll_node_ptr edge_2)
{
  if ((edge_1 != 0) && (edge_2 != 0))
  {
    edge_1->reverse = edge_2;
  }
  else
  {
    
  }

}

graph *graph_create(int number_of_vertices)
{
  graph *g = malloc(sizeof(graph));
  g->order = number_of_vertices;
  g->llacency_list = ll_adj_init(number_of_vertices);
  return g;
}

void graph_delete(graph *g)
{
  ll_delete_list(g->llacency_list, g->order);
  free(g);
}

ll_node_ptr graph_get_node_edges(graph *g, int vertex_index)
{
  return g->llacency_list[vertex_index];
}

int graph_get_order(graph *g)
{
  return g->order;
}

int graph_has_edge(graph *g, int u, int v)
{
  ll_node_ptr aux = 0;
  ll_node_ptr *vertex_head = &g->llacency_list[u];
  for (aux = *vertex_head; aux != 0; aux = aux->next)
  {
    if (aux->i == v)
    {
      return 1;
    }
    else
    {
      
    }

  }

  return 0;
}

ll_node_ptr graph_get_edge(graph *g, int u, int v)
{
  ll_node_ptr aux = 0;
  ll_node_ptr *vertex_head = &g->llacency_list[u];
  for (aux = *vertex_head; aux != 0; aux = aux->next)
  {
    if (aux->i == v)
    {
      return aux;
    }
    else
    {
      
    }

  }

  return 0;
}

ll_node_ptr graph_add_edge(graph *g, int u, int v, int cap)
{
  if (!graph_has_edge(g, u, v))
  {
    ll_node_ptr *vertex_head = &g->llacency_list[u];
    ll_node_ptr new_edge = ll_new_entry(v, cap);
    if ((*vertex_head) == 0)
    {
      *vertex_head = new_edge;
    }
    else
    {
      ll_node_ptr aux = 0;
      int found = 0;
      for (aux = *vertex_head; aux->next != 0; aux = aux->next)
      {
        if (aux->next->i >= new_edge->i)
        {
          new_edge->next = aux->next;
          aux->next = new_edge;
          found = 1;
          break;
        }
        else
        {
          
        }

      }

      if (!found)
      {
        aux->next = new_edge;
      }
      else
      {
        
      }

    }

    return new_edge;
  }
  else
  {
    
  }

  return 0;
}

void add_edge_and_reverse(graph *g, int u, int v, int cap)
{
  if (g != 0)
  {
    if ((((u >= 0) && (u < g->order)) && (v >= 0)) && (v < g->order))
    {
      ll_node_ptr uu = graph_add_edge(g, u, v, cap);
      ll_node_ptr vv = graph_add_edge(g, v, u, 0);
      set_reverse_edge(uu, vv);
      set_reverse_edge(vv, uu);
    }
    else
    {
      
    }

  }
  else
  {
    
  }

}

int BFS(graph *g, int source, int sink, int pred[])
{
  circ_list *queue = 0;
  int v = -1;
  int i = 0;
  ll_node_ptr ll_list = 0;
  for (i = 0; i < graph_get_order(g); i++)
  {
    pred[i] = -1;
  }

  c_list_add_last(&queue, source);
  while (!c_list_is_empty(&queue))
  {
    v = c_list_pop(&queue);
    ll_list = graph_get_node_edges(g, v);
    for (; ll_list != 0; ll_list = ll_get_next_node(ll_list))
    {
      if (((pred[ll_list->i] == (-1)) && (ll_list->i != source)) && (get_edge_cap(ll_list) > 0))
      {
        pred[ll_list->i] = v;
        c_list_add_last(&queue, ll_list->i);
        if (ll_list->i == sink)
        {
          c_list_free(&queue);
          return 1;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  c_list_free(&queue);
  return -1;
}

int max_flow(graph *g, int source, int sink)
{
  int pred[graph_get_order(g)];
  int max_flow = 0;
  int parent = sink;
  ll_node_ptr edge = 0;
  while (BFS(g, source, sink, pred) != (-1))
  {
    for (parent = sink; pred[parent] != (-1); parent = pred[parent])
    {
      edge = graph_get_edge(g, pred[parent], parent);
      set_edge_cap(edge, 0);
      set_edge_cap(get_reverse_edge(edge), 1);
    }

    max_flow++;
  }

  return max_flow;
}

int main()
{
  int n_avenues = 0;
  int n_streets = 0;
  int n_people = 0;
  int n_markets = 0;
  graph *city = 0;
  int max_people = 0;
  int cord = 0;
  int totalv = 0;
  int i = 0;
  int j = 0;
  n_avenues = new_sym_var(sizeof(int) * 8);
  n_streets = new_sym_var(sizeof(int) * 8);
  totalv = n_streets * n_avenues;
  city = graph_create((totalv * 2) + 2);
  for (i = 0; i < n_avenues; i++)
  {
    for (j = 0; j < n_streets; j++)
    {
      cord = (i * n_streets) + j;
      if (j != 0)
      {
        add_edge_and_reverse(city, cord + totalv, cord - 1, 1);
        add_edge_and_reverse(city, (cord + totalv) - 1, cord, 1);
      }
      else
      {
        
      }

      if (i != 0)
      {
        add_edge_and_reverse(city, cord + totalv, ((i - 1) * n_streets) + j, 1);
        add_edge_and_reverse(city, (((i - 1) * n_streets) + j) + totalv, cord, 1);
      }
      else
      {
        
      }

      add_edge_and_reverse(city, cord, cord + totalv, 1);
    }

  }

  n_markets = new_sym_var(sizeof(int) * 8);
  n_people = new_sym_var(sizeof(int) * 8);
  for (i = 0; i < n_markets; i++)
  {
    int avenue = 0;
    int street = 0;
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    add_edge_and_reverse(city, (((avenue - 1) * n_streets) + (street - 1)) + totalv, (totalv * 2) + 1, 1);
  }

  for (i = 0; i < n_people; i++)
  {
    int avenue = 0;
    int street = 0;
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    add_edge_and_reverse(city, totalv * 2, ((avenue - 1) * n_streets) + (street - 1), 1);
  }

  max_people = max_flow(city, totalv * 2, (totalv * 2) + 1);
  printf("%d\n", max_people);
  graph_delete(city);
  return 0;
}

