#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int avenues = 0;
int streets = 0;
int nodes = 0;
int maxnodes = 0;
int num_citizens = 0;
int num_markets = 0;
typedef struct intersectionLink
{
  int pos;
  int flow;
  struct intersectionLink *next;
} *link;
typedef struct intersection
{
  link connections;
} Intersection;
int *citizens;
int *markets;
int *pred;
int *q;
int *color;
int head = 0;
int end = 0;
Intersection *intersections;
int min(int v1, int v2)
{
  if (v1 < v2)
  {
    return v1;
  }
  else
  {
    return v2;
  }

}

int calcPos(int st, int av)
{
  return (st * avenues) + av;
}

int repeated(int *list, int len, int v)
{
  int i = 0;
  for (i = 0; (i < len) && (list[i] != (-1)); i++)
    if (list[i] == v)
  {
    return 1;
  }
  else
  {
    
  }


  return 0;
}

int getFlow(int s, int t)
{
  link aux;
  for (aux = intersections[s].connections; aux != 0; aux = aux->next)
  {
    if (aux->pos == t)
    {
      return aux->flow;
    }
    else
    {
      
    }

  }

  return 0;
}

void setFlow(int s, int t, int flow)
{
  link aux;
  for (aux = intersections[s].connections; aux != 0; aux = aux->next)
  {
    if (aux->pos == t)
    {
      aux->flow -= flow;
    }
    else
    {
      
    }

  }

  for (aux = intersections[t].connections; aux != 0; aux = aux->next)
  {
    if (aux->pos == s)
    {
      aux->flow += flow;
    }
    else
    {
      
    }

  }

}

link newLink(int pos, int flow)
{
  link l = (link) malloc(sizeof(struct intersectionLink));
  l->pos = pos;
  l->flow = flow;
  l->next = 0;
  return l;
}

void insertLink(int v1, int v2, int flow)
{
  link l = newLink(v2, flow);
  if (intersections[v1].connections == 0)
  {
    intersections[v1].connections = l;
  }
  else
  {
    l->next = intersections[v1].connections;
    intersections[v1].connections = l;
  }

}

void queue(int x)
{
  q[end] = x;
  end++;
  color[x] = 1;
}

int outqueue()
{
  int x = q[head];
  head++;
  color[x] = 2;
  return x;
}

int bfs(int source, int sink)
{
  int i = 0;
  int j = 0;
  int flow = 0;
  link aux;
  memset(color, 0, maxnodes * (sizeof(int)));
  head = (end = 0);
  queue(source);
  pred[source] = -1;
  while (head != end)
  {
    i = outqueue();
    for (aux = intersections[i].connections; aux != 0; aux = aux->next)
    {
      j = aux->pos;
      flow = aux->flow;
      if ((color[j] == 0) && (flow > 0))
      {
        queue(j);
        pred[j] = i;
        if (j == sink)
        {
          return 1;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  return color[sink] == 2;
}

int fordFulkerson(int source, int sink)
{
  int maxFlow = 0;
  int flow;
  int i;
  while (bfs(source, sink))
  {
    flow = 1;
    for (i = sink; pred[i] >= 0; i = pred[i])
    {
      flow = min(flow, getFlow(pred[i], i));
    }

    for (i = sink; pred[i] >= 0; i = pred[i])
    {
      setFlow(pred[i], i, flow);
    }

    maxFlow += flow;
    if (maxFlow == num_citizens)
    {
      break;
    }
    else
    {
      
    }

  }

  return maxFlow;
}

void calcLinks()
{
  int i = 0;
  int j = 0;
  int k = 0;
  for (i = 0; i < (2 * streets); i++)
  {
    for (j = 0; j < avenues; j++)
    {
      if (i >= streets)
      {
        k = i - streets;
        if ((k - 1) >= 0)
        {
          insertLink(calcPos(i, j), calcPos(k - 1, j), 1);
          insertLink(calcPos(k - 1, j), calcPos(i, j), 0);
        }
        else
        {
          
        }

        if ((k + 1) <= (streets - 1))
        {
          insertLink(calcPos(i, j), calcPos(k + 1, j), 1);
          insertLink(calcPos(k + 1, j), calcPos(i, j), 0);
        }
        else
        {
          
        }

        if ((j + 1) <= (avenues - 1))
        {
          insertLink(calcPos(i, j), calcPos(k, j + 1), 1);
          insertLink(calcPos(k, j + 1), calcPos(i, j), 0);
        }
        else
        {
          
        }

        if ((j - 1) >= 0)
        {
          insertLink(calcPos(i, j), calcPos(k, j - 1), 1);
          insertLink(calcPos(k, j - 1), calcPos(i, j), 0);
        }
        else
        {
          
        }

      }
      else
      {
        insertLink(calcPos(i, j), calcPos(i + streets, j), 1);
        insertLink(calcPos(i + streets, j), calcPos(i, j), 0);
      }

    }

  }

}

void createSuper()
{
  int i = 0;
  intersections[nodes].connections = 0;
  intersections[nodes + 1].connections = 0;
  for (i = 0; i < num_citizens; i++)
  {
    insertLink(nodes, citizens[i], 1);
    insertLink(citizens[i], nodes, 0);
  }

  for (i = 0; i < num_markets; i++)
  {
    insertLink(markets[i], nodes + 1, 1);
    insertLink(nodes + 1, markets[i], 0);
  }

}

void freeLinks(link head)
{
  link item = head;
  link aux = 0;
  while (item != 0)
  {
    aux = item;
    item = item->next;
    free(aux);
  }

}

void freeIntersections()
{
  int i;
  for (i = 0; i < maxnodes; i++)
  {
    freeLinks(intersections[i].connections);
  }

  free(intersections);
}

int main()
{
  int i = 0;
  int j = 0;
  int av = 0;
  int st = 0;
  int pos = 0;
  avenues = new_sym_var(sizeof(int) * 8);
  streets = new_sym_var(sizeof(int) * 8);
  nodes = (2 * streets) * avenues;
  maxnodes = nodes + 2;
  intersections = (Intersection *) malloc(maxnodes * (sizeof(Intersection)));
  for (i = 0; i < (2 * streets); i++)
  {
    for (j = 0; j < avenues; j++)
    {
      intersections[calcPos(i, j)].connections = 0;
    }

  }

  pred = (int *) malloc(maxnodes * (sizeof(int)));
  q = (int *) malloc(maxnodes * (sizeof(int)));
  color = (int *) malloc(maxnodes * (sizeof(int)));
  num_markets = new_sym_var(sizeof(int) * 8);
  num_citizens = new_sym_var(sizeof(int) * 8);
  markets = (int *) malloc((sizeof(int)) * num_markets);
  citizens = (int *) malloc((sizeof(int)) * num_citizens);
  memset(markets, -1, (sizeof(int)) * num_markets);
  memset(citizens, -1, (sizeof(int)) * num_citizens);
  for (i = 0, j = 0; i < num_markets; i++)
  {
    av = new_sym_var(sizeof(int) * 8);
    st = new_sym_var(sizeof(int) * 8);
    pos = calcPos((st - 1) + streets, av - 1);
    if (!repeated(markets, num_markets, pos))
    {
      markets[j] = pos;
      j++;
    }
    else
    {
      
    }

  }

  num_markets = j;
  for (i = 0, j = 0; i < num_citizens; i++)
  {
    av = new_sym_var(sizeof(int) * 8);
    st = new_sym_var(sizeof(int) * 8);
    pos = calcPos(st - 1, av - 1);
    if (!repeated(citizens, num_citizens, pos))
    {
      citizens[j] = pos;
      j++;
    }
    else
    {
      
    }

  }

  num_citizens = j;
  calcLinks();
  createSuper();
  printf("%d\n", fordFulkerson(nodes, nodes + 1));
  freeIntersections();
  free(markets);
  free(citizens);
  free(q);
  free(color);
  free(pred);
  return 0;
}

