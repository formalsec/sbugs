#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>


typedef struct Vertex
{
  int id;
  int flow;
  bool visited;
  struct Vertex *next;
} Vertex;
typedef struct Queue
{
  int id;
  struct Queue *next;
} Queue;
typedef struct Graph
{
  int numVertices;
  int numAvenues;
  Vertex **adjLists;
} Graph;
bool *added;
int *parents;
int head;
int tail;
int *q;
int *visited;
Graph *createGraph(int numVertices);
void addEdge(Graph *graph, int src, int dest);
Graph *processInput()
{
  int *super;
  int *homes;
  char line[20];
  int numAvenues = 0;
  int numStreets = 0;
  int numSuperMarkets = 0;
  int numPeople = 0;
  int numVertices = 0;
  int avenue = 0;
  int street = 0;
  int i = 0;
  fgets(line, (sizeof(line)) / (sizeof(char)), stdin);
  numAvenues = atoi(strtok(line, " "));
  numStreets = atoi(strtok(0, " "));
  numVertices = numAvenues * numStreets;
  fgets(line, (sizeof(line)) / (sizeof(char)), stdin);
  numSuperMarkets = atoi(strtok(line, " "));
  numPeople = atoi(strtok(0, " "));
  Graph *graph = createGraph(numVertices);
  graph->numVertices = numVertices;
  graph->numAvenues = numAvenues;
  homes = (int *) malloc((numPeople + 1) * (sizeof(int)));
  super = (int *) malloc((numSuperMarkets + 1) * (sizeof(int)));
  for (i = 1; i <= numSuperMarkets; i++)
  {
    fgets(line, (sizeof(line)) / (sizeof(char)), stdin);
    avenue = atoi(strtok(line, " "));
    street = atoi(strtok(0, " "));
    super[i] = avenue + ((street - 1) * numAvenues);
    addEdge(graph, super[i] * 2, (graph->numVertices * 2) + 1);
  }

  for (i = 1; i <= numPeople; i++)
  {
    fgets(line, (sizeof(line)) / (sizeof(char)), stdin);
    avenue = atoi(strtok(line, " "));
    street = atoi(strtok(0, " "));
    homes[i] = avenue + ((street - 1) * numAvenues);
    addEdge(graph, 0, (homes[i] * 2) - 1);
  }

  free(homes);
  free(super);
  return graph;
}

void addEdge(Graph *graph, int src, int dest)
{
  Vertex *aux = (Vertex *) malloc(sizeof(Vertex));
  aux->flow = 0;
  aux->id = dest;
  aux->visited = false;
  aux->next = graph->adjLists[src];
  graph->adjLists[src] = aux;
}

Graph *createGraph(int numVertices)
{
  int i;
  Graph *graph = malloc(sizeof(struct Graph));
  parents = (int *) malloc(((numVertices * 2) + 2) * (sizeof(int)));
  q = (int *) malloc(((numVertices * 2) + 4) * (sizeof(int)));
  visited = (int *) malloc(((numVertices * 2) + 2) * (sizeof(int)));
  added = (bool *) malloc(((numVertices * 2) + 2) * (sizeof(bool)));
  graph->adjLists = (Vertex **) malloc(((numVertices * 2) + 2) * (sizeof(Vertex *)));
  for (i = 0; i <= ((graph->numVertices * 2) + 1); i++)
  {
    graph->adjLists[i] = 0;
    added[i] = false;
  }

  return graph;
}

int dequeue()
{
  int x = q[head];
  head++;
  return x;
}

void enqueue(int x)
{
  q[tail] = x;
  tail++;
}

int bfs(Graph *graph)
{
  int i;
  for (i = 0; i <= ((graph->numVertices * 2) + 1); i++)
  {
    visited[i] = false;
    parents[i] = -1;
  }

  head = (tail = 0);
  visited[0] = true;
  enqueue(0);
  while (head != tail)
  {
    int u = dequeue();
    if (((added[u] == false) && (u != 0)) && (u != ((graph->numVertices * 2) + 1)))
    {
      added[u] = true;
      if ((u % 2) == 1)
      {
        addEdge(graph, u, u + 1);
      }
      else
      {
        
      }

      if ((u % 2) == 0)
      {
        if ((u % (graph->numAvenues * 2)) != 0)
        {
          addEdge(graph, u, u + 1);
        }
        else
        {
          
        }

        if ((u % (graph->numAvenues * 2)) != 2)
        {
          addEdge(graph, u, u - 3);
        }
        else
        {
          
        }

        if ((u + (graph->numAvenues * 2)) <= (graph->numVertices * 2))
        {
          addEdge(graph, u, (u + (graph->numAvenues * 2)) - 1);
        }
        else
        {
          
        }

        if ((u - (graph->numAvenues * 2)) > 0)
        {
          addEdge(graph, u, (u - (graph->numAvenues * 2)) - 1);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }
    else
    {
      
    }

    Vertex *v = graph->adjLists[u];
    for (; v != 0; v = v->next)
    {
      if ((visited[v->id] == false) && ((1 - v->flow) > 0))
      {
        enqueue(v->id);
        parents[v->id] = u;
        visited[v->id] = true;
      }
      else
      {
        
      }

    }

  }

  return visited[(graph->numVertices * 2) + 1];
}

int edmondsKarp(Graph *graph)
{
  int maxFlow = 0;
  int u;
  while (bfs(graph))
  {
    for (u = (graph->numVertices * 2) + 1; parents[u] >= 0; u = parents[u])
    {
      Vertex *temp = graph->adjLists[parents[u]];
      for (; temp != 0; temp = temp->next)
      {
        if (temp->id == u)
        {
          temp->flow += 1;
          break;
        }
        else
        {
          
        }

      }

      Vertex *aux = graph->adjLists[u];
      for (; aux != 0; aux = aux->next)
      {
        if (aux->id == parents[u])
        {
          aux->flow -= 1;
          break;
        }
        else
        {
          
        }

      }

      addEdge(graph, u, parents[u]);
    }

    maxFlow++;
  }

  return maxFlow;
}

int main()
{
  Graph *graph = processInput();
  printf("%d\n", edmondsKarp(graph));
  int i;
  for (i = 0; i <= ((graph->numVertices * 2) + 1); i++)
  {
    Vertex *vertexAux = graph->adjLists[i];
    while (vertexAux != 0)
    {
      Vertex *vextexNext = vertexAux->next;
      free(vertexAux);
      vertexAux = vextexNext;
    }

  }

  free(graph->adjLists);
  free(graph);
  return 0;
}

