/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct stack
{
  int id;
  struct stack *next;
} Stack;
Stack *first;
Stack *last;
void stack_init()
{
  first = 0;
  last = 0;
}

void push(int id)
{
  Stack *new_elem = malloc(sizeof(Stack));
  new_elem->id = id;
  new_elem->next = 0;
  if (first == 0)
  {
    first = new_elem;
    last = first;
  }
  else
  {
    Stack *elem_aux = last;
    elem_aux->next = new_elem;
    last = last->next;
  }

}

int pop()
{
  int id;
  id = -1;
  if (first == 0)
  {
    return id;
  }
  else
  {
    
  }

  if (last == first)
  {
    last = 0;
  }
  else
  {
    
  }

  id = first->id;
  Stack *d = first;
  first = first->next;
  free(d);
  return id;
}

typedef struct arco
{
  int to;
  int capacidade;
  int fluxo;
  struct arco *next;
} Arco;
typedef struct 
{
  int pi;
  Arco *vizinhos;
} Cruzamento;
Cruzamento *cruzamentos;
int num_avenidas;
int num_ruas;
int num_super;
int num_cidadaos;
void ad_vizinho_aux(int from, int to, int capacidade)
{
  if (cruzamentos[from].vizinhos == 0)
  {
    cruzamentos[from].vizinhos = (Arco *) malloc(sizeof(Arco));
    cruzamentos[from].vizinhos->capacidade = capacidade;
    cruzamentos[from].vizinhos->fluxo = 0;
    cruzamentos[from].vizinhos->to = to;
    cruzamentos[from].vizinhos->next = 0;
  }
  else
  {
    Arco *iter;
    for (iter = cruzamentos[from].vizinhos; iter->next != 0; iter = iter->next)
      ;

    iter->next = (Arco *) malloc(sizeof(Arco));
    iter->next->capacidade = capacidade;
    iter->next->fluxo = 0;
    iter->next->to = to;
    iter->next->next = 0;
  }

}

void ad_vizinho(int from, int to)
{
  ad_vizinho_aux(from, to, 1);
  ad_vizinho_aux(to, from, 0);
}

int BFS()
{
  int i;
  int atual;
  int to;
  Arco *iter;
  for (i = 0; i < (((num_avenidas * num_ruas) * 2) + 2); i++)
  {
    cruzamentos[i].pi = -1;
  }

  push((num_ruas * num_avenidas) * 2);
  cruzamentos[(num_ruas * num_avenidas) * 2].pi = -2;
  while ((atual = pop()) != (-1))
  {
    for (iter = cruzamentos[atual].vizinhos; iter != 0; iter = iter->next)
    {
      to = iter->to;
      if (cruzamentos[to].pi == (-1))
      {
        if ((iter->capacidade - iter->fluxo) > 0)
        {
          cruzamentos[to].pi = atual;
          if (to == (((num_avenidas * num_ruas) * 2) + 1))
          {
            while (pop() != (-1))
              ;

            return 1;
          }
          else
          {
            
          }

          push(to);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  return 0;
}

int Karp()
{
  int fluxo_max = 0;
  int atual;
  int anterior;
  Arco *iter;
  while (BFS())
  {
    fluxo_max++;
    atual = ((num_ruas * num_avenidas) * 2) + 1;
    while (atual != ((num_avenidas * num_ruas) * 2))
    {
      anterior = cruzamentos[atual].pi;
      for (iter = cruzamentos[anterior].vizinhos; iter->to != atual; iter = iter->next)
        ;

      iter->fluxo++;
      for (iter = cruzamentos[atual].vizinhos; iter->to != anterior; iter = iter->next)
        ;

      iter->fluxo--;
      atual = anterior;
    }

  }

  return fluxo_max;
}

void init_cuzamentos()
{
  int i;
  int from;
  cruzamentos = (Cruzamento *) malloc((((num_ruas * num_avenidas) * 2) + 2) * (sizeof(Cruzamento)));
  for (i = 0; i < (((num_ruas * num_avenidas) * 2) + 2); i++)
  {
    cruzamentos[i].vizinhos = 0;
  }

  for (from = 0; from < (num_ruas * num_avenidas); from++)
  {
    ad_vizinho(from, from + (num_ruas * num_avenidas));
  }

  for (from = num_ruas * num_avenidas; from < ((num_ruas * num_avenidas) * 2); from++)
  {
    if ((from % num_avenidas) != (num_avenidas - 1))
    {
      ad_vizinho(from, (from - (num_ruas * num_avenidas)) + 1);
    }
    else
    {
      
    }

    if ((from % num_avenidas) != 0)
    {
      ad_vizinho(from, (from - (num_ruas * num_avenidas)) - 1);
    }
    else
    {
      
    }

    if (from >= ((num_ruas * num_avenidas) + num_avenidas))
    {
      ad_vizinho(from, (from - (num_ruas * num_avenidas)) - num_avenidas);
    }
    else
    {
      
    }

    if (from < (((num_ruas * num_avenidas) * 2) - num_avenidas))
    {
      ad_vizinho(from, (from - (num_ruas * num_avenidas)) + num_avenidas);
    }
    else
    {
      
    }

  }

}

void criar_super(int ave, int rua)
{
  ad_vizinho(((num_avenidas * num_ruas) + (rua * num_avenidas)) + ave, ((num_avenidas * num_ruas) * 2) + 1);
}

void ad_cidadao(int ave, int rua)
{
  ad_vizinho((num_avenidas * num_ruas) * 2, (rua * num_avenidas) + ave);
}

void free_allocs()
{
  Arco *iter;
  int i;
  for (i = 0; i < (((num_ruas * num_avenidas) * 2) + 2); i++)
  {
    while (cruzamentos[i].vizinhos)
    {
      iter = cruzamentos[i].vizinhos;
      cruzamentos[i].vizinhos = iter->next;
      free(iter);
    }

  }

  free(cruzamentos);
}

int main()
{
  int ave;
  int rua;
  int i;
  num_avenidas = new_sym_var(sizeof(int) * 8);
  num_ruas = new_sym_var(sizeof(int) * 8);
  num_super = new_sym_var(sizeof(int) * 8);
  num_cidadaos = new_sym_var(sizeof(int) * 8);
  init_cuzamentos();
  stack_init();
  for (i = 0; i < num_super; i++)
  {
    ave = new_sym_var(sizeof(int) * 8);
    rua = new_sym_var(sizeof(int) * 8);
    criar_super(ave - 1, rua - 1);
  }

  for (i = 0; i < num_cidadaos; i++)
  {
    ave = new_sym_var(sizeof(int) * 8);
    rua = new_sym_var(sizeof(int) * 8);
    ad_cidadao(ave - 1, rua - 1);
  }

  int val = Karp();
  printf("%d\n", val);
  free_allocs();
  return 0;
}

