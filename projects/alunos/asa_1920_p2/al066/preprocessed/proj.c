#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct Queue
{
  int *elemnts;
  int size;
  int end;
  int front;
} queue;
typedef struct Edge
{
  int capacity;
  int flow;
  int to;
  struct Edge *next;
} edge;
typedef struct Node
{
  int vertex_id;
  int hasSuperMarket;
  int hasClient;
  edge *head;
} node;
typedef struct Graph
{
  int num_vertices;
  node *adjList;
} grph;
int bfs(grph *g, int source, int target, int parents[]);
int edmondsKarp(grph *g, int source, int target);
int min(int val1, int val2);
int num_avenues;
int num_streets;
int num_citiezens;
int num_supermarket;
queue *init_queue(int size)
{
  queue *q;
  q = (queue *) malloc(sizeof(queue));
  q->elemnts = (int *) malloc((sizeof(int)) * size);
  q->size = size;
  q->end = 0;
  q->front = 0;
  return q;
}

void addQueue(queue *queue, int element)
{
  if (queue->end != queue->size)
  {
    queue->elemnts[queue->end] = element;
    queue->end++;
  }
  else
  {
    
  }

}

int pop(queue *queue)
{
  int el = -1;
  if (queue->front != queue->end)
  {
    el = queue->elemnts[queue->front];
    queue->elemnts[queue->front] = -1;
    queue->front++;
  }
  else
  {
    
  }

  return el;
}

int is_empty(queue *q)
{
  if (q->front == q->end)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void free_queue(queue *q)
{
  if (q != 0)
  {
    free(q->elemnts);
    free(q);
  }
  else
  {
    
  }

}

grph *createGraph(int vertices)
{
  grph *gr = (grph *) malloc(sizeof(grph));
  int i;
  gr->num_vertices = vertices;
  gr->adjList = (node *) malloc(vertices * (sizeof(node)));
  for (i = 0; i < vertices; i++)
  {
    gr->adjList[i].head = 0;
  }

  return gr;
}

void createNode(grph *g, int vertex_id)
{
  g->adjList[vertex_id].vertex_id = vertex_id;
  g->adjList[vertex_id].hasClient = 0;
  g->adjList[vertex_id].hasSuperMarket = 0;
}

void addEdge(grph *G, int vertexU, int vertexV, int reverse)
{
  edge *e = (edge *) malloc(sizeof(edge));
  edge *aux;
  e->flow = 0;
  e->to = vertexV;
  if (!reverse)
  {
    e->capacity = 1;
  }
  else
  {
    e->capacity = 0;
  }

  if (G->adjList[vertexU].head == 0)
  {
    G->adjList[vertexU].head = e;
    e->next = 0;
  }
  else
  {
    aux = G->adjList[vertexU].head;
    e->next = aux;
    G->adjList[vertexU].head = e;
  }

}

void addAllCityEdges(grph *g, int M, int N)
{
  int i;
  for (i = 1; i <= (N * M); i++)
  {
    addEdge(g, i, i + (M * N), 0);
    addEdge(g, i + (M * N), i, 1);
    if (i == 1)
    {
      if (M > 1)
      {
        addEdge(g, 1 + (N * M), 2, 0);
        addEdge(g, 2, 1 + (M * N), 1);
      }
      else
      {
        
      }

      if (N > 1)
      {
        addEdge(g, 1 + (N * M), 1 + M, 0);
        addEdge(g, 1 + M, 1 + (M * N), 1);
      }
      else
      {
        
      }

    }
    else
    {
      if ((i == M) && (M != 1))
      {
        addEdge(g, i + (N * M), i - 1, 0);
        addEdge(g, i - 1, i + (N * M), 1);
        if (N > 1)
        {
          addEdge(g, M + (N * M), M + M, 0);
          addEdge(g, M + M, M + (M * N), 1);
        }
        else
        {
          
        }

      }
      else
      {
        if ((i == (M * N)) && (N > 1))
        {
          addEdge(g, i + (M * N), i - M, 0);
          addEdge(g, i - M, i + (M * N), 1);
          addEdge(g, i + (M * N), i - 1, 0);
          addEdge(g, i - 1, i + (M * N), 1);
        }
        else
        {
          if ((i == ((M * N) - (M - 1))) && (N > 1))
          {
            addEdge(g, i + (M * N), i - M, 0);
            addEdge(g, i - M, i + (M * N), 1);
            addEdge(g, i + (M * N), i + 1, 0);
            addEdge(g, i + 1, i + (M * N), 1);
          }
          else
          {
            if ((i > 1) && (i < M))
            {
              addEdge(g, i + (M * N), i - 1, 0);
              addEdge(g, i - 1, i + (M * N), 1);
              addEdge(g, i + (M * N), i + 1, 0);
              addEdge(g, i + 1, i + (M * N), 1);
              addEdge(g, i + (M * N), i + M, 0);
              addEdge(g, i + M, i + (M * N), 1);
            }
            else
            {
              if (((i > ((M * N) - (M - 1))) && (i < (N * M))) && (N > 1))
              {
                addEdge(g, i + (M * N), i - 1, 0);
                addEdge(g, i - 1, i + (M * N), 1);
                addEdge(g, i + (M * N), i + 1, 0);
                addEdge(g, i + 1, i + (M * N), 1);
                addEdge(g, i + (M * N), i - M, 0);
                addEdge(g, i - M, i + (M * N), 1);
              }
              else
              {
                if ((((i % M) == 1) && (i != 1)) && (i != (((N * M) - M) + 1)))
                {
                  addEdge(g, i + (M * N), i - M, 0);
                  addEdge(g, i - M, i + (M * N), 1);
                  addEdge(g, i + (M * N), i + 1, 0);
                  addEdge(g, i + 1, i + (M * N), 1);
                  addEdge(g, i + (M * N), i + M, 0);
                  addEdge(g, i + M, i + (M * N), 1);
                }
                else
                {
                  if ((((i % M) == 0) && (i != (M - 1))) && (i != (N * M)))
                  {
                    addEdge(g, i + (M * N), i - M, 0);
                    addEdge(g, i - M, (i + M) + (M * N), 1);
                    addEdge(g, i + (M * N), i - 1, 0);
                    addEdge(g, i - 1, i + (M * N), 1);
                    addEdge(g, i + (M * N), i + M, 0);
                    addEdge(g, i + M, (i + M) + (M * N), 1);
                  }
                  else
                  {
                    addEdge(g, i + (M * N), i - M, 0);
                    addEdge(g, i - M, (i + M) + (M * N), 1);
                    addEdge(g, i + (M * N), i - 1, 0);
                    addEdge(g, i - 1, i + (M * N), 1);
                    addEdge(g, i + (M * N), i + M, 0);
                    addEdge(g, i + M, (i + M) + (M * N), 1);
                    addEdge(g, i + (M * N), i + 1, 0);
                    addEdge(g, i + 1, i + (M * N), 1);
                  }

                }

              }

            }

          }

        }

      }

    }

  }

}

void free_graphs(grph *gr)
{
  int i;
  edge *aux;
  for (i = 0; i < gr->num_vertices; i++)
  {
    aux = gr->adjList[i].head;
    while (aux != 0)
    {
      aux = aux->next;
      free(gr->adjList[i].head);
      gr->adjList[i].head = aux;
    }

  }

  free(gr->adjList);
  free(gr);
}

int bfs(grph *g, int source, int target, int parents[])
{
  int currentPathCapacity[g->num_vertices];
  int i;
  edge *temp;
  for (i = 0; i < g->num_vertices; i++)
  {
    parents[i] = -1;
    currentPathCapacity[i] = 0;
  }

  queue *q = init_queue(g->num_vertices);
  addQueue(q, source);
  parents[source] = -2;
  currentPathCapacity[source] = 999;
  while (!is_empty(q))
  {
    int currentNode = pop(q);
    for (temp = g->adjList[currentNode].head; temp != 0; temp = temp->next)
    {
      if (parents[temp->to] == (-1))
      {
        if ((temp->capacity - temp->flow) > 0)
        {
          parents[temp->to] = currentNode;
          currentPathCapacity[temp->to] = min(currentPathCapacity[currentNode], temp->capacity - temp->flow);
          if (temp->to == target)
          {
            free_queue(q);
            return currentPathCapacity[target];
          }
          else
          {
            
          }

          addQueue(q, temp->to);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  free_queue(q);
  return 0;
}

int min(int val1, int val2)
{
  return (val1 < val2) ? (val1) : (val2);
}

int edmondsKarp(grph *g, int source, int target)
{
  int maxFlow = 0;
  int flow;
  int currentNode;
  edge *temp;
  edge *aux;
  int parents[g->num_vertices];
  while (1)
  {
    flow = bfs(g, source, target, parents);
    if (flow == 0)
    {
      break;
    }
    else
    {
      
    }

    maxFlow += flow;
    currentNode = target;
    while (currentNode != source)
    {
      temp = g->adjList[parents[currentNode]].head;
      while (temp != 0)
      {
        if (temp->to == currentNode)
        {
          temp->flow += flow;
          break;
        }
        else
        {
          
        }

        temp = temp->next;
      }

      aux = g->adjList[currentNode].head;
      while (aux != 0)
      {
        if (aux->to == parents[currentNode])
        {
          aux->flow -= flow;
          break;
        }
        else
        {
          
        }

        aux = aux->next;
      }

      currentNode = parents[currentNode];
    }

  }

  free_graphs(g);
  return maxFlow;
}

int main(int argc, const char **argv)
{
  int i;
  int avenue;
  int street;
  grph *G;
  num_avenues = new_sym_var(sizeof(int) * 8);
  num_streets = new_sym_var(sizeof(int) * 8);
  num_supermarket = new_sym_var(sizeof(int) * 8);
  num_citiezens = new_sym_var(sizeof(int) * 8);
  G = createGraph(((num_avenues * num_streets) * 2) + 2);
  for (i = 0; i < (((num_avenues * num_streets) * 2) + 2); i++)
  {
    createNode(G, i);
  }

  for (i = 0; i < num_supermarket; i++)
  {
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    if (!G->adjList[(((street - 1) * num_avenues) + avenue) + (((((num_avenues * num_streets) * 2) + 2) - 2) / 2)].hasSuperMarket)
    {
      addEdge(G, (((street - 1) * num_avenues) + avenue) + (((((num_avenues * num_streets) * 2) + 2) - 2) / 2), (((num_avenues * num_streets) * 2) + 2) - 1, 0);
      addEdge(G, (((num_avenues * num_streets) * 2) + 2) - 1, (((street - 1) * num_avenues) + avenue) + (((((num_avenues * num_streets) * 2) + 2) - 2) / 2), 1);
      G->adjList[(((street - 1) * num_avenues) + avenue) + (((((num_avenues * num_streets) * 2) + 2) - 2) / 2)].hasSuperMarket = 1;
    }
    else
    {
      
    }

  }

  for (i = 0; i < num_citiezens; i++)
  {
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    if (!G->adjList[((street - 1) * num_avenues) + avenue].hasClient)
    {
      addEdge(G, 0, ((street - 1) * num_avenues) + avenue, 0);
      addEdge(G, ((street - 1) * num_avenues) + avenue, 0, 1);
      G->adjList[((street - 1) * num_avenues) + avenue].hasClient = 1;
    }
    else
    {
      
    }

  }

  addAllCityEdges(G, num_avenues, num_streets);
  for (i = 0; i < G->num_vertices; i++)
  {
    edge *temp = G->adjList[i].head;
    while (temp != 0)
    {
      temp = temp->next;
    }

  }

  printf("%d\n", edmondsKarp(G, 0, (((num_avenues * num_streets) * 2) + 2) - 1));
  return 0;
}

