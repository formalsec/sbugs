#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int nBoulevards;
int nStreets;
int nMarkets;
int nCitizens;
typedef struct node
{
  int adj;
  struct node *next;
} node;
node **adjList;
int sIndex;
int tIndex;
int *colors;
int *parents;
int found;
int done;
int flux;
void DFSvisit(int u);
void clearDFS();
void increasePath();
void increaseArc(int u, int v);
int getIndex(int b, int s, int out);
void processInput();
void initGraph();
void freeGraph();
void addAdjacency(int u, int v);
int removeAdjacency(int u, int v);
int main()
{
  processInput();
  clearDFS();
  found = 0;
  done = 0;
  flux = 0;
  while (!done)
  {
    DFSvisit(sIndex);
    if (!found)
    {
      done = 1;
    }
    else
    {
      clearDFS();
      found = 0;
    }

  }

  printf("%d\n", flux);
  freeGraph();
  return 0;
}

void DFSvisit(int u)
{
  if (found)
  {
    return;
  }
  else
  {
    
  }

  colors[u] = 1;
  node *adj = adjList[u];
  while (adj != 0)
  {
    int v = adj->adj;
    if (colors[v] == 0)
    {
      parents[v] = u;
      if (v == tIndex)
      {
        found = 1;
        increasePath();
      }
      else
      {
        DFSvisit(v);
      }

    }
    else
    {
      
    }

    if (found)
    {
      break;
    }
    else
    {
      
    }

    adj = adj->next;
  }

  colors[u] = 2;
}

void clearDFS()
{
  memset(colors, 0, (((nBoulevards * nStreets) * 2) + 2) * (sizeof(int)));
  int i;
  for (i = 0; i < (((nBoulevards * nStreets) * 2) + 2); i++)
  {
    parents[i] = -1;
  }

}

void increasePath()
{
  if (!found)
  {
    return;
  }
  else
  {
    
  }

  int current = tIndex;
  while (parents[current] != (-1))
  {
    increaseArc(parents[current], current);
    current = parents[current];
  }

  flux++;
}

void increaseArc(int u, int v)
{
  int suc = removeAdjacency(u, v);
  if (suc)
  {
    addAdjacency(v, u);
  }
  else
  {
    
  }

}

void processInput()
{
  int i;
  char buffer[128];
  fgets(buffer, 128, stdin);
  nBoulevards = new_sym_var(sizeof(int) * 8);
  nStreets = new_sym_var(sizeof(int) * 8);
  fgets(buffer, 128, stdin);
  nMarkets = new_sym_var(sizeof(int) * 8);
  nCitizens = new_sym_var(sizeof(int) * 8);
  initGraph();
  char *indexKeeper = malloc(((nBoulevards * nStreets) * 2) * (sizeof(char)));
  memset(indexKeeper, 0, ((nBoulevards * nStreets) * 2) * (sizeof(char)));
  for (i = 0; i < nMarkets; i++)
  {
    int b;
    int s;
    fgets(buffer, 128, stdin);
    b = new_sym_var(sizeof(int) * 8);
    s = new_sym_var(sizeof(int) * 8);
    indexKeeper[getIndex(b, s, 1)] = 1;
  }

  for (i = 0; i < ((nBoulevards * nStreets) * 2); i++)
  {
    if (indexKeeper[i])
    {
      addAdjacency(i, tIndex);
    }
    else
    {
      
    }

  }

  memset(indexKeeper, 0, ((nBoulevards * nStreets) * 2) * (sizeof(char)));
  for (i = 0; i < nCitizens; i++)
  {
    int b;
    int s;
    fgets(buffer, 128, stdin);
    b = new_sym_var(sizeof(int) * 8);
    s = new_sym_var(sizeof(int) * 8);
    indexKeeper[getIndex(b, s, 0)] = 1;
  }

  for (i = 0; i < ((nBoulevards * nStreets) * 2); i++)
  {
    if (indexKeeper[i])
    {
      addAdjacency(sIndex, i);
    }
    else
    {
      
    }

  }

  free(indexKeeper);
}

int getIndex(int b, int s, int out)
{
  return ((((s - 1) * nBoulevards) + (b - 1)) * 2) + out;
}

void initGraph()
{
  int i = 0;
  adjList = malloc((((nBoulevards * nStreets) * 2) + 2) * (sizeof(node *)));
  memset(adjList, 0, (((nBoulevards * nStreets) * 2) + 2) * (sizeof(node *)));
  for (i = 0; i < ((nBoulevards * nStreets) * 2); i++)
  {
    if ((i % 2) == 0)
    {
      addAdjacency(i, i + 1);
    }
    else
    {
      if (i >= (nBoulevards * 2))
      {
        addAdjacency(i, (i - (nBoulevards * 2)) - 1);
      }
      else
      {
        
      }

      if (i < (((nBoulevards * nStreets) * 2) - (nBoulevards * 2)))
      {
        addAdjacency(i, (i + (nBoulevards * 2)) - 1);
      }
      else
      {
        
      }

      if ((i % (nBoulevards * 2)) > 1)
      {
        addAdjacency(i, i - 3);
      }
      else
      {
        
      }

      if ((i % (nBoulevards * 2)) < ((nBoulevards * 2) - 2))
      {
        addAdjacency(i, i + 1);
      }
      else
      {
        
      }

    }

  }

  sIndex = ((nBoulevards * nStreets) * 2) + 1;
  tIndex = (nBoulevards * nStreets) * 2;
  colors = malloc((((nBoulevards * nStreets) * 2) + 2) * (sizeof(int)));
  parents = malloc((((nBoulevards * nStreets) * 2) + 2) * (sizeof(int)));
  clearDFS();
}

void freeGraph()
{
  int i;
  for (i = 0; i < (((nBoulevards * nStreets) * 2) + 2); i++)
  {
    node *adj = adjList[i];
    while (adj != 0)
    {
      node *temp = adj;
      adj = adj->next;
      free(temp);
    }

  }

  free(adjList);
  free(colors);
  free(parents);
}

void addAdjacency(int u, int v)
{
  node *new = malloc(sizeof(node));
  new->next = adjList[u];
  new->adj = v;
  adjList[u] = new;
}

int removeAdjacency(int u, int v)
{
  node *temp = adjList[u];
  node *prev = 0;
  while (temp != 0)
  {
    if (temp->adj == v)
    {
      if (prev != 0)
      {
        prev->next = temp->next;
      }
      else
      {
        adjList[u] = temp->next;
      }

      free(temp);
      return 1;
    }
    else
    {
      
    }

    prev = temp;
    temp = temp->next;
  }

  return 0;
}

