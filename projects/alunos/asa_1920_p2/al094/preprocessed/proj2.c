#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct vertex
{
  int id;
  int type;
} Vertex;
typedef struct node
{
  Vertex *vertex;
  struct node *next;
} Node;
typedef struct list
{
  Node *head;
  Node *tail;
} List;
typedef struct int_number
{
  int i;
  struct int_number *next;
} Int;
typedef struct queue
{
  Int *head;
  Int *tail;
} Queue;
typedef struct edge
{
  int capacity;
  int to;
  struct edge *next;
} Edge;
typedef struct edgeList
{
  Edge *head;
  Edge *tail;
} EdgeList;
int maxFlow = 0;
List *newList()
{
  List *l = (List *) malloc(sizeof(List));
  l->head = (l->tail = 0);
  return l;
}

EdgeList *newEdgeList()
{
  EdgeList *l = (EdgeList *) malloc(sizeof(EdgeList));
  l->head = (l->tail = 0);
  return l;
}

void addVertex(List *l, Vertex *v)
{
  Node *node = (Node *) malloc(sizeof(Node));
  node->vertex = v;
  if (l->head == 0)
  {
    l->head = (l->tail = node);
    node->next = 0;
    return;
  }
  else
  {
    
  }

  l->tail->next = node;
  l->tail = node;
  node->next = 0;
}

void freeList(List *l)
{
  Node *n = l->head;
  Node *aux;
  while (n != 0)
  {
    aux = n->next;
    free(n);
    n = aux;
  }

  free(l);
}

void freeGraph(List **graph, int graphSize)
{
  int i;
  for (i = 0; i < graphSize; i++)
    free(graph[i]->head->vertex);

  for (i = 0; i < graphSize; i++)
    freeList(graph[i]);

  free(graph);
}

List **initGraph(int graphSize)
{
  int i;
  int c = 0;
  int x = 0;
  List **list = (List **) malloc((sizeof(List *)) * graphSize);
  for (i = 0; i < graphSize; i++)
  {
    list[i] = newList();
  }

  Vertex *source = (Vertex *) malloc(sizeof(Vertex));
  Vertex *sink = (Vertex *) malloc(sizeof(Vertex));
  source->id = c++;
  sink->id = c++;
  source->type = (sink->type = 5);
  addVertex(list[x++], source);
  addVertex(list[x++], sink);
  for (i = 0; i < ((graphSize - 2) / 2); i++)
  {
    Vertex *v_in = (Vertex *) malloc(sizeof(Vertex));
    Vertex *v_out = (Vertex *) malloc(sizeof(Vertex));
    v_in->id = c++;
    v_out->id = c++;
    v_in->type = (v_out->type = 5);
    addVertex(list[x], v_in);
    addVertex(list[x++], v_out);
    addVertex(list[x++], v_out);
  }

  return list;
}

void processPositions(int numSupermarkets, int numPeople, int numStreets, List **graph)
{
  int i;
  int x;
  int y;
  int s;
  int n = numSupermarkets + numPeople;
  for (i = 0; i < n; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    s = ((2 * numStreets) * (x - 1)) + (2 * y);
    if (i < numSupermarkets)
    {
      graph[s++]->head->vertex->type = 3;
      graph[s]->head->vertex->type = 3;
    }
    else
    {
      if (graph[s]->head->vertex->type == 3)
      {
        graph[s++]->head->vertex->type = 4;
        graph[s]->head->vertex->type = 4;
      }
      else
      {
        if (graph[s]->head->vertex->type != 4)
        {
          graph[s++]->head->vertex->type = 2;
          graph[s]->head->vertex->type = 2;
        }
        else
        {
          
        }

      }

    }

  }

}

void addNeighbors(List **graph, int graphSize, int numStreets)
{
  int i;
  int x;
  for (i = 0; i < graphSize; i++)
  {
    if (graph[i]->head->vertex->type == 2)
    {
      addVertex(graph[0], graph[i]->head->vertex);
      i++;
    }
    else
    {
      
    }

  }

  for (i = 3; i < graphSize; i += 2)
  {
    int type = graph[i]->head->vertex->type;
    if (type == 3)
    {
      addVertex(graph[i], graph[1]->head->vertex);
    }
    else
    {
      if (type == 4)
      {
        maxFlow++;
      }
      else
      {
        x = i - ((2 * numStreets) + 1);
        if ((x >= 2) && (graph[x]->head->vertex->type != 4))
        {
          addVertex(graph[i], graph[x]->head->vertex);
        }
        else
        {
          
        }

        x = i + ((2 * numStreets) - 1);
        if ((x < graphSize) && (graph[x]->head->vertex->type != 4))
        {
          addVertex(graph[i], graph[x]->head->vertex);
        }
        else
        {
          
        }

        x = i - 3;
        if (((x < (numStreets * 2)) && (x >= 2)) && (graph[x]->head->vertex->type != 4))
        {
          addVertex(graph[i], graph[x]->head->vertex);
        }
        else
        {
          if (((x >= (numStreets * 2)) && ((x % (numStreets * 2)) != 0)) && (graph[x]->head->vertex->type != 4))
          {
            addVertex(graph[i], graph[x]->head->vertex);
          }
          else
          {
            
          }

        }

        x = i + 1;
        if ((x <= (numStreets * 2)) && (graph[x]->head->vertex->type != 4))
        {
          addVertex(graph[i], graph[x]->head->vertex);
        }
        else
        {
          if ((((x < graphSize) && (x > (numStreets * 2))) && (((i - 1) % (numStreets * 2)) != 0)) && (graph[x]->head->vertex->type != 4))
          {
            addVertex(graph[i], graph[x]->head->vertex);
          }
          else
          {
            
          }

        }

      }

    }

  }

}

void addEdge(EdgeList *list, int v, int capacity)
{
  Edge *edge = (Edge *) malloc(sizeof(Edge));
  edge->to = v;
  edge->capacity = capacity;
  if (list->head == 0)
  {
    list->head = (list->tail = edge);
    edge->next = 0;
    return;
  }
  else
  {
    
  }

  list->tail->next = edge;
  list->tail = edge;
  edge->next = 0;
}

void freeEdgeList(EdgeList *l)
{
  Edge *e = l->head;
  Edge *aux;
  while (e != 0)
  {
    aux = e->next;
    free(e);
    e = aux;
  }

  free(l);
}

void freeEdges(EdgeList **edges, int graphSize)
{
  int i;
  for (i = 0; i < graphSize; i++)
    freeEdgeList(edges[i]);

  free(edges);
}

EdgeList **createEdges(List **graph, int graphSize)
{
  int i;
  Node *aux;
  EdgeList **list = (EdgeList **) malloc((sizeof(EdgeList *)) * graphSize);
  for (i = 0; i < graphSize; i++)
  {
    list[i] = newEdgeList();
  }

  for (i = 0; i < graphSize; i++)
  {
    aux = graph[i]->head->next;
    while (aux != 0)
    {
      addEdge(list[i], aux->vertex->id, 1);
      aux = aux->next;
    }

  }

  return list;
}

void push(Queue *queue, int i)
{
  Int *number = (Int *) malloc(sizeof(Int));
  number->i = i;
  number->next = 0;
  if (queue->head == 0)
  {
    queue->head = (queue->tail = number);
    return;
  }
  else
  {
    
  }

  queue->tail->next = number;
  queue->tail = number;
}

int pop(Queue *queue)
{
  Int *aux = queue->head;
  queue->head = queue->head->next;
  int i = aux->i;
  free(aux);
  return i;
}

void freeQueue(Queue *queue)
{
  Int *i = queue->head;
  Int *aux;
  while (i != 0)
  {
    aux = i->next;
    free(i);
    i = aux;
  }

  free(queue);
}

int emptyQueue(Queue *queue)
{
  return queue->head == 0;
}

int min(int n_one, int n_two)
{
  if (n_one <= n_two)
  {
    return n_one;
  }
  else
  {
    
  }

  return n_two;
}

void setVector(int *vector, int value, int size)
{
  int i;
  for (i = 0; i < size; i++)
    vector[i] = value;

}

int bfs(int startNode, int endNode, EdgeList **edges, int *parentsList, int *currentPathCapacity, int graphSize)
{
  setVector(parentsList, -1, graphSize);
  setVector(currentPathCapacity, 0, graphSize);
  Queue *queue = (Queue *) malloc(sizeof(Queue));
  queue->head = (queue->tail = 0);
  push(queue, startNode);
  parentsList[startNode] = -2;
  currentPathCapacity[startNode] = 999;
  while (!emptyQueue(queue))
  {
    Edge *edge;
    int currentNodeId = pop(queue);
    edge = edges[currentNodeId]->head;
    while (edge != 0)
    {
      int to = edge->to;
      if (parentsList[to] == (-1))
      {
        if (edge->capacity > 0)
        {
          parentsList[to] = currentNodeId;
          currentPathCapacity[to] = min(currentPathCapacity[currentNodeId], edge->capacity);
          if (to == endNode)
          {
            freeQueue(queue);
            return currentPathCapacity[endNode];
          }
          else
          {
            
          }

          push(queue, to);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      edge = edge->next;
    }

  }

  freeQueue(queue);
  return 0;
}

void addCapacity(int u, int v, int flow, EdgeList **edges)
{
  Edge *aux = edges[u]->head;
  while (aux != 0)
  {
    if (aux->to == v)
    {
      aux->capacity += flow;
      return;
    }
    else
    {
      
    }

    aux = aux->next;
  }

  addEdge(edges[u], v, flow);
}

int edmondsKarp(int startNode, int endNode, EdgeList **edges, int graphSize)
{
  int maxFlow = 0;
  int *parentsList = (int *) malloc((sizeof(int)) * graphSize);
  int *currentPathCapacity = (int *) malloc((sizeof(int)) * graphSize);
  ;
  while (1)
  {
    int flow = bfs(startNode, endNode, edges, parentsList, currentPathCapacity, graphSize);
    if (flow == 0)
    {
      break;
    }
    else
    {
      
    }

    maxFlow += flow;
    int currentNode = endNode;
    while (currentNode != startNode)
    {
      int previousNode = parentsList[currentNode];
      addCapacity(previousNode, currentNode, -flow, edges);
      addCapacity(currentNode, previousNode, flow, edges);
      currentNode = previousNode;
    }

  }

  free(parentsList);
  free(currentPathCapacity);
  return maxFlow;
}

int main()
{
  int numAvenues;
  int numStreets;
  int numSupermarkets;
  int numPeople;
  numAvenues = new_sym_var(sizeof(int) * 8);
  numStreets = new_sym_var(sizeof(int) * 8);
  numSupermarkets = new_sym_var(sizeof(int) * 8);
  numPeople = new_sym_var(sizeof(int) * 8);
  int graphSize = ((2 * numAvenues) * numStreets) + 2;
  List **graph = initGraph(graphSize);
  processPositions(numSupermarkets, numPeople, numStreets, graph);
  addNeighbors(graph, graphSize, numStreets);
  EdgeList **edges = createEdges(graph, graphSize);
  freeGraph(graph, graphSize);
  maxFlow += edmondsKarp(0, 1, edges, graphSize);
  printf("%d\n", maxFlow);
  freeEdges(edges, graphSize);
  return 0;
}

