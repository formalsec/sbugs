/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>


typedef struct cruz
{
  int coord[2];
  int type;
  int visited;
  int reachSize;
  int used;
  struct cruz **reach;
  struct cruz *adj[4];
} cruz;
int avNum;
int strNum;
int smNum;
int originalsmNum;
int ctNum;
int originalctNum;
int max;
int counter = 0;
cruz **city;
cruz **citList;
void processFirstLine()
{
  int i;
  city = (cruz **) malloc((sizeof(cruz *)) * avNum);
  if (!city)
  {
    perror("failed to allocate streets");
    exit(1);
  }
  else
  {
    
  }

  for (i = 0; i < avNum; i++)
  {
    city[i] = (cruz *) malloc((sizeof(cruz)) * strNum);
  }

}

void search(cruz *current, cruz *original)
{
  int i;
  if (current->visited == 1)
  {
    return;
  }
  else
  {
    
  }

  current->visited = 1;
  for (i = 0; i < 4; i++)
  {
    if (!(current->adj[i] == 0))
    {
      if ((current->adj[i]->type == 1) && (current->adj[i]->visited == 0))
      {
        int p;
        current->adj[i]->visited = 1;
        original->reachSize++;
        p = original->reachSize;
        original->reach[p - 1] = current->adj[i];
        if (p == smNum)
        {
          return;
        }
        else
        {
          
        }

      }
      else
      {
        if (current->adj[i]->type == 2)
        {
          current->adj[i]->visited = 1;
        }
        else
        {
          if (!(current->adj[i]->visited == 1))
          {
            search(current->adj[i], original);
          }
          else
          {
            
          }

        }

      }

    }
    else
    {
      
    }

  }

}

void resetVisits()
{
  int i;
  int j;
  for (i = 0; i < avNum; i++)
  {
    for (j = 0; j < strNum; j++)
    {
      city[i][j].visited = 0;
    }

  }

}

void find_paths()
{
  int i;
  for (i = 0; i < ctNum; i++)
  {
    resetVisits();
    if ((citList[i] != 0) && (citList[i]->type == 2))
    {
      search(citList[i], citList[i]);
    }
    else
    {
      
    }

  }

}

void startGraph()
{
  int i;
  int j;
  for (i = 0; i < avNum; i++)
  {
    for (j = 0; j < strNum; j++)
    {
      city[i][j].type = 0;
      city[i][j].visited = 0;
      city[i][j].coord[0] = i + 1;
      city[i][j].coord[1] = j + 1;
    }

  }

}

void swap(int i, int j)
{
  cruz t = *citList[i];
  citList[i] = citList[j];
  citList[j] = &t;
}

int part(int low, int high)
{
  int j;
  int pivot = citList[high]->reachSize;
  int i = low - 1;
  for (j = low; j < high; j++)
  {
    if (citList[j]->reachSize < pivot)
    {
      i++;
      swap(i, j);
    }
    else
    {
      
    }

  }

  swap(i + 1, high);
  return i + 1;
}

void quicksort(int low, int high)
{
  if (low < high)
  {
    int p = part(low, high);
    quicksort(low, p - 1);
    quicksort(p + 1, high);
  }
  else
  {
    
  }

}

int flow()
{
  int i;
  int j;
  int start;
  int temp;
  int total = 0;
  start = 0;
  quicksort(0, ctNum - 1);
  for (i = 0; i < ctNum; i++)
  {
    temp = citList[i]->reachSize;
    if (temp > 0)
    {
      start = i;
      break;
    }
    else
    {
      
    }

  }

  for (i = start; i < ctNum; i++)
  {
    temp = citList[i]->reachSize;
    for (j = 0; j < temp; j++)
    {
      if (citList[i]->reach[j]->used == 0)
      {
        total++;
        citList[i]->reach[j]->used = 1;
        break;
      }
      else
      {
        
      }

    }

  }

  return total;
}

void freeAll()
{
  free(city);
}

void adj()
{
  int i;
  int j;
  for (i = 0; i < avNum; i++)
  {
    for (j = 0; j < strNum; j++)
    {
      if (j > 0)
      {
        city[i][j].adj[0] = &city[i][j - 1];
      }
      else
      {
        city[i][j].adj[0] = 0;
      }

      if (j < (strNum - 1))
      {
        city[i][j].adj[1] = &city[i][j + 1];
      }
      else
      {
        city[i][j].adj[1] = 0;
      }

      if (i > 0)
      {
        city[i][j].adj[2] = &city[i - 1][j];
      }
      else
      {
        city[i][j].adj[2] = 0;
      }

      if (i < (avNum - 1))
      {
        city[i][j].adj[3] = &city[i + 1][j];
      }
      else
      {
        city[i][j].adj[3] = 0;
      }

    }

  }

}

int main()
{
  char line[100];
  int final;
  int temp;
  int penalty;
  int i = 0;
  penalty = 0;
  final = 0;
  while (fgets(line, (sizeof(line)) / (sizeof(char)), stdin))
  {
    if (i == 0)
    {
      char *avNums = strtok(line, " ");
      char *strNums = strtok(0, "\n");
      avNum = atoi(avNums);
      strNum = atoi(strNums);
      processFirstLine();
    }
    else
    {
      if (i == 1)
      {
        char *smNums = strtok(line, " ");
        char *ctNums = strtok(0, "\n");
        smNum = atoi(smNums);
        originalsmNum = smNum;
        ctNum = atoi(ctNums);
        originalctNum = ctNum;
        startGraph();
        adj();
        citList = (cruz **) malloc((sizeof(cruz *)) * ctNum);
      }
      else
      {
        if (i <= (1 + originalsmNum))
        {
          char *x = strtok(line, " ");
          char *y = strtok(0, "\n");
          int av = atoi(x);
          int st = atoi(y);
          if (city[av - 1][st - 1].type == 0)
          {
            city[av - 1][st - 1].type = 1;
            city[av - 1][st - 1].visited = 0;
            city[av - 1][st - 1].used = 0;
          }
          else
          {
            smNum--;
          }

        }
        else
        {
          if (i <= ((1 + originalsmNum) + originalctNum))
          {
            char *x = strtok(line, " ");
            char *y = strtok(0, "\n");
            int av = atoi(x);
            int st = atoi(y);
            if (city[av - 1][st - 1].type == 0)
            {
              city[av - 1][st - 1].type = 2;
              city[av - 1][st - 1].visited = 0;
              city[av - 1][st - 1].reachSize = 0;
              city[av - 1][st - 1].reach = (cruz **) malloc((sizeof(cruz *)) * originalsmNum);
              citList[((i - 2) - originalsmNum) - penalty] = &city[av - 1][st - 1];
            }
            else
            {
              if (city[av - 1][st - 1].type == 2)
              {
                ctNum--;
                penalty++;
                citList = (cruz **) realloc(citList, (sizeof(cruz *)) * ctNum);
              }
              else
              {
                if (city[av - 1][st - 1].type == 1)
                {
                  final++;
                  penalty++;
                  smNum--;
                  ctNum--;
                  city[av - 1][st - 1].type = 2;
                  citList = (cruz **) realloc(citList, (sizeof(cruz *)) * ctNum);
                }
                else
                {
                  
                }

              }

            }

            if (i == ((1 + originalsmNum) + originalctNum))
            {
              break;
            }
            else
            {
              
            }

          }
          else
          {
            
          }

        }

      }

    }

    i++;
  }

  if (!citList)
  {
    return 0;
  }
  else
  {
    
  }

  find_paths();
  temp = flow();
  final = final + temp;
  printf("%d\n", final);
  freeAll();
  return 0;
}

