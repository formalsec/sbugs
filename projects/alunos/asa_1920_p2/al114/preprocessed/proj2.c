#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>


int nStreets = 0;
int nAvenues = 0;
int nSuperM = 0;
int nCitizens = 0;
int nVertexs = 0;
int head;
int tail;
typedef struct vertex
{
  int colour;
  int citizen;
  int supermarket;
  int nNeighbours;
  int *neighbours;
  int *flow;
  int parent;
} Vertex;
Vertex *vertexList;
int *queue;
int findVertexIndex(int avenue, int street)
{
  return 2 * ((((avenue - 1) * nStreets) + street) - 1);
}

void initialize()
{
  int i;
  int j;
  int index;
  for (i = 1; i <= nAvenues; i++)
  {
    for (j = 1; j <= nStreets; j++)
    {
      index = findVertexIndex(i, j);
      vertexList[index].colour = 0;
      vertexList[index].citizen = -1;
      vertexList[index].supermarket = -1;
      vertexList[index].neighbours = (int *) malloc(sizeof(int));
      vertexList[index].flow = (int *) malloc(sizeof(int));
      vertexList[index].flow[0] = 0;
      vertexList[index].neighbours[0] = index + 1;
      vertexList[index].nNeighbours = 1;
      vertexList[index].parent = -1;
      index++;
      vertexList[index].colour = 0;
      vertexList[index].citizen = -1;
      vertexList[index].supermarket = -1;
      vertexList[index].flow = 0;
      vertexList[index].neighbours = 0;
      vertexList[index].nNeighbours = 0;
      vertexList[index].parent = index - 1;
    }

  }

}

void initializeSourceSink()
{
  int sourceIndex;
  int sinkIndex;
  sourceIndex = nVertexs;
  vertexList[sourceIndex].colour = 0;
  vertexList[sourceIndex].citizen = -1;
  vertexList[sourceIndex].supermarket = -1;
  vertexList[sourceIndex].flow = 0;
  vertexList[sourceIndex].neighbours = 0;
  vertexList[sourceIndex].nNeighbours = 0;
  vertexList[sourceIndex].parent = -1;
  sinkIndex = nVertexs + 1;
  vertexList[sinkIndex].colour = 0;
  vertexList[sinkIndex].citizen = -1;
  vertexList[sinkIndex].supermarket = -1;
  vertexList[sinkIndex].flow = 0;
  vertexList[sinkIndex].neighbours = 0;
  vertexList[sinkIndex].nNeighbours = 0;
  vertexList[sinkIndex].parent = -1;
}

void addNeighbour(int index, int indexN)
{
  vertexList[index].nNeighbours++;
  vertexList[index].neighbours = (int *) realloc(vertexList[index].neighbours, (sizeof(int)) * vertexList[index].nNeighbours);
  vertexList[index].flow = (int *) realloc(vertexList[index].flow, (sizeof(int)) * vertexList[index].nNeighbours);
  vertexList[index].neighbours[vertexList[index].nNeighbours - 1] = indexN;
  vertexList[index].flow[vertexList[index].nNeighbours - 1] = 0;
}

void findNeighboursOut()
{
  int d;
  int avenue;
  int street;
  int aa;
  int ss;
  int index;
  int indexN;
  int dAvenues[] = {-1, +1, 0, 0};
  int dStreets[] = {0, 0, -1, +1};
  for (avenue = 1; avenue <= nAvenues; avenue++)
  {
    for (street = 1; street <= nStreets; street++)
    {
      for (d = 0; d < 4; d++)
      {
        aa = avenue + dAvenues[d];
        ss = street + dStreets[d];
        if (!((((aa <= 0) || (ss <= 0)) || (ss > nStreets)) || (aa > nAvenues)))
        {
          index = findVertexIndex(avenue, street);
          indexN = findVertexIndex(aa, ss);
          addNeighbour(index + 1, indexN);
        }
        else
        {
          
        }

      }

    }

  }

}

int findNeighbourIndex(int pai, int filho)
{
  int i;
  for (i = 0; i < vertexList[pai].nNeighbours; i++)
  {
    if (vertexList[pai].neighbours[i] == filho)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void enqueue(int vertexIndex)
{
  queue[tail] = vertexIndex;
  tail++;
  vertexList[vertexIndex].colour = 1;
}

int dequeue()
{
  int vertexIndex = queue[head];
  head++;
  vertexList[vertexIndex].colour = 2;
  return vertexIndex;
}

int bfs()
{
  int source = nVertexs;
  int sink = nVertexs + 1;
  int i;
  int vertexIndex;
  for (i = 0; i < (nVertexs + 2); i++)
  {
    vertexList[i].colour = 0;
  }

  head = (tail = 0);
  enqueue(source);
  while (head != tail)
  {
    vertexIndex = dequeue();
    for (i = 0; i < vertexList[vertexIndex].nNeighbours; i++)
    {
      if ((vertexList[vertexList[vertexIndex].neighbours[i]].colour == 0) && (vertexList[vertexIndex].flow[i] == 0))
      {
        if (vertexList[vertexIndex].neighbours[i] == (nVertexs + 1))
        {
          vertexList[vertexList[vertexIndex].neighbours[i]].parent = vertexIndex;
          return 1;
        }
        else
        {
          if ((vertexList[vertexList[vertexIndex].neighbours[i]].citizen != (-1)) && (vertexIndex != nVertexs))
          {
            continue;
          }
          else
          {
            enqueue(vertexList[vertexIndex].neighbours[i]);
            vertexList[vertexList[vertexIndex].neighbours[i]].parent = vertexIndex;
          }

        }

      }
      else
      {
        
      }

    }

  }

  return vertexList[sink].colour == 2;
}

int edmondsKarp()
{
  int sink = nVertexs + 1;
  int i;
  int o;
  int index;
  int max_flow = 0;
  while (bfs())
  {
    for (i = sink; vertexList[i].parent != nVertexs; i = vertexList[i].parent)
    {
      o = vertexList[i].parent;
      index = findNeighbourIndex(o, i);
      vertexList[o].flow[index] = 1;
      addNeighbour(i, o);
    }

    max_flow++;
  }

  return max_flow;
}

int main()
{
  int i;
  int street;
  int avenue;
  int index;
  nAvenues = new_sym_var(sizeof(int) * 8);
  nStreets = new_sym_var(sizeof(int) * 8);
  nSuperM = new_sym_var(sizeof(int) * 8);
  nCitizens = new_sym_var(sizeof(int) * 8);
  nVertexs = (2 * nAvenues) * nStreets;
  vertexList = (Vertex *) malloc((sizeof(Vertex)) * (nVertexs + 2));
  queue = (int *) malloc((sizeof(int)) * (nVertexs + 2));
  initialize();
  initializeSourceSink();
  findNeighboursOut();
  for (i = 0; i < nSuperM; i++)
  {
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    index = findVertexIndex(avenue, street);
    vertexList[index].supermarket = i;
    free(vertexList[index + 1].neighbours);
    vertexList[index + 1].neighbours = (int *) malloc(sizeof(int));
    vertexList[index + 1].neighbours[0] = nVertexs + 1;
    vertexList[index + 1].nNeighbours = 1;
  }

  for (i = 0; i < nCitizens; i++)
  {
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    index = findVertexIndex(avenue, street);
    if (vertexList[index].citizen == (-1))
    {
      addNeighbour(nVertexs, index);
      vertexList[index].citizen = i;
    }
    else
    {
      
    }

  }

  printf("%d\n", edmondsKarp());
  for (i = 0; i < (nVertexs + 2); i++)
  {
    free(vertexList[i].neighbours);
    free(vertexList[i].flow);
  }

  free(queue);
  free(vertexList);
  return 0;
}

