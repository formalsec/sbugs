#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include<stdio.h>
#include<stdlib.h>


typedef struct edge
{
  int indexfromV;
  int indexToV;
  int flow;
  int capacity;
} Edge;
typedef struct node
{
  Edge e;
  struct node *next;
} Node;
typedef struct list
{
  Node *head;
  Node *tail;
} List;
typedef struct graph
{
  List listOfAdjEdges;
} Graph;
typedef struct queuenode
{
  int verticeindex;
  struct queuenode *next;
} QueueNode;
typedef struct queuelist
{
  QueueNode *head;
  QueueNode *tail;
} QueueList;
int nAvenues = 0;
int nStreets = 0;
int nSuperm = 0;
int nCitiz = 0;
int **MatrixOfverticesCit;
int **MatrixOfverticesSup;
int *prev;
int *path;
Graph *Manhattan;
QueueList queue;
QueueNode *createQueueNode(int i)
{
  QueueNode *newNode;
  newNode = (QueueNode *) malloc(sizeof(QueueNode));
  newNode->verticeindex = i;
  newNode->next = 0;
  return newNode;
}

int QUEUEempty()
{
  return queue.head == 0;
}

void QUEUEinit()
{
  queue.head = 0;
  queue.tail = 0;
}

void QUEUEput(int i)
{
  if (queue.head == 0)
  {
    queue.head = (queue.tail = createQueueNode(i));
    return;
  }
  else
  {
    queue.tail->next = createQueueNode(i);
    queue.tail = queue.tail->next;
  }

}

int QUEUEget()
{
  int i = 0;
  QueueNode *previousNode;
  if (!QUEUEempty())
  {
    i = queue.head->verticeindex;
    previousNode = queue.head;
    queue.head = queue.head->next;
    free(previousNode);
  }
  else
  {
    printf("Queue is empty.");
  }

  return i;
}

int returnIndexInGraph(int i, int j)
{
  return (i * nStreets) + j;
}

void inputOfCitizens(int lenght, int id)
{
  int i;
  int input1;
  int input2;
  for (i = 0; i < lenght; i++)
  {
    input1 = new_sym_var(sizeof(int) * 8);
    input2 = new_sym_var(sizeof(int) * 8);
    MatrixOfverticesCit[input1 - 1][input2 - 1] = id;
  }

}

void inputOfSupermarkets(int lenght, int id)
{
  int i;
  int input1;
  int input2;
  for (i = 0; i < lenght; i++)
  {
    input1 = new_sym_var(sizeof(int) * 8);
    input2 = new_sym_var(sizeof(int) * 8);
    MatrixOfverticesSup[input1 - 1][input2 - 1] = id;
  }

}

Edge NewEdge(int ToV, int FromV, int c)
{
  Edge e;
  e.flow = 0;
  e.capacity = c;
  e.indexfromV = FromV;
  e.indexToV = ToV;
  return e;
}

Node *createNode(Edge e)
{
  Node *newNode;
  newNode = (Node *) malloc(sizeof(Node));
  newNode->e = e;
  newNode->next = 0;
  return newNode;
}

void insertAtEnd(int n, Edge edge)
{
  if (Manhattan[n].listOfAdjEdges.head == 0)
  {
    Manhattan[n].listOfAdjEdges.head = createNode(edge);
    Manhattan[n].listOfAdjEdges.tail = Manhattan[n].listOfAdjEdges.head;
    return;
  }
  else
  {
    
  }

  Manhattan[n].listOfAdjEdges.tail->next = createNode(edge);
  Manhattan[n].listOfAdjEdges.tail = Manhattan[n].listOfAdjEdges.tail->next;
}

void aux_init_ListOfAdjEdgesINtoOUT(int iIN, int jIN, int iOUT, int jOUT, int c)
{
  int indexIN = returnIndexInGraph(iIN, jIN);
  int indexOUT = returnIndexInGraph(iOUT, jOUT) + (nAvenues * nStreets);
  Edge eAux = NewEdge(indexOUT, indexIN, c);
  insertAtEnd(indexIN, eAux);
}

void aux_init_ListOfAdjEdgesOUTtoIN(int iOUT, int jOUT, int iIN, int jIN, int c)
{
  int indexIN = returnIndexInGraph(iIN, jIN);
  int indexOUT = returnIndexInGraph(iOUT, jOUT) + (nAvenues * nStreets);
  Edge eAux = NewEdge(indexIN, indexOUT, c);
  insertAtEnd(indexOUT, eAux);
}

void aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(int iOUT, int jOUT, int iIN, int jIN)
{
  aux_init_ListOfAdjEdgesOUTtoIN(iOUT, jOUT, iIN, jIN, 1);
  aux_init_ListOfAdjEdgesINtoOUT(iIN, jIN, iOUT, jOUT, 0);
}

void init_ListOfAdjEdges()
{
  int i;
  int j;
  for (i = 0; i < nAvenues; i++)
  {
    for (j = 0; j < nStreets; j++)
    {
      aux_init_ListOfAdjEdgesINtoOUT(i, j, i, j, 1);
      aux_init_ListOfAdjEdgesOUTtoIN(i, j, i, j, 0);
      if (i == 0)
      {
        aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i + 1, j);
        if (j == 0)
        {
          aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j + 1);
        }
        else
        {
          if ((j > 0) && (j < (nStreets - 1)))
          {
            aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j - 1);
            aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j + 1);
          }
          else
          {
            if (j == (nStreets - 1))
            {
              aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j - 1);
            }
            else
            {
              
            }

          }

        }

      }
      else
      {
        if ((i > 0) && (i < (nAvenues - 1)))
        {
          aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i + 1, j);
          aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i - 1, j);
          if (j == 0)
          {
            aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j + 1);
          }
          else
          {
            if ((j > 0) && (j < (nStreets - 1)))
            {
              aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j + 1);
              aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j - 1);
            }
            else
            {
              if (j == (nStreets - 1))
              {
                aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j - 1);
              }
              else
              {
                
              }

            }

          }

        }
        else
        {
          if (i == (nAvenues - 1))
          {
            aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i - 1, j);
            if (j == 0)
            {
              aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j + 1);
            }
            else
            {
              if ((j > 0) && (j < (nStreets - 1)))
              {
                aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j + 1);
                aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j - 1);
              }
              else
              {
                if (j == (nStreets - 1))
                {
                  aux_init_ListOfAdjEdgesOUTtoINandINtoOUT(i, j, i, j - 1);
                }
                else
                {
                  
                }

              }

            }

          }
          else
          {
            
          }

        }

      }

    }

  }

}

void init_SourceAndSink()
{
  int SourceIndex = 2 * (nAvenues * nStreets);
  int SinkIndex = (2 * (nAvenues * nStreets)) + 1;
  int i;
  int j;
  int indexIN = 0;
  int indexOUT = 0;
  for (i = 0; i < nAvenues; i++)
  {
    for (j = 0; j < nStreets; j++)
    {
      if (MatrixOfverticesCit[i][j] == 1)
      {
        indexIN = returnIndexInGraph(i, j);
        insertAtEnd(SourceIndex, NewEdge(indexIN, SourceIndex, 1));
        insertAtEnd(indexIN, NewEdge(SourceIndex, indexIN, 0));
      }
      else
      {
        
      }

      if (MatrixOfverticesSup[i][j] == 2)
      {
        indexOUT = returnIndexInGraph(i, j) + (nAvenues * nStreets);
        insertAtEnd(indexOUT, NewEdge(SinkIndex, indexOUT, 1));
        insertAtEnd(SinkIndex, NewEdge(indexOUT, SinkIndex, 0));
      }
      else
      {
        
      }

    }

  }

}

void init_graph()
{
  int i;
  Manhattan = (Graph *) malloc(((2 * (nAvenues * nStreets)) + 2) * (sizeof(Graph)));
  for (i = 0; i < ((2 * (nAvenues * nStreets)) + 2); i++)
  {
    Manhattan[i].listOfAdjEdges.head = 0;
    Manhattan[i].listOfAdjEdges.tail = 0;
  }

  init_ListOfAdjEdges();
  init_SourceAndSink();
}

void init_MatrixOfVerticesBoth()
{
  int i;
  int j;
  MatrixOfverticesCit = (int **) malloc(nAvenues * (sizeof(int *)));
  MatrixOfverticesSup = (int **) malloc(nAvenues * (sizeof(int *)));
  for (i = 0; i < nAvenues; i++)
  {
    MatrixOfverticesCit[i] = (int *) malloc(nStreets * (sizeof(int)));
    MatrixOfverticesSup[i] = (int *) malloc(nStreets * (sizeof(int)));
    for (j = 0; j < nStreets; j++)
    {
      MatrixOfverticesCit[i][j] = 0;
      MatrixOfverticesSup[i][j] = 0;
    }

  }

}

void init_prev_and_path()
{
  int n = 0;
  prev = (int *) malloc(((2 * (nAvenues * nStreets)) + 2) * (sizeof(int)));
  for (n = 0; n < ((2 * (nAvenues * nStreets)) + 2); n++)
  {
    prev[n] = -1;
  }

  path = (int *) malloc(((2 * (nAvenues * nStreets)) + 2) * (sizeof(int)));
  for (n = 0; n < ((2 * (nAvenues * nStreets)) + 2); n++)
  {
    path[n] = 0;
  }

}

void set_prev_and_path()
{
  int n = 0;
  for (n = 0; n < ((2 * (nAvenues * nStreets)) + 2); n++)
  {
    prev[n] = -1;
  }

  for (n = 0; n < ((2 * (nAvenues * nStreets)) + 2); n++)
  {
    path[n] = 0;
  }

}

int min(int u, int v)
{
  if (v < u)
  {
    return v;
  }
  else
  {
    
  }

  return u;
}

int bfs(int SourceIndex, int SinkIndex)
{
  int flow = 0;
  int indexPoped = 0;
  Node *aux;
  set_prev_and_path();
  QUEUEinit();
  QUEUEput(SourceIndex);
  prev[SourceIndex] = 11;
  path[SourceIndex] = 333;
  while (!QUEUEempty())
  {
    indexPoped = QUEUEget();
    for (aux = Manhattan[indexPoped].listOfAdjEdges.head; aux != 0; aux = aux->next)
    {
      if (prev[aux->e.indexToV] == (-1))
      {
        if ((aux->e.capacity - aux->e.flow) > 0)
        {
          prev[aux->e.indexToV] = indexPoped;
          path[aux->e.indexToV] = min(path[indexPoped], aux->e.capacity - aux->e.flow);
          if (aux->e.indexToV == SinkIndex)
          {
            flow = path[aux->e.indexToV];
          }
          else
          {
            
          }

          QUEUEput(aux->e.indexToV);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  return flow;
}

int edmondsKarp()
{
  int SourceIndex = 2 * (nAvenues * nStreets);
  int SinkIndex = (2 * (nAvenues * nStreets)) + 1;
  int maxFlow = 0;
  int flow = 0;
  int aux = 0;
  int beforeAux = 0;
  Node *auxNode = 0;
  while (1)
  {
    flow = bfs(SourceIndex, SinkIndex);
    if (flow == 0)
    {
      break;
    }
    else
    {
      
    }

    maxFlow += flow;
    aux = SinkIndex;
    while (aux != SourceIndex)
    {
      beforeAux = prev[aux];
      for (auxNode = Manhattan[beforeAux].listOfAdjEdges.head; auxNode->e.indexToV != aux; auxNode = auxNode->next)
        ;

      auxNode->e.flow += flow;
      for (auxNode = Manhattan[aux].listOfAdjEdges.head; auxNode->e.indexToV != beforeAux; auxNode = auxNode->next)
        ;

      auxNode->e.flow -= flow;
      aux = beforeAux;
    }

  }

  return maxFlow;
}

void free_all()
{
  int n;
  int i;
  Node *aux;
  Node *auxBefore;
  for (n = 0; n < ((2 * (nAvenues * nStreets)) + 2); n++)
  {
    for (aux = Manhattan[n].listOfAdjEdges.head; aux != 0;)
    {
      auxBefore = aux;
      aux = aux->next;
      free(auxBefore);
    }

    Manhattan[n].listOfAdjEdges.head = 0;
    Manhattan[n].listOfAdjEdges.tail = 0;
  }

  free(Manhattan);
  for (i = 0; i < nAvenues; i++)
  {
    free(MatrixOfverticesCit[i]);
    free(MatrixOfverticesSup[i]);
  }

  free(MatrixOfverticesCit);
  free(MatrixOfverticesSup);
  free(prev);
  free(path);
}

int main()
{
  int maxFlow = 0;
  nAvenues = new_sym_var(sizeof(int) * 8);
  nStreets = new_sym_var(sizeof(int) * 8);
  if ((nAvenues < 1) || (nStreets < 1))
  {
    exit(1);
  }
  else
  {
    
  }

  nSuperm = new_sym_var(sizeof(int) * 8);
  nCitiz = new_sym_var(sizeof(int) * 8);
  init_MatrixOfVerticesBoth();
  inputOfSupermarkets(nSuperm, 2);
  inputOfCitizens(nCitiz, 1);
  init_graph();
  init_prev_and_path();
  maxFlow = edmondsKarp();
  free_all();
  printf("%d\n", maxFlow);
  return 0;
}

