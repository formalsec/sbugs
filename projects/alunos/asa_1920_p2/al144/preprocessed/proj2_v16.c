#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int source_id;
int target_id;
int n_Vertex;
short *parents;
int *queue;
typedef struct Edge
{
  int to;
  short capacity;
  struct Edge *next;
} edge;
typedef edge *elink;
void allocAdjLists(elink **e)
{
  *e = (elink *) malloc((sizeof(elink)) * n_Vertex);
  return;
}

void initializeEdges(elink *edges)
{
  int i;
  for (i = 0; i < n_Vertex; i++)
  {
    *(edges + i) = 0;
  }

  return;
}

void addEdge(elink *edges, elink new_edge, int from)
{
  new_edge->next = *(edges + from);
  *(edges + from) = new_edge;
  return;
}

void invertCapacities(int v1, int v2, elink *edges)
{
  elink temp;
  temp = *(edges + v1);
  while (temp->to != v2)
  {
    temp = temp->next;
  }

  temp->capacity = 0;
  temp = *(edges + v2);
  while (temp->to != v1)
  {
    temp = temp->next;
  }

  temp->capacity = 1;
  return;
}

void allocBasic(int **M, int **N, int **S, int **C)
{
  *M = (int *) malloc(sizeof(int));
  *N = (int *) malloc(sizeof(int));
  *S = (int *) malloc(sizeof(int));
  *C = (int *) malloc(sizeof(int));
  return;
}

void parseBasic(int *M, int *N, int *S, int *C)
{
  for (int M_index = 0; M_index < 10; M_index++)
  {
    M[M_index] = new_sym_var(sizeof(int) * 8);
  }

  for (int N_index = 0; N_index < 10; N_index++)
  {
    N[N_index] = new_sym_var(sizeof(int) * 8);
  }

  for (int S_index = 0; S_index < 10; S_index++)
  {
    S[S_index] = new_sym_var(sizeof(int) * 8);
  }

  for (int C_index = 0; C_index < 10; C_index++)
  {
    C[C_index] = new_sym_var(sizeof(int) * 8);
  }

  source_id = ((*N) * (*M)) * 2;
  target_id = (((*N) * (*M)) * 2) + 1;
  n_Vertex = (((*N) * (*M)) * 2) + 2;
  parents = (short *) malloc((sizeof(short)) * n_Vertex);
  queue = (int *) malloc((sizeof(int)) * n_Vertex);
  return;
}

int borderSide(int i, int A)
{
  if ((i >= 0) && (i <= ((2 * A) - 2)))
  {
    return 1;
  }
  else
  {
    if ((i >= ((n_Vertex - 2) - (2 * A))) && (i <= (n_Vertex - 4)))
    {
      return 4;
    }
    else
    {
      if ((((i % (2 * A)) == 0) && (i != 0)) && (i != ((n_Vertex - 2) - (2 * A))))
      {
        return 2;
      }
      else
      {
        if (((((i + 2) % (2 * A)) == 0) && (i != ((2 * A) - 2))) && (i != (n_Vertex - 4)))
        {
          return 3;
        }
        else
        {
          
        }

      }

    }

  }

  return 0;
}

int leftHandCorner(int i, int A)
{
  if ((i == 0) || (i == ((n_Vertex - 2) - (2 * A))))
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

int rightHandCorner(int i, int A)
{
  if ((i == ((2 * A) - 2)) || (i == (n_Vertex - 4)))
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void connectLeft(elink *edges, int i)
{
  elink e1;
  elink e2;
  e1 = (elink) malloc(sizeof(edge));
  e1->to = i - 1;
  e1->capacity = 1;
  e1->next = 0;
  addEdge(edges, e1, i);
  e2 = (elink) malloc(sizeof(edge));
  e2->to = i - 2;
  e2->capacity = 0;
  e2->next = 0;
  addEdge(edges, e2, i + 1);
}

void connectRight(elink *edges, int i)
{
  elink e1;
  elink e2;
  e1 = (elink) malloc(sizeof(edge));
  e1->to = i + 3;
  e1->capacity = 1;
  e1->next = 0;
  addEdge(edges, e1, i);
  e2 = (elink) malloc(sizeof(edge));
  e2->to = i + 2;
  e2->capacity = 0;
  e2->next = 0;
  addEdge(edges, e2, i + 1);
}

void connectAbove(elink *edges, int i, int A)
{
  elink e1;
  elink e2;
  e1 = (elink) malloc(sizeof(edge));
  e1->to = (i - (2 * A)) + 1;
  e1->capacity = 1;
  e1->next = 0;
  addEdge(edges, e1, i);
  e2 = (elink) malloc(sizeof(edge));
  e2->to = i - (2 * A);
  e2->capacity = 0;
  e2->next = 0;
  addEdge(edges, e2, i + 1);
}

void connectBelow(elink *edges, int i, int A)
{
  elink e1;
  elink e2;
  e1 = (elink) malloc(sizeof(edge));
  e1->to = (i + (2 * A)) + 1;
  e1->capacity = 1;
  e1->next = 0;
  addEdge(edges, e1, i);
  e2 = (elink) malloc(sizeof(edge));
  e2->to = i + (2 * A);
  e2->capacity = 0;
  e2->next = 0;
  addEdge(edges, e2, i + 1);
}

void connectWithin(elink *edges, int i)
{
  elink e1;
  elink e2;
  e1 = (elink) malloc(sizeof(edge));
  e1->to = i + 1;
  e1->capacity = 0;
  e1->next = 0;
  addEdge(edges, e1, i);
  e2 = (elink) malloc(sizeof(edge));
  e2->to = i;
  e2->capacity = 1;
  e2->next = 0;
  addEdge(edges, e2, i + 1);
}

void prepAdj(elink *edges, int *A)
{
  int i;
  int effec;
  int border;
  int l_corner;
  int r_corner;
  effec = n_Vertex - 2;
  for (i = 0; i < effec; i = i + 2)
  {
    border = borderSide(i, *A);
    l_corner = leftHandCorner(i, *A);
    r_corner = rightHandCorner(i, *A);
    if ((border == 1) && (l_corner != 0))
    {
      connectWithin(edges, i);
      connectRight(edges, i);
      connectBelow(edges, i, *A);
    }
    else
    {
      if ((border == 1) && (r_corner != 0))
      {
        connectWithin(edges, i);
        connectLeft(edges, i);
        connectBelow(edges, i, *A);
      }
      else
      {
        if ((border == 4) && (l_corner != 0))
        {
          connectWithin(edges, i);
          connectRight(edges, i);
          connectAbove(edges, i, *A);
        }
        else
        {
          if ((border == 4) && (r_corner != 0))
          {
            connectWithin(edges, i);
            connectLeft(edges, i);
            connectAbove(edges, i, *A);
          }
          else
          {
            if (((border == 1) && (r_corner == 0)) && (l_corner == 0))
            {
              connectWithin(edges, i);
              connectLeft(edges, i);
              connectRight(edges, i);
              connectBelow(edges, i, *A);
            }
            else
            {
              if (((border == 4) && (r_corner == 0)) && (l_corner == 0))
              {
                connectWithin(edges, i);
                connectLeft(edges, i);
                connectRight(edges, i);
                connectAbove(edges, i, *A);
              }
              else
              {
                if (border == 2)
                {
                  connectWithin(edges, i);
                  connectAbove(edges, i, *A);
                  connectBelow(edges, i, *A);
                  connectRight(edges, i);
                }
                else
                {
                  if (border == 3)
                  {
                    connectWithin(edges, i);
                    connectAbove(edges, i, *A);
                    connectBelow(edges, i, *A);
                    connectLeft(edges, i);
                  }
                  else
                  {
                    connectWithin(edges, i);
                    connectAbove(edges, i, *A);
                    connectBelow(edges, i, *A);
                    connectLeft(edges, i);
                    connectRight(edges, i);
                  }

                }

              }

            }

          }

        }

      }

    }

  }

}

void connectTarget(elink *edges, int SMerc, int Av)
{
  int i;
  int a;
  int s;
  int orig;
  elink e1;
  elink e2;
  for (i = 0; i < SMerc; i++)
  {
    a = new_sym_var(sizeof(int) * 8);
    s = new_sym_var(sizeof(int) * 8);
    orig = (2 * (a - 1)) + (((s - 1) * 2) * Av);
    e1 = (elink) malloc(sizeof(edge));
    e1->to = target_id;
    e1->capacity = 1;
    e1->next = 0;
    addEdge(edges, e1, orig);
    e2 = (elink) malloc(sizeof(edge));
    e2->to = orig;
    e2->capacity = 0;
    e2->next = 0;
    addEdge(edges, e2, target_id);
  }

}

void connectSource(elink *edges, int Citiz, int Av)
{
  int i;
  int a;
  int s;
  int orig;
  elink e1;
  elink e2;
  for (i = 0; i < Citiz; i++)
  {
    a = new_sym_var(sizeof(int) * 8);
    s = new_sym_var(sizeof(int) * 8);
    orig = (2 * (a - 1)) + (((s - 1) * 2) * Av);
    e1 = (elink) malloc(sizeof(edge));
    e1->to = orig + 1;
    e1->capacity = 1;
    e1->next = 0;
    addEdge(edges, e1, source_id);
    e2 = (elink) malloc(sizeof(edge));
    e2->to = source_id;
    e2->capacity = 0;
    e2->next = 0;
    addEdge(edges, e2, orig + 1);
  }

}

int bfsMinPath(elink *edges)
{
  int i;
  int v;
  int p;
  int f;
  int l;
  elink e;
  f = 0;
  l = 0;
  memset(parents, -1, n_Vertex * (sizeof(short)));
  memset(queue, -1, n_Vertex * (sizeof(int)));
  *(queue + f) = source_id;
  l++;
  while ((*(queue + f)) != (-1))
  {
    v = *(queue + f);
    e = *(edges + v);
    while (e != 0)
    {
      if (((e->capacity == 1) && ((*(parents + e->to)) == (-1))) && (e->to != source_id))
      {
        *(parents + e->to) = v;
        if (e->to == target_id)
        {
          i = e->to;
          p = *(parents + i);
          while (p != (-1))
          {
            invertCapacities(p, i, edges);
            i = p;
            p = *(parents + i);
          }

          return 1;
        }
        else
        {
          
        }

        *(queue + l) = e->to;
        l++;
      }
      else
      {
        
      }

      e = e->next;
    }

    f++;
  }

  return 0;
}

int edmondsKarp(elink *edges)
{
  int maxFlow;
  int f;
  maxFlow = 0;
  while (1)
  {
    f = bfsMinPath(edges);
    if (f == 0)
    {
      break;
    }
    else
    {
      
    }

    maxFlow++;
  }

  return maxFlow;
}

void freeAll(int *M, int *N, int *S, int *C, elink *edges)
{
  int i;
  elink e;
  elink temp;
  free(M);
  free(N);
  free(S);
  free(C);
  free(parents);
  free(queue);
  for (i = 0; i < n_Vertex; i++)
  {
    e = *(edges + i);
    while (e != 0)
    {
      temp = e->next;
      free(e);
      e = temp;
    }

    continue;
  }

  free(edges);
  return;
}

int main()
{
  int *M;
  int *N;
  int *S;
  int *C;
  elink *edges;
  allocBasic(&M, &N, &S, &C);
  parseBasic(M, N, S, C);
  allocAdjLists(&edges);
  initializeEdges(edges);
  connectTarget(edges, *S, *M);
  connectSource(edges, *C, *M);
  prepAdj(edges, M);
  printf("%d\n", edmondsKarp(edges));
  freeAll(M, N, S, C, edges);
  return 0;
}

