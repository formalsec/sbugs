#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct 
{
  int x;
  int y;
  char state;
} place;
typedef struct 
{
  int distancia;
  int cid;
} list;
list *aux;
place *market;
place *cidadao;
int *tab[2];
int **duplicatemat(int **map, int **dup, int M, int N)
{
  int i;
  int j;
  for (i = 0; i < M; i++)
  {
    for (j = 0; j < N; j++)
    {
      dup[i][j] = map[i][j];
    }

  }

  return dup;
}

int percurso(int xi, int yi, int xf, int yf, int M, int N, int **dup, int **map, place *cidadao, int i)
{
  if (((xf == xi) && ((yf - 1) == yi)) && (map[xi][yi] == 0))
  {
    map[cidadao[i].x][cidadao[i].y] = 0;
    map[xi][yi] = 3;
    cidadao[i].x = xi;
    cidadao[i].y = yi;
    cidadao[i].state = 'B';
    return 1;
  }
  else
  {
    if (((xf == xi) && (yi == (yf + 1))) && (map[xi][yi] == 0))
    {
      map[cidadao[i].x][cidadao[i].y] = 0;
      map[xi][yi] = 3;
      cidadao[i].x = xi;
      cidadao[i].y = yi;
      cidadao[i].state = 'B';
      return 1;
    }
    else
    {
      if ((((xf - 1) == xi) && (yf == yi)) && (map[xi][yi] == 0))
      {
        map[cidadao[i].x][cidadao[i].y] = 0;
        map[xi][yi] = 3;
        cidadao[i].x = xi;
        cidadao[i].y = yi;
        cidadao[i].state = 'B';
        return 1;
      }
      else
      {
        if ((((xf + 1) == xi) && (yi == yf)) && (map[xi][yi] == 0))
        {
          map[cidadao[i].x][cidadao[i].y] = 0;
          map[xi][yi] = 3;
          cidadao[i].x = xi;
          cidadao[i].y = yi;
          cidadao[i].state = 'B';
          return 1;
        }
        else
        {
          
        }

      }

    }

  }

  if ((xi == cidadao[i].x) && (yi == cidadao[i].y))
  {
    if ((xf == xi) && ((yf - 1) == yi))
    {
      map[cidadao[i].x][cidadao[i].y] = 0;
      map[xi][yi] = 3;
      cidadao[i].x = xi;
      cidadao[i].y = yi;
      cidadao[i].state = 'B';
      return 1;
    }
    else
    {
      if ((xf == xi) && (yi == (yf + 1)))
      {
        map[cidadao[i].x][cidadao[i].y] = 0;
        map[xi][yi] = 3;
        cidadao[i].x = xi;
        cidadao[i].y = yi;
        cidadao[i].state = 'B';
        return 1;
      }
      else
      {
        if (((xf - 1) == xi) && (yf == yi))
        {
          map[cidadao[i].x][cidadao[i].y] = 0;
          map[xi][yi] = 3;
          cidadao[i].x = xi;
          cidadao[i].y = yi;
          cidadao[i].state = 'B';
          return 1;
        }
        else
        {
          if (((xf + 1) == xi) && (yi == yf))
          {
            map[cidadao[i].x][cidadao[i].y] = 0;
            map[xi][yi] = 3;
            cidadao[i].x = xi;
            cidadao[i].y = yi;
            cidadao[i].state = 'B';
            return 1;
          }
          else
          {
            
          }

        }

      }

    }

    if (percurso(xi + 1, yi, xf, yf, M, N, dup, map, cidadao, i))
    {
      return 1;
    }
    else
    {
      
    }

    if (percurso(xi, yi + 1, xf, yf, M, N, dup, map, cidadao, i))
    {
      return 1;
    }
    else
    {
      
    }

    if (percurso(xi - 1, yi, xf, yf, M, N, dup, map, cidadao, i))
    {
      return 1;
    }
    else
    {
      
    }

    if (percurso(xi, yi - 1, xf, yf, M, N, dup, map, cidadao, i))
    {
      return 1;
    }
    else
    {
      
    }

    return 0;
  }
  else
  {
    if ((((((xi >= 0) && (yi >= 0)) && (xi < M)) && (yi < N)) && (dup[xi][yi] == 0)) && (map[xi][yi] == 0))
    {
      dup[xi][yi] = 1;
      if (percurso(xi + 1, yi, xf, yf, M, N, dup, map, cidadao, i))
      {
        return 1;
      }
      else
      {
        
      }

      if (percurso(xi, yi + 1, xf, yf, M, N, dup, map, cidadao, i))
      {
        return 1;
      }
      else
      {
        
      }

      if (percurso(xi - 1, yi, xf, yf, M, N, dup, map, cidadao, i))
      {
        return 1;
      }
      else
      {
        
      }

      if (percurso(xi, yi - 1, xf, yf, M, N, dup, map, cidadao, i))
      {
        return 1;
      }
      else
      {
        
      }

      dup[xi][yi] = 0;
      return 0;
    }
    else
    {
      
    }

  }

  return 0;
}

void sort(int n, list *tabela)
{
  int i;
  int j;
  int t;
  int m;
  for (i = 0; i < n; i++)
  {
    for (j = i + 1; j < n; j++)
    {
      if (tabela[j].distancia < tabela[i].distancia)
      {
        t = tabela[i].distancia;
        m = tabela[i].cid;
        tabela[i].distancia = tabela[j].distancia;
        tabela[i].cid = tabela[j].cid;
        tabela[j].distancia = t;
        tabela[j].cid = m;
      }
      else
      {
        
      }

    }

  }

}

int distancia(place market, place cidadao)
{
  int x = market.x - cidadao.x;
  int y = market.y - cidadao.y;
  if (x < 0)
  {
    x *= -1;
  }
  else
  {
    
  }

  if (y < 0)
  {
    y *= -1;
  }
  else
  {
    
  }

  return x + y;
}

void tabela(place market, place *cidadao, int C)
{
  int i = 0;
  for (i = 0; i < C; i++)
  {
    aux[i].distancia = distancia(market, cidadao[i]);
    aux[i].cid = i;
  }

  sort(C, aux);
}

int contarnum(int **map, int **dup, int M, int N, place *cidadao, place *market, int S, int C)
{
  int num = 0;
  int i;
  int j;
  int num2;
  aux = malloc((sizeof(list)) * C);
  for (i = 0; i < S; i++)
  {
    tabela(market[i], cidadao, C);
    for (j = 0; j < C; j++)
    {
      if (market[i].state == 'B')
      {
        break;
      }
      else
      {
        
      }

      if (cidadao[aux[j].cid].state != 'B')
      {
        num2 = percurso(cidadao[aux[j].cid].x, cidadao[aux[j].cid].y, market[i].x, market[i].y, M, N, dup, map, cidadao, aux[j].cid);
        if (num2)
        {
          num += num2;
          market[i].state = 'B';
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    dup = duplicatemat(map, dup, M, N);
  }

  return num;
}

void test(int **map, int **dup, int M, int N)
{
  int i;
  int x = 0;
  int y = 0;
  int num = 0;
  int S;
  int C;
  S = new_sym_var(sizeof(int) * 8);
  C = new_sym_var(sizeof(int) * 8);
  market = malloc((sizeof(place)) * S);
  cidadao = malloc((sizeof(place)) * C);
  for (i = 0; i < S; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    map[--x][--y] = 2, market[i].x = x;
    market[i].y = y;
    market[i].state = 'L';
  }

  for (i = 0; i < C; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    map[--x][--y] = 3, cidadao[i].x = x;
    cidadao[i].y = y;
    cidadao[i].state = 'L';
  }

  dup = duplicatemat(map, dup, M, N);
  num = contarnum(map, dup, M, N, cidadao, market, S, C);
  printf("%d\n", num);
  free(market);
  free(cidadao);
}

int main()
{
  int M;
  int N;
  int j;
  int i;
  int b;
  int **map;
  int **dup;
  M = new_sym_var(sizeof(int) * 8);
  N = new_sym_var(sizeof(int) * 8);
  map = malloc((sizeof(int *)) * M);
  dup = malloc((sizeof(int *)) * M);
  for (i = 0; i < M; i++)
  {
    map[i] = malloc((sizeof(int)) * N);
    dup[i] = malloc((sizeof(int)) * N);
    for (b = 0; b < N; b++)
    {
      map[i][b] = 0;
      dup[i][b] = 0;
    }

  }

  test(map, dup, M, N);
  for (j = 0; j < M; j++)
  {
    free(map[j]);
    free(dup[j]);
  }

  free(dup);
  free(map);
  free(aux);
  return 0;
}

