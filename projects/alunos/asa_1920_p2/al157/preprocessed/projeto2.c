/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int M;
int N;
int S;
int C;
enum color
{
  White,
  Gray,
  Black
};
int p[100000000];
enum color color[100000000];
typedef struct node *link;
typedef struct graph *Graph;
typedef struct queue *queue;
struct node
{
  int v;
  link next;
};
struct graph
{
  int V;
  int E;
  link *adj;
};
struct queue
{
  int items[100000000];
  int front;
  int rear;
};
struct arrayofGrays
{
  int array[100000000];
  int count;
};
struct arrayofGrays visited;
queue createQueue();
void enqueue(queue q, int);
int dequeue(queue q);
int isEmpty(queue q);
Graph GRAPHinit(int V);
void GRAPHcreate(Graph G);
void insertE(link *head, int v);
void insertExy(link *head, int x, int y);
void deleteE(link *head, int v);
void EdmondsKarp(Graph G);
int bfs(Graph G);
void paintGray();
void getMN();
void getSC();
void getSsCs(Graph G);
int main()
{
  Graph G;
  getMN();
  getSC();
  G = GRAPHinit((M * N) + 2);
  GRAPHcreate(G);
  getSsCs(G);
  EdmondsKarp(G);
  return 0;
}

void EdmondsKarp(Graph G)
{
  int i;
  int f = 0;
  while (bfs(G) == 1)
  {
    i = G->V - 1;
    while (p[i] >= 0)
    {
      if (i != (G->V - 1))
      {
        deleteE(&G->adj[p[i]], i);
        visited.array[visited.count] = i;
        visited.count++;
      }
      else
      {
        
      }

      i = p[i];
    }

    f++;
  }

  printf("%d\n", f);
}

int bfs(Graph G)
{
  int u = 0;
  int v = 0;
  link a;
  struct queue *q = createQueue();
  for (u = 1; u < G->V; u++)
  {
    color[u] = White;
    p[u] = -1;
  }

  paintGray();
  u = 0;
  color[0] = Gray;
  p[0] = -1;
  enqueue(q, 0);
  while (!isEmpty(q))
  {
    u = dequeue(q);
    for (a = G->adj[u]; a != 0; a = a->next)
    {
      v = a->v;
      if (color[v] == White)
      {
        color[v] = Gray;
        p[v] = u;
        enqueue(q, v);
      }
      else
      {
        
      }

    }

    color[u] = Black;
  }

  return color[(M * N) + 1] == Black;
}

void paintGray()
{
  int i;
  if (visited.count == 0)
  {
    return;
  }
  else
  {
    
  }

  if (visited.count != 0)
  {
    for (i = 0; i < visited.count; i++)
      color[visited.array[i]] = Gray;

  }
  else
  {
    
  }

}

void getMN()
{
  M = new_sym_var(sizeof(int) * 8);
  N = new_sym_var(sizeof(int) * 8);
}

void getSC()
{
  S = new_sym_var(sizeof(int) * 8);
  C = new_sym_var(sizeof(int) * 8);
}

void getSsCs(Graph G)
{
  int i;
  int v;
  int x;
  int y;
  for (i = 0; i < S; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    v = ((x - 1) * N) + y;
    insertE(&G->adj[v], (M * N) + 1);
  }

  for (i = 0; i < C; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    v = ((x - 1) * N) + y;
    insertE(&G->adj[0], v);
  }

}

Graph GRAPHinit(int V)
{
  int v;
  Graph G = malloc(sizeof(struct graph));
  G->V = V;
  G->E = 0;
  G->adj = malloc(V * (sizeof(link)));
  for (v = 0; v < V; v++)
    G->adj[v] = 0;

  return G;
}

void GRAPHcreate(Graph G)
{
  int i = 0;
  int x = 0;
  int y = 0;
  for (i = 0; i < ((M * N) + 2); i++)
    insertE(&G->adj[i], i);

  i = 1;
  for (x = 1; x <= M; x++)
    for (y = 1; y <= N; y++)
  {
    if (x == 1)
    {
      if (y == 1)
      {
        insertExy(&G->adj[i], x, y + 1);
        insertExy(&G->adj[i], x + 1, y);
      }
      else
      {
        
      }

      if ((y != 1) && (y != N))
      {
        insertExy(&G->adj[i], x, y - 1);
        insertExy(&G->adj[i], x, y + 1);
        insertExy(&G->adj[i], x + 1, y);
      }
      else
      {
        
      }

      if (y == N)
      {
        insertExy(&G->adj[i], x, y - 1);
        insertExy(&G->adj[i], x + 1, y);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    if ((x != 1) && (x != M))
    {
      if (y == 1)
      {
        insertExy(&G->adj[i], x - 1, y);
        insertExy(&G->adj[i], x, y + 1);
        insertExy(&G->adj[i], x + 1, y);
      }
      else
      {
        
      }

      if ((y != 1) && (y != N))
      {
        insertExy(&G->adj[i], x - 1, y);
        insertExy(&G->adj[i], x, y - 1);
        insertExy(&G->adj[i], x, y + 1);
        insertExy(&G->adj[i], x + 1, y);
      }
      else
      {
        
      }

      if (y == N)
      {
        insertExy(&G->adj[i], x - 1, y);
        insertExy(&G->adj[i], x, y - 1);
        insertExy(&G->adj[i], x + 1, y);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    if (x == M)
    {
      if (y == 1)
      {
        insertExy(&G->adj[i], x - 1, y);
        insertExy(&G->adj[i], x, y + 1);
      }
      else
      {
        
      }

      if ((y != 1) && (y != N))
      {
        insertExy(&G->adj[i], x - 1, y);
        insertExy(&G->adj[i], x, y - 1);
        insertExy(&G->adj[i], x, y + 1);
      }
      else
      {
        
      }

      if (y == N)
      {
        insertExy(&G->adj[i], x - 1, y);
        insertExy(&G->adj[i], x, y - 1);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    i++;
  }


}

void insertE(link *head, int v)
{
  link a = (link) malloc(sizeof(struct node));
  link last = *head;
  a->v = v;
  a->next = 0;
  if ((*head) == 0)
  {
    *head = a;
    return;
  }
  else
  {
    
  }

  while (last->next != 0)
    last = last->next;

  last->next = a;
  return;
}

void insertExy(link *head, int x, int y)
{
  int v;
  link a = (link) malloc(sizeof(struct node));
  link last = *head;
  v = ((x - 1) * N) + y;
  a->v = v;
  a->next = 0;
  if ((*head) == 0)
  {
    *head = a;
    return;
  }
  else
  {
    
  }

  while (last->next != 0)
    last = last->next;

  last->next = a;
  return;
}

void deleteE(struct node **head, int v)
{
  struct node *temp = *head;
  struct node *prev;
  if ((temp != 0) && (temp->v == v))
  {
    *head = temp->next;
    free(temp);
    return;
  }
  else
  {
    
  }

  while ((temp != 0) && (temp->v != v))
  {
    prev = temp;
    temp = temp->next;
  }

  if (temp == 0)
  {
    return;
  }
  else
  {
    
  }

  prev->next = temp->next;
  free(temp);
}

struct queue *createQueue()
{
  struct queue *q = malloc(sizeof(struct queue));
  q->front = -1;
  q->rear = -1;
  return q;
}

int isEmpty(struct queue *q)
{
  if (q->rear == (-1))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

void enqueue(struct queue *q, int value)
{
  if (q->rear == (10000000 - 1))
  {
    return;
  }
  else
  {
    if (q->front == (-1))
    {
      q->front = 0;
    }
    else
    {
      
    }

    q->rear++;
    q->items[q->rear] = value;
  }

}

int dequeue(struct queue *q)
{
  int item;
  if (isEmpty(q))
  {
    item = -1;
  }
  else
  {
    item = q->items[q->front];
    q->front++;
    if (q->front > q->rear)
    {
      q->front = (q->rear = -1);
    }
    else
    {
      
    }

  }

  return item;
}

