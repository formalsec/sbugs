#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stdio.h>


typedef struct Link
{
  struct Arco *arc;
  struct Link *next;
} *link;
typedef struct Arco
{
  struct Cruzamento *dest;
  short int fluxo;
  struct Arco *oposto;
} *arco;
typedef struct Cruzamento
{
  int av;
  int rua;
  short int cidadao;
  short int superm;
  short int ocupado;
  short int temCaminho;
  short int visited;
  struct Link *adj;
} *cruz;
arco newArco(cruz c);
void addArco(cruz c, arco a);
void fordFulkerson(cruz source, cruz target, cruz **cruzamentos, int m, int n);
int dfsVisit(arco a);
arco newArco(cruz c)
{
  arco new = (arco) malloc(sizeof(struct Arco));
  new->dest = c;
  new->fluxo = 0;
  return new;
}

void addArco(cruz orig, arco a)
{
  link new = (link) malloc(sizeof(struct Link));
  new->arc = a;
  new->next = orig->adj;
  orig->adj = new;
}

void fordFulkerson(cruz source, cruz target, cruz **cruzamentos, int m, int n)
{
  link link_cid = source->adj;
  int i;
  int j;
  int fluxo = 0;
  short int hasPath;
  while (link_cid != 0)
  {
    hasPath = 0;
    source->visited = 0;
    target->visited = 0;
    for (i = 0; i < m; i++)
    {
      for (j = 0; j < n; j++)
      {
        cruzamentos[i][j]->visited = 0;
      }

    }

    hasPath = dfsVisit(link_cid->arc);
    if (hasPath == 1)
    {
      link_cid->arc->dest->temCaminho = 1;
    }
    else
    {
      
    }

    link_cid = link_cid->next;
  }

  link_cid = source->adj;
  while (link_cid != 0)
  {
    fluxo += link_cid->arc->dest->temCaminho;
    link_cid = link_cid->next;
  }

  printf("%d\n", fluxo);
}

int dfsVisit(arco a)
{
  cruz c = a->dest;
  cruz viz;
  link adj = c->adj;
  short int suc;
  c->visited = 1;
  if (c->av == (-2))
  {
    return 1;
  }
  else
  {
    
  }

  while (adj != 0)
  {
    viz = adj->arc->dest;
    if (((viz->visited == 0) && ((viz->cidadao == 0) || (adj->arc->oposto->fluxo == 1))) && (adj->arc->fluxo == 0))
    {
      suc = dfsVisit(adj->arc);
      if (suc == 1)
      {
        c->ocupado = 1;
        adj->arc->fluxo = 1;
        if ((adj->arc->oposto != 0) && (adj->arc->oposto->fluxo == 1))
        {
          adj->arc->oposto->fluxo = 0;
          adj->arc->fluxo = 0;
        }
        else
        {
          
        }

        return 1;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    adj = adj->next;
  }

  return 0;
}

int main(int argc, char *argv[])
{
  int i;
  int j;
  int m;
  int n;
  int s;
  int c;
  int aven;
  int rua;
  cruz **cruzamentos;
  cruz source;
  cruz target;
  arco arcN;
  arco arcS;
  arco arcE;
  arco arcO;
  link lfrees;
  link laux;
  m = new_sym_var(sizeof(int) * 8);
  n = new_sym_var(sizeof(int) * 8);
  cruzamentos = (cruz **) malloc((sizeof(cruz *)) * m);
  for (i = 0; i < m; i++)
  {
    cruzamentos[i] = (cruz *) malloc((sizeof(cruz)) * n);
    for (j = 0; j < n; j++)
    {
      cruzamentos[i][j] = (cruz) malloc(sizeof(struct Cruzamento));
      cruzamentos[i][j]->cidadao = 0;
      cruzamentos[i][j]->superm = 0;
      cruzamentos[i][j]->av = i;
      cruzamentos[i][j]->rua = j;
      cruzamentos[i][j]->ocupado = 0;
      cruzamentos[i][j]->temCaminho = 0;
    }

  }

  source = (cruz) malloc(sizeof(struct Cruzamento));
  source->av = -1;
  source->rua = -1;
  target = (cruz) malloc(sizeof(struct Cruzamento));
  target->av = -2;
  target->rua = -2;
  s = new_sym_var(sizeof(int) * 8);
  c = new_sym_var(sizeof(int) * 8);
  for (i = 0; i < s; i++)
  {
    aven = new_sym_var(sizeof(int) * 8);
    rua = new_sym_var(sizeof(int) * 8);
    cruzamentos[aven - 1][rua - 1]->superm = 1;
    arcO = newArco(target);
    arcE = newArco(cruzamentos[aven - 1][rua - 1]);
    addArco(cruzamentos[aven - 1][rua - 1], arcO);
    addArco(target, arcE);
    arcE->oposto = arcO;
    arcO->oposto = arcE;
  }

  for (i = 0; i < c; i++)
  {
    aven = new_sym_var(sizeof(int) * 8);
    rua = new_sym_var(sizeof(int) * 8);
    cruzamentos[aven - 1][rua - 1]->cidadao = 1;
    arcO = newArco(cruzamentos[aven - 1][rua - 1]);
    addArco(source, arcO);
  }

  for (i = 0; i < m; i++)
  {
    for (j = 0; j < n; j++)
    {
      arcN = 0;
      arcS = 0;
      arcE = 0;
      arcO = 0;
      if (i < (m - 1))
      {
        arcE = newArco(cruzamentos[i + 1][j]);
        addArco(cruzamentos[i][j], arcE);
        arcO = newArco(cruzamentos[i][j]);
        addArco(cruzamentos[i + 1][j], arcO);
      }
      else
      {
        
      }

      if (j < (n - 1))
      {
        arcS = newArco(cruzamentos[i][j + 1]);
        addArco(cruzamentos[i][j], arcS);
        arcN = newArco(cruzamentos[i][j]);
        addArco(cruzamentos[i][j + 1], arcN);
      }
      else
      {
        
      }

      if (arcN != 0)
      {
        arcN->oposto = arcS;
      }
      else
      {
        
      }

      if (arcS != 0)
      {
        arcS->oposto = arcN;
      }
      else
      {
        
      }

      if (arcE != 0)
      {
        arcE->oposto = arcO;
      }
      else
      {
        
      }

      if (arcO != 0)
      {
        arcO->oposto = arcE;
      }
      else
      {
        
      }

    }

  }

  fordFulkerson(source, target, cruzamentos, m, n);
  for (i = 0; i < m; i++)
  {
    for (j = 0; j < n; j++)
    {
      lfrees = cruzamentos[i][j]->adj;
      while (lfrees != 0)
      {
        laux = lfrees->next;
        free(lfrees->arc);
        free(lfrees);
        lfrees = laux;
      }

      free(cruzamentos[i][j]);
    }

    free(cruzamentos[i]);
  }

  free(cruzamentos);
  lfrees = source->adj;
  while (lfrees != 0)
  {
    laux = lfrees->next;
    free(lfrees->arc);
    free(lfrees);
    lfrees = laux;
  }

  free(source);
  lfrees = target->adj;
  while (lfrees != 0)
  {
    laux = lfrees->next;
    free(lfrees->arc);
    free(lfrees);
    lfrees = laux;
  }

  free(target);
  return 0;
}

