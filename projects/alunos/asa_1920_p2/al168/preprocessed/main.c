#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


enum Vertex_State
{
  UNVISITED,
  VISITED,
  CLOSED
};
typedef struct Node
{
  void *content;
  struct Node *next;
} node;
typedef struct Edge
{
  int flow;
  int to_id;
} edg;
typedef struct Vertex
{
  int id;
  node *edges;
  enum Vertex_State state;
} vtx;
typedef struct Graph
{
  int n;
  int m;
  vtx **vertices;
  vtx *source;
  vtx *sink;
} gph;
gph *graph;
node *new_node(void *e)
{
  node *n = (node *) malloc(sizeof(struct Node));
  n->content = e;
  n->next = 0;
  return n;
}

void add_node(node **head, node *node)
{
  if ((*head) == 0)
  {
    *head = node;
  }
  else
  {
    node->next = *head;
    *head = node;
  }

}

void free_list(node *head)
{
  node *tmp;
  node *n = head;
  while (n != 0)
  {
    tmp = n;
    n = n->next;
    free(tmp->content);
    free(tmp);
  }

}

vtx *new_vertex(int id)
{
  vtx *v = (vtx *) malloc(sizeof(struct Vertex));
  v->id = id;
  v->edges = 0;
  v->state = UNVISITED;
  return v;
}

edg *new_edge(int id, int flow)
{
  edg *e = malloc(sizeof(struct Edge));
  e->flow = flow;
  e->to_id = id;
  return e;
}

void add_edge(vtx *v, edg *e)
{
  add_node(&v->edges, new_node((void *) e));
}

void connect_source(gph *g, int id)
{
  add_edge(g->source, new_edge(id, 0));
  add_edge(g->vertices[id], new_edge(g->source->id, 1));
}

void connect_sink(gph *g, int id)
{
  add_edge(g->vertices[id], new_edge(g->sink->id, 0));
}

void free_vertex(vtx *v)
{
  free_list(v->edges);
  free(v);
}

void free_graph(gph *g)
{
  int i;
  int n = (2 * g->n) * g->m;
  for (i = 0; i < n; i++)
    free_vertex(g->vertices[i]);

  free(g->sink);
  free(g->source);
  free(g);
}

gph *new_graph(int n, int m)
{
  gph *g = malloc(sizeof(struct Graph));
  int id_1;
  int id_2;
  int i;
  int j;
  g->m = m;
  g->n = n;
  g->vertices = malloc((sizeof(struct Vertex *)) * (((2 * n) * m) + 2));
  for (i = 1; i <= n; i++)
  {
    for (j = 1; j <= m; j++)
    {
      id_1 = ((2 * (j - 1)) + ((i - 1) * (2 * m))) + 0;
      id_2 = ((2 * (j - 1)) + ((i - 1) * (2 * m))) + 1;
      g->vertices[id_1] = new_vertex(id_1);
      g->vertices[id_2] = new_vertex(id_2);
      add_edge(g->vertices[id_1], new_edge(id_2, 0));
      add_edge(g->vertices[id_2], new_edge(id_1, 1));
      if (j != 1)
      {
        add_edge(g->vertices[id_2], new_edge(((2 * ((j - 1) - 1)) + ((i - 1) * (2 * m))) + 0, 0));
        add_edge(g->vertices[id_1], new_edge(((2 * ((j - 1) - 1)) + ((i - 1) * (2 * m))) + 1, 1));
      }
      else
      {
        
      }

      if (j != m)
      {
        add_edge(g->vertices[id_1], new_edge(((2 * ((j + 1) - 1)) + ((i - 1) * (2 * m))) + 1, 1));
        add_edge(g->vertices[id_2], new_edge(((2 * ((j + 1) - 1)) + ((i - 1) * (2 * m))) + 0, 0));
      }
      else
      {
        
      }

      if (i != 1)
      {
        add_edge(g->vertices[id_1], new_edge(((2 * (j - 1)) + (((i - 1) - 1) * (2 * m))) + 1, 1));
        add_edge(g->vertices[id_2], new_edge(((2 * (j - 1)) + (((i - 1) - 1) * (2 * m))) + 0, 0));
      }
      else
      {
        
      }

      if (i != n)
      {
        add_edge(g->vertices[id_1], new_edge(((2 * (j - 1)) + (((i + 1) - 1) * (2 * m))) + 1, 1));
        add_edge(g->vertices[id_2], new_edge(((2 * (j - 1)) + (((i + 1) - 1) * (2 * m))) + 0, 0));
      }
      else
      {
        
      }

    }

  }

  id_1 = (2 * n) * m;
  id_2 = ((2 * n) * m) + 1;
  g->sink = new_vertex(id_1);
  g->source = new_vertex(id_2);
  g->vertices[id_1] = g->sink;
  g->vertices[id_2] = g->source;
  return g;
}

int is_head(vtx *v, int id)
{
  edg *e = (edg *) v->edges->content;
  if ((e != 0) && (e->to_id == id))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

void empty_residual_edge(vtx *vertex, int id)
{
  node *node;
  for (node = vertex->edges; node != 0; node = node->next)
  {
    edg *edge = (edg *) node->content;
    if (edge->to_id == id)
    {
      edge->flow = 0;
    }
    else
    {
      
    }

  }

}

int dfs(vtx *source, vtx *sink)
{
  node *node;
  if (source->id == sink->id)
  {
    return 1;
  }
  else
  {
    if (source->state == VISITED)
    {
      return 0;
    }
    else
    {
      
    }

    source->state = VISITED;
    for (node = source->edges; node != 0; node = node->next)
    {
      edg *edge = (edg *) node->content;
      if (edge->flow == 0)
      {
        vtx *next_vtx = graph->vertices[edge->to_id];
        if (dfs(next_vtx, sink))
        {
          edge->flow = 1;
          empty_residual_edge(next_vtx, source->id);
          return 1;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  return 0;
}

int ford_fulkerson(int max_flow, int n, int m)
{
  int i;
  int flow = 0;
  while (dfs(graph->source, graph->sink))
  {
    flow++;
    if (flow == max_flow)
    {
      return flow;
    }
    else
    {
      
    }

    graph->source->state = UNVISITED;
    for (i = 0; i < ((2 * n) * m); i++)
      graph->vertices[i]->state = UNVISITED;

  }

  return flow;
}

int main()
{
  int n;
  int m;
  int s;
  int c;
  int i;
  int id;
  int lin;
  int col;
  m = new_sym_var(sizeof(int) * 8);
  n = new_sym_var(sizeof(int) * 8);
  s = new_sym_var(sizeof(int) * 8);
  c = new_sym_var(sizeof(int) * 8);
  if ((((m == 0) || (n == 0)) || (s == 0)) || (c == 0))
  {
    printf("0\n");
    return 0;
  }
  else
  {
    
  }

  graph = new_graph(n, m);
  for (i = 0; i < s; i++)
  {
    col = new_sym_var(sizeof(int) * 8);
    lin = new_sym_var(sizeof(int) * 8);
    id = ((2 * (col - 1)) + ((lin - 1) * (2 * m))) + 1;
    if (!is_head(graph->vertices[id], graph->sink->id))
    {
      connect_sink(graph, id);
    }
    else
    {
      
    }

  }

  for (i = 0; i < c; i++)
  {
    col = new_sym_var(sizeof(int) * 8);
    lin = new_sym_var(sizeof(int) * 8);
    id = ((2 * (col - 1)) + ((lin - 1) * (2 * m))) + 0;
    if (!is_head(graph->vertices[id], graph->source->id))
    {
      connect_source(graph, id);
    }
    else
    {
      
    }

  }

  printf("%d\n", ford_fulkerson((s < c) ? (s) : (c), n, m));
  free_graph(graph);
  return 0;
}

