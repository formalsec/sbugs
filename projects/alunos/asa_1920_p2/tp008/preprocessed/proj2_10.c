/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct edge
{
  int origin;
  int destination;
  int capacity;
  int flow;
  struct edge *next;
} edge_t;
typedef struct intersection
{
  int id;
  edge_t *roads;
  int visited;
  int pi;
} intersection_t;
int N;
int M;
int S;
int C;
edge_t **supermarkets;
edge_t **citizens;
edge_t **path;
int path_ptr;
int *q;
int en_ptr;
int de_ptr;
void enqueue(int value)
{
  q[en_ptr++] = value;
}

int dequeue()
{
  return q[de_ptr++];
}

int getid(int avenue, int street, int in)
{
  if (in)
  {
    return ((street - 1) * M) + avenue;
  }
  else
  {
    
  }

  return (((street - 1) * M) + avenue) + (N * M);
}

edge_t *create_road(int origin, int destination, intersection_t *city, int capacity)
{
  edge_t *new_road;
  new_road = (edge_t *) malloc(sizeof(edge_t));
  new_road->origin = origin;
  new_road->destination = destination;
  new_road->capacity = capacity;
  new_road->flow = 0;
  new_road->next = city[origin].roads;
  city[origin].roads = new_road;
  return new_road;
}

edge_t *create_supermarket(int avenue, int street, intersection_t *city)
{
  create_road(getid(avenue, street, 0), ((M * N) * 2) + 1, city, 1);
  return create_road(((M * N) * 2) + 1, getid(avenue, street, 0), city, 0);
}

edge_t *create_citizen(int avenue, int street, intersection_t *city)
{
  create_road(getid(avenue, street, 1), 0, city, 0);
  return create_road(0, getid(avenue, street, 1), city, 1);
}

edge_t *find_edge(int origin, int destination, intersection_t *city)
{
  edge_t *edge;
  if (origin == 0)
  {
    return citizens[destination];
  }
  else
  {
    if (origin == (((M * N) * 2) + 1))
    {
      return supermarkets[destination];
    }
    else
    {
      
    }

  }

  for (edge = city[origin].roads; edge; edge = edge->next)
    if (edge->destination == destination)
  {
    return edge;
  }
  else
  {
    
  }


  return 0;
}

edge_t *find_inverse(edge_t *edge, intersection_t *city)
{
  int u;
  int v;
  u = edge->origin;
  v = edge->destination;
  return find_edge(v, u, city);
}

intersection_t *create_city(int total)
{
  intersection_t *city = (intersection_t *) malloc((total + 2) * (sizeof(intersection_t)));
  int i;
  for (i = 0; i < (total + 2); i++)
  {
    city[i].id = i;
    city[i].roads = 0;
  }

  for (i = 1; i <= (total / 2); i++)
  {
    create_road(i, (total / 2) + i, city, 1);
    create_road((total / 2) + i, i, city, 0);
  }

  for (i = (total / 2) + 1; i <= total; i++)
  {
    if ((i % M) != 0)
    {
      create_road(i, (i - (total / 2)) + 1, city, 1);
      create_road((i - (total / 2)) + 1, i, city, 0);
    }
    else
    {
      
    }

    if (((i % M) != 1) && (N != 1))
    {
      create_road(i, (i - (total / 2)) - 1, city, 1);
      create_road((i - (total / 2)) - 1, i, city, 0);
    }
    else
    {
      
    }

    if (((i - (total / 2)) - M) > 0)
    {
      create_road(i, (i - (total / 2)) - M, city, 1);
      create_road((i - (total / 2)) - M, i, city, 0);
    }
    else
    {
      
    }

    if (((i - (total / 2)) + M) <= (total / 2))
    {
      create_road(i, (i - (total / 2)) + M, city, 1);
      create_road((i - (total / 2)) + M, i, city, 0);
    }
    else
    {
      
    }

  }

  return city;
}

void destroy_city(intersection_t *city)
{
  int i;
  edge_t *edge;
  edge_t *aux;
  for (i = 0; i < (((M * N) * 2) + 2); i++)
  {
    for (edge = city[i].roads; edge;)
    {
      aux = edge->next;
      free(edge);
      edge = aux;
    }

  }

  free(city);
}

edge_t **increase_path(intersection_t *city, edge_t **path)
{
  int i;
  int v;
  int u;
  edge_t *edge;
  path_ptr = 0;
  en_ptr = 0;
  de_ptr = 0;
  city[0].visited = 1;
  city[0].pi = -1;
  for (i = 1; i <= (((M * N) * 2) + 1); i++)
  {
    city[i].visited = 0;
    city[i].pi = -1;
  }

  enqueue(0);
  while (de_ptr < en_ptr)
  {
    u = dequeue();
    for (edge = city[u].roads; edge; edge = edge->next)
    {
      v = edge->destination;
      if ((v == (((M * N) * 2) + 1)) && (edge->capacity > edge->flow))
      {
        while (u >= 0)
        {
          path[path_ptr++] = find_edge(u, v, city);
          v = u;
          u = city[u].pi;
        }

        path[path_ptr] = find_edge(0, v, city);
        path[path_ptr + 1] = 0;
        while (de_ptr < en_ptr)
          dequeue();

        return path;
      }
      else
      {
        
      }

      if ((city[v].visited == 0) && (edge->capacity > edge->flow))
      {
        city[v].visited = 1;
        city[v].pi = u;
        enqueue(v);
      }
      else
      {
        
      }

    }

  }

  return 0;
}

int edmonds_karp(intersection_t *city)
{
  edge_t **path;
  edge_t *pathinv;
  int i;
  int flow = 0;
  q = malloc((sizeof(int)) * (((2 * M) * N) + 1));
  for (i = 0; i < (((2 * M) * N) + 1); i++)
    q[i] = -1;

  path = malloc((sizeof(edge_t *)) * (((2 * N) * M) + 1));
  while (path = increase_path(city, path))
  {
    for (i = 0; path[i]; i++)
    {
      path[i]->flow++;
      if (pathinv = find_inverse(path[i], city))
      {
        pathinv->flow = -path[i]->flow;
      }
      else
      {
        
      }

    }

    flow++;
  }

  free(path);
  free(q);
  return flow;
}

int main()
{
  int i;
  int total;
  int id;
  int avenue;
  int street;
  intersection_t *city;
  M = new_sym_var(sizeof(int) * 8);
  N = new_sym_var(sizeof(int) * 8);
  S = new_sym_var(sizeof(int) * 8);
  C = new_sym_var(sizeof(int) * 8);
  total = (2 * M) * N;
  city = create_city(total);
  supermarkets = malloc((sizeof(edge_t *)) * (total + 1));
  citizens = malloc((sizeof(edge_t *)) * (total + 1));
  for (i = 0; i < total; i++)
  {
    supermarkets[i] = 0;
    citizens[i] = 0;
  }

  for (i = 0; i < S; i++)
  {
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    id = getid(avenue, street, 1);
    if (!supermarkets[id])
    {
      supermarkets[id] = create_supermarket(avenue, street, city);
    }
    else
    {
      
    }

  }

  for (i = 0; i < C; i++)
  {
    avenue = new_sym_var(sizeof(int) * 8);
    street = new_sym_var(sizeof(int) * 8);
    id = getid(avenue, street, 1);
    if (!citizens[id])
    {
      citizens[id] = create_citizen(avenue, street, city);
    }
    else
    {
      
    }

  }

  printf("%d\n", edmonds_karp(city));
  free(supermarkets);
  free(citizens);
  destroy_city(city);
  return 0;
}

