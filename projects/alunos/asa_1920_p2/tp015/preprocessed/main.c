/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct Node
{
  int id;
  int flag_super;
  int flag_person;
  int source;
  int sink;
  struct Node **adjs;
  int numberAdj;
  int *cap;
} node;
typedef struct List
{
  struct Node *current;
  struct List *next;
  struct List *previous;
} list;
node **nodes = 0;
list *queue = 0;
int *color;
int *pi;
node *source = 0;
node *sink = 0;
int M;
int N;
int s;
int c;
void addList(node *nodeAdd)
{
  if (queue == 0)
  {
    queue = malloc(sizeof(list));
    queue->current = nodeAdd;
    queue->previous = queue;
    queue->next = 0;
  }
  else
  {
    list *toAdd = malloc(sizeof(list));
    list *last = queue->previous;
    toAdd->current = nodeAdd;
    toAdd->next = 0;
    toAdd->previous = last;
    last->next = toAdd;
    queue->previous = toAdd;
  }

}

void remove_list()
{
  list *aux = 0;
  if (queue->next != 0)
  {
    queue->next->previous = queue->previous;
    aux = queue->next;
    queue->next = 0;
    queue->previous = 0;
    free(queue);
    queue = aux;
  }
  else
  {
    free(queue);
    queue = 0;
  }

}

void initBfs()
{
  list *aux;
  memset(color, 0, (((N * M) * 2) + 2) * (sizeof(int)));
  memset(pi, 0, (((N * M) * 2) + 2) * (sizeof(int)));
  while (queue != 0)
  {
    aux = queue->next;
    free(queue);
    queue = aux;
  }

  queue = 0;
  addList(source);
}

int bfs()
{
  int i;
  initBfs();
  while (queue != 0)
  {
    node *aux = queue->current;
    remove_list();
    for (i = 0; i < aux->numberAdj; i++)
    {
      if ((color[aux->adjs[i]->id] == 0) && (aux->cap[i] > 0))
      {
        color[aux->adjs[i]->id] = 1;
        pi[aux->adjs[i]->id] = aux->id;
        if (aux->adjs[i] == sink)
        {
          return 1;
        }
        else
        {
          
        }

        addList(aux->adjs[i]);
      }
      else
      {
        
      }

    }

  }

  return 0;
}

int which_adj(node *current, node *adj)
{
  int i;
  for (i = 0; i < current->numberAdj; i++)
  {
    if (current->adjs[i]->id == adj->id)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int edmondsKarp()
{
  int maxFlow = 0;
  int last_pi = 0;
  while (1)
  {
    int flow = bfs();
    if ((flow == 0) || ((flow + maxFlow) == s))
    {
      maxFlow += flow;
      break;
    }
    else
    {
      
    }

    maxFlow += flow;
    node *currentNode = sink;
    node *previousNode = 0;
    while (currentNode != source)
    {
      if (pi[currentNode->id] == ((M * N) * 2))
      {
        previousNode = source;
      }
      else
      {
        previousNode = nodes[pi[currentNode->id]];
        last_pi = pi[currentNode->id];
      }

      int adj = which_adj(currentNode, previousNode);
      if (adj == (-1))
      {
        adj = currentNode->numberAdj;
        currentNode->adjs = realloc(currentNode->adjs, (sizeof(node *)) * (adj + 1));
        currentNode->cap = realloc(currentNode->cap, (sizeof(int)) * (adj + 1));
        currentNode->adjs[adj] = previousNode;
        currentNode->cap[adj] = 0;
        currentNode->numberAdj++;
      }
      else
      {
        
      }

      currentNode->cap[adj] = !currentNode->cap[adj];
      adj = which_adj(previousNode, currentNode);
      previousNode->cap[adj] = !previousNode->cap[adj];
      currentNode = previousNode;
    }

    int adj = which_adj(source, nodes[last_pi]);
    source->cap[adj] = !source->cap[adj];
  }

  return maxFlow;
}

void processInput()
{
  int i;
  int S;
  int C;
  int j;
  int m;
  int n;
  if (!2)
  {
    printf("Error");
  }
  else
  {
    m = new_sym_var(sizeof(int) * 8);
    n = new_sym_var(sizeof(int) * 8);
    
  }

  M = m;
  N = n;
  if (!2)
  {
    printf("Error");
  }
  else
  {
    S = new_sym_var(sizeof(int) * 8);
    C = new_sym_var(sizeof(int) * 8);
    
  }

  s = S;
  c = C;
  source = malloc(sizeof(node));
  source->flag_super = 0;
  source->flag_person = 0;
  source->numberAdj = 0;
  source->source = 1;
  source->sink = 0;
  source->id = (M * N) * 2;
  sink = malloc(sizeof(node));
  sink->flag_super = 0;
  sink->flag_person = 0;
  sink->numberAdj = 0;
  sink->source = 0;
  sink->sink = 1;
  sink->id = ((M * N) * 2) + 1;
  nodes = malloc((sizeof(node *)) * ((N * M) * 2));
  int id = 0;
  for (i = 0; i < ((N * M) * 2); i += 2)
  {
    for (j = 0; j < 2; j++)
    {
      nodes[i + j] = malloc(sizeof(node));
      nodes[i + j]->id = id++;
      nodes[i + j]->flag_super = 0;
      nodes[i + j]->flag_person = 0;
      nodes[i + j]->numberAdj = 0;
      nodes[i + j]->source = 0;
      nodes[i + j]->sink = 0;
    }

    nodes[i]->cap = malloc(sizeof(int));
    nodes[i]->adjs = malloc(sizeof(node *));
    nodes[i]->adjs[nodes[i]->numberAdj] = nodes[i + 1];
    nodes[i]->cap[0] = 1;
    nodes[i]->numberAdj++;
  }

  for (i = 1; i < ((N * M) * 2); i += 2)
  {
    if (((i % (2 * M)) - 3) >= 0)
    {
      nodes[i]->adjs = realloc(nodes[i]->adjs, (sizeof(node *)) * (nodes[i]->numberAdj + 1));
      nodes[i]->cap = realloc(nodes[i]->cap, (sizeof(int)) * (nodes[i]->numberAdj + 1));
      nodes[i]->adjs[nodes[i]->numberAdj] = nodes[i - 3];
      nodes[i]->cap[nodes[i]->numberAdj] = 1;
      nodes[i]->numberAdj++;
    }
    else
    {
      
    }

    if (((i % (2 * M)) + 1) < (2 * M))
    {
      nodes[i]->adjs = realloc(nodes[i]->adjs, (sizeof(node *)) * (nodes[i]->numberAdj + 1));
      nodes[i]->cap = realloc(nodes[i]->cap, (sizeof(int)) * (nodes[i]->numberAdj + 1));
      nodes[i]->adjs[nodes[i]->numberAdj] = nodes[i + 1];
      nodes[i]->cap[nodes[i]->numberAdj] = 1;
      nodes[i]->numberAdj++;
    }
    else
    {
      
    }

    if (((i - (2 * M)) - 1) >= 0)
    {
      nodes[i]->adjs = realloc(nodes[i]->adjs, (sizeof(node *)) * (nodes[i]->numberAdj + 1));
      nodes[i]->cap = realloc(nodes[i]->cap, (sizeof(int)) * (nodes[i]->numberAdj + 1));
      nodes[i]->adjs[nodes[i]->numberAdj] = nodes[(i - (2 * M)) - 1];
      nodes[i]->cap[nodes[i]->numberAdj] = 1;
      nodes[i]->numberAdj++;
    }
    else
    {
      
    }

    if (((i + (2 * M)) - 1) < ((M * N) * 2))
    {
      nodes[i]->adjs = realloc(nodes[i]->adjs, (sizeof(node *)) * (nodes[i]->numberAdj + 1));
      nodes[i]->cap = realloc(nodes[i]->cap, (sizeof(int)) * (nodes[i]->numberAdj + 1));
      nodes[i]->adjs[nodes[i]->numberAdj] = nodes[(i + (2 * M)) - 1];
      nodes[i]->cap[nodes[i]->numberAdj] = 1;
      nodes[i]->numberAdj++;
    }
    else
    {
      
    }

  }

  for (i = 0; i < S; i++)
  {
    int line;
    int column;
    if (!2)
    {
      printf("Error");
    }
    else
    {
      column = new_sym_var(sizeof(int) * 8);
      line = new_sym_var(sizeof(int) * 8);
      
    }

    int pos = (((--line) * M) * 2) + ((--column) * 2);
    if (!nodes[pos + 1]->flag_super)
    {
      nodes[pos + 1]->flag_super = 1;
      nodes[pos + 1]->adjs = realloc(nodes[pos + 1]->adjs, (sizeof(node *)) * (nodes[pos + 1]->numberAdj + 1));
      nodes[pos + 1]->cap = realloc(nodes[pos + 1]->cap, (sizeof(int)) * (nodes[pos + 1]->numberAdj + 1));
      nodes[pos + 1]->adjs[nodes[pos + 1]->numberAdj] = sink;
      nodes[pos + 1]->cap[nodes[pos + 1]->numberAdj] = 1;
      nodes[pos + 1]->numberAdj++;
    }
    else
    {
      
    }

  }

  for (i = 0; i < C; i++)
  {
    int line;
    int column;
    if (!2)
    {
      printf("Error");
    }
    else
    {
      column = new_sym_var(sizeof(int) * 8);
      line = new_sym_var(sizeof(int) * 8);
      
    }

    int pos = (((--line) * M) * 2) + ((--column) * 2);
    if (!nodes[pos]->flag_person)
    {
      nodes[pos]->flag_person = 1;
      if (source->numberAdj == 0)
      {
        source->adjs = malloc(sizeof(node *));
        source->cap = malloc(sizeof(int));
      }
      else
      {
        source->adjs = realloc(source->adjs, (sizeof(node *)) * (source->numberAdj + 1));
        source->cap = realloc(source->cap, (sizeof(int)) * (source->numberAdj + 1));
      }

      source->adjs[source->numberAdj] = nodes[pos];
      source->cap[source->numberAdj] = 1;
      source->numberAdj++;
    }
    else
    {
      
    }

  }

}

int main()
{
  processInput();
  color = malloc((sizeof(int)) * (((M * N) * 2) + 2));
  pi = malloc((sizeof(int)) * (((M * N) * 2) + 2));
  int i = edmondsKarp();
  printf("%d\n", i);
  return 0;
}

