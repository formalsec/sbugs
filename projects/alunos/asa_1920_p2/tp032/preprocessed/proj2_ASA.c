#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>


struct vertice
{
  int vIn;
  int capacity;
  int flow;
  int vOut[5];
};
int n;
int avenidas;
int numRuas;
int cidadaos;
int indVizinho = -1;
int color[10000];
int pred[10000];
int head;
int tail;
int q[10000 + 2];
void enqueue(int x)
{
  q[tail] = x;
  tail++;
  color[x] = 1;
}

int dequeue()
{
  int x = q[head];
  head++;
  color[x] = 2;
  return x;
}

void condicao(int viz, struct vertice lista[n + 2])
{
  int i;
  int preced;
  preced = pred[lista[indVizinho].vOut[viz]];
  for (i = 0; lista[preced].vOut[i] != 0; i++)
    ;

  if (i >= 2)
  {
    color[lista[indVizinho].vOut[viz]] = 0;
    pred[lista[indVizinho].vOut[viz]] = indVizinho;
  }
  else
  {
    
  }

}

int bfs(int start, int target, struct vertice lista[n + 2])
{
  int u;
  int v;
  for (u = 0; u <= (n + 1); u++)
  {
    color[u] = 0;
  }

  head = (tail = 0);
  enqueue(start);
  pred[start] = -1;
  while (head != tail)
  {
    u = dequeue();
    if (u == 0)
    {
      for (v = 0; v < cidadaos; v++)
      {
        indVizinho = lista[u].vOut[v];
        if ((color[indVizinho] == 0) && ((lista[indVizinho].capacity - lista[indVizinho].flow) > 0))
        {
          enqueue(indVizinho);
          pred[indVizinho] = u;
        }
        else
        {
          
        }

      }

    }
    else
    {
      for (v = 0; v < 5; v++)
      {
        indVizinho = lista[u].vOut[v];
        if ((indVizinho == (n + 1)) && ((lista[indVizinho].capacity - lista[indVizinho].flow) > 0))
        {
          pred[indVizinho] = u;
          return 1;
        }
        else
        {
          if ((color[indVizinho] == 0) && ((lista[indVizinho].capacity - lista[indVizinho].flow) > 0))
          {
            enqueue(indVizinho);
            pred[indVizinho] = u;
            if (lista[indVizinho].vOut[2] == 0)
            {
              if (lista[indVizinho].vOut[0] != u)
              {
                condicao(0, lista);
              }
              else
              {
                if (lista[indVizinho].vOut[1] != u)
                {
                  condicao(1, lista);
                }
                else
                {
                  
                }

              }

            }
            else
            {
              
            }

          }
          else
          {
            
          }

        }

      }

    }

  }

  return color[target] == 2;
}

int max_flow(int source, int sink, struct vertice lista[n + 2])
{
  int u;
  while (bfs(source, sink, lista))
  {
    for (u = n + 1; u >= 0; u = pred[u])
    {
      lista[u].flow += 1;
    }

  }

  return lista[sink].flow;
}

int calculaVertice(int avenida, int rua, int numRuas)
{
  return rua + ((avenida - 1) * numRuas);
}

void buildGraph(struct vertice lista[n + 2])
{
  int i;
  int j;
  int d;
  int supermercados;
  int avenida;
  int rua;
  int vert;
  supermercados = new_sym_var(sizeof(int) * 8);
  cidadaos = new_sym_var(sizeof(int) * 8);
  for (i = 0; i <= (n + 1); i++)
  {
    lista[i].vIn = i;
    lista[i].flow = 0;
    lista[i].capacity = 1;
    for (j = 0; j < 5; j++)
    {
      lista[i].vOut[j] = 0;
    }

  }

  lista[n + 1].vIn = n + 1;
  lista[n + 1].capacity = supermercados;
  for (i = 0; i < supermercados; i++)
  {
    avenida = new_sym_var(sizeof(int) * 8);
    rua = new_sym_var(sizeof(int) * 8);
    vert = calculaVertice(avenida, rua, numRuas);
    lista[vert].vOut[0] = n + 1;
  }

  lista[0].capacity = cidadaos;
  for (i = 0; i < cidadaos; i++)
  {
    avenida = new_sym_var(sizeof(int) * 8);
    rua = new_sym_var(sizeof(int) * 8);
    vert = calculaVertice(avenida, rua, numRuas);
    lista[0].vOut[i] = vert;
  }

  for (i = 1; i <= n; i++)
  {
    if ((i % numRuas) != 1)
    {
      d = i - 1;
      for (j = 0; lista[i].vOut[j] != 0; j++)
        ;

      lista[i].vOut[j] = d;
    }
    else
    {
      
    }

    if (i > numRuas)
    {
      d = i - numRuas;
      for (j = 0; lista[i].vOut[j] != 0; j++)
        ;

      lista[i].vOut[j] = d;
    }
    else
    {
      
    }

    if (i <= (n - numRuas))
    {
      d = i + numRuas;
      for (j = 0; lista[i].vOut[j] != 0; j++)
        ;

      lista[i].vOut[j] = d;
    }
    else
    {
      
    }

    if ((i % numRuas) != 0)
    {
      d = i + 1;
      for (j = 0; lista[i].vOut[j] != 0; j++)
        ;

      lista[i].vOut[j] = d;
    }
    else
    {
      
    }

  }

}

int main()
{
  avenidas = new_sym_var(sizeof(int) * 8);
  numRuas = new_sym_var(sizeof(int) * 8);
  n = avenidas * numRuas;
  struct vertice lista[n + 2];
  buildGraph(lista);
  int s = 0;
  int t = n + 1;
  printf("%d\n", max_flow(s, t, lista));
  return 0;
}

