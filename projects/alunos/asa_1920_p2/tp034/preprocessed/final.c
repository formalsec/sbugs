#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>


typedef struct Edge
{
  struct Edge *res;
  int dest;
  int ccap;
  int cap;
} edge;
typedef struct Node
{
  edge *edge;
  struct Node *next;
} node;
typedef struct List
{
  node *head;
} list;
typedef struct AdjList
{
  int n;
  list *lists;
} adjList;
typedef struct Graph
{
  int nClients;
  int nSupers;
  int nVertices;
  int nEdges;
  int m;
  int n;
  adjList *adjList;
} graph;
typedef struct Dfsdata
{
  adjList *adjList;
  int vertex;
  int flow;
  int *visited;
  int time;
} dfsData;
edge *createEdge(int dest, int cap)
{
  edge *newEdge = (edge *) malloc(sizeof(edge));
  newEdge->dest = dest;
  newEdge->cap = cap;
  newEdge->ccap = cap;
  return newEdge;
}

node *createNode(int dest, int cap)
{
  node *newNode = (node *) malloc(sizeof(node));
  edge *newEdge = createEdge(dest, cap);
  newNode->edge = newEdge;
  newNode->next = 0;
  return newNode;
}

adjList *createAdjList(int n)
{
  int i;
  adjList *newAdjList = (adjList *) malloc(sizeof(adjList));
  newAdjList->n = n;
  newAdjList->lists = (list *) malloc((sizeof(list)) * n);
  for (i = 0; i < n; i++)
  {
    newAdjList->lists[i].head = 0;
  }

  return newAdjList;
}

edge *addEdge(adjList *adjList, int origin, int dest, int cap)
{
  node *newNode = createNode(dest, cap);
  newNode->next = adjList->lists[origin].head;
  adjList->lists[origin].head = newNode;
  return newNode->edge;
}

void printAdjList(adjList *adjList)
{
  int v;
  for (v = 0; v < adjList->n; v++)
  {
    node *nodep = adjList->lists[v].head;
    while (nodep)
    {
      printf("  > [edge: (%d->%d) | capacity: %d/%d c: %d]\n", v, nodep->edge->dest, nodep->edge->res->ccap, nodep->edge->cap, nodep->edge->ccap);
      nodep = nodep->next;
    }

    printf("\n");
  }

}

graph *createGraph(int f, int e, int m, int n)
{
  graph *newGraph = (graph *) malloc(sizeof(graph));
  newGraph->nClients = f;
  newGraph->nSupers = e;
  newGraph->nVertices = (m * n) + 2;
  newGraph->nEdges = (((((2 * m) * n) - m) - n) + f) + e;
  return newGraph;
}

graph *parseInput()
{
  int m;
  int n;
  int c;
  int su;
  int i;
  int e;
  int s;
  int x;
  int y;
  graph *graph;
  adjList *adjList;
  edge *e1;
  edge *e2;
  m = new_sym_var(sizeof(int) * 8);
  n = new_sym_var(sizeof(int) * 8);
  su = new_sym_var(sizeof(int) * 8);
  c = new_sym_var(sizeof(int) * 8);
  graph = createGraph(c, su, m, n);
  adjList = createAdjList(graph->nVertices);
  for (i = 1; i < (graph->nVertices - 1); i++)
  {
    e = i + 1;
    s = i + m;
    if (i % m)
    {
      e1 = addEdge(adjList, i, e, 1);
      e2 = addEdge(adjList, e, i, 1);
      e1->res = e2;
      e2->res = e1;
    }
    else
    {
      
    }

    if (s < (graph->nVertices - 1))
    {
      e1 = addEdge(adjList, i, s, 1);
      e2 = addEdge(adjList, s, i, 1);
      e1->res = e2;
      e2->res = e1;
    }
    else
    {
      
    }

  }

  for (i = 0; i < su; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    e1 = addEdge(adjList, x + ((y - 1) * m), graph->nVertices - 1, 1);
    e2 = addEdge(adjList, graph->nVertices - 1, x + ((y - 1) * m), 0);
    e1->res = e2;
    e2->res = e1;
  }

  for (i = 0; i < c; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    e1 = addEdge(adjList, 0, x + ((y - 1) * m), 1);
    e2 = addEdge(adjList, x + ((y - 1) * m), 0, 0);
    e1->res = e2;
    e2->res = e1;
  }

  graph->adjList = adjList;
  return graph;
}

int dfsFF(dfsData *data, int sink)
{
  adjList *adjList = data->adjList;
  int vertex = data->vertex;
  int flow = data->flow;
  int *visited = data->visited;
  int time = data->time;
  int dfsFlow = 0;
  node *nodep = adjList->lists[vertex].head;
  if (vertex == sink)
  {
    return flow;
  }
  else
  {
    
  }

  visited[vertex] = time;
  while (nodep)
  {
    edge *edgep = nodep->edge;
    edge *resEdgep = edgep->res;
    if (((visited[edgep->dest] != time) && (edgep->ccap > 0)) && (visited[edgep->dest] != (-1)))
    {
      if (edgep->ccap < flow)
      {
        data->flow = edgep->ccap;
      }
      else
      {
        
      }

      data->vertex = edgep->dest;
      dfsFlow = dfsFF(data, sink);
      if (dfsFlow > 0)
      {
        edgep->ccap -= dfsFlow;
        resEdgep->ccap += dfsFlow;
        return dfsFlow;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    nodep = nodep->next;
  }

  return 0;
}

void fordFulkerson(graph *graph)
{
  dfsData *data = (dfsData *) malloc(sizeof(dfsData));
  int flow = 0;
  int maxFlow = 0;
  int time = 1;
  int visited[graph->nVertices];
  data->adjList = graph->adjList;
  data->visited = visited;
  do
  {
    data->vertex = 0;
    data->flow = 32767;
    data->time = time;
    flow = dfsFF(data, graph->nVertices - 1);
    maxFlow += flow;
    time++;
  }
  while (flow != 0);
  printf("%d\n", maxFlow);
}

int main()
{
  graph *graph;
  graph = parseInput();
  fordFulkerson(graph);
  return 0;
}

