#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct node
{
  int n;
  struct node *next;
} *Node;
typedef struct vertex
{
  int pos;
  int color;
  int pi;
  Node first;
  Node tail;
} *Vertex;
typedef struct queue
{
  int data;
  struct queue *next;
} *Queue;
Queue rear;
Queue front;
unsigned int size;
int *res;
int convertCoor(int x, int y, int width)
{
  return x + (y * width);
}

int isEmpty()
{
  return size <= 0;
}

void enqueue(int data)
{
  Queue newNode = 0;
  newNode = (Queue) malloc(sizeof(struct queue));
  newNode->data = data;
  newNode->next = 0;
  if (rear)
  {
    rear->next = newNode;
  }
  else
  {
    
  }

  rear = newNode;
  if (!front)
  {
    front = rear;
  }
  else
  {
    
  }

  size++;
}

int dequeue()
{
  Queue toDequque = 0;
  int data;
  if (isEmpty())
  {
    return -1;
  }
  else
  {
    
  }

  toDequque = front;
  data = toDequque->data;
  front = front->next;
  size--;
  free(toDequque);
  return data;
}

int BFS(Vertex *graph, int N, int v, int sink)
{
  int i;
  int popped;
  Node aux;
  int foundPath = 0;
  for (i = 0; i < N; i++)
  {
    if (graph[i]->color == 2)
    {
    }
    else
    {
      graph[i]->color = 1;
      graph[i]->pi = -1;
    }

  }

  graph[i]->color = 1;
  graph[i]->pi = -1;
  graph[i + 1]->color = 1;
  graph[i + 1]->pi = -1;
  graph[v]->color = 0;
  graph[v]->pi = -1;
  enqueue(v);
  while (!isEmpty())
  {
    popped = dequeue();
    for (aux = graph[popped]->first; aux != 0; aux = aux->next)
    {
      if ((graph[aux->n]->color == 1) && (res[convertCoor(popped, aux->n, N + 2)] > 0))
      {
        graph[aux->n]->color = 0;
        graph[aux->n]->pi = popped;
        enqueue(aux->n);
        if (graph[aux->n]->pos == graph[sink]->pos)
        {
          foundPath = 1;
          break;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (aux != 0)
    {
      graph[aux->n]->color = -1;
    }
    else
    {
      
    }

  }

  return foundPath;
}

int maxFlow(Vertex *graph, int source, int sink, int N)
{
  Vertex v;
  int u;
  int maxFlow = 0;
  while (BFS(graph, N, source, sink))
  {
    int flow = 999;
    v = graph[sink];
    while (v->pos != source)
    {
      v->color = 2;
      u = v->pi;
      if (flow > res[convertCoor(u, v->pos, N + 2)])
      {
        flow = res[convertCoor(u, v->pos, N + 2)];
      }
      else
      {
        
      }

      v = graph[u];
    }

    graph[source]->color = 2;
    maxFlow += flow;
    v = graph[sink];
    while (v->pos != source)
    {
      u = v->pi;
      res[convertCoor(u, v->pos, N + 2)] -= flow;
      res[convertCoor(v->pos, u, N + 2)] += flow;
      v = graph[u];
    }

  }

  return maxFlow;
}

Vertex newVertex(int pos)
{
  Vertex v = (Vertex) malloc(sizeof(struct vertex));
  v->color = 1;
  v->pi = -1;
  v->pos = pos;
  v->first = 0;
  v->tail = 0;
  return v;
}

Node newNode(int pos)
{
  Node new = (Node) malloc(sizeof(struct node));
  new->n = pos;
  new->next = 0;
  return new;
}

int *to2D(int index, int width)
{
  int *coor = (int *) malloc(2 * (sizeof(int)));
  coor[0] = index % width;
  coor[1] = index / width;
  return coor;
}

Vertex insEnd(Vertex v, int newPos)
{
  Node new = newNode(newPos);
  if (v->tail == 0)
  {
    v->first = new;
    v->tail = new;
    return v;
  }
  else
  {
    
  }

  v->tail->next = new;
  v->tail = new;
  return v;
}

Vertex *initUrb(int N, int width, int height)
{
  int i;
  int *coor;
  int newcoor;
  Vertex *sect = (Vertex *) malloc((N + 2) * (sizeof(struct vertex)));
  res = (int *) malloc(((N + 2) * (N + 2)) * (sizeof(int)));
  for (i = 0; i < N; i++)
  {
    sect[i] = newVertex(i);
    coor = to2D(i, width);
    if ((coor[1] - 1) >= 0)
    {
      newcoor = convertCoor(coor[0], coor[1] - 1, width);
      insEnd(sect[i], newcoor);
      res[convertCoor(i, newcoor, N + 2)] = 1;
    }
    else
    {
      
    }

    if ((coor[0] - 1) >= 0)
    {
      newcoor = convertCoor(coor[0] - 1, coor[1], width);
      insEnd(sect[i], newcoor);
      res[convertCoor(i, newcoor, N + 2)] = 1;
    }
    else
    {
      
    }

    if ((coor[0] + 1) <= (width - 1))
    {
      newcoor = convertCoor(coor[0] + 1, coor[1], width);
      insEnd(sect[i], newcoor);
      res[convertCoor(i, newcoor, N + 2)] = 1;
    }
    else
    {
      
    }

    if ((coor[1] + 1) <= (height - 1))
    {
      newcoor = convertCoor(coor[0], coor[1] + 1, width);
      insEnd(sect[i], newcoor);
      res[convertCoor(i, newcoor, N + 2)] = 1;
    }
    else
    {
      
    }

    free(coor);
  }

  sect[i] = newVertex(i);
  sect[i + 1] = newVertex(i + 1);
  return sect;
}

int main()
{
  int i;
  int width;
  int height;
  int markets;
  int citizens;
  int x;
  int y;
  Vertex *urb;
  width = new_sym_var(sizeof(int) * 8);
  height = new_sym_var(sizeof(int) * 8);
  urb = initUrb(width * height, width, height);
  markets = new_sym_var(sizeof(int) * 8);
  citizens = new_sym_var(sizeof(int) * 8);
  for (i = 0; i < markets; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    insEnd(urb[convertCoor(x - 1, y - 1, width)], (width * height) + 1);
    res[convertCoor(convertCoor(x - 1, y - 1, width), (width * height) + 1, (width * height) + 2)] = 1;
  }

  for (i = 0; i < citizens; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    insEnd(urb[width * height], convertCoor(x - 1, y - 1, width));
    res[convertCoor(width * height, convertCoor(x - 1, y - 1, width), (width * height) + 2)] = 1;
  }

  printf("%d\n", maxFlow(urb, width * height, (width * height) + 1, width * height));
  return 0;
}

