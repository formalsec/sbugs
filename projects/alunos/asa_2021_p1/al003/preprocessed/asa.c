#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef enum 
{
  WHITE,
  GRAY,
  BLACK
} Color;
typedef struct dependence
{
  int id_domino;
  struct dependence *next_dep;
} Dependence;
typedef struct domino
{
  int idDomino;
  int does_depend;
  int color;
  Dependence *first;
  Dependence *last;
  struct domino *nextAfterSort;
  struct domino *previousAfterSort;
} Domino;
typedef struct game
{
  int num_pieces;
  int sources;
  int maxSequence;
  Domino *dominos;
  Domino *firstAfterSort;
  Domino *lastAfterSort;
} Game;
typedef struct stack_el
{
  int id;
  struct stack_el *next;
  struct stack_el *previous;
} StackEl;
typedef struct stack
{
  StackEl *first;
  StackEl *last;
} Stack;
StackEl *newStackEl(int id)
{
  StackEl *el = (StackEl *) malloc(sizeof(StackEl));
  el->id = id;
  el->next = 0;
  el->previous = 0;
  return el;
}

void freeStackEl(StackEl *el)
{
  free(el);
}

Stack *newStack()
{
  Stack *s = (Stack *) malloc(sizeof(Stack));
  s->first = 0;
  s->last = 0;
  return s;
}

void freeStack(Stack *s)
{
  StackEl *aux1;
  StackEl *aux2;
  aux1 = s->first;
  while (aux1)
  {
    aux2 = aux1->next;
    freeStackEl(aux1);
    aux1 = aux2;
  }

  free(s);
}

int isStackEmpty(Stack *s)
{
  if (!s->first)
  {
    return -1;
  }
  else
  {
    
  }

  return 0;
}

void push(Stack *s, int id)
{
  StackEl *el = newStackEl(id);
  if (isStackEmpty(s))
  {
    s->first = el;
  }
  else
  {
    s->last->next = el;
    el->previous = s->last;
  }

  s->last = el;
}

int pop(Stack *s)
{
  StackEl *el;
  int id;
  if (isStackEmpty(s))
  {
    return 0;
  }
  else
  {
    
  }

  el = s->last;
  if (!s->first->next)
  {
    s->first = 0;
    s->last = 0;
  }
  else
  {
    s->last->previous->next = 0;
    s->last = el->previous;
  }

  id = el->id;
  freeStackEl(el);
  return id;
}

Game *createGame(int num_pieces)
{
  Game *g = (Game *) malloc(sizeof(Game));
  g->num_pieces = num_pieces;
  g->sources = 0;
  g->maxSequence = 0;
  g->dominos = malloc(num_pieces * (sizeof(Domino)));
  g->firstAfterSort = malloc(sizeof(Domino));
  g->firstAfterSort = 0;
  g->lastAfterSort = malloc(sizeof(Domino));
  g->lastAfterSort = 0;
  return g;
}

void addDomino(Domino *domino, int id)
{
  domino->idDomino = id;
  domino->does_depend = 0;
  domino->color = WHITE;
  domino->first = 0;
  domino->last = 0;
  domino->nextAfterSort = 0;
  domino->previousAfterSort = 0;
}

void addDependence(Game *game, int piece, int dependence)
{
  Dependence *dep = (Dependence *) malloc(sizeof(Dependence));
  Domino *d = (game->dominos + piece) - 1;
  Domino *aux = (game->dominos + dependence) - 1;
  dep->next_dep = 0;
  dep->id_domino = dependence;
  if (d->first == 0)
  {
    d->first = dep;
  }
  else
  {
    d->last->next_dep = dep;
  }

  d->last = dep;
  aux->does_depend = 1;
}

void countSources(Game *g)
{
  int i;
  int counter = 0;
  for (i = 0; i < g->num_pieces; i++)
  {
    Domino *d = g->dominos + i;
    if (!d->does_depend)
    {
      counter++;
    }
    else
    {
      
    }

  }

  g->sources = counter;
}

void longestPath(Game *g)
{
  int i;
  int levels[g->num_pieces];
  for (i = 0; i < g->num_pieces; i++)
  {
    levels[i] = 1;
  }

  Domino *d = g->firstAfterSort;
  while (d)
  {
    if (d->first != 0)
    {
      Dependence *dep = d->first;
      while (dep)
      {
        if ((levels[d->idDomino - 1] + 1) > levels[dep->id_domino - 1])
        {
          levels[dep->id_domino - 1] = levels[d->idDomino - 1] + 1;
        }
        else
        {
          
        }

        dep = dep->next_dep;
      }

    }
    else
    {
      
    }

    d = d->nextAfterSort;
  }

  for (i = 0; i < g->num_pieces; i++)
  {
    if (levels[i] > g->maxSequence)
    {
      g->maxSequence = levels[i];
    }
    else
    {
      
    }

  }

}

void topSort(Game *g, Domino *d)
{
  if (g->lastAfterSort == 0)
  {
    g->lastAfterSort = d;
  }
  else
  {
    g->firstAfterSort->previousAfterSort = d;
    d->nextAfterSort = g->firstAfterSort;
  }

  g->firstAfterSort = d;
}

void dfs(Game *g)
{
  Stack *s = newStack();
  int i;
  int id;
  Domino *d1;
  for (i = 0; i < g->num_pieces; i++)
  {
    Domino *d = g->dominos + i;
    if (d->color == WHITE)
    {
      push(s, d->idDomino);
      while (!isStackEmpty(s))
      {
        StackEl *el = s->last;
        id = el->id;
        d = (g->dominos + id) - 1;
        if (d->first == 0)
        {
          id = pop(s);
          d = (g->dominos + id) - 1;
          topSort(g, d);
          d->color = BLACK;
        }
        else
        {
          if (d->color == GRAY)
          {
            id = pop(s);
            d = (g->dominos + id) - 1;
            topSort(g, d);
            d->color = BLACK;
          }
          else
          {
            Dependence *dep;
            for (dep = d->first; dep != 0; dep = dep->next_dep)
            {
              id = dep->id_domino;
              d1 = (g->dominos + id) - 1;
              if (d1->color == WHITE)
              {
                push(s, d1->idDomino);
              }
              else
              {
                
              }

            }

            d->color = GRAY;
          }

        }

      }

    }
    else
    {
      
    }

  }

}

int main()
{
  int num_pieces;
  int num_dependences;
  int i;
  int tmp1;
  int tmp2;
  Domino *domino;
  if (2)
  {
    num_pieces = new_sym_var(sizeof(int) * 8);
    num_dependences = new_sym_var(sizeof(int) * 8);
    Game *game = createGame(num_pieces);
    for (i = 0; i < num_pieces; i++)
    {
      domino = game->dominos + i;
      addDomino(domino, i + 1);
    }

    for (i = 0; i < num_dependences; i++)
    {
      if (2)
      {
        tmp1 = new_sym_var(sizeof(int) * 8);
        tmp2 = new_sym_var(sizeof(int) * 8);
        addDependence(game, tmp1, tmp2);
      }
      else
      {
        
      }

    }

    countSources(game);
    dfs(game);
    longestPath(game);
    printf("%d %d\n", game->sources, game->maxSequence);
  }
  else
  {
    
  }

  return 0;
}

