#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include<stdio.h>
#include<stdlib.h>


typedef struct adj_domino
{
  int n;
  struct adj_domino *next;
} adj_domino;
typedef struct node
{
  int n;
  struct node *next;
  struct node *previous;
} node;
typedef struct domino
{
  int n;
  int source;
  int color;
  int fallen;
  struct adj_domino *next;
  struct adj_domino *last_adj;
} domino;
int N;
int M;
domino *graph;
void initGraph()
{
  graph = malloc((sizeof(domino)) * N);
  int i;
  for (i = 0; i < N; i++)
  {
    graph[i].n = i;
    graph[i].source = 1;
    graph[i].color = 0;
    graph[i].fallen = 0;
    graph[i].next = 0;
    graph[i].last_adj = 0;
  }

}

void insert_end(int x, int y)
{
  adj_domino *new = malloc(sizeof(adj_domino));
  new->n = y - 1;
  new->next = 0;
  if (graph[x - 1].last_adj == 0)
  {
    graph[x - 1].next = new;
    graph[x - 1].last_adj = new;
    return;
  }
  else
  {
    
  }

  adj_domino *last = graph[x - 1].last_adj;
  last->next = new;
  graph[x - 1].last_adj = new;
}

int readInput()
{
  N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  int nsources = N;
  int x;
  int y;
  initGraph();
  int i;
  for (i = 0; i < M; i++)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    if (graph[y - 1].source)
    {
      graph[y - 1].source = 0;
      nsources--;
    }
    else
    {
      
    }

    insert_end(x, y);
  }

  return nsources;
}

int dfsVisit(int i)
{
  graph[i].color = 1;
  int fallen;
  node *head = malloc(sizeof(node));
  head->n = graph[i].n;
  head->next = 0;
  head->previous = 0;
  while (head != 0)
  {
    fallen = 1;
    adj_domino *adj = graph[head->n].next;
    while (adj != 0)
    {
      if (graph[adj->n].color == 2)
      {
        if (fallen < (graph[adj->n].fallen + 1))
        {
          fallen = graph[adj->n].fallen + 1;
        }
        else
        {
          
        }

      }
      else
      {
        if (graph[adj->n].color == 0)
        {
          graph[adj->n].color = 1;
          node *new_node = malloc(sizeof(node));
          new_node->n = adj->n;
          new_node->next = 0;
          new_node->previous = head;
          head->next = new_node;
          head = new_node;
          break;
        }
        else
        {
          
        }

      }

      adj = adj->next;
    }

    if (adj == 0)
    {
      graph[head->n].color = 2;
      graph[head->n].fallen = fallen;
      if (head->previous == 0)
      {
        free(head);
        return fallen;
      }
      else
      {
        
      }

      node *removed = head;
      head = head->previous;
      head->next = 0;
      removed->previous = 0;
      free(removed);
    }
    else
    {
      
    }

  }

  return fallen;
}

int dfs()
{
  int fallen = 1;
  int new;
  int i;
  for (i = 0; i < N; i++)
  {
    if (graph[i].color == 0)
    {
      new = dfsVisit(i);
      if (fallen < new)
      {
        fallen = new;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return fallen;
}

void freeGraph()
{
  int i;
  adj_domino *head;
  adj_domino *removed;
  for (i = 0; i < N; i++)
  {
    head = graph[i].next;
    while (head != 0)
    {
      removed = head;
      head = head->next;
      free(removed);
    }

  }

  free(graph);
}

int main()
{
  int k = readInput();
  int l = dfs();
  printf("%d %d\n", k, l);
  freeGraph();
  return 0;
}

