/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>


typedef struct 
{
  int number;
  int discovered;
  int level;
  int edgeNo;
  int *edges;
} Node;
typedef struct 
{
  int size;
  Node *list;
  int rootNo;
  int *roots;
} Graph;
typedef struct 
{
  int top;
  Node **list;
} Stack;
Graph *readInput();
void exec(Graph *graph);
int DFS(Graph *graph, Node *root);
Graph *createGraph(int size);
void deleteGraph(Graph *graph);
void addNodeEdge(Graph *graph, int node, int edge);
Stack *createStack(int maxSize);
void deleteStack(Stack *stack);
void pushStack(Stack *stack, Node *node);
Node *popStack(Stack *stack);
int emptyStack(Stack *stack);
void debugList(Graph *graph);
void debugStack(Stack *Stack);
int main()
{
  Graph *graph = readInput();
  exec(graph);
  deleteGraph(graph);
  return 0;
}

Graph *readInput()
{
  int i;
  int nodeNo;
  int edgeNo;
  int first;
  int second;
  int *roots;
  Node *node;
  nodeNo = new_sym_var(sizeof(int) * 8);
  edgeNo = new_sym_var(sizeof(int) * 8);
  Graph *graph = createGraph(nodeNo);
  roots = (int *) malloc((sizeof(int)) * (nodeNo + 1));
  graph->rootNo = nodeNo;
  for (i = 1; i <= nodeNo; i++)
  {
    node = &graph->list[i];
    node->number = i;
    node->level = 0;
    node->edgeNo = 0;
    roots[i] = 1;
  }

  for (i = 0; i < edgeNo; i++)
  {
    first = new_sym_var(sizeof(int) * 8);
    second = new_sym_var(sizeof(int) * 8);
    addNodeEdge(graph, first, second);
    if (roots[second] == 1)
    {
      roots[second] = 0;
      graph->rootNo--;
    }
    else
    {
      
    }

  }

  graph->roots = (int *) malloc((sizeof(int)) * graph->rootNo);
  int head = 0;
  for (i = 1; i <= nodeNo; i++)
  {
    if (roots[i] == 1)
    {
      graph->roots[head++] = i;
    }
    else
    {
      
    }

  }

  return graph;
}

void exec(Graph *graph)
{
  int i;
  int maxTreeLen = 0;
  int treeLen;
  Node *node;
  for (i = 0; i < graph->rootNo; i++)
  {
    node = &graph->list[graph->roots[i]];
    treeLen = DFS(graph, node);
    if (treeLen > maxTreeLen)
    {
      maxTreeLen = treeLen;
    }
    else
    {
      
    }

  }

  printf("%d %d\n", graph->rootNo, maxTreeLen);
}

int DFS(Graph *graph, Node *root)
{
  int i;
  int maxLevel = 0;
  Node *node;
  Node *childNode;
  Stack *stack = createStack(graph->size);
  for (i = 1; i <= graph->size; i++)
  {
    graph->list[i].discovered = 0;
  }

  root->level = 1;
  pushStack(stack, root);
  while (!emptyStack(stack))
  {
    node = popStack(stack);
    root->discovered = 1;
    for (i = 0; i < node->edgeNo; i++)
    {
      childNode = &graph->list[node->edges[i]];
      if (childNode->level <= node->level)
      {
        childNode->level = node->level + 1;
        pushStack(stack, childNode);
        if (childNode->level > maxLevel)
        {
          maxLevel = childNode->level;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  deleteStack(stack);
  return maxLevel;
}

Graph *createGraph(int size)
{
  Graph *graph = (Graph *) malloc(sizeof(Graph));
  graph->list = (Node *) malloc((sizeof(Node)) * (size + 1));
  graph->size = size;
  return graph;
}

void deleteGraph(Graph *graph)
{
  free(graph->list);
  free(graph);
}

void addNodeEdge(Graph *graph, int n, int edge)
{
  Node *node = &graph->list[n];
  if (node->edgeNo == 0)
  {
    node->edgeNo++;
    node->edges = (int *) malloc(sizeof(int));
    node->edges[0] = edge;
  }
  else
  {
    node->edgeNo++;
    int *aux = (int *) malloc((sizeof(int)) * node->edgeNo);
    int i;
    for (i = 0; i < (node->edgeNo - 1); i++)
    {
      aux[i] = node->edges[i];
    }

    aux[i] = edge;
    free(node->edges);
    node->edges = aux;
  }

}

Stack *createStack(int maxSize)
{
  Stack *stack = (Stack *) malloc(sizeof(Stack));
  stack->top = -1;
  stack->list = (Node **) malloc((sizeof(Node *)) * maxSize);
  return stack;
}

void deleteStack(Stack *stack)
{
  free(stack->list);
  free(stack);
}

void pushStack(Stack *stack, Node *node)
{
  stack->list[++stack->top] = node;
}

Node *popStack(Stack *stack)
{
  return stack->list[stack->top--];
}

int emptyStack(Stack *stack)
{
  return stack->top == (-1);
}

void debugList(Graph *graph)
{
  int i;
  int j;
  puts("------ Graph ------");
  printf("rootNo: %d   roots:", graph->rootNo);
  for (i = 0; i < graph->rootNo; i++)
  {
    printf(" %d", graph->roots[i]);
  }

  puts("");
  for (i = 1; i <= graph->size; i++)
  {
    printf("node: %d  |-> level: %d  |-> adgeNo: %d  |-> adges:", graph->list[i].number, graph->list[i].level, graph->list[i].edgeNo);
    for (j = 0; j < graph->list[i].edgeNo; j++)
    {
      printf(" %d", graph->list[i].edges[j]);
    }

    puts("");
  }

  puts("-------------------");
}

void debugStack(Stack *stack)
{
  puts("------ Stack ------");
  printf("top: %d\n", stack->top);
  puts("-------------------");
}

