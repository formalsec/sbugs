#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct 
{
  int id;
  int *connectedTo;
  int numConnections;
  int isRoot;
} Domino;
Domino *connectionList;
void fillPositions(int numDominos)
{
  int i;
  for (i = 0; i < numDominos; i++)
  {
    connectionList[i].id = i;
    connectionList[i].connectedTo = 0;
    connectionList[i].numConnections = 0;
    connectionList[i].isRoot = 0;
  }

}

void addPairs(int d1, int d2)
{
  int i;
  connectionList[d1].numConnections++;
  int *tamanho = malloc((sizeof(int)) * connectionList[d1].numConnections);
  for (i = 0; i < (connectionList[d1].numConnections - 1); i++)
  {
    tamanho[i] = connectionList[d1].connectedTo[i];
  }

  tamanho[connectionList[d1].numConnections - 1] = d2;
  connectionList[d1].connectedTo = tamanho;
  connectionList[d2].isRoot = 1;
  tamanho = 0;
  free(tamanho);
}

void checkStructContents(int numDominos)
{
  int i;
  int j;
  for (i = 0; i < numDominos; i++)
  {
    printf("id:%d, numConnections:%d connectedTo: ", i, connectionList[i].numConnections);
    for (j = 0; j < connectionList[i].numConnections; j++)
    {
      printf("%d ", connectionList[i].connectedTo[j]);
    }

    printf("\n");
    if (connectionList[i].isRoot == 0)
    {
      printf("root: %d\n", i);
    }
    else
    {
      
    }

  }

}

int filhos(int z, int *distict)
{
  int i;
  int size = 0;
  if (distict[z] == 1)
  {
    return 0;
  }
  else
  {
    
  }

  distict[z] = 1;
  size++;
  for (i = 0; i < connectionList[z].numConnections; i++)
  {
    size += filhos(connectionList[z].connectedTo[i], distict);
  }

  return size;
}

int *checkIfRoot(int numDominos, int *out)
{
  int numRoots = 0;
  int sizeBiggestRoot = -1;
  int distict[numDominos];
  int z;
  int i;
  for (i = 0; i < numDominos; i++)
  {
    if (connectionList[i].isRoot == 0)
    {
      numRoots++;
      for (z = 0; z < numDominos; z++)
      {
        distict[z] = 0;
      }

      int s = 0;
      for (z = 0; z < connectionList[i].numConnections; z++)
      {
        s += filhos(connectionList[i].connectedTo[z], distict);
      }

      if (sizeBiggestRoot < s)
      {
        sizeBiggestRoot = s;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  out[0] = numRoots;
  out[1] = sizeBiggestRoot;
  return out;
}

int main()
{
  int numDominos;
  int numDependencias;
  int domino1;
  int domino2;
  int i;
  if (2 != 2)
  {
    return -1;
  }
  else
  {
    numDominos = new_sym_var(sizeof(int) * 8);
    numDependencias = new_sym_var(sizeof(int) * 8);
    
  }

  if ((numDominos < 2) || (numDependencias < 0))
  {
    return -1;
  }
  else
  {
    
  }

  connectionList = malloc((sizeof(Domino)) * numDominos);
  fillPositions(numDominos);
  for (i = 0; i < numDependencias; i++)
  {
    if (2 == 2)
    {
      domino1 = new_sym_var(sizeof(int) * 8);
      domino2 = new_sym_var(sizeof(int) * 8);
      addPairs(domino1 - 1, domino2 - 1);
    }
    else
    {
      return 1;
    }

  }

  int out[2] = {0, 0};
  checkIfRoot(numDominos, out);
  printf("%d %d\n", out[0], out[1]);
  free(connectionList);
  return 0;
}

