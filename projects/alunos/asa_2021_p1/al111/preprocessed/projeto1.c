#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


struct AdjListNode
{
  int dest;
  struct AdjListNode *next;
};
struct AdjList
{
  struct AdjListNode *head;
};
struct Graph
{
  int V;
  struct AdjList *array;
};
struct AdjListNode *newAdjListNode(int dest)
{
  struct AdjListNode *newNode = (struct AdjListNode *) malloc(sizeof(struct AdjListNode));
  newNode->dest = dest;
  newNode->next = 0;
  return newNode;
}

struct Graph *createGraph(int V)
{
  struct Graph *graph = (struct Graph *) malloc(sizeof(struct Graph));
  graph->V = V;
  graph->array = (struct AdjList *) malloc(V * (sizeof(struct AdjList)));
  int i;
  for (i = 1; i < V; ++i)
    graph->array[i].head = 0;

  return graph;
}

void addEdge(struct Graph *graph, int src, int dest)
{
  struct AdjListNode *newNode = newAdjListNode(dest);
  newNode->next = graph->array[src].head;
  graph->array[src].head = newNode;
}

int main()
{
  int i;
  int v = 0;
  int e = 0;
  int outD = 0;
  int inD = 0;
  int minTouchesReq = 0;
  int *discovery;
  struct Graph *graph;
  struct AdjListNode *pCrawl;
  if (2)
  {
    v = new_sym_var(sizeof(int) * 8);
    e = new_sym_var(sizeof(int) * 8);
    graph = createGraph(++v);
    discovery = malloc((sizeof(int)) * v);
    for (i = 1; i < v; i++)
      discovery[i] = 0;

  }
  else
  {
    return 1;
  }

  while (e)
  {
    if (2)
    {
      outD = new_sym_var(sizeof(int) * 8);
      inD = new_sym_var(sizeof(int) * 8);
      addEdge(graph, outD, inD);
      discovery[inD] = 1;
      e--;
    }
    else
    {
      return 1;
    }

  }

  int time;
  int maxTime;
  for (time = 0; time < (v - 1); time++)
  {
    for (i = 1; i < v; i++)
    {
      if (discovery[i] == time)
      {
        pCrawl = graph->array[i].head;
        while (pCrawl)
        {
          if (discovery[pCrawl->dest] < (time + 1))
          {
            discovery[pCrawl->dest] = time + 1;
          }
          else
          {
            
          }

          pCrawl = pCrawl->next;
        }

      }
      else
      {
        
      }

    }

  }

  maxTime = 0;
  for (i = 1; i < v; i++)
  {
    if (discovery[i] == 0)
    {
      minTouchesReq++;
    }
    else
    {
      
    }

    if (discovery[i] > maxTime)
    {
      maxTime = discovery[i];
    }
    else
    {
      
    }

  }

  printf("%d %d\n", minTouchesReq, maxTime + 1);
  free(discovery);
  return 0;
}

