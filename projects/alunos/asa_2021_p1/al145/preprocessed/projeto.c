/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int K;
int L;
int current_node;
enum color
{
  White,
  Gray,
  Black
};
int time;
int p[10000000];
int d[10000000];
int f[10000000];
int netedges[10000000];
int orphans[10000000];
enum color color[10000000];
typedef struct node *link;
typedef struct graph *Graph;
struct node
{
  int v;
  link next;
};
struct graph
{
  int V;
  int E;
  link *adj;
};
void dfs_visit(Graph G, int u)
{
  link a;
  color[u] = Gray;
  d[u] = time;
  time++;
  for (a = G->adj[u]; a != 0; a = a->next)
  {
    if (color[a->v] == White)
    {
      p[a->v] = u;
      netedges[current_node] = netedges[current_node] + 1;
      dfs_visit(G, a->v);
    }
    else
    {
      
    }

  }

  color[u] = Black;
  f[u] = time;
  time++;
}

void dfs(Graph G, int Array[])
{
  int u;
  for (u = 0; u < G->V; u++)
  {
    color[u] = White;
    p[u] = -1;
  }

  time = 1;
  for (u = 0; u < G->V; u++)
  {
    if (orphans[u] == 1)
    {
      current_node = u;
      netedges[current_node] = netedges[current_node] + 1;
      dfs_visit(G, u);
    }
    else
    {
      
    }

  }

}

Graph GRAPHinit(int V)
{
  int v;
  Graph G = malloc(sizeof(struct graph));
  G->V = V;
  G->E = 0;
  G->adj = malloc(V * (sizeof(link)));
  for (v = 0; v < V; v++)
    G->adj[v] = 0;

  return G;
}

void insertE(link *head, int v)
{
  link a = (link) malloc(sizeof(struct node));
  link last = *head;
  a->v = v;
  a->next = 0;
  if ((*head) == 0)
  {
    *head = a;
    return;
  }
  else
  {
    
  }

  while (last->next != 0)
    last = last->next;

  last->next = a;
  return;
}

void GRAPHinsertE(Graph G, int v, int w)
{
  link a;
  for (a = G->adj[v]; a != 0; a = a->next)
    if (a->v == w)
  {
    return;
  }
  else
  {
    
  }


  insertE(&G->adj[v], w);
  G->E++;
}

void predictK(Graph G)
{
  int u;
  for (u = 0; u < G->V; u++)
    if (p[u] == (-1))
  {
    K = K + 1;
  }
  else
  {
    
  }


}

void predictL(Graph G)
{
  int u;
  int max = 0;
  for (u = 0; u < G->V; u++)
    if (netedges[u] > max)
  {
    max = netedges[u];
  }
  else
  {
    
  }


  L = max - 1;
}

void getEdges(Graph G, Graph GT, int M)
{
  int i;
  int v;
  int w;
  for (i = 0; i < M; i++)
  {
    v = new_sym_var(sizeof(int) * 8);
    w = new_sym_var(sizeof(int) * 8);
    GRAPHinsertE(G, v - 1, w - 1);
    GRAPHinsertE(GT, w - 1, v - 1);
  }

}

void findOrphans(Graph G)
{
  int u;
  for (u = 0; u < G->V; u++)
  {
    orphans[u] = 0;
  }

  for (u = 0; u < G->V; u++)
    if (G->adj[u] == 0)
  {
    orphans[u] = 1;
  }
  else
  {
    
  }


}

int main()
{
  int N;
  int M;
  N = new_sym_var(sizeof(int) * 8);
  M = new_sym_var(sizeof(int) * 8);
  if ((N >= 2) && (M >= 0))
  {
    Graph G = GRAPHinit(N);
    Graph GT = GRAPHinit(N);
    getEdges(G, GT, M);
    findOrphans(GT);
    dfs(G, orphans);
    predictK(G);
    predictL(G);
    printf("%d %d\n", K, L);
  }
  else
  {
    
  }

  return 0;
}

