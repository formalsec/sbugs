#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


typedef struct graph
{
  int vertices;
  int source;
  int target;
  int **graphF;
} Graph;
void initGraph(Graph *graph, int vertices)
{
  int i;
  int j;
  vertices += 2;
  graph->vertices = vertices;
  graph->source = vertices - 2;
  graph->target = vertices - 1;
  graph->graphF = (int **) malloc((sizeof(int *)) * vertices);
  for (i = 0; i < vertices; i++)
  {
    graph->graphF[i] = (int *) malloc((sizeof(int)) * vertices);
  }

  for (i = 0; i < vertices; i++)
  {
    for (j = 0; j < vertices; j++)
    {
      graph->graphF[i][j] = 0;
    }

  }

}

void addEdge(Graph *graph, int u, int v, int weight)
{
  graph->graphF[u][v] = weight;
  graph->graphF[v][u] = weight;
}

void destroyGraph(Graph *graph)
{
  int i;
  for (i = 0; i < graph->vertices; i++)
  {
    int *toFree = graph->graphF[i];
    free(toFree);
  }

  free(graph->graphF);
}

int getShortestPath(Graph *graph, int *path, int *pathLength, char *color, int *parent)
{
  int i;
  int head;
  *pathLength = 0;
  int *stack = (int *) malloc((sizeof(int)) * graph->vertices);
  int stackHead = 0;
  for (i = 0; i < graph->vertices; i++)
  {
    color[i] = 0;
    parent[i] = -1;
  }

  color[graph->source] = 1;
  stack[stackHead] = graph->source;
  while (stackHead >= 0)
  {
    head = stack[stackHead];
    stackHead--;
    for (i = 0; i < graph->vertices; i++)
    {
      if ((color[i] == 0) && (graph->graphF[head][i] > 0))
      {
        if (i == graph->target)
        {
          int minimumIncrease = 2147483646;
          parent[i] = head;
          while (parent[i] != (-1))
          {
            path[*pathLength] = i;
            (*pathLength)++;
            if (graph->graphF[parent[i]][i] < minimumIncrease)
            {
              minimumIncrease = graph->graphF[parent[i]][i];
            }
            else
            {
              
            }

            i = parent[i];
          }

          path[*pathLength] = i;
          (*pathLength)++;
          free(stack);
          return minimumIncrease;
        }
        else
        {
          
        }

        stackHead++;
        stack[stackHead] = i;
        parent[i] = head;
        color[i] = 1;
      }
      else
      {
        
      }

    }

  }

  free(stack);
  return 0;
}

int computeMinimumCost(Graph *graph)
{
  int i;
  int minimumIncrease;
  int minimumCost = 0;
  int *path = (int *) malloc((sizeof(int)) * graph->vertices);
  int pathLength;
  char *color = (char *) malloc((sizeof(char)) * graph->vertices);
  int *parent = (int *) malloc((sizeof(int)) * graph->vertices);
  while (1)
  {
    minimumIncrease = getShortestPath(graph, path, &pathLength, color, parent);
    if (pathLength == 0)
    {
      free(color);
      free(parent);
      free(path);
      return minimumCost;
    }
    else
    {
      
    }

    for (i = 0; i < (pathLength - 1); i++)
    {
      int u = path[i];
      int v = path[i + 1];
      graph->graphF[v][u] -= minimumIncrease;
      graph->graphF[u][v] += minimumIncrease;
    }

    minimumCost += minimumIncrease;
  }

}

void processInput(Graph *graph)
{
  int vertices;
  int edges;
  int i;
  vertices = new_sym_var(sizeof(int) * 8);
  edges = new_sym_var(sizeof(int) * 8);
  initGraph(graph, vertices);
  for (i = 0; i < vertices; i++)
  {
    int x;
    int y;
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    addEdge(graph, graph->source, i, x);
    addEdge(graph, graph->target, i, y);
  }

  for (i = 0; i < edges; i++)
  {
    int u;
    int v;
    int w;
    u = new_sym_var(sizeof(int) * 8);
    v = new_sym_var(sizeof(int) * 8);
    w = new_sym_var(sizeof(int) * 8);
    addEdge(graph, u - 1, v - 1, w);
  }

}

int main()
{
  Graph graph;
  processInput(&graph);
  int minimumCost = computeMinimumCost(&graph);
  printf("%d\n", minimumCost);
  destroyGraph(&graph);
  return 0;
}

