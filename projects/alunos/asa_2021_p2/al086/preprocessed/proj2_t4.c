#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct edge
{
  int arcoPartida;
  int arcoDestino;
  int capacidade;
  int flow;
} Edge;
typedef struct queuenode
{
  int verticeNum;
  struct queuenode *next;
} QueueNode;
typedef struct queuelist
{
  QueueNode *head;
  QueueNode *tail;
} QueueList;
Edge *ArrayArcos;
QueueList queue;
int *parent;
bool *visited;
void Queueinit();
int Queueempty();
QueueNode *createQueueNode(int v);
void Queuepush(int vertice);
int Queuegetlast();
void criaArco(int u, int v, int indiceArco);
void iniciaArcos(int vertices);
void freeArcos();
int returnIndiceArcos(int u, int v, int vertices);
void adicionaArcos(int vertices, int edges);
int fordfulkerson(int vertices);
bool bfs_aux(int start, int finish);
int main()
{
  int vertices = 0;
  int total_edges = 0;
  if (2 == 1)
  {
    vertices = new_sym_var(sizeof(int) * 8);
    total_edges = new_sym_var(sizeof(int) * 8);
    exit(1);
  }
  else
  {
    if ((vertices < 2) || (total_edges < 0))
    {
      exit(1);
    }
    else
    {
      
    }

    iniciaArcos(vertices);
    adicionaArcos(vertices, total_edges);
    printf("%d\n", fordfulkerson(vertices));
    freeArcos();
  }

  return 0;
}

int min(int n, int n1)
{
  return (n < n1) ? (n) : (n1);
}

void Queueinit()
{
  queue.head = 0;
  queue.tail = 0;
}

int Queueempty()
{
  return queue.head == 0;
}

QueueNode *createQueueNode(int v)
{
  QueueNode *newNode;
  newNode = (QueueNode *) malloc(sizeof(QueueNode));
  newNode->verticeNum = v;
  newNode->next = 0;
  return newNode;
}

void Queuepush(int v)
{
  if (queue.head == 0)
  {
    queue.head = (queue.tail = createQueueNode(v));
    return;
  }
  else
  {
    queue.tail->next = createQueueNode(v);
    queue.tail = queue.tail->next;
  }

}

int Queuegetlast()
{
  int v = 0;
  QueueNode *previousNode;
  if (!Queueempty())
  {
    v = queue.head->verticeNum;
    previousNode = queue.head;
    queue.head = queue.head->next;
    free(previousNode);
  }
  else
  {
    printf("Queue empty.");
  }

  return v;
}

void criaArco(int u, int v, int indiceArco)
{
  ArrayArcos[indiceArco].arcoPartida = u;
  ArrayArcos[indiceArco].arcoDestino = v;
  ArrayArcos[indiceArco].capacidade = 0;
  ArrayArcos[indiceArco].flow = 0;
}

void iniciaArcos(int vertices)
{
  int u = 0;
  int v = 0;
  int k = 0;
  int indiceArco = 0;
  ArrayArcos = (Edge *) malloc((sizeof(Edge)) * ((vertices + 2) * (vertices + 2)));
  parent = (int *) malloc((sizeof(int)) * (vertices + 2));
  visited = (bool *) malloc((sizeof(bool)) * (vertices + 2));
  for (u = 0; u <= (vertices + 1); u++)
  {
    for (v = 0; v <= (vertices + 1); v++)
    {
      indiceArco = (u * (vertices + 1)) + (v + k);
      criaArco(u, v, indiceArco);
    }

    k++;
  }

}

void freeArcos()
{
  free(ArrayArcos);
  free(parent);
  free(visited);
}

int returnIndiceArcos(int u, int v, int vertices)
{
  int indiceArco = 0;
  indiceArco = (u * vertices) + (v + u);
  return indiceArco;
}

void adicionaArcos(int vertices, int edges)
{
  int vertice = 0;
  int next_vertice = 0;
  int i = 0;
  int weight = 0;
  int cap_x = 0;
  int cap_y = 0;
  int indiceArco = 0;
  for (i = 1; i <= vertices; i++)
  {
    if (2)
    {
      cap_x = new_sym_var(sizeof(int) * 8);
      cap_y = new_sym_var(sizeof(int) * 8);
      indiceArco = returnIndiceArcos(0, i, vertices + 1);
      ArrayArcos[indiceArco].capacidade = cap_x;
      ArrayArcos[indiceArco].flow = cap_x;
      indiceArco = returnIndiceArcos(i, vertices + 1, vertices + 1);
      ArrayArcos[indiceArco].capacidade = cap_y;
      ArrayArcos[indiceArco].flow = cap_y;
    }
    else
    {
      
    }

  }

  for (i = 1; i <= edges; i++)
  {
    if (3)
    {
      vertice = new_sym_var(sizeof(int) * 8);
      next_vertice = new_sym_var(sizeof(int) * 8);
      weight = new_sym_var(sizeof(int) * 8);
      indiceArco = returnIndiceArcos(vertice, next_vertice, vertices + 1);
      ArrayArcos[indiceArco].capacidade = weight;
      ArrayArcos[indiceArco].flow = weight;
      indiceArco = returnIndiceArcos(next_vertice, vertice, vertices + 1);
      ArrayArcos[indiceArco].capacidade = weight;
      ArrayArcos[indiceArco].flow = weight;
    }
    else
    {
      
    }

  }

}

int fordfulkerson(int vertices)
{
  int i = 0;
  int j = 0;
  int max_flow = 0;
  int indiceArco = 0;
  int indiceArco2 = 0;
  while (bfs_aux(0, vertices))
  {
    int flow_calculated = 0;
    for (i = vertices + 1; i != 0; i = parent[i])
    {
      j = parent[i];
      indiceArco = returnIndiceArcos(j, i, vertices + 1);
      if (i == (vertices + 1))
      {
        flow_calculated = ArrayArcos[indiceArco].flow;
      }
      else
      {
        flow_calculated = min(flow_calculated, ArrayArcos[indiceArco].flow);
      }

    }

    for (i = vertices + 1; i != 0; i = parent[i])
    {
      j = parent[i];
      indiceArco = returnIndiceArcos(j, i, vertices + 1);
      ArrayArcos[indiceArco].flow = ArrayArcos[indiceArco].flow - flow_calculated;
      indiceArco2 = returnIndiceArcos(i, j, vertices + 1);
      ArrayArcos[indiceArco2].flow = ArrayArcos[indiceArco2].flow + flow_calculated;
    }

    max_flow = max_flow + flow_calculated;
  }

  return max_flow;
}

bool bfs_aux(int start, int finish)
{
  int v = 0;
  int u = 0;
  int i = 0;
  int indiceArco = 0;
  for (i = 0; i <= (finish + 1); i++)
  {
    visited[i] = false;
  }

  Queueinit();
  Queuepush(start);
  visited[start] = true;
  parent[start] = -1;
  while (!Queueempty())
  {
    u = Queuegetlast();
    for (v = 0; v <= (finish + 1); v++)
    {
      indiceArco = returnIndiceArcos(u, v, finish + 1);
      if ((!visited[v]) && (ArrayArcos[indiceArco].flow > 0))
      {
        if (v == (finish + 1))
        {
          parent[v] = u;
          return true;
        }
        else
        {
          
        }

        Queuepush(v);
        parent[v] = u;
        visited[v] = true;
      }
      else
      {
        
      }

    }

  }

  return false;
}

