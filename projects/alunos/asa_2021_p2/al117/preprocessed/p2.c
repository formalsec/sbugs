#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <stdlib.h>


int custoMinimo;
typedef struct node
{
  int vertice;
  struct node *prev;
  struct node *next;
} *Node;
typedef struct queue
{
  Node head;
  Node tail;
} *Queue;
typedef struct edge
{
  int capacidade;
  int max;
} *Edge;
typedef struct graph
{
  int numVertices;
  int *color;
  int *previous;
  Edge *edges;
} *Graph;
int min(int a, int b);
Graph createGraph(int num);
void initializeEdges(Graph graph, int index);
void addEdge(Graph graph, int custoX, int custoY, int processo);
void addCom(Graph graph, int ver1, int ver2, int custo);
void ED(Graph graph, int source, int sink);
int isReachable(Graph graph, int source, int sink);
Node createNode(int v);
Queue initQueue();
Queue pushQueue(Queue queue, int v);
Queue popQueue(Queue queue);
void paint(Graph graph, int source, int sink, int color1, int color2);
int main()
{
  int i;
  int v1;
  int v2;
  int processos;
  int nCom;
  int custoX;
  int custoY;
  int somaX = 0;
  int somaY = 0;
  if (2 <= 0)
  {
    return -1;
  }
  else
  {
    processos = new_sym_var(sizeof(int) * 8);
    nCom = new_sym_var(sizeof(int) * 8);
    
  }

  Graph graph = createGraph(processos);
  for (i = 1; i <= processos; i++)
  {
    if (2 <= 0)
    {
      return -1;
    }
    else
    {
      custoX = new_sym_var(sizeof(int) * 8);
      custoY = new_sym_var(sizeof(int) * 8);
      
    }

    addEdge(graph, custoX, custoY, i);
    somaX += custoX;
    somaY += custoY;
  }

  custoMinimo = min(somaY, somaX);
  for (i = 1; i <= nCom; i++)
  {
    if (3 <= 0)
    {
      return -1;
    }
    else
    {
      v1 = new_sym_var(sizeof(int) * 8);
      v2 = new_sym_var(sizeof(int) * 8);
      custoX = new_sym_var(sizeof(int) * 8);
      
    }

    addCom(graph, v1, v2, custoX);
  }

  ED(graph, 0, graph->numVertices - 1);
  paint(graph, 0, graph->numVertices - 1, 2, 3);
  paint(graph, graph->numVertices - 1, 0, 3, 2);
  printf("%d\n", custoMinimo);
  return 0;
}

int min(int a, int b)
{
  return (a < b) ? (a) : (b);
}

Graph createGraph(int num)
{
  int i;
  Graph graph = malloc(sizeof(struct graph));
  graph->numVertices = num + 2;
  graph->color = malloc((sizeof(int)) * (num + 2));
  graph->color[0] = 2;
  graph->color[num + 1] = 3;
  graph->previous = malloc((sizeof(int)) * (num + 2));
  graph->edges = malloc((sizeof(Edge)) * (num + 2));
  for (i = 0; i <= (num + 1); i++)
  {
    graph->edges[i] = malloc((sizeof(struct edge)) * (num + 2));
    initializeEdges(graph, i);
  }

  return graph;
}

void initializeEdges(Graph graph, int index)
{
  int i;
  for (i = 0; i < graph->numVertices; i++)
  {
    graph->edges[index][i].max = 0;
    graph->edges[index][i].capacidade = 0;
  }

}

void addEdge(Graph graph, int custoX, int custoY, int processo)
{
  graph->edges[processo][0].max = custoX;
  graph->edges[0][processo].max = custoX;
  graph->edges[processo][graph->numVertices - 1].max = custoY;
  graph->edges[graph->numVertices - 1][processo].max = custoY;
}

void addCom(Graph graph, int ver1, int ver2, int custo)
{
  graph->edges[ver1][ver2].max = custo;
  graph->edges[ver2][ver1].max = custo;
}

void ED(Graph graph, int source, int sink)
{
  int u;
  int v;
  while (isReachable(graph, source, sink))
  {
    int minFlow = 32767;
    for (v = sink; v != source; v = graph->previous[v])
    {
      u = graph->previous[v];
      minFlow = min(minFlow, graph->edges[u][v].max - graph->edges[u][v].capacidade);
    }

    for (v = sink; v != source; v = graph->previous[v])
    {
      u = graph->previous[v];
      graph->edges[u][v].capacidade += minFlow;
      graph->edges[v][u].capacidade += minFlow;
    }

  }

}

int isReachable(Graph graph, int source, int sink)
{
  int i;
  int history[graph->numVertices];
  for (i = 0; i < graph->numVertices; i++)
    history[i] = 0;

  Queue queue = initQueue();
  queue = pushQueue(queue, source);
  history[source] = 1;
  graph->previous[source] = -1;
  while (queue->head)
  {
    int s = queue->tail->vertice;
    queue = popQueue(queue);
    for (i = 0; i < graph->numVertices; i++)
    {
      if ((history[i] == 0) && ((graph->edges[s][i].max - graph->edges[s][i].capacidade) > 0))
      {
        if (i == sink)
        {
          graph->previous[i] = s;
          return 1;
        }
        else
        {
          
        }

        queue = pushQueue(queue, i);
        graph->previous[i] = s;
        history[i] = 1;
      }
      else
      {
        
      }

    }

  }

  return 0;
}

void paint(Graph graph, int source, int sink, int color1, int color2)
{
  int i;
  int j;
  int custo = 0;
  int history[graph->numVertices];
  for (i = 0; i < graph->numVertices; i++)
  {
    graph->color[i] = color2;
    history[i] = 0;
  }

  Queue queue = initQueue();
  queue = pushQueue(queue, source);
  history[source] = 1;
  graph->color[source] = color1;
  while (queue->head != 0)
  {
    int s = queue->tail->vertice;
    queue = popQueue(queue);
    for (i = 0; i < graph->numVertices; i++)
    {
      if (((i != sink) && (history[i] == 0)) && ((graph->edges[s][i].max - graph->edges[s][i].capacidade) > 0))
      {
        queue = pushQueue(queue, i);
        graph->color[i] = color1;
        history[i] = 1;
      }
      else
      {
        
      }

    }

  }

  for (i = 0; i < graph->numVertices; i++)
  {
    for (j = i; j < graph->numVertices; j++)
    {
      if ((graph->color[i] != graph->color[j]) && (graph->edges[i][j].max == graph->edges[i][j].capacidade))
      {
        custo += graph->edges[i][j].max;
      }
      else
      {
        
      }

    }

  }

  custoMinimo = min(custoMinimo, custo);
}

Queue initQueue()
{
  Queue q;
  q = malloc(sizeof(struct queue));
  q->head = 0;
  q->tail = 0;
  return q;
}

Node createNode(int v)
{
  Node newNode = malloc(sizeof(struct node));
  newNode->vertice = v;
  newNode->prev = 0;
  newNode->next = 0;
  return newNode;
}

Queue pushQueue(Queue queue, int v)
{
  Node newNode = createNode(v);
  if (queue->head)
  {
    newNode->next = queue->head;
    queue->head->prev = newNode;
    queue->head = newNode;
    return queue;
  }
  else
  {
    
  }

  queue->head = newNode;
  queue->tail = newNode;
  return queue;
}

Queue popQueue(Queue queue)
{
  if (!queue->head)
  {
    return 0;
  }
  else
  {
    
  }

  if (queue->tail->prev)
  {
    queue->tail = queue->tail->prev;
    queue->tail->next = 0;
    free(queue->tail->next);
    return queue;
  }
  else
  {
    
  }

  free(queue->tail);
  queue->head = 0;
  queue->tail = 0;
  return queue;
}

