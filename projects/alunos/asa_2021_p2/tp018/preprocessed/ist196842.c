#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>


int fifoSize = 0;
int *array;
int narr = 0;
typedef struct node
{
  int id;
  int h;
  int e;
  int nViz;
  int *viz;
} Node;
typedef struct pipe
{
  int act;
  int max;
} Pipe;
struct qNode
{
  int data;
  struct qNode *next;
};
struct qNode *first = 0;
struct qNode *last = 0;
void add(int item)
{
  struct qNode *elm = malloc(sizeof(struct qNode));
  elm->data = item;
  elm->next = 0;
  if (last == 0)
  {
    first = elm;
    last = elm;
  }
  else
  {
    last->next = elm;
    last = last->next;
  }

}

void add2(int item)
{
  struct qNode *elm = malloc(sizeof(struct qNode));
  elm->data = item;
  elm->next = 0;
  if (last == 0)
  {
    first = elm;
    last = elm;
  }
  else
  {
    elm->next = first;
    first = elm;
  }

}

int rmv()
{
  if (first != last)
  {
    struct qNode *temp;
    temp = first;
    int temp2 = first->data;
    first = first->next;
    free(temp);
    return temp2;
  }
  else
  {
    
  }

  struct qNode *temp;
  temp = first;
  int temp2 = first->data;
  first = first->next;
  free(temp);
  first = 0;
  last = 0;
  return temp2;
}

int getSize()
{
  return fifoSize;
}

int gmin(int a, int b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    
  }

  return b;
}

void initPreF(Node *nodes, Pipe **pipes, int nNodes)
{
  int x;
  int Sn = 0;
  int f;
  for (x = 1; x <= nNodes; x++)
  {
    f = pipes[Sn][x].max;
    pipes[Sn][x].act = f;
    nodes[x].e = f;
    nodes[Sn].e -= f;
    add(x);
  }

}

void Push(Node *nodos, Pipe **pipes, int u, int v)
{
  int flow;
  flow = gmin(nodos[u].e, pipes[u][v].max - pipes[u][v].act);
  nodos[u].e -= flow;
  nodos[v].e += flow;
  pipes[u][v].act += flow;
  pipes[v][u].act -= flow;
}

void Relabel(Node *nodos, Pipe **pipes, int nodo, int minH)
{
  nodos[nodo].h += minH;
}

int getMinH(Node *nodos, Pipe **pipes, int nodo, int pmh)
{
  int minH = nodos[0].h;
  int i;
  for (i = 0; i < nodos[nodo].nViz; i++)
  {
    if ((nodos[nodos[nodo].viz[i]].h < minH) && ((nodos[nodos[nodo].viz[i]].h + 1) > pmh))
    {
      minH = nodos[nodos[nodo].viz[i]].h;
    }
    else
    {
      
    }

  }

  return minH + 1;
}

void Discharge(Node *nodos, Pipe **pipes, int nodo)
{
  int minH = nodos[0].h;
  int pmh = 0;
  int nViz = 0;
  int viz = nodos[nodo].viz[0];
  while (nodos[nodo].e > 0)
  {
    if (nViz == nodos[nodo].nViz)
    {
      minH = getMinH(nodos, pipes, nodo, pmh);
      pmh = minH;
      Relabel(nodos, pipes, nodo, minH);
      nViz = 0;
    }
    else
    {
      if ((pipes[nodo][viz].act < pipes[nodo][viz].max) && (nodos[nodo].h > nodos[viz].h))
      {
        Push(nodos, pipes, nodo, viz);
        ++nViz;
      }
      else
      {
        ++nViz;
      }

    }

    viz = nodos[nodo].viz[nViz];
  }

}

void addToArr(int v)
{
  array[narr++] = v;
}

int rmvFromArr()
{
  --narr;
  return array[narr];
}

void restoreQ()
{
  while (narr > 0)
  {
    add2(rmvFromArr());
  }

}

int main()
{
  int nNodes;
  int nEdges;
  int x;
  int y;
  int z;
  int w;
  int nPipes;
  int Sn;
  int sn;
  int np = 0;
  nNodes = new_sym_var(sizeof(int) * 8);
  nEdges = new_sym_var(sizeof(int) * 8);
  array = malloc(nNodes * (sizeof(int)));
  Sn = 0;
  sn = nNodes + 1;
  nPipes = nNodes + 2;
  Node *nodes = malloc((nNodes + 2) * (sizeof(Node)));
  for (x = 0; x <= (nNodes + 1); x++)
  {
    nodes[x].viz = malloc((nNodes + 2) * (sizeof(int)));
  }

  Pipe **pipes = (Pipe **) malloc(nPipes * (sizeof(Pipe *)));
  for (x = 0; x < nPipes; x++)
  {
    pipes[x] = (Pipe *) malloc(nPipes * (sizeof(Pipe)));
  }

  nodes[Sn].h = nNodes;
  nodes[sn].h = 0;
  for (x = 1; x <= nNodes; x++)
  {
    y = new_sym_var(sizeof(int) * 8);
    z = new_sym_var(sizeof(int) * 8);
    pipes[Sn][x].max = y;
    pipes[x][Sn].max = y;
    ++np;
    ++np;
    pipes[x][sn].max = z;
    ++np;
    nodes[x].h = 0;
    nodes[x].e = 0;
    nodes[x].viz[nodes[x].nViz] = sn;
    nodes[x].nViz += 1;
    nodes[x].viz[nodes[x].nViz] = Sn;
    nodes[x].nViz += 1;
  }

  for (x = 0; x < nEdges; x++)
  {
    y = new_sym_var(sizeof(int) * 8);
    z = new_sym_var(sizeof(int) * 8);
    w = new_sym_var(sizeof(int) * 8);
    pipes[y][z].max = w;
    pipes[z][y].max = w;
    pipes[y][z].act = 0;
    pipes[z][y].act = 0;
    ++np;
    ++np;
    nodes[y].viz[nodes[y].nViz] = z;
    nodes[y].nViz += 1;
    nodes[z].viz[nodes[z].nViz] = y;
    nodes[z].nViz += 1;
  }

  initPreF(nodes, pipes, nNodes);
  x = 0;
  int nodo;
  int oldh;
  while (nodes[Sn].e != (-nodes[sn].e))
  {
    if (x == nNodes)
    {
      break;
    }
    else
    {
      
    }

    nodo = rmv();
    oldh = nodes[nodo].h;
    if (nodes[nodo].e > 0)
    {
      Discharge(nodes, pipes, nodo);
    }
    else
    {
      
    }

    if (oldh < nodes[nodo].h)
    {
      if (narr > 0)
      {
        restoreQ();
      }
      else
      {
        
      }

      add2(nodo);
      x = 0;
    }
    else
    {
      ++x;
      addToArr(nodo);
    }

    ;
  }

  printf("%d\n", nodes[sn].e);
  for (x = 0; x <= (nNodes + 1); x++)
  {
    free(nodes[x].viz);
  }

  for (x = 0; x < nPipes; x++)
  {
    free(pipes[x]);
  }

  free(pipes);
  free(nodes);
  free(array);
  return 0;
}

