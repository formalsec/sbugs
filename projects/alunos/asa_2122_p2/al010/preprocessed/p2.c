#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include<stdio.h>
#include<stdlib.h>


typedef struct node
{
  int v;
  struct node *next;
} node;
typedef struct graph
{
  int n;
  node **adj;
} G;
G *newGraph(int n)
{
  int i;
  G *g = malloc(sizeof(G));
  g->n = n;
  g->adj = malloc(n * (sizeof(node *)));
  for (i = 0; i < n; i++)
  {
    g->adj[i] = 0;
  }

  return g;
}

node *newNode(int v)
{
  node *new = malloc(sizeof(node));
  new->v = v;
  new->next = 0;
  return new;
}

void newEdge(G *g, int s, int d)
{
  node *new = newNode(d);
  new->next = g->adj[s - 1];
  g->adj[s - 1] = new;
}

void printAdj(G *g)
{
  int i;
  node *tmp;
  for (i = 0; i < g->n; i++)
  {
    tmp = g->adj[i];
    while (tmp != 0)
    {
      printf("%d -> %d\n", i + 1, tmp->v);
      tmp = tmp->next;
    }

  }

}

int isCyclicAux(G *g, int v, int *visit, int *stack)
{
  node *iter;
  if (!visit[v - 1])
  {
    visit[v - 1] = 1;
    stack[v - 1] = 1;
    iter = g->adj[v - 1];
    while (iter != 0)
    {
      if ((!visit[iter->v - 1]) && isCyclicAux(g, iter->v, visit, stack))
      {
        return 1;
      }
      else
      {
        if (stack[iter->v - 1])
        {
          return 1;
        }
        else
        {
          
        }

      }

      iter = iter->next;
    }

  }
  else
  {
    
  }

  stack[v - 1] = 0;
  return 0;
}

int isCyclic(G *g)
{
  int *visit = malloc((sizeof(int)) * g->n);
  int *stack = malloc((sizeof(int)) * g->n);
  int i;
  for (i = 0; i < g->n; i++)
  {
    visit[i] = 0;
    stack[i] = 0;
  }

  for (i = 1; i <= g->n; i++)
  {
    if (isCyclicAux(g, i, visit, stack))
    {
      free(visit);
      free(stack);
      return 1;
    }
    else
    {
      
    }

  }

  free(visit);
  free(stack);
  return 0;
}

int DFSaux(G *g, int v, int *visited, int *canReach, int goal)
{
  node *aux = g->adj[v];
  visited[v] = 1;
  while (aux != 0)
  {
    if (!visited[aux->v - 1])
    {
      if (aux->v == goal)
      {
        return 1;
      }
      else
      {
        
      }

      if (DFSaux(g, aux->v - 1, visited, canReach, goal))
      {
        canReach[aux->v - 1] = 1;
        return 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (canReach[aux->v - 1] == 1)
      {
        return 1;
      }
      else
      {
        
      }

    }

    aux = aux->next;
  }

  return 0;
}

int *findVDFS(G *g, int v)
{
  int *visited;
  int i;
  int *canReach;
  visited = malloc(g->n * (sizeof(int)));
  canReach = malloc(g->n * (sizeof(int)));
  for (i = 0; i < g->n; i++)
  {
    visited[i] = 0;
    canReach[i] = 0;
  }

  for (i = 0; i < g->n; i++)
  {
    if (!visited[i])
    {
      if (DFSaux(g, i, visited, canReach, v))
      {
        canReach[i] = 1;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  free(visited);
  return canReach;
}

void freeGraph(G *g)
{
  int i;
  node *tmp;
  for (i = 0; i < g->n; i++)
  {
    while (g->adj[i] != 0)
    {
      tmp = g->adj[i];
      g->adj[i] = g->adj[i]->next;
      free(tmp);
    }

  }

  free(g->adj);
  free(g);
}

int isTree(G *g, int *connected, int *nParents)
{
  int i;
  for (i = 0; i < g->n; i++)
  {
    if (nParents[i] > 2)
    {
      printf("0\n");
      return 0;
    }
    else
    {
      
    }

  }

  if (isCyclic(g))
  {
    printf("0\n");
    return 0;
  }
  else
  {
    
  }

  return 1;
}

int zeroOutDeg(G *g, int v, int *common, int n)
{
  int i;
  node *tmp = g->adj[v];
  while (tmp != 0)
  {
    for (i = 0; i < n; i++)
    {
      if (tmp->v == (common[i] + 1))
      {
        return 0;
      }
      else
      {
        
      }

    }

    tmp = tmp->next;
  }

  return 1;
}

int main(int argc, const char *argv[])
{
  int v1;
  int v2;
  int nV;
  int nE;
  int i;
  int a;
  int b;
  int count = 0;
  G *g;
  v1 = (v2 = (nV = (nE = (a = (b = 0)))));
  int *connected;
  int *nParents;
  int *reachV1;
  int *reachV2;
  int *commonAncestors;
  commonAncestors = (reachV1 = (reachV2 = 0));
  if (2 != 2)
  {
    return -1;
  }
  else
  {
    v1 = new_sym_var(sizeof(int) * 8);
    v2 = new_sym_var(sizeof(int) * 8);
    
  }

  if (2 != 2)
  {
    return -1;
  }
  else
  {
    nV = new_sym_var(sizeof(int) * 8);
    nE = new_sym_var(sizeof(int) * 8);
    
  }

  connected = malloc((sizeof(int)) * nV);
  nParents = malloc((sizeof(int)) * nV);
  for (i = 0; i < nV; i++)
  {
    nParents[i] = 0;
    connected[i] = 0;
  }

  g = newGraph(nV);
  for (i = 0; i < nE; i++)
  {
    if (2 != 2)
    {
      return -1;
    }
    else
    {
      a = new_sym_var(sizeof(int) * 8);
      b = new_sym_var(sizeof(int) * 8);
      
    }

    newEdge(g, a, b);
    connected[a - 1] = 1;
    connected[b - 1] = 1;
    nParents[b - 1]++;
  }

  if (isTree(g, connected, nParents))
  {
    reachV1 = findVDFS(g, v1);
    reachV2 = findVDFS(g, v2);
    commonAncestors = malloc((sizeof(int)) * nV);
    for (i = 0; i < g->n; i++)
    {
      if ((reachV1[i] == 1) && (reachV2[i] == 1))
      {
        commonAncestors[i] = 1;
        commonAncestors[count] = i;
        count++;
      }
      else
      {
        commonAncestors[i] = 0;
      }

    }

    if (count == 0)
    {
      printf("-\n");
    }
    else
    {
      commonAncestors = realloc(commonAncestors, count * (sizeof(int)));
      for (i = 0; i < count; i++)
      {
        if (zeroOutDeg(g, commonAncestors[i], commonAncestors, count))
        {
          printf("%d ", commonAncestors[i] + 1);
        }
        else
        {
          
        }

      }

      printf("\n");
    }

  }
  else
  {
    
  }

  free(connected);
  free(nParents);
  free(commonAncestors);
  free(reachV1);
  free(reachV2);
  freeGraph(g);
  return 0;
}

