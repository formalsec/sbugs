#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>


typedef struct queue_el
{
  int id;
  struct queue_el *next;
} QueueEl;
typedef struct queue
{
  QueueEl *first;
  QueueEl *last;
} Queue;
typedef struct associationNode
{
  int id;
  struct associationNode *nextNode;
} AssociationNode;
typedef struct Basenode
{
  int color;
  int colorPredecessor;
  int count;
  int inDegree;
  AssociationNode *firstNode;
  AssociationNode *lastNode;
} BaseNode;
typedef struct graph
{
  int dim;
  BaseNode *nodes;
} Graph;
QueueEl *newQueueEl(int id)
{
  QueueEl *el = (QueueEl *) malloc(sizeof(QueueEl));
  el->id = id;
  el->next = 0;
  return el;
}

void freeQueueEl(QueueEl *el)
{
  free(el);
}

Queue *newQueue()
{
  Queue *q = (Queue *) malloc(sizeof(Queue));
  q->first = 0;
  q->last = 0;
  return q;
}

void freeQueue(Queue *q)
{
  QueueEl *aux1;
  QueueEl *aux2;
  aux1 = q->first;
  while (aux1)
  {
    aux2 = aux1->next;
    freeQueueEl(aux1);
    aux1 = aux2;
  }

  free(q);
}

int isQueueEmpty(Queue *q)
{
  if (!q->first)
  {
    return -1;
  }
  else
  {
    
  }

  return 0;
}

void enQueue(Queue *q, int id)
{
  QueueEl *el = newQueueEl(id);
  if (isQueueEmpty(q))
  {
    q->first = el;
  }
  else
  {
    q->last->next = el;
  }

  q->last = el;
}

int deQueue(Queue *q)
{
  QueueEl *el;
  int id;
  if (isQueueEmpty(q))
  {
    return 0;
  }
  else
  {
    
  }

  el = q->first;
  if (!q->first->next)
  {
    q->first = 0;
    q->last = 0;
  }
  else
  {
    q->first = el->next;
  }

  id = el->id;
  freeQueueEl(el);
  return id;
}

Graph *newGraph(int dim)
{
  int i;
  Graph *g = malloc(sizeof(Graph));
  BaseNode *b;
  g->dim = dim;
  g->nodes = malloc(g->dim * (sizeof(BaseNode)));
  b = g->nodes;
  for (i = 0; i < g->dim; i++)
  {
    (b + i)->color = 0;
    (b + i)->colorPredecessor = 0;
    (b + i)->count = 0;
    (b + i)->inDegree = 0;
    (b + i)->firstNode = 0;
    (b + i)->lastNode = 0;
  }

  return g;
}

void freeGraph(Graph *g)
{
  int i;
  BaseNode *b;
  AssociationNode *a1;
  AssociationNode *a2;
  for (i = 0; i < g->dim; i++)
  {
    b = g->nodes + i;
    a1 = b->firstNode;
    while (a1)
    {
      a2 = a1->nextNode;
      free(a1);
      a1 = a2;
    }

  }

  free(g->nodes);
  free(g);
}

void newNode(Graph *g, int from, int to)
{
  BaseNode *b1 = g->nodes + from;
  BaseNode *b2 = (g->nodes + to) - 1;
  AssociationNode *a = malloc(sizeof(AssociationNode));
  a->id = to;
  a->nextNode = 0;
  b2->inDegree = b2->inDegree + 1;
  if (b1->firstNode == 0)
  {
    b1->firstNode = a;
  }
  else
  {
    b1->lastNode->nextNode = a;
  }

  b1->lastNode = a;
}

int isGraphAcyclic(Graph *g)
{
  int i;
  int actual_node;
  int visited_nodes = 0;
  BaseNode *b = g->nodes;
  AssociationNode *a;
  Queue *q = newQueue();
  for (i = 0; i < g->dim; i++)
  {
    if ((b + i)->inDegree == 0)
    {
      enQueue(q, i + 1);
    }
    else
    {
      
    }

  }

  while (isQueueEmpty(q) != (-1))
  {
    actual_node = deQueue(q);
    visited_nodes = visited_nodes + 1;
    a = ((b + actual_node) - 1)->firstNode;
    while (a != 0)
    {
      ((b + a->id) - 1)->inDegree = ((b + a->id) - 1)->inDegree - 1;
      if (((b + a->id) - 1)->inDegree == 0)
      {
        enQueue(q, a->id);
      }
      else
      {
        
      }

      a = a->nextNode;
    }

  }

  freeQueue(q);
  if (visited_nodes == g->dim)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

void bfs(Graph *g, int root)
{
  int actual_node;
  BaseNode *b = g->nodes;
  AssociationNode *a;
  Queue *q = newQueue();
  enQueue(q, root);
  ((b + root) - 1)->color = 1;
  ((b + root) - 1)->colorPredecessor = ((b + root) - 1)->colorPredecessor + 1;
  while (isQueueEmpty(q) != (-1))
  {
    actual_node = deQueue(q);
    ((b + actual_node) - 1)->color = 2;
    a = ((b + actual_node) - 1)->firstNode;
    while (a != 0)
    {
      if (((b + a->id) - 1)->color == 0)
      {
        enQueue(q, a->id);
        ((b + a->id) - 1)->color = 1;
        ((b + a->id) - 1)->colorPredecessor = ((b + a->id) - 1)->colorPredecessor + 1;
      }
      else
      {
        
      }

      a = a->nextNode;
    }

  }

  freeQueue(q);
}

void lca(Graph *g, int v1, int v2)
{
  int i;
  int nodes_in_common = 0;
  int len_str = 1;
  char *string = (char *) malloc(len_str);
  BaseNode *b = g->nodes;
  AssociationNode *a;
  memset(string, '\0', len_str);
  bfs(g, v1);
  for (i = 0; i < g->dim; i++)
  {
    (b + i)->color = 0;
  }

  bfs(g, v2);
  for (i = 0; i < g->dim; i++)
  {
    if ((b + i)->colorPredecessor == 2)
    {
      a = (b + i)->firstNode;
      while (a != 0)
      {
        ((b + a->id) - 1)->count = ((b + a->id) - 1)->count + 1;
        a = a->nextNode;
      }

    }
    else
    {
      
    }

  }

  for (i = 0; i < g->dim; i++)
  {
    if ((b + i)->colorPredecessor == 2)
    {
      if ((b + i)->count == 0)
      {
        nodes_in_common = nodes_in_common + 1;
        len_str = (len_str + log10(i + 1)) + 3;
        string = (char *) realloc(string, len_str);
        char *aux = (char *) malloc(log10(i + 1) + 3);
        sprintf(aux, "%d ", i + 1);
        strcat(string, aux);
        free(aux);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  if (nodes_in_common != 0)
  {
    printf("%s\n", string);
  }
  else
  {
    printf("-\n");
  }

  free(string);
}

int main()
{
  int i;
  int v1;
  int v2;
  int num_persons;
  int num_associations;
  int tmp1;
  int tmp2;
  int graphic_is_acyclic;
  if (2)
  {
    v1 = new_sym_var(sizeof(int) * 8);
    v2 = new_sym_var(sizeof(int) * 8);
    if (2)
    {
      num_persons = new_sym_var(sizeof(int) * 8);
      num_associations = new_sym_var(sizeof(int) * 8);
      Graph *g = newGraph(num_persons);
      for (i = 0; i < num_associations; i++)
      {
        if (2)
        {
          tmp1 = new_sym_var(sizeof(int) * 8);
          tmp2 = new_sym_var(sizeof(int) * 8);
          newNode(g, tmp2 - 1, tmp1);
        }
        else
        {
          
        }

      }

      graphic_is_acyclic = isGraphAcyclic(g);
      if (graphic_is_acyclic == 1)
      {
        lca(g, v1, v2);
      }
      else
      {
        printf("0\n");
      }

      freeGraph(g);
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  return 0;
}

