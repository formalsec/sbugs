#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


struct node
{
  int ancestors[2];
  int num_ancestors;
  int color;
};
typedef struct node NODE;
static NODE *graph;
static int exist_ancestors = 0;
void read_graph(int n, int m)
{
  int x;
  int y;
  graph = (NODE *) calloc(n, sizeof(NODE));
  NODE *node_ptr;
  while ((--m) >= 0)
  {
    x = new_sym_var(sizeof(int) * 8);
    y = new_sym_var(sizeof(int) * 8);
    node_ptr = &graph[y - 1];
    node_ptr->ancestors[node_ptr->num_ancestors++] = --x;
    if (node_ptr->num_ancestors > 2)
    {
      printf("0\n");
      exit(0);
    }
    else
    {
      
    }

  }

}

void find_cycles_visit(int v)
{
  int i;
  graph[v].color = 1;
  for (i = 0; i < graph[v].num_ancestors; ++i)
  {
    if (graph[graph[v].ancestors[i]].color == 0)
    {
      find_cycles_visit(graph[v].ancestors[i]);
    }
    else
    {
      if (graph[graph[v].ancestors[i]].color == 1)
      {
        printf("0\n");
        exit(0);
      }
      else
      {
        
      }

    }

  }

  graph[v].color = 2;
}

void find_cycles(int n)
{
  int v;
  for (v = 0; v < n; ++v)
  {
    if (graph[v].color == 0)
    {
      find_cycles_visit(v);
    }
    else
    {
      
    }

  }

}

void find_ancestors_v1(int v)
{
  int i;
  if (graph[v].color == 1)
  {
    return;
  }
  else
  {
    
  }

  graph[v].color = 1;
  for (i = 0; i < graph[v].num_ancestors; i++)
    find_ancestors_v1(graph[v].ancestors[i]);

}

void fill_ancestors_red(int v)
{
  int i;
  if (graph[v].color == (-1))
  {
    return;
  }
  else
  {
    
  }

  graph[v].color = -1;
  for (i = 0; i < graph[v].num_ancestors; i++)
  {
    fill_ancestors_red(graph[v].ancestors[i]);
  }

}

void find_ancestors_v2(int v)
{
  int i;
  if (graph[v].color == (-1))
  {
    return;
  }
  else
  {
    
  }

  if (graph[v].color == 1)
  {
    graph[v].color = 3;
    exist_ancestors = 1;
    for (i = 0; i < graph[v].num_ancestors; i++)
      fill_ancestors_red(graph[v].ancestors[i]);

  }
  else
  {
    for (i = 0; i < graph[v].num_ancestors; i++)
      find_ancestors_v2(graph[v].ancestors[i]);

  }

}

void print_lca(int n)
{
  int i;
  if (!exist_ancestors)
  {
    printf("-\n");
  }
  else
  {
    for (i = 0; i < n; i++)
      if (graph[i].color == 3)
    {
      printf("%d ", i + 1);
    }
    else
    {
      
    }


    printf("\n");
  }

}

int main()
{
  int v1;
  int v2;
  int n;
  int m;
  v1 = new_sym_var(sizeof(int) * 8);
  v2 = new_sym_var(sizeof(int) * 8);
  n = new_sym_var(sizeof(int) * 8);
  m = new_sym_var(sizeof(int) * 8);
  read_graph(n, m);
  find_cycles(n);
  find_ancestors_v1(--v1);
  find_ancestors_v2(--v2);
  print_lca(n);
  return 0;
}

