/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct A
{
  int id;
  int parent1;
  int parent2;
  int hasBeenVisited;
} Child;
Child *familyTree;
int *sol;
int *queue1;
int *queue2;
int isValidTree(int len);
int cicleDetected(int el);
void removeFromQueue(int *a, int len);
int addToQueue(int *a, int len, int el);
void firstBFS(int len, int el);
int secondBFS(int len, int el, int el2, int *s);
void bfsDelete(int len, int el);
int main()
{
  int v1;
  int v2;
  int n;
  int m;
  int i;
  int child;
  int parent;
  int check;
  v1 = new_sym_var(sizeof(int) * 8);
  v2 = new_sym_var(sizeof(int) * 8);
  n = new_sym_var(sizeof(int) * 8);
  m = new_sym_var(sizeof(int) * 8);
  familyTree = (Child *) malloc((sizeof(Child)) * n);
  sol = (int *) malloc((sizeof(int)) * n);
  queue1 = (int *) malloc((sizeof(int)) * n);
  queue2 = (int *) malloc((sizeof(int)) * n);
  if ((((((m < 0) || (v1 > n)) || (v1 < 1)) || (v2 > n)) || (v2 < 1)) || (n < 1))
  {
    putchar('0');
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < n; i++)
  {
    Child temp;
    temp.id = i + 1;
    temp.parent1 = 0;
    temp.parent2 = 0;
    temp.hasBeenVisited = 0;
    familyTree[i] = temp;
    sol[i] = 0;
    queue1[i] = 0;
    queue2[i] = 0;
  }

  for (i = 0; i < m; i++)
  {
    parent = new_sym_var(sizeof(int) * 8);
    child = new_sym_var(sizeof(int) * 8);
    if (((((child > n) || (child < 0)) || (parent > n)) || (parent < 0)) || (child == parent))
    {
      putchar('0');
      putchar('\n');
      return 0;
    }
    else
    {
      
    }

    if (familyTree[child - 1].parent1 == 0)
    {
      familyTree[child - 1].parent1 = parent;
    }
    else
    {
      if ((familyTree[child - 1].parent2 == 0) && (familyTree[child - 1].parent1 != parent))
      {
        familyTree[child - 1].parent2 = parent;
      }
      else
      {
        putchar('\n');
        return 0;
      }

    }

  }

  if (!isValidTree(n))
  {
    putchar('0');
    putchar('\n');
    return 0;
  }
  else
  {
    
  }

  if (v1 == v2)
  {
    printf("%d \n", v1);
    return 0;
  }
  else
  {
    
  }

  if ((familyTree[v1 - 1].parent1 == v2) || (familyTree[v1 - 1].parent2 == v2))
  {
    printf("%d \n", v2);
    return 0;
  }
  else
  {
    
  }

  if ((familyTree[v2 - 1].parent1 == v1) || (familyTree[v2 - 1].parent2 == v1))
  {
    printf("%d \n", v1);
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < n; i++)
  {
    familyTree[i].hasBeenVisited = 0;
  }

  if ((familyTree[v1 - 1].parent1 == 0) && (familyTree[v1 - 1].parent2 == 0))
  {
    if ((familyTree[v2 - 1].parent1 == 0) && (familyTree[v2 - 1].parent2 == 0))
    {
      printf("-\n");
      return 0;
    }
    else
    {
      
    }

    firstBFS(n, v2);
    if (familyTree[v1 - 1].hasBeenVisited == 1)
    {
      printf("%d \n", v1);
      return 0;
    }
    else
    {
      printf("-\n");
      return 0;
    }

  }
  else
  {
    if ((familyTree[v2 - 1].parent1 == 0) && (familyTree[v2 - 1].parent2 == 0))
    {
      firstBFS(n, v1);
      if (familyTree[v2 - 1].hasBeenVisited == 1)
      {
        printf("%d \n", v2);
        return 0;
      }
      else
      {
        printf("-\n");
        return 0;
      }

    }
    else
    {
      
    }

  }

  firstBFS(n, v1);
  if (familyTree[v2 - 1].hasBeenVisited == 1)
  {
    printf("%d \n", v2);
    return 0;
  }
  else
  {
    
  }

  check = secondBFS(n, v2, v1, &sol[0]);
  if (check == 1)
  {
    printf("%d \n", v1);
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < n; i++)
  {
    if ((sol[i] == 1) && (familyTree[i].hasBeenVisited != (-1)))
    {
      printf("%d ", i + 1);
      check = 1;
    }
    else
    {
      
    }

  }

  if (check == 0)
  {
    printf("-\n");
  }
  else
  {
    putchar('\n');
  }

  return 0;
}

void removeFromQueue(int *a, int len)
{
  int i;
  int elem;
  int n = 0;
  for (i = len - 1; i >= 0; i--)
  {
    elem = a[i];
    a[i] = n;
    n = elem;
  }

}

int addToQueue(int *a, int len, int el)
{
  int i;
  for (i = 0; i < len; i++)
  {
    if (a[i] == 0)
    {
      a[i] = el;
      return 1;
    }
    else
    {
      
    }

  }

  return 0;
}

int isValidTree(int len)
{
  int i;
  for (i = 0; i < len; i++)
  {
    if (familyTree[i].hasBeenVisited != (-4))
    {
      if (cicleDetected(i + 1))
      {
        return 0;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return 1;
}

int cicleDetected(int el)
{
  int p1;
  int p2;
  familyTree[el - 1].hasBeenVisited = 4;
  p1 = familyTree[el - 1].parent1;
  p2 = familyTree[el - 1].parent2;
  if (p1 != 0)
  {
    if (familyTree[p1 - 1].hasBeenVisited == 4)
    {
      return 1;
    }
    else
    {
      if (familyTree[p1 - 1].hasBeenVisited != (-4))
      {
        if (cicleDetected(p1))
        {
          return 1;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  if (p2 != 0)
  {
    if (familyTree[p2 - 1].hasBeenVisited == 4)
    {
      return 1;
    }
    else
    {
      if (familyTree[p2 - 1].hasBeenVisited != (-4))
      {
        if (cicleDetected(p2))
        {
          return 1;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  familyTree[el - 1].hasBeenVisited = -4;
  return 0;
}

void firstBFS(int len, int el)
{
  int p1;
  int p2;
  Child current = familyTree[el - 1];
  addToQueue(&queue1[0], len, el);
  current.hasBeenVisited = 1;
  while (queue1[0] != 0)
  {
    current = familyTree[queue1[0] - 1];
    p1 = current.parent1;
    p2 = current.parent2;
    if ((p1 != 0) && (!familyTree[p1 - 1].hasBeenVisited))
    {
      addToQueue(&queue1[0], len, p1);
      familyTree[p1 - 1].hasBeenVisited = 1;
    }
    else
    {
      
    }

    if ((p2 != 0) && (!familyTree[p2 - 1].hasBeenVisited))
    {
      addToQueue(&queue1[0], len, p2);
      familyTree[p2 - 1].hasBeenVisited = 1;
    }
    else
    {
      
    }

    removeFromQueue(&queue1[0], len);
  }

}

int secondBFS(int len, int el, int el2, int *s)
{
  int p1;
  int p2;
  Child current;
  addToQueue(&queue1[0], len, el);
  while (queue1[0] != 0)
  {
    current = familyTree[queue1[0] - 1];
    p1 = current.parent1;
    p2 = current.parent2;
    if (current.id == el2)
    {
      return 1;
    }
    else
    {
      
    }

    if (current.hasBeenVisited == 1)
    {
      s[current.id - 1] = 1;
      bfsDelete(len, current.id);
    }
    else
    {
      if (((p1 != 0) && (familyTree[p1 - 1].hasBeenVisited != (-1))) && (familyTree[p1 - 1].hasBeenVisited != 2))
      {
        addToQueue(&queue1[0], len, p1);
        if (familyTree[p1 - 1].hasBeenVisited != 1)
        {
          familyTree[p1 - 1].hasBeenVisited = 2;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      if (((p2 != 0) && (familyTree[p2 - 1].hasBeenVisited != (-1))) && (familyTree[p2 - 1].hasBeenVisited != 2))
      {
        addToQueue(&queue1[0], len, p2);
        if (familyTree[p2 - 1].hasBeenVisited != 1)
        {
          familyTree[p2 - 1].hasBeenVisited = 2;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    removeFromQueue(&queue1[0], len);
  }

  return 0;
}

void bfsDelete(int len, int el)
{
  int p1;
  int p2;
  Child current;
  addToQueue(&queue2[0], len, el);
  while (queue2[0] != 0)
  {
    current = familyTree[queue2[0] - 1];
    p1 = current.parent1;
    p2 = current.parent2;
    if (p1 != 0)
    {
      addToQueue(&queue2[0], len, p1);
      familyTree[p1 - 1].hasBeenVisited = -1;
    }
    else
    {
      
    }

    if (p2 != 0)
    {
      addToQueue(&queue2[0], len, p2);
      familyTree[p2 - 1].hasBeenVisited = -1;
    }
    else
    {
      
    }

    removeFromQueue(&queue2[0], len);
  }

}

