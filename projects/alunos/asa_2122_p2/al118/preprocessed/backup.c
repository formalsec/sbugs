/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>


int addEdge(int u, int v);
void prepara();
int dfs();
int visit(int node);
int novo_visit(int node);
void prepara_again();
int limpar_ancestrais();
void swap();
void bubbleSort(int arr[], int n);
typedef struct 
{
  int cor;
  int nfilhos;
  int *filhos;
  int count;
} Node;
typedef struct 
{
  int cor;
  int nfilhos;
  int *filhos;
} NodeOutro;
NodeOutro *grafo;
Node *transposed;
int *ancestrais;
int *finais;
int numero_ancestrais = 0;
int contador3 = 0;
int nodes;
int edges;
int invalid = 0;
int main()
{
  int i;
  int vertice1;
  int vertice2;
  int primeiro;
  int segundo;
  vertice1 = new_sym_var(sizeof(int) * 8);
  vertice2 = new_sym_var(sizeof(int) * 8);
  nodes = new_sym_var(sizeof(int) * 8);
  edges = new_sym_var(sizeof(int) * 8);
  grafo = malloc((sizeof(Node)) * nodes);
  transposed = malloc((sizeof(Node)) * nodes);
  ancestrais = malloc(sizeof(int));
  finais = malloc(sizeof(int));
  prepara();
  for (i = 0; i < edges; i++)
  {
    primeiro = new_sym_var(sizeof(int) * 8);
    segundo = new_sym_var(sizeof(int) * 8);
    addEdge(primeiro, segundo);
  }

  dfs();
  if (invalid == 1)
  {
    printf("0\n");
    return 0;
  }
  else
  {
    
  }

  novo_visit(vertice1);
  prepara_again();
  novo_visit(vertice2);
  if (numero_ancestrais == 0)
  {
    printf("-\n");
    return 0;
  }
  else
  {
    
  }

  limpar_ancestrais();
  bubbleSort(finais, contador3);
  for (i = 0; i < contador3; i++)
  {
    printf("%d ", finais[i]);
  }

  printf("\n");
  return 0;
}

int addEdge(int u, int v)
{
  if (grafo[u].nfilhos == 0)
  {
    grafo[u].nfilhos = 1;
    grafo[u].filhos = malloc(sizeof(int));
    grafo[u].filhos[0] = v;
  }
  else
  {
    
  }

  if (transposed[v].nfilhos == 0)
  {
    transposed[v].nfilhos = 1;
    transposed[v].filhos = malloc(sizeof(int));
    transposed[v].filhos[0] = u;
  }
  else
  {
    
  }

  if (grafo[u].nfilhos > 0)
  {
    int i;
    grafo[u].nfilhos++;
    int *carry1 = malloc((sizeof(int)) * grafo[u].nfilhos);
    for (i = 0; i < (grafo[u].nfilhos - 1); i++)
    {
      carry1[i] = grafo[u].filhos[i];
    }

    carry1[grafo[u].nfilhos - 1] = v;
    grafo[u].filhos = carry1;
  }
  else
  {
    
  }

  if (transposed[v].nfilhos > 0)
  {
    int i;
    transposed[v].nfilhos++;
    int *carry2 = malloc((sizeof(int)) * transposed[v].nfilhos);
    for (i = 0; i < (transposed[v].nfilhos - 1); i++)
    {
      carry2[i] = transposed[v].filhos[i];
    }

    carry2[transposed[v].nfilhos - 1] = u;
    transposed[v].filhos = carry2;
  }
  else
  {
    
  }

  return 0;
}

void prepara()
{
  int i;
  for (i = 1; i <= nodes; i++)
  {
    grafo[i].cor = 0;
    grafo[i].nfilhos = 0;
    grafo[i].filhos = 0;
    transposed[i].cor = 0;
    transposed[i].nfilhos = 0;
    transposed[i].filhos = 0;
    transposed[i].count = 0;
  }

}

int dfs()
{
  int i;
  for (i = 1; i <= nodes; i++)
  {
    if (grafo[i].cor == 0)
    {
      visit(i);
    }
    else
    {
      
    }

  }

  return 0;
}

int visit(int node)
{
  grafo[node].cor = 1;
  int i;
  for (i = 0; i < grafo[node].nfilhos; i++)
  {
    if (grafo[grafo[node].filhos[i]].cor == 1)
    {
      invalid = 1;
    }
    else
    {
      if (grafo[grafo[node].filhos[i]].cor == 0)
      {
        visit(grafo[node].filhos[i]);
      }
      else
      {
        
      }

    }

  }

  grafo[node].cor = 2;
  return 0;
}

int novo_visit(int node)
{
  int i;
  int j;
  transposed[node].cor = 1;
  transposed[node].count++;
  if (transposed[node].count == 2)
  {
    numero_ancestrais++;
    int *carry3 = malloc((sizeof(int)) * numero_ancestrais);
    for (j = 0; j < numero_ancestrais; j++)
    {
      carry3[j] = ancestrais[j];
    }

    carry3[numero_ancestrais - 1] = node;
    ancestrais = carry3;
  }
  else
  {
    
  }

  for (i = 0; i < transposed[node].nfilhos; i++)
  {
    if (transposed[transposed[node].filhos[i]].cor == 0)
    {
      novo_visit(transposed[node].filhos[i]);
    }
    else
    {
      
    }

  }

  transposed[node].cor = 2;
  return 0;
}

void prepara_again()
{
  int i;
  for (i = 1; i <= nodes; i++)
  {
    transposed[i].cor = 0;
  }

}

int limpar_ancestrais()
{
  int i;
  int j;
  int k;
  int l;
  for (i = 0; i < numero_ancestrais; i++)
  {
    int helper = ancestrais[i];
    int contador2 = 0;
    int contador = 0;
    for (j = 0; j < grafo[helper].nfilhos; j++)
    {
      for (k = 0; k < numero_ancestrais; k++)
      {
        if (grafo[helper].filhos[j] != ancestrais[k])
        {
          contador++;
        }
        else
        {
          
        }

      }

      if (contador == numero_ancestrais)
      {
        contador2++;
      }
      else
      {
        
      }

      contador = 0;
    }

    if (contador2 == grafo[helper].nfilhos)
    {
      contador3++;
      int *carry4 = malloc((sizeof(int)) * contador3);
      for (l = 0; l < (contador3 - 1); l++)
      {
        carry4[l] = finais[l];
      }

      carry4[contador3 - 1] = helper;
      finais = carry4;
    }
    else
    {
      
    }

    contador2 = 0;
  }

  return 0;
}

void swap(int *xp, int *yp)
{
  int temp = *xp;
  *xp = *yp;
  *yp = temp;
}

void bubbleSort(int arr[], int n)
{
  int i;
  int j;
  bool swapped;
  for (i = 0; i < (n - 1); i++)
  {
    swapped = false;
    for (j = 0; j < ((n - i) - 1); j++)
    {
      if (arr[j] > arr[j + 1])
      {
        swap(&arr[j], &arr[j + 1]);
        swapped = true;
      }
      else
      {
        
      }

    }

    if (swapped == false)
    {
      break;
    }
    else
    {
      
    }

  }

}

