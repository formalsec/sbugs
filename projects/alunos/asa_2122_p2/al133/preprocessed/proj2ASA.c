/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct 
{
  int id;
  int color;
  int parent1;
  int parent2;
} node;
node **readInput(int *, int *, int *);
node **initNodeList(int);
bool validTree(node **, int);
bool validNode(node **, int);
int lowestCommonAncestors(node **, int, int);
void paintToRoot(node **, int, int);
int findWhite(node **, int);
void printCommonAncestors(node **, int);
int main()
{
  int id1;
  int id2;
  int nNodes;
  node **nodeList = readInput(&id1, &id2, &nNodes);
  if ((nodeList == 0) || (!validTree(nodeList, nNodes)))
  {
    printf("0\n");
    return 0;
  }
  else
  {
    
  }

  if (!lowestCommonAncestors(nodeList, id1, id2))
  {
    printf("-\n");
    return 0;
  }
  else
  {
    
  }

  printCommonAncestors(nodeList, nNodes);
  return 0;
}

node **readInput(int *id1, int *id2, int *nNodes)
{
  char line[100];
  fgets(line, 100, stdin);
  if (2 == EOF)
  {
    return 0;
  }
  else
  {
    for (int id1_index = 0; id1_index < 10; id1_index++)
    {
      id1[id1_index] = new_sym_var(sizeof(int) * 8);
    }

    for (int id2_index = 0; id2_index < 10; id2_index++)
    {
      id2[id2_index] = new_sym_var(sizeof(int) * 8);
    }

    
  }

  fgets(line, 100, stdin);
  int nEdges;
  if (2 == EOF)
  {
    return 0;
  }
  else
  {
    for (int nNodes_index = 0; nNodes_index < 10; nNodes_index++)
    {
      nNodes[nNodes_index] = new_sym_var(sizeof(int) * 8);
    }

    nEdges = new_sym_var(sizeof(int) * 8);
    
  }

  node **nodeList = initNodeList(*nNodes);
  int parent;
  int child;
  for (; 0 < nEdges; nEdges--)
  {
    fgets(line, 100, stdin);
    if (2 == EOF)
    {
      return 0;
    }
    else
    {
      parent = new_sym_var(sizeof(int) * 8);
      child = new_sym_var(sizeof(int) * 8);
      
    }

    node *childNode = nodeList[child - 1];
    if (childNode->parent1 == 0)
    {
      childNode->parent1 = parent;
    }
    else
    {
      if (childNode->parent2 == 0)
      {
        childNode->parent2 = parent;
      }
      else
      {
        return 0;
      }

    }

  }

  return nodeList;
}

node **initNodeList(int nNodes)
{
  node **nodeList = (node **) malloc((sizeof(node *)) * nNodes);
  int i = 0;
  for (; i < nNodes; i++)
  {
    node *n = (node *) malloc(sizeof(node));
    n->id = i + 1;
    n->color = 0;
    n->parent1 = 0;
    n->parent2 = 0;
    nodeList[i] = n;
  }

  return nodeList;
}

bool validTree(node **nodeList, int nNodes)
{
  int i = 0;
  for (; i < nNodes; i++)
  {
    if (!validNode(nodeList, i))
    {
      return false;
    }
    else
    {
      
    }

  }

  return true;
}

bool validNode(node **nodeList, int n)
{
  node *currentNode = nodeList[n];
  if (currentNode->color == 2)
  {
    return true;
  }
  else
  {
    
  }

  currentNode->color = 1;
  bool res = true;
  if (currentNode->parent1 != 0)
  {
    if (nodeList[currentNode->parent1 - 1]->color == 0)
    {
      res = res && validNode(nodeList, currentNode->parent1 - 1);
    }
    else
    {
      if (nodeList[currentNode->parent1 - 1]->color == 1)
      {
        return false;
      }
      else
      {
        
      }

    }

    if (currentNode->parent2 != 0)
    {
      if (nodeList[currentNode->parent2 - 1]->color == 0)
      {
        res = res && validNode(nodeList, currentNode->parent2 - 1);
      }
      else
      {
        if (nodeList[currentNode->parent2 - 1]->color == 1)
        {
          return false;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }
  else
  {
    
  }

  currentNode->color = 2;
  return res;
}

int lowestCommonAncestors(node **nodeList, int id1, int id2)
{
  nodeList[id1 - 1]->color = 0;
  paintToRoot(nodeList, id1, 0);
  return findWhite(nodeList, id2);
}

void paintToRoot(node **nodeList, int id, int color)
{
  node *currentNode = nodeList[id - 1];
  if (currentNode->parent1 != 0)
  {
    nodeList[currentNode->parent1 - 1]->color = color;
    paintToRoot(nodeList, currentNode->parent1, color);
    if (currentNode->parent2 != 0)
    {
      nodeList[currentNode->parent2 - 1]->color = color;
      paintToRoot(nodeList, currentNode->parent2, color);
    }
    else
    {
      
    }

  }
  else
  {
    
  }

}

int findWhite(node **nodeList, int id)
{
  node *currentNode = nodeList[id - 1];
  int res = 0;
  if (currentNode->color == 0)
  {
    currentNode->color = 1;
    res++;
    paintToRoot(nodeList, id, 2);
  }
  else
  {
    if (currentNode->color == 2)
    {
      if (currentNode->parent1 != 0)
      {
        res += findWhite(nodeList, currentNode->parent1);
        if (currentNode->parent2 != 0)
        {
          res += findWhite(nodeList, currentNode->parent2);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return res;
}

void printCommonAncestors(node **nodeList, int size)
{
  int i = 0;
  for (; i < size; i++)
  {
    node *currentNode = nodeList[i];
    if (currentNode->color == 1)
    {
      printf("%d ", currentNode->id);
    }
    else
    {
      
    }

    free(currentNode);
  }

  printf("\n");
  free(nodeList);
}

