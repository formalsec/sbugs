#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


enum color
{
  WHITE,
  GRAY,
  BLACK,
  RED
};
typedef struct node
{
  int vertex;
  struct node *next;
} *Node;
Node insert(Node head, int vertex)
{
  Node child = (Node) malloc(sizeof(struct node));
  child->vertex = vertex;
  child->next = 0;
  if (head == 0)
  {
    return child;
  }
  else
  {
    
  }

  if (head->next != 0)
  {
    return 0;
  }
  else
  {
    
  }

  if (head->vertex > vertex)
  {
    child->next = head;
    return child;
  }
  else
  {
    
  }

  if (head->next == 0)
  {
    head->next = child;
    return head;
  }
  else
  {
    
  }

  return head;
}

void destroy(Node head)
{
  if (head != 0)
  {
    destroy(head->next);
    free(head);
  }
  else
  {
    
  }

}

int DFS_visit(int u, int numV, Node adj[], enum color color[])
{
  color[u] = GRAY;
  Node n;
  for (n = adj[u]; n != 0; n = n->next)
  {
    int vertex = n->vertex - 1;
    enum color n_color = color[vertex];
    if (n_color == WHITE)
    {
      if (DFS_visit(vertex, numV, adj, color))
      {
        return 1;
      }
      else
      {
        
      }

    }
    else
    {
      if (n_color == GRAY)
      {
        return 1;
      }
      else
      {
        
      }

    }

  }

  color[u] = BLACK;
  return 0;
}

int DFS(int numV, Node adj[])
{
  enum color *color = (enum color *) malloc((sizeof(enum color)) * numV);
  int u;
  for (u = 0; u < numV; u++)
  {
    color[u] = WHITE;
  }

  for (u = 0; u < numV; u++)
  {
    if (color[u] == WHITE)
    {
      if (DFS_visit(u, numV, adj, color))
      {
        free(color);
        return 1;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  free(color);
  return 0;
}

void LCA_visit(int u, int numV, Node adj[], enum color color[], int mode)
{
  if (!mode)
  {
    color[u] = GRAY;
  }
  else
  {
    if (color[u] == GRAY)
    {
      color[u] = BLACK;
    }
    else
    {
      
    }

  }

  Node n;
  for (n = adj[u]; n != 0; n = n->next)
  {
    int vertex = n->vertex - 1;
    enum color n_color = color[vertex];
    if ((n_color == WHITE) || mode)
    {
      LCA_visit(vertex, numV, adj, color, mode);
    }
    else
    {
      
    }

  }

}

void LCA(int vertex1, int vertex2, int numV, Node adj[])
{
  enum color *color = (enum color *) malloc((sizeof(enum color)) * numV);
  int u;
  for (u = 0; u < numV; u++)
  {
    color[u] = WHITE;
  }

  LCA_visit(vertex1 - 1, numV, adj, color, 0);
  LCA_visit(vertex2 - 1, numV, adj, color, 1);
  for (u = 0; u < numV; u++)
  {
    Node n;
    if ((color[u] == BLACK) || (color[u] == RED))
    {
      for (n = adj[u]; n != 0; n = n->next)
      {
        int vertex = n->vertex - 1;
        enum color n_color = color[vertex];
        if (n_color == BLACK)
        {
          color[vertex] = RED;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  int numLCA = 0;
  for (u = 0; u < numV; u++)
  {
    if (color[u] == BLACK)
    {
      printf("%d ", u + 1);
      numLCA++;
    }
    else
    {
      
    }

  }

  if (numLCA == 0)
  {
    printf("-");
  }
  else
  {
    
  }

  printf("\n");
  free(color);
}

int main()
{
  int vertex1;
  int vertex2;
  int number_vertexes;
  int number_edges;
  int scan;
  int i;
  scan = 2;
  vertex1 = new_sym_var(sizeof(int) * 8);
  vertex2 = new_sym_var(sizeof(int) * 8);
  if (scan != 2)
  {
    printf("0\n");
    return 0;
  }
  else
  {
    
  }

  scan = 2;
  number_vertexes = new_sym_var(sizeof(int) * 8);
  number_edges = new_sym_var(sizeof(int) * 8);
  if (scan != 2)
  {
    printf("0\n");
    return 0;
  }
  else
  {
    
  }

  Node *adjList = (Node *) malloc((sizeof(Node)) * number_vertexes);
  for (i = 0; i < number_vertexes; i++)
    adjList[i] = 0;

  int temp_vertex1;
  int temp_vertex2;
  for (i = 0; i < number_edges; i++)
  {
    scan = 2;
    temp_vertex1 = new_sym_var(sizeof(int) * 8);
    temp_vertex2 = new_sym_var(sizeof(int) * 8);
    if (scan != 2)
    {
      printf("0\n");
      return 0;
    }
    else
    {
      
    }

    adjList[temp_vertex2 - 1] = insert(adjList[temp_vertex2 - 1], temp_vertex1);
    if (adjList[temp_vertex2 - 1] == 0)
    {
      printf("0\n");
      return 0;
    }
    else
    {
      
    }

  }

  if (DFS(number_vertexes, adjList))
  {
    printf("0\n");
    return 0;
  }
  else
  {
    
  }

  LCA(vertex1, vertex2, number_vertexes, adjList);
  for (i = 0; i < number_vertexes; i++)
    destroy(adjList[i]);

  free(adjList);
  return 0;
}

