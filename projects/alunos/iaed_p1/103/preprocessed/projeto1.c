#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  char nome[64];
  int preco;
  int peso;
  int stock;
} produto;
void cria_produto(produto vetor[], int i, char c[], int preco, int peso, int stock);
void cria_copia_produto(produto vetor1[], int d, produto vetor[], int f);
int produto_in_stock(produto p, int qtd);
int eh_idp(int n);
void altera_stock_produto(produto vetor[], int idp, int qtd);
typedef struct encomenda
{
  int peso;
  produto produtos[200];
  int n_produtos;
  int idps[200];
} encomenda;
int calcula_peso(encomenda e);
void novo_produto_encomenda(int ide, int idp, int qtd);
void adiciona_qtd_encomenda(int ide, int indice, int qtd);
int eh_ide(int ide);
int produto_em_encomenda(encomenda e, int ide);
void __a__();
void __q__();
void __N__();
void __A__();
void __r__();
void __R__();
void __C__();
void __p__();
void __E__();
void __m__();
void __l__();
void __L__();
void __x__();
void Merge_int(int A[], int esquerdo, int direito, int Fim, int B[], int v[], int v2[]);
void CopiaVetor_int(int B[], int A[], int n, int v2[], int v[]);
void MergeSort_int(int A[], int B[], int n, int v[], int v2[]);
void Merge_str(char A[][64], int esquerdo, int direito, int Fim, char B[][64], int v[], int v2[]);
void CopiaVetor_str(char B[][64], char A[][64], int n, int v2[], int v[]);
void MergeSort_str(char A[][64], char B[][64], int n, int v[], int v2[]);
produto sistema[10000];
encomenda encomendas[500];
int ultimo_idp;
int ultimo_ide;
int main()
{
  char c;
  ultimo_idp = -1;
  ultimo_ide = -1;
  while ((c = getchar()) != EOF)
  {
    switch (c)
    {
      case 'a':
        __a__();
        break;

      case 'q':
        __q__();
        break;

      case 'N':
        __N__();
        break;

      case 'A':
        __A__();
        break;

      case 'r':
        __r__();
        break;

      case 'R':
        __R__();
        break;

      case 'C':
        __C__();
        break;

      case 'p':
        __p__();
        break;

      case 'E':
        __E__();
        break;

      case 'm':
        __m__();
        break;

      case 'l':
        __l__();
        break;

      case 'L':
        __L__();
        break;

      case 'x':
        return 0;

    }

  }

  return 0;
}

void __a__()
{
  int preco;
  int peso;
  int qtd;
  char descricao[64];
  ++ultimo_idp;
  for (int descricao_index = 0; descricao_index < 10; descricao_index++)
  {
    descricao[descricao_index] = new_sym_var(sizeof(char) * 8);
  }

  descricao[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  cria_produto(sistema, ultimo_idp, descricao, preco, peso, qtd);
  printf("Novo produto %d.\n", ultimo_idp);
}

void __q__()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (eh_idp(idp) == 1)
  {
    altera_stock_produto(sistema, idp, qtd);
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void __N__()
{
  ultimo_ide++;
  encomendas[ultimo_ide].peso = 0;
  encomendas[ultimo_ide].n_produtos = 0;
  printf("Nova encomenda %d.\n", ultimo_ide);
}

void __A__()
{
  int ide;
  int idp;
  int qtd;
  int indice;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (eh_ide(ide) == (-1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (eh_idp(idp) == (-1))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (produto_in_stock(sistema[idp], qtd) == (-1))
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((encomendas[ide].peso + (qtd * sistema[idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          indice = produto_em_encomenda(encomendas[ide], idp);
          if (indice == (-1))
          {
            novo_produto_encomenda(ide, idp, qtd);
          }
          else
          {
            adiciona_qtd_encomenda(ide, indice, qtd);
            altera_stock_produto(sistema, idp, (-1) * qtd);
          }

        }

      }

    }

  }

}

void __r__()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (eh_idp(idp) == 1)
  {
    if (produto_in_stock(sistema[idp], qtd) == 1)
    {
      altera_stock_produto(sistema, idp, (-1) * qtd);
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }

}

void __R__()
{
  int ide;
  int idp;
  int qtd;
  int peso;
  int indice;
  int prods_enc;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (eh_ide(ide) == (-1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (eh_idp(idp) == (-1))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      indice = produto_em_encomenda(encomendas[ide], idp);
      if (indice != (-1))
      {
        qtd = encomendas[ide].produtos[indice].stock;
        peso = encomendas[ide].produtos[indice].peso;
        prods_enc = encomendas[ide].n_produtos - 1;
        encomendas[ide].peso -= qtd * peso;
        altera_stock_produto(sistema, idp, qtd);
        if (indice < prods_enc)
        {
          cria_copia_produto(encomendas[ide].produtos, prods_enc, encomendas[ide].produtos, indice);
          encomendas[ide].idps[indice] = encomendas[ide].idps[prods_enc];
          encomendas[ide].produtos[indice].stock = encomendas[ide].produtos[prods_enc].stock;
        }
        else
        {
          
        }

        cria_produto(encomendas[ide].produtos, prods_enc, "", 0, 0, 0);
        encomendas[ide].idps[prods_enc] = -1;
        encomendas[ide].n_produtos -= 1;
      }
      else
      {
        
      }

    }

  }

}

void __C__()
{
  int ide;
  int d;
  int total;
  ide = new_sym_var(sizeof(int) * 8);
  if (eh_ide(ide) == 1)
  {
    total = 0;
    for (d = 0; d < encomendas[ide].n_produtos; d++)
    {
      total += encomendas[ide].produtos[d].stock * encomendas[ide].produtos[d].preco;
    }

    printf("Custo da encomenda %d %d.\n", ide, total);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void __p__()
{
  int idp;
  int preco;
  int d;
  int indice;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (eh_idp(idp) == 1)
  {
    sistema[idp].preco = preco;
    for (d = 0; d <= ultimo_ide; d++)
    {
      indice = produto_em_encomenda(encomendas[d], idp);
      if (indice != (-1))
      {
        encomendas[d].produtos[indice].preco = preco;
      }
      else
      {
        
      }

    }

  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

void __E__()
{
  int ide;
  int idp;
  int indice;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (eh_ide(ide) == 1)
  {
    if (eh_idp(idp) == 1)
    {
      indice = produto_em_encomenda(encomendas[ide], idp);
      if (indice != (-1))
      {
        printf("%s %d.\n", encomendas[ide].produtos[indice].nome, encomendas[ide].produtos[indice].stock);
      }
      else
      {
        printf("%s 0.\n", sistema[idp].nome);
      }

    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void __m__()
{
  int idp;
  int ide;
  int qtd;
  int d;
  int indice;
  idp = new_sym_var(sizeof(int) * 8);
  if (eh_idp(idp) == 1)
  {
    ide = -1;
    qtd = -1;
    for (d = 0; d <= ultimo_ide; d++)
    {
      indice = produto_em_encomenda(encomendas[d], idp);
      if (indice != (-1))
      {
        if (encomendas[d].produtos[indice].stock > qtd)
        {
          qtd = encomendas[d].produtos[indice].stock;
          ide = d;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (ide >= 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide, qtd);
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }

}

void __l__()
{
  int vetor_idps[10000];
  int vetor_precos[10000];
  int d;
  int v_precos_aux[10000];
  int v_idps_aux[10000];
  for (d = 0; d <= ultimo_idp; d++)
  {
    vetor_precos[d] = sistema[d].preco;
    vetor_idps[d] = d;
  }

  MergeSort_int(vetor_precos, v_precos_aux, ultimo_idp + 1, vetor_idps, v_idps_aux);
  printf("Produtos\n");
  for (d = 0; d <= ultimo_idp; d++)
  {
    printf("* %s %d %d\n", sistema[vetor_idps[d]].nome, sistema[vetor_idps[d]].preco, sistema[vetor_idps[d]].stock);
  }

}

void __L__()
{
  int i;
  int ide;
  int vetor_indices[200];
  int vetor_indices_aux[200];
  char tab_aux[200][64];
  char tab[200][64];
  ide = new_sym_var(sizeof(int) * 8);
  if (eh_ide(ide) == 1)
  {
    printf("Encomenda %d\n", ide);
    for (i = 0; i < encomendas[ide].n_produtos; i++)
    {
      strcpy(tab[i], encomendas[ide].produtos[i].nome);
      vetor_indices[i] = i;
    }

    MergeSort_str(tab, tab_aux, encomendas[ide].n_produtos, vetor_indices, vetor_indices_aux);
    for (i = 0; i < encomendas[ide].n_produtos; i++)
    {
      printf("* %s %d %d\n", tab[i], encomendas[ide].produtos[vetor_indices[i]].preco, encomendas[ide].produtos[vetor_indices[i]].stock);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void cria_produto(produto vetor[], int i, char c[], int preco, int peso, int stock)
{
  vetor[i].preco = preco;
  vetor[i].stock = stock;
  vetor[i].peso = peso;
  strcpy(vetor[i].nome, c);
}

void cria_copia_produto(produto vetor1[], int d, produto vetor[], int f)
{
  vetor[f].preco = vetor1[d].preco;
  vetor[f].peso = vetor1[d].peso;
  strcpy(vetor[f].nome, vetor1[d].nome);
}

int eh_idp(int idp)
{
  if (idp > ultimo_idp)
  {
    return -1;
  }
  else
  {
    return 1;
  }

}

int produto_in_stock(produto p, int qtd)
{
  if (p.stock < qtd)
  {
    return -1;
  }
  else
  {
    return 1;
  }

}

void altera_stock_produto(produto vetor[], int idp, int qtd)
{
  vetor[idp].stock += qtd;
}

void novo_produto_encomenda(int ide, int idp, int qtd)
{
  cria_copia_produto(sistema, idp, encomendas[ide].produtos, encomendas[ide].n_produtos);
  encomendas[ide].produtos[encomendas[ide].n_produtos].stock = qtd;
  altera_stock_produto(sistema, idp, (-1) * qtd);
  encomendas[ide].peso += sistema[idp].peso * qtd;
  encomendas[ide].idps[encomendas[ide].n_produtos] = idp;
  encomendas[ide].n_produtos++;
}

void adiciona_qtd_encomenda(int ide, int indice, int qtd)
{
  altera_stock_produto(encomendas[ide].produtos, indice, qtd);
  encomendas[ide].peso += encomendas[ide].produtos[indice].peso * qtd;
}

int eh_ide(int ide)
{
  if (ide > ultimo_ide)
  {
    return -1;
  }
  else
  {
    return 1;
  }

}

int produto_em_encomenda(encomenda encomenda, int idp)
{
  int i;
  for (i = 0; i < encomenda.n_produtos; i++)
  {
    if (encomenda.idps[i] == idp)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int min(int a, int b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    return b;
  }

}

void MergeSort_int(int A[], int B[], int n, int v[], int v2[])
{
  int i;
  int tamanho;
  for (tamanho = 1; tamanho < n; tamanho = 2 * tamanho)
  {
    for (i = 0; i < n; i = i + (2 * tamanho))
    {
      Merge_int(A, i, min(i + tamanho, n), min(i + (2 * tamanho), n), B, v, v2);
    }

    CopiaVetor_int(B, A, n, v2, v);
  }

}

void Merge_int(int A[], int esquerdo, int direito, int Fim, int B[], int v[], int v2[])
{
  int i = esquerdo;
  int j = direito;
  int k;
  for (k = esquerdo; k < Fim; k++)
  {
    if ((i < direito) && ((j >= Fim) || (A[i] <= A[j])))
    {
      v2[k] = v[i];
      B[k] = A[i];
      i = i + 1;
    }
    else
    {
      v2[k] = v[j];
      B[k] = A[j];
      j = j + 1;
    }

  }

}

void CopiaVetor_int(int B[], int A[], int n, int v2[], int v[])
{
  int i;
  for (i = 0; i < n; i++)
  {
    A[i] = B[i];
    v[i] = v2[i];
  }

}

void MergeSort_str(char A[][64], char B[][64], int n, int v[], int v2[])
{
  int i;
  int tamanho;
  for (tamanho = 1; tamanho < n; tamanho = 2 * tamanho)
  {
    for (i = 0; i < n; i = i + (2 * tamanho))
    {
      Merge_str(A, i, min(i + tamanho, n), min(i + (2 * tamanho), n), B, v, v2);
    }

    CopiaVetor_str(B, A, n, v2, v);
  }

}

void Merge_str(char A[][64], int esquerdo, int direito, int iEnd, char B[][64], int v[], int v2[])
{
  int i = esquerdo;
  int j = direito;
  int k;
  for (k = esquerdo; k < iEnd; k++)
  {
    if ((i < direito) && ((j >= iEnd) || (strcmp(A[i], A[j]) <= 0)))
    {
      v2[k] = v[i];
      strcpy(B[k], A[i]);
      i = i + 1;
    }
    else
    {
      v2[k] = v[j];
      strcpy(B[k], A[j]);
      j = j + 1;
    }

  }

}

void CopiaVetor_str(char B[][64], char A[][64], int n, int v2[], int v[])
{
  int i;
  for (i = 0; i < n; i++)
  {
    strcpy(A[i], B[i]);
    v[i] = v2[i];
  }

}

