#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int id;
  int peso;
  int preco;
  int quant;
  char nome[64];
} produto;
typedef struct 
{
  int peso;
  int quant;
  produto produto[200];
} encomenda;
produto produtos[10000];
encomenda encomendas[500];
int cont_idp;
int cont_ide;
void merge(int copia_idp[], int esq, int meio, int dir);
void mergeSort(int copia_idp[], int esq, int dir);
int existe_prod(int idp)
{
  if (idp >= cont_idp)
  {
    return 0;
  }
  else
  {
    
  }

  return 1;
}

int existe_encomenda(int ide)
{
  if (ide >= cont_ide)
  {
    return 0;
  }
  else
  {
    
  }

  return 1;
}

void a();
void q();
void N();
void A();
void r();
void R();
void C();
void p();
void E();
void m();
void l();
void L();
int main()
{
  int c;
  while ((c = getchar()) != EOF)
  {
    switch (c)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

      case 'x':
        break;

    }

  }

  return 0;
}

void a()
{
  for (int produtos_index = 0; produtos_index < 10; produtos_index++)
  {
    produtos[cont_idp].nome[produtos_index] = new_sym_var(sizeof(char) * 8);
  }

  produtos[cont_idp].nome[10 - 1] = '\0';
  produtos[cont_idp].preco = new_sym_var(sizeof(int) * 8);
  produtos[cont_idp].peso = new_sym_var(sizeof(int) * 8);
  produtos[cont_idp].quant = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", cont_idp);
  cont_idp++;
}

void q()
{
  int idp;
  int quant;
  idp = new_sym_var(sizeof(int) * 8);
  quant = new_sym_var(sizeof(int) * 8);
  if (existe_prod(idp) == 0)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  produtos[idp].quant += quant;
}

void N()
{
  printf("Nova encomenda %d.\n", cont_ide);
  cont_ide++;
}

void A()
{
  int idp;
  int ide;
  int quant;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  quant = new_sym_var(sizeof(int) * 8);
  if (existe_encomenda(ide) == 0)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (existe_prod(idp) == 0)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (quant > produtos[idp].quant)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if ((encomendas[ide].peso + (produtos[idp].peso * quant)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[ide].quant; i++)
  {
    if (encomendas[ide].produto[i].id == idp)
    {
      encomendas[ide].peso += produtos[idp].peso * quant;
      encomendas[ide].produto[i].quant += quant;
      produtos[idp].quant -= quant;
      return;
    }
    else
    {
      
    }

  }

  encomendas[ide].produto[encomendas[ide].quant].id = idp;
  encomendas[ide].produto[encomendas[ide].quant].quant = quant;
  produtos[idp].quant -= quant;
  encomendas[ide].peso += produtos[idp].peso * quant;
  encomendas[ide].quant++;
}

void r()
{
  int idp;
  int quant;
  idp = new_sym_var(sizeof(int) * 8);
  quant = new_sym_var(sizeof(int) * 8);
  if (existe_prod(idp) == 0)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (produtos[idp].quant < quant)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quant, idp);
    return;
  }
  else
  {
    
  }

  produtos[idp].quant -= quant;
}

void R()
{
  int j;
  int i;
  int ide;
  int idp;
  int remove;
  int atualiza = 0;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (existe_encomenda(ide) == 0)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (existe_prod(idp) == 0)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[ide].quant; i++)
  {
    if (encomendas[ide].produto[i].id == idp)
    {
      atualiza = 1;
      remove = encomendas[ide].produto[i].quant;
      for (j = i; j < (encomendas[ide].quant - 1); j++)
      {
        encomendas[ide].produto[j] = encomendas[ide].produto[j + 1];
      }

    }
    else
    {
      
    }

  }

  if (atualiza == 1)
  {
    produtos[idp].quant += remove;
    encomendas[ide].peso -= remove * produtos[idp].peso;
    encomendas[ide].quant -= 1;
  }
  else
  {
    
  }

}

void C()
{
  int ide;
  int id;
  int i;
  int custo = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (existe_encomenda(ide) == 0)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[ide].quant; i++)
  {
    id = encomendas[ide].produto[i].id;
    custo += encomendas[ide].produto[i].quant * produtos[id].preco;
  }

  printf("Custo da encomenda %d %d.\n", ide, custo);
}

void p()
{
  int preco;
  int idp;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (existe_prod(idp) == 0)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  produtos[idp].preco = preco;
}

void E()
{
  int ide;
  int idp;
  int i;
  int existe = 0;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (existe_encomenda(ide) == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  if (existe_prod(idp) == 0)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[ide].quant; i++)
  {
    if (encomendas[ide].produto[i].id == idp)
    {
      printf("%s %d.\n", produtos[idp].nome, encomendas[ide].produto[i].quant);
      existe = 1;
    }
    else
    {
      
    }

  }

  if (existe == 0)
  {
    printf("%s 0.\n", produtos[idp].nome);
  }
  else
  {
    
  }

}

void m()
{
  int i;
  int j;
  int idp;
  int max_ide = 0;
  int max_quant = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (existe_prod(idp) == 0)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < cont_ide; i++)
  {
    for (j = 0; j < encomendas[i].quant; j++)
    {
      if (encomendas[i].produto[j].id == idp)
      {
        if (encomendas[i].produto[j].quant > max_quant)
        {
          max_quant = encomendas[i].produto[j].quant;
          max_ide = i;
        }
        else
        {
          
        }

        if (encomendas[i].produto[j].quant == max_quant)
        {
          if (i < max_ide)
          {
            max_ide = i;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  if (max_quant > 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, max_ide, max_quant);
  }
  else
  {
    
  }

}

void l()
{
  int i;
  int copia_idp[10000];
  for (i = 0; i < cont_idp; i++)
  {
    copia_idp[i] = i;
  }

  mergeSort(copia_idp, 0, cont_idp - 1);
  printf("Produtos\n");
  for (i = 0; i < cont_idp; i++)
  {
    printf("* %s %d %d\n", produtos[copia_idp[i]].nome, produtos[copia_idp[i]].preco, produtos[copia_idp[i]].quant);
  }

}

void L()
{
  int ide;
  int i;
  int j;
  int idp_j = 0;
  int idp_i = 0;
  produto aux;
  ide = new_sym_var(sizeof(int) * 8);
  if (existe_encomenda(ide) == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[ide].quant; i++)
  {
    for (j = i + 1; j < encomendas[ide].quant; j++)
    {
      idp_i = encomendas[ide].produto[i].id;
      idp_j = encomendas[ide].produto[j].id;
      if (strcmp(produtos[idp_i].nome, produtos[idp_j].nome) > 0)
      {
        aux = encomendas[ide].produto[i];
        encomendas[ide].produto[i].id = encomendas[ide].produto[j].id;
        encomendas[ide].produto[i].quant = encomendas[ide].produto[j].quant;
        encomendas[ide].produto[j] = aux;
      }
      else
      {
        
      }

    }

  }

  printf("Encomenda %d\n", ide);
  for (i = 0; i < encomendas[ide].quant; i++)
  {
    idp_i = encomendas[ide].produto[i].id;
    printf("* %s %d %d\n", produtos[idp_i].nome, produtos[idp_i].preco, encomendas[ide].produto[i].quant);
  }

}

void merge(int copia_idp[], int esq, int meio, int dir)
{
  int i;
  int j;
  int k;
  int n1 = (meio - esq) + 1;
  int n2 = dir - meio;
  int ESQ[10000];
  int DIR[10000];
  for (i = 0; i < n1; i++)
  {
    ESQ[i] = copia_idp[esq + i];
  }

  for (j = 0; j < n2; j++)
  {
    DIR[j] = copia_idp[(meio + 1) + j];
  }

  i = 0;
  j = 0;
  k = esq;
  while ((i < n1) && (j < n2))
  {
    if (produtos[ESQ[i]].preco <= produtos[DIR[j]].preco)
    {
      copia_idp[k] = ESQ[i];
      i++;
    }
    else
    {
      copia_idp[k] = DIR[j];
      j++;
    }

    k++;
  }

  while (i < n1)
  {
    copia_idp[k] = ESQ[i];
    i++;
    k++;
  }

  while (j < n2)
  {
    copia_idp[k] = DIR[j];
    j++;
    k++;
  }

}

void mergeSort(int copia_idp[], int esq, int dir)
{
  if (esq < dir)
  {
    int meio = esq + ((dir - esq) / 2);
    mergeSort(copia_idp, esq, meio);
    mergeSort(copia_idp, meio + 1, dir);
    merge(copia_idp, esq, meio, dir);
  }
  else
  {
    
  }

}

