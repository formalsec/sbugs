#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


int np = 0;
int ne = 0;
int sair = 1;
struct produto
{
  int idp;
  char descricao[64];
  int preco;
  int peso;
  int stock;
};
struct encomenda
{
  int ide;
  int preco;
  int peso;
  int n_p_d;
  struct produto lista_p_enc[200];
};
struct encomenda lista_e[500];
struct produto lista_p[10000];
struct produto p1;
struct encomenda e1;
int in_encomenda(int idp, int ide)
{
  int i;
  for (i = 0; i < lista_e[ide].n_p_d; i++)
  {
    if (lista_e[ide].lista_p_enc[i].idp == idp)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void troca(struct produto lista[], int i, int r)
{
  struct produto p4;
  p4 = lista[i];
  lista[i] = lista[r];
  lista[r] = p4;
}

int ord_p_or_l(struct produto p2, struct produto p3, int k)
{
  if (k == 0)
  {
    return strcmp(p2.descricao, p3.descricao) < 0;
  }
  else
  {
    if (p2.preco == p3.preco)
    {
      return p2.idp < p3.idp;
    }
    else
    {
      
    }

    return p2.preco < p3.preco;
  }

}

int divisao(struct produto lista[], int l, int r, int k)
{
  int a = l - 1;
  int b = r;
  struct produto p2 = lista[r];
  while (a < b)
  {
    while (ord_p_or_l(lista[++a], p2, k))
      ;

    while (ord_p_or_l(p2, lista[--b], k))
      if (b == l)
    {
      break;
    }
    else
    {
      
    }


    if (a < b)
    {
      troca(lista, a, b);
    }
    else
    {
      
    }

  }

  troca(lista, a, r);
  return a;
}

void q_s(struct produto lista[], int l, int r, int k)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = divisao(lista, l, r, k);
  q_s(lista, l, i - 1, k);
  q_s(lista, i + 1, r, k);
}

void a()
{
  int idp;
  for (int p1_index = 0; p1_index < 10; p1_index++)
  {
    p1.descricao[p1_index] = new_sym_var(sizeof(char) * 8);
  }

  p1.descricao[10 - 1] = '\0';
  p1.preco = new_sym_var(sizeof(int) * 8);
  p1.peso = new_sym_var(sizeof(int) * 8);
  p1.stock = new_sym_var(sizeof(int) * 8);
  idp = np;
  p1.idp = idp;
  lista_p[p1.idp] = p1;
  np++;
  printf("Novo produto %d.\n", p1.idp);
}

void q()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= np)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    lista_p[idp].stock += qtd;
  }

}

void N()
{
  int ide;
  ide = ne;
  e1.ide = ide;
  e1.preco = 0;
  e1.peso = 0;
  e1.n_p_d = 0;
  lista_e[e1.ide] = e1;
  ne++;
  printf("Nova encomenda %d.\n", e1.ide);
}

void A()
{
  int ide;
  int idp;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= ne)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= np)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (qtd > lista_p[idp].stock)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((lista_e[ide].peso + (lista_p[idp].peso * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          if (in_encomenda(idp, ide) == (-1))
          {
            lista_e[ide].lista_p_enc[lista_e[ide].n_p_d] = lista_p[idp];
            lista_e[ide].lista_p_enc[lista_e[ide].n_p_d].stock = qtd;
            lista_e[ide].peso += lista_p[idp].peso * qtd;
            lista_p[idp].stock -= qtd;
            lista_e[ide].n_p_d++;
          }
          else
          {
            lista_e[ide].lista_p_enc[in_encomenda(idp, ide)].stock += qtd;
            lista_e[ide].peso += lista_p[idp].peso * qtd;
            lista_p[idp].stock -= qtd;
          }

        }

      }

    }

  }

}

void r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= np)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (qtd > lista_p[idp].stock)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      lista_p[idp].stock -= qtd;
    }

  }

}

void R()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ne)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= np)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (in_encomenda(idp, ide) != (-1))
      {
        lista_p[idp].stock += lista_e[ide].lista_p_enc[in_encomenda(idp, ide)].stock;
        lista_e[ide].peso -= lista_e[ide].lista_p_enc[in_encomenda(idp, ide)].stock * lista_p[idp].peso;
        lista_e[ide].lista_p_enc[in_encomenda(idp, ide)].stock = 0;
      }
      else
      {
        
      }

    }

  }

}

void C()
{
  int ide;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ne)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    lista_e[ide].preco = 0;
    for (i = 0; i < lista_e[ide].n_p_d; i++)
    {
      if (lista_e[ide].lista_p_enc[i].stock != 0)
      {
        lista_e[ide].preco += lista_e[ide].lista_p_enc[i].preco * lista_e[ide].lista_p_enc[i].stock;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d %d.\n", ide, lista_e[ide].preco);
  }

}

void p()
{
  int idp;
  int n_preco;
  int j;
  idp = new_sym_var(sizeof(int) * 8);
  n_preco = new_sym_var(sizeof(int) * 8);
  if (idp >= np)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    lista_p[idp].preco = n_preco;
    for (j = 0; j < ne; j++)
    {
      if (in_encomenda(idp, j) >= 0)
      {
        lista_e[j].lista_p_enc[in_encomenda(idp, j)].preco = n_preco;
      }
      else
      {
        
      }

    }

  }

}

void E()
{
  int idp;
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ne)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= np)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      if (in_encomenda(idp, ide) != (-1))
      {
        printf("%s %d.\n", lista_p[idp].descricao, lista_e[ide].lista_p_enc[in_encomenda(idp, ide)].stock);
      }
      else
      {
        printf("%s %d.\n", lista_p[idp].descricao, 0);
      }

    }

  }

}

void m()
{
  int idp;
  int ide;
  int max;
  int a;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= np)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    max = 0;
    ide = -1;
    for (a = 0; a < ne; a++)
    {
      if (in_encomenda(idp, a) != (-1))
      {
        if (lista_e[a].lista_p_enc[in_encomenda(idp, a)].stock > max)
        {
          max = lista_e[a].lista_p_enc[in_encomenda(idp, a)].stock;
          ide = a;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (ide != (-1))
    {
      printf("Maximo produto %d %d %d.\n", idp, ide, max);
    }
    else
    {
      
    }

  }

}

void l()
{
  struct produto lista_ord[10000];
  int k = 1;
  int i = 0;
  for (i = 0; i < np; i++)
    lista_ord[i] = lista_p[i];

  q_s(lista_ord, 0, np - 1, k);
  printf("Produtos\n");
  for (i = 0; i < np; i++)
    printf("* %s %d %d\n", lista_ord[i].descricao, lista_ord[i].preco, lista_ord[i].stock);

}

void L()
{
  struct produto lista_ord[200];
  int k = 0;
  int i;
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ne)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < lista_e[ide].n_p_d; i++)
      lista_ord[i] = lista_e[ide].lista_p_enc[i];

    q_s(lista_ord, 0, lista_e[ide].n_p_d - 1, k);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < lista_e[ide].n_p_d; i++)
    {
      if (lista_ord[i].stock > 0)
      {
        printf("* %s %d %d\n", lista_ord[i].descricao, lista_ord[i].preco, lista_ord[i].stock);
      }
      else
      {
        
      }

    }

  }

}

int main(void)
{
  while (sair)
  {
    char c;
    c = getchar();
    switch (c)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

      case 'x':
        sair = 0;
        break;

      default:
        break;

    }

  }

  return 0;
}

