#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "ls.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int product_count = 0;
int order_count = 0;
Product storage[10000];
int storage_ids[10000];
Order orders[500];
void add_product(const char *description, const int price, const int weight, const int stock)
{
  storage[product_count].id = product_count;
  strcpy(storage[product_count].description, description);
  storage[product_count].price = price;
  storage[product_count].weight = weight;
  storage[product_count].stock = stock;
  storage_ids[product_count] = product_count;
  printf("Novo produto %d.\n", product_count++);
}

void add_stock(const int product_id, const int quantity)
{
  if (product_id >= product_count)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", product_id);
    return;
  }
  else
  {
    
  }

  storage[product_id].stock += quantity;
}

void create_order()
{
  printf("Nova encomenda %d.\n", order_count++);
}

void add_product_to_order(const int order_id, const int product_id, const int quantity)
{
  int weight_after;
  if (order_id >= order_count)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", product_id, order_id);
    return;
  }
  else
  {
    
  }

  if (product_id >= product_count)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", product_id, order_id);
    return;
  }
  else
  {
    
  }

  if (quantity > storage[product_id].stock)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", product_id, order_id);
    return;
  }
  else
  {
    
  }

  weight_after = orders[order_id].weight + (storage[product_id].weight * quantity);
  if (weight_after > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", product_id, order_id);
    return;
  }
  else
  {
    
  }

  if (orders[order_id].product_qty[product_id] != 0)
  {
    storage[product_id].stock -= quantity;
    orders[order_id].product_qty[product_id] += quantity;
    orders[order_id].weight = weight_after;
    return;
  }
  else
  {
    
  }

  storage[product_id].stock -= quantity;
  orders[order_id].product_ids[orders[order_id].num_products] = product_id;
  orders[order_id].product_qty[product_id] = quantity;
  orders[order_id].weight = weight_after;
  orders[order_id].num_products++;
}

void remove_stock_from_product(const int product_id, const int quantity)
{
  if (product_id >= product_count)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", product_id);
    return;
  }
  else
  {
    
  }

  if (quantity > storage[product_id].stock)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantity, product_id);
    return;
  }
  else
  {
    
  }

  storage[product_id].stock -= quantity;
}

void remove_product_from_order(const int order_id, const int product_id)
{
  int i;
  Order order;
  if (order_id >= order_count)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", product_id, order_id);
    return;
  }
  else
  {
    
  }

  if (product_id >= product_count)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", product_id, order_id);
    return;
  }
  else
  {
    
  }

  order = orders[order_id];
  for (i = 0; i < order.num_products; i++)
  {
    if (order.product_ids[i] == product_id)
    {
      storage[product_id].stock += order.product_qty[product_id];
      order.weight -= order.product_qty[product_id] * storage[product_id].weight;
      order.product_qty[product_id] = 0;
      order.product_ids[i] = order.product_ids[--order.num_products];
      order.product_ids[order.num_products] = -1;
      orders[order_id] = order;
      return;
    }
    else
    {
      
    }

  }

}

void get_order_cost(const int order_id)
{
  int i;
  int num_products = orders[order_id].num_products;
  int product_id;
  int cost = 0;
  if (order_id >= order_count)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", order_id);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < num_products; i++)
  {
    product_id = orders[order_id].product_ids[i];
    cost += storage[product_id].price * orders[order_id].product_qty[product_id];
  }

  printf("Custo da encomenda %d %d.\n", order_id, cost);
}

void change_product_price(const int product_id, const int price)
{
  if (product_id >= product_count)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", product_id);
    return;
  }
  else
  {
    
  }

  storage[product_id].price = price;
}

void list_product_from_order(const int order_id, const int product_id)
{
  if (order_id >= order_count)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order_id);
    return;
  }
  else
  {
    
  }

  if (product_id >= product_count)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", product_id);
    return;
  }
  else
  {
    
  }

  printf("%s %d.\n", storage[product_id].description, orders[order_id].product_qty[product_id]);
}

void list_order_with_highest_qty_of_product(const int product_id)
{
  int i;
  int highest_quantity = 0;
  int order_id = -1;
  if (product_id >= product_count)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", product_id);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < order_count; i++)
  {
    if (orders[i].product_qty[product_id] > highest_quantity)
    {
      order_id = i;
      highest_quantity = orders[i].product_qty[product_id];
    }
    else
    {
      
    }

  }

  if (order_id >= 0)
  {
    printf("Maximo produto %d %d %d.\n", product_id, order_id, highest_quantity);
  }
  else
  {
    
  }

}

void list_all_products_by_price_asc()
{
  int size = product_count;
  int ids_array[10000];
  memcpy(ids_array, storage_ids, (sizeof(int)) * size);
  mergesort(ids_array, 0, size - 1, compare_product_by_price_asc);
  print_products(ids_array, size);
}

void list_products_by_description(const int order_id)
{
  int size = orders[order_id].num_products;
  int ids_array[200];
  if (order_id >= order_count)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order_id);
    return;
  }
  else
  {
    
  }

  memcpy(ids_array, orders[order_id].product_ids, (sizeof(int)) * size);
  mergesort(ids_array, 0, size - 1, compare_product_by_description);
  print_order_products(order_id, ids_array, size);
}

void print_products(int ids_array[], int size)
{
  int i;
  printf("Produtos\n");
  for (i = 0; i < size; i++)
  {
    printf("* %s %d %d\n", storage[ids_array[i]].description, storage[ids_array[i]].price, storage[ids_array[i]].stock);
  }

}

void print_order_products(int order_id, int ids_array[], int size)
{
  int i;
  printf("Encomenda %d\n", order_id);
  for (i = 0; i < size; i++)
  {
    printf("* %s %d %d\n", storage[ids_array[i]].description, storage[ids_array[i]].price, orders[order_id].product_qty[ids_array[i]]);
  }

}

int compare_product_by_description(const Item i1, const Item i2)
{
  return strcmp(storage[i1].description, storage[i2].description) < 0;
}

int compare_product_by_price_asc(const Item i1, const Item i2)
{
  return (storage[i1].price == storage[i2].price) ? (storage[i1].id < storage[i2].id) : (storage[i1].price < storage[i2].price);
}

void merge(Item a[], int l, int m, int r, int (*comparator)(Item, Item))
{
  int i;
  int j;
  int k;
  Item aux[10000];
  for (i = m + 1; i > l; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < r; j++)
    aux[(r + m) - j] = a[j + 1];

  for (k = l; k <= r; k++)
    if (comparator(aux[j], aux[i]) || (i > m))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

void mergesort(Item a[], int l, int r, int (*comparator)(Item, Item))
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, l, m, comparator);
  mergesort(a, m + 1, r, comparator);
  merge(a, l, m, r, comparator);
}

