#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "stdio.h"
#include "string.h"


typedef struct produto
{
  int identificador;
  char descricao[63];
  int preco;
  int peso;
  int quantidade;
} produto;
typedef struct prods_enc
{
  int identificador;
  int quantidade;
  int peso;
} prods_enc;
produto produtos[10000] = {0};
prods_enc encomendas[500][200] = {0};
int prods_dif_encomendas[500] = {0};
int qtd_prods_enc[500][10000] = {0};
int total_prod = 0;
int total_enc = 0;
int peso_enc(int ide)
{
  int i;
  int idp;
  int peso_total = 0;
  for (i = 0; i < prods_dif_encomendas[ide]; i++)
  {
    idp = encomendas[ide][i].identificador;
    peso_total += encomendas[ide][i].quantidade * produtos[idp].peso;
  }

  return peso_total;
}

void a()
{
  static int num_prod = 0;
  int preco;
  int peso;
  int quantidade;
  getchar();
  for (int produtos_index = 0; produtos_index < 10; produtos_index++)
  {
    produtos[num_prod].descricao[produtos_index] = new_sym_var(sizeof(char) * 8);
  }

  produtos[num_prod].descricao[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  produtos[num_prod].identificador = num_prod;
  produtos[num_prod].preco = preco;
  produtos[num_prod].peso = peso;
  produtos[num_prod].quantidade = quantidade;
  printf("Novo produto %d.\n", num_prod);
  num_prod++;
  total_prod++;
  return;
}

void q()
{
  int idp;
  int qtd;
  getchar();
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp < total_prod)
  {
    produtos[idp].quantidade += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

  return;
}

void N()
{
  static int num_enc = 0;
  printf("Nova encomenda %d.\n", num_enc);
  num_enc++;
  total_enc++;
  return;
}

void A()
{
  int ide;
  int idp;
  int qtd;
  int i;
  int coluna;
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= total_enc)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (idp >= total_prod)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      if (qtd > produtos[idp].quantidade)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        return;
      }
      else
      {
        if ((peso_enc(ide) + (qtd * produtos[idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          return;
        }
        else
        {
          qtd_prods_enc[ide][idp] += qtd;
          for (i = 0; i < 200; i++)
          {
            if ((encomendas[ide][i].identificador == idp) && (encomendas[ide][i].peso == produtos[idp].peso))
            {
              encomendas[ide][i].quantidade += qtd;
              produtos[idp].quantidade -= qtd;
              return;
            }
            else
            {
              
            }

          }

          coluna = prods_dif_encomendas[ide];
          encomendas[ide][coluna].identificador = idp;
          encomendas[ide][coluna].quantidade = qtd;
          encomendas[ide][coluna].peso = produtos[idp].peso;
          prods_dif_encomendas[ide]++;
          produtos[idp].quantidade -= qtd;
          return;
        }

      }

    }

  }

}

void r()
{
  int idp;
  int qtd;
  getchar();
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= total_prod)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    if ((produtos[idp].quantidade - qtd) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
      return;
    }
    else
    {
      produtos[idp].quantidade -= qtd;
      return;
    }

  }

}

void R()
{
  int ide;
  int idp;
  int i;
  int ind_maximo;
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= total_enc)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (idp >= total_prod)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      qtd_prods_enc[ide][idp] = 0;
      ind_maximo = prods_dif_encomendas[ide] - 1;
      for (i = 0; i < prods_dif_encomendas[ide]; i++)
      {
        if ((encomendas[ide][i].identificador == idp) && (encomendas[ide][i].peso == produtos[idp].peso))
        {
          produtos[idp].quantidade += encomendas[ide][i].quantidade;
          encomendas[ide][i].identificador = encomendas[ide][ind_maximo].identificador;
          encomendas[ide][i].quantidade = encomendas[ide][ind_maximo].quantidade;
          encomendas[ide][i].peso = encomendas[ide][ind_maximo].peso;
          encomendas[ide][ind_maximo].identificador = 0;
          encomendas[ide][ind_maximo].quantidade = 0;
          encomendas[ide][ind_maximo].peso = 0;
          prods_dif_encomendas[ide]--;
          return;
        }
        else
        {
          
        }

      }

      return;
    }

  }

}

void C()
{
  int ide;
  int custo = 0;
  int i;
  int idp;
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= total_enc)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    for (i = 0; i < 200; i++)
    {
      idp = encomendas[ide][i].identificador;
      custo += encomendas[ide][i].quantidade * produtos[idp].preco;
    }

    printf("Custo da encomenda %d %d.\n", ide, custo);
    return;
  }

}

void p()
{
  int idp;
  int preco;
  getchar();
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= total_prod)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    produtos[idp].preco = preco;
    return;
  }

}

void E()
{
  int ide;
  int idp;
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= total_enc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    if (idp >= total_prod)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      return;
    }
    else
    {
      printf("%s %d.\n", produtos[idp].descricao, qtd_prods_enc[ide][idp]);
      return;
    }

  }

}

void m()
{
  int idp;
  int i;
  int ide;
  int qtd_max = 0;
  getchar();
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= total_prod)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    for (i = 0; i < total_enc; i++)
    {
      if (qtd_prods_enc[i][idp] > qtd_max)
      {
        qtd_max = qtd_prods_enc[i][idp];
        ide = i;
      }
      else
      {
        
      }

    }

    if (qtd_max > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide, qtd_max);
    }
    else
    {
      
    }

    return;
  }

}

int less(int a, int b, int tipo)
{
  if (tipo == 0)
  {
    if (produtos[a].preco < produtos[b].preco)
    {
      return 1;
    }
    else
    {
      if (produtos[a].preco == produtos[b].preco)
      {
        if (produtos[a].identificador < produtos[b].identificador)
        {
          return 1;
        }
        else
        {
          return 0;
        }

      }
      else
      {
        return 0;
      }

    }

  }
  else
  {
    if (strcmp(produtos[a].descricao, produtos[b].descricao) < 0)
    {
      return 1;
    }
    else
    {
      return 0;
    }

  }

}

void merge(int a[], int left, int m, int right, int tipo)
{
  int i;
  int j;
  int k;
  int aux[10000] = {0};
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
  {
    if (less(aux[j], aux[i], tipo))
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void mergesort(int a[], int left, int right, int tipo)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, left, m, tipo);
  mergesort(a, m + 1, right, tipo);
  merge(a, left, m, right, tipo);
}

void l()
{
  int i;
  int vetor[10000] = {0};
  for (i = 0; i < total_prod; i++)
    vetor[i] = i;

  mergesort(vetor, 0, total_prod - 1, 0);
  i = 0;
  printf("Produtos\n");
  while (i < total_prod)
  {
    printf("* %s %d %d\n", produtos[vetor[i]].descricao, produtos[vetor[i]].preco, produtos[vetor[i]].quantidade);
    i++;
  }

  return;
}

void L()
{
  int i;
  int ide;
  int array[200] = {0};
  getchar();
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= total_enc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < prods_dif_encomendas[ide]; i++)
    array[i] = encomendas[ide][i].identificador;

  mergesort(array, 0, prods_dif_encomendas[ide] - 1, 1);
  i = 0;
  printf("Encomenda %d\n", ide);
  while (i < prods_dif_encomendas[ide])
  {
    printf("* %s %d %d\n", produtos[array[i]].descricao, produtos[array[i]].preco, qtd_prods_enc[ide][array[i]]);
    i++;
  }

  return;
}

int main()
{
  char c;
  while ((c = getchar()) != 'x')
  {
    switch (c)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

    }

  }

  return 0;
}

