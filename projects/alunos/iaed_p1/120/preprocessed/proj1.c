#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int price;
  char name[64];
  int weight;
  int stock;
} Product;
typedef struct 
{
  int weight;
  int products[200][2];
  int nprods;
} Order;
Product products[10000];
Order orders[500];
int pid;
int oid;
int pidExists(int tpid);
int oidExists(int toid);
int cmpPrice(int x, int y);
int cmpName(int x, int y);
void a();
void q();
void r();
void p();
void l();
void m();
void N();
void A();
void R();
void C();
void E();
void L();
void mergeSortl(int ids[], int e, int d);
void mergel(int ids[], int e, int m, int d);
void bubbleSwap(int toid, int p1, int p2);
int main()
{
  int cmd;
  while ((cmd = getchar()) != EOF)
  {
    switch (cmd)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'r':
        r();
        break;

      case 'p':
        p();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'E':
        E();
        break;

      case 'L':
        L();
        break;

      case 'x':
        break;

    }

  }

  return 0;
}

int pidExists(int tpid)
{
  if (tpid > (pid - 1))
  {
    return 3;
  }
  else
  {
    
  }

  return 2;
}

int oidExists(int toid)
{
  if (toid > (oid - 1))
  {
    return 3;
  }
  else
  {
    
  }

  return 2;
}

int cmpPrice(int x, int y)
{
  if ((x <= (pid - 1)) && (y <= (pid - 1)))
  {
    if (products[x].price < products[y].price)
    {
      return 4;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  return 5;
}

int cmpName(int x, int y)
{
  if (strcmp(products[x].name, products[y].name) > 0)
  {
    return 2;
  }
  else
  {
    
  }

  return 3;
}

void a()
{
  for (int products_index = 0; products_index < 10; products_index++)
  {
    products[pid].name[products_index] = new_sym_var(sizeof(char) * 8);
  }

  products[pid].name[10 - 1] = '\0';
  products[pid].price = new_sym_var(sizeof(int) * 8);
  products[pid].weight = new_sym_var(sizeof(int) * 8);
  products[pid].stock = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", pid);
  pid++;
}

void q()
{
  int tpid;
  int qty;
  tpid = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (pidExists(tpid) == 3)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", tpid);
    return;
  }
  else
  {
    
  }

  products[tpid].stock += qty;
}

void r()
{
  int tpid;
  int qty;
  tpid = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (pidExists(tpid) == 3)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", tpid);
    return;
  }
  else
  {
    
  }

  if ((products[tpid].stock - qty) < 0)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qty, tpid);
    return;
  }
  else
  {
    
  }

  products[tpid].stock -= qty;
}

void p()
{
  int tpid;
  int price;
  tpid = new_sym_var(sizeof(int) * 8);
  price = new_sym_var(sizeof(int) * 8);
  if (pidExists(tpid) == 3)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", tpid);
    return;
  }
  else
  {
    
  }

  products[tpid].price = price;
}

void l()
{
  int ids[10000];
  int i;
  for (i = 0; i < pid; i++)
  {
    ids[i] = i;
  }

  mergeSortl(ids, 0, pid - 1);
  printf("Produtos\n");
  for (i = 0; i < pid; i++)
  {
    printf("* %s %d %d\n", products[ids[i]].name, products[ids[i]].price, products[ids[i]].stock);
  }

}

void m()
{
  int tpid;
  int max = -1;
  int i;
  int j;
  int ord;
  tpid = new_sym_var(sizeof(int) * 8);
  if (pidExists(tpid) == 3)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", tpid);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < oid; i++)
  {
    for (j = 0; j < orders[i].nprods; j++)
    {
      if (orders[i].products[j][0] == tpid)
      {
        if (orders[i].products[j][1] > max)
        {
          max = orders[i].products[j][1];
          ord = i;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  if (max != (-1))
  {
    printf("Maximo produto %d %d %d.\n", tpid, ord, max);
  }
  else
  {
    
  }

}

void N()
{
  printf("Nova encomenda %d.\n", oid);
  oid++;
}

void A()
{
  int p;
  int toid;
  int tpid;
  int qty;
  toid = new_sym_var(sizeof(int) * 8);
  tpid = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (oidExists(toid) == 3)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", tpid, toid);
    return;
  }
  else
  {
    
  }

  if (pidExists(tpid) == 3)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", tpid, toid);
    return;
  }
  else
  {
    
  }

  if (products[tpid].stock < qty)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", tpid, toid);
    return;
  }
  else
  {
    
  }

  if ((orders[toid].weight + (products[tpid].weight * qty)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", tpid, toid);
    return;
  }
  else
  {
    
  }

  orders[toid].weight += products[tpid].weight * qty;
  products[tpid].stock -= qty;
  for (p = 0; p < orders[toid].nprods; p++)
  {
    if (orders[toid].products[p][0] == tpid)
    {
      orders[toid].products[p][1] += qty;
      return;
    }
    else
    {
      
    }

  }

  orders[toid].products[orders[toid].nprods][0] = tpid;
  orders[toid].products[orders[toid].nprods][1] = qty;
  orders[toid].nprods++;
}

void R()
{
  int i;
  int j;
  int toid;
  int tpid;
  toid = new_sym_var(sizeof(int) * 8);
  tpid = new_sym_var(sizeof(int) * 8);
  if (oidExists(toid) == 3)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", tpid, toid);
    return;
  }
  else
  {
    
  }

  if (pidExists(tpid) == 3)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", tpid, toid);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < orders[toid].nprods; i++)
  {
    if (orders[toid].products[i][0] == tpid)
    {
      products[tpid].stock += orders[toid].products[i][1];
      orders[toid].weight -= products[tpid].weight * orders[toid].products[i][1];
      for (j = i; j < (orders[toid].nprods - 1); j++)
      {
        orders[toid].products[j][0] = orders[toid].products[j + 1][0];
        orders[toid].products[j][1] = orders[toid].products[j + 1][1];
      }

      orders[toid].nprods--;
    }
    else
    {
      
    }

  }

}

void C()
{
  int toid;
  int cost = 0;
  int tpid;
  int qty;
  int i;
  toid = new_sym_var(sizeof(int) * 8);
  if (oidExists(toid) == 3)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", toid);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < orders[toid].nprods; i++)
  {
    tpid = orders[toid].products[i][0];
    qty = orders[toid].products[i][1];
    cost += products[tpid].price * qty;
  }

  printf("Custo da encomenda %d %d.\n", toid, cost);
}

void E()
{
  int toid;
  int tpid;
  int p;
  toid = new_sym_var(sizeof(int) * 8);
  tpid = new_sym_var(sizeof(int) * 8);
  if (oidExists(toid) == 3)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", toid);
    return;
  }
  else
  {
    
  }

  if (pidExists(tpid) == 3)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", tpid);
    return;
  }
  else
  {
    
  }

  for (p = 0; p < orders[toid].nprods; p++)
  {
    if (orders[toid].products[p][0] == tpid)
    {
      printf("%s %d.\n", products[tpid].name, orders[toid].products[p][1]);
      return;
    }
    else
    {
      
    }

  }

  printf("%s 0.\n", products[tpid].name);
}

void bubbleSwap(int toid, int p1, int p2)
{
  int tempid;
  int tempqt;
  tempid = orders[toid].products[p1][0];
  tempqt = orders[toid].products[p1][1];
  orders[toid].products[p1][0] = orders[toid].products[p2][0];
  orders[toid].products[p1][1] = orders[toid].products[p2][1];
  orders[toid].products[p2][0] = tempid;
  orders[toid].products[p2][1] = tempqt;
}

void L()
{
  int toid;
  int i;
  int j;
  int pidi;
  int pidj;
  toid = new_sym_var(sizeof(int) * 8);
  if (oidExists(toid) == 3)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", toid);
    return;
  }
  else
  {
    
  }

  printf("Encomenda %d\n", toid);
  for (i = 0; i < orders[toid].nprods; i++)
  {
    for (j = i + 1; j < orders[toid].nprods; j++)
    {
      pidi = orders[toid].products[i][0];
      pidj = orders[toid].products[j][0];
      if (cmpName(pidi, pidj) == 2)
      {
        bubbleSwap(toid, i, j);
      }
      else
      {
        
      }

    }

  }

  for (i = 0; i < orders[toid].nprods; i++)
  {
    printf("* %s %d %d\n", products[orders[toid].products[i][0]].name, products[orders[toid].products[i][0]].price, orders[toid].products[i][1]);
  }

}

int aux[10000];
void mergel(int ids[], int left, int mid, int right)
{
  int i;
  int j;
  int k;
  for (i = mid + 1; i > left; i--)
  {
    aux[i - 1] = ids[i - 1];
  }

  for (j = mid; j < right; j++)
  {
    aux[(right + mid) - j] = ids[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if ((cmpPrice(aux[j], aux[i]) == 4) || (i > mid))
    {
      ids[k] = aux[j--];
    }
    else
    {
      ids[k] = aux[i++];
    }

  }

}

void mergeSortl(int ids[], int left, int right)
{
  if (left < right)
  {
    int mid = left + ((right - left) / 2);
    mergeSortl(ids, left, mid);
    mergeSortl(ids, mid + 1, right);
    mergel(ids, left, mid, right);
  }
  else
  {
    
  }

}

