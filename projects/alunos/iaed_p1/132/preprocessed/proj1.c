/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct a
{
  int id;
  int price;
  int weight;
  int stock;
  char description[63];
} Product;
typedef struct b
{
  int id;
  int quantity;
} ProductInOrder;
typedef struct c
{
  int id;
  int weight;
  int price;
  int num_of_prods;
  ProductInOrder orderProducts[200];
} Order;
Product allProducts[10000] = {0};
Order allOrders[500] = {0};
int countProd = 0;
int countOrd = 0;
void initOrder()
{
  int i;
  for (i = 0; i < 500; i++)
  {
    allOrders[i].id = -1;
  }

}

int getNumOfProds(int orderId)
{
  return allOrders[orderId].num_of_prods;
}

void deleteStruct(int orderId, int index)
{
  int i;
  for (i = index; i < (200 - 1); i++)
  {
    allOrders[orderId].orderProducts[i].id = allOrders[orderId].orderProducts[i + 1].id;
    allOrders[orderId].orderProducts[i].quantity = allOrders[orderId].orderProducts[i + 1].quantity;
  }

}

void copyStructsProducts(Product dest[], int destIndex, Product src[], int srcIndex)
{
  memmove(dest[destIndex].description, src[srcIndex].description, strlen(src[srcIndex].description) + 1);
  dest[destIndex].price = src[srcIndex].price;
  dest[destIndex].id = src[srcIndex].id;
  dest[destIndex].weight = src[srcIndex].weight;
  dest[destIndex].stock = src[srcIndex].stock;
}

void copyStructsOrders(ProductInOrder dest[], int destIndex, ProductInOrder src[], int srcIndex)
{
  dest[destIndex].id = src[srcIndex].id;
  dest[destIndex].quantity = src[srcIndex].quantity;
}

void swapStructs(Product v[], int a, int b)
{
  Product temporary[1] = {0};
  copyStructsProducts(temporary, 0, v, b);
  copyStructsProducts(v, b, v, a);
  copyStructsProducts(v, a, temporary, 0);
}

void swapStructsDescription(ProductInOrder v[], int a, int b)
{
  ProductInOrder temporary;
  temporary.id = v[b].id;
  temporary.quantity = v[b].quantity;
  v[b].id = v[a].id;
  v[b].quantity = v[a].quantity;
  v[a].id = temporary.id;
  v[a].quantity = temporary.quantity;
}

void addProduct()
{
  allProducts[countProd].id = countProd;
  for (int allProducts_index = 0; allProducts_index < 10; allProducts_index++)
  {
    allProducts[countProd].description[allProducts_index] = new_sym_var(sizeof(char) * 8);
  }

  allProducts[countProd].description[10 - 1] = '\0';
  allProducts[countProd].price = new_sym_var(sizeof(int) * 8);
  allProducts[countProd].weight = new_sym_var(sizeof(int) * 8);
  allProducts[countProd].stock = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", countProd);
  countProd++;
}

void addStock()
{
  int addId;
  int addQuantity;
  int i;
  addId = new_sym_var(sizeof(int) * 8);
  addQuantity = new_sym_var(sizeof(int) * 8);
  if (allProducts[addId].price == 0)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", addId);
  }
  else
  {
    for (i = 0; i < countProd; i++)
    {
      if (allProducts[i].id == addId)
      {
        allProducts[i].stock += addQuantity;
        break;
      }
      else
      {
        
      }

    }

  }

}

void createOrder()
{
  allOrders[countOrd].id = countOrd;
  allOrders[countOrd].weight = 0;
  printf("Nova encomenda %d.\n", allOrders[countOrd].id);
  countOrd++;
}

int calcWeight(int idp, int qtt)
{
  int individualWeight;
  int i;
  for (i = 0; i < countProd; i++)
  {
    if (allProducts[i].id == idp)
    {
      individualWeight = allProducts[i].weight;
      break;
    }
    else
    {
      
    }

  }

  return qtt * individualWeight;
}

int getStock(int idp)
{
  int i;
  for (i = 0; i < countProd; i++)
  {
    if (allProducts[i].id == idp)
    {
      return allProducts[i].stock;
    }
    else
    {
      
    }

  }

  return 0;
}

void reduceStock(int idp, int removeQuantity)
{
  int i;
  for (i = 0; i < countProd; i++)
  {
    if (allProducts[i].id == idp)
    {
      allProducts[i].stock -= removeQuantity;
      break;
    }
    else
    {
      
    }

  }

}

int getPrice(int idp, int qtt)
{
  int individualPrice;
  int i;
  for (i = 0; i < countProd; i++)
  {
    if (allProducts[i].id == idp)
    {
      individualPrice = allProducts[i].price;
    }
    else
    {
      
    }

  }

  return individualPrice * qtt;
}

void addProduct_2_Order(int orderId, int productId, int productQuantity)
{
  int i;
  int checker = 0;
  int id2Add;
  if (allOrders[orderId].id == (-1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", productId, orderId);
  }
  else
  {
    if (allProducts[productId].price == 0)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", productId, orderId);
    }
    else
    {
      if (productQuantity > getStock(productId))
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", productId, orderId);
      }
      else
      {
        if ((allOrders[orderId].weight + calcWeight(productId, productQuantity)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", productId, orderId);
        }
        else
        {
          for (i = 0; i < getNumOfProds(orderId); i++)
          {
            if (allOrders[orderId].orderProducts[i].id == productId)
            {
              checker = 1;
              id2Add = i;
              break;
            }
            else
            {
              
            }

          }

          if (checker == 0)
          {
            allOrders[orderId].num_of_prods += 1;
            allOrders[orderId].price += getPrice(productId, productQuantity);
            allOrders[orderId].weight += calcWeight(productId, productQuantity);
            reduceStock(productId, productQuantity);
            allOrders[orderId].orderProducts[getNumOfProds(orderId) - 1].id = productId;
            allOrders[orderId].orderProducts[getNumOfProds(orderId) - 1].quantity = productQuantity;
          }
          else
          {
            allOrders[orderId].price += getPrice(productId, productQuantity);
            allOrders[orderId].weight += calcWeight(productId, productQuantity);
            reduceStock(productId, productQuantity);
            allOrders[orderId].orderProducts[id2Add].quantity += productQuantity;
          }

        }

      }

    }

  }

}

void removeStock()
{
  int removeId;
  int removeQuantity;
  removeId = new_sym_var(sizeof(int) * 8);
  removeQuantity = new_sym_var(sizeof(int) * 8);
  if (allProducts[removeId].price == 0)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", removeId);
  }
  else
  {
    if ((getStock(removeId) - removeQuantity) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", removeQuantity, removeId);
    }
    else
    {
      reduceStock(removeId, removeQuantity);
    }

  }

}

void removeProduct(int orderId, int productId)
{
  int removeQuantity;
  int i;
  int j;
  if (allOrders[orderId].id == (-1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", productId, orderId);
  }
  else
  {
    if (allProducts[productId].price == 0)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", productId, orderId);
    }
    else
    {
      for (i = 0; i < 200; i++)
      {
        if ((allOrders[orderId].orderProducts[i].id == productId) && (allOrders[orderId].orderProducts[i].quantity != 0))
        {
          allOrders[orderId].num_of_prods -= 1;
          removeQuantity = allOrders[orderId].orderProducts[i].quantity;
          allOrders[orderId].weight -= calcWeight(productId, removeQuantity);
          for (j = 0; j < countProd; j++)
          {
            if (allProducts[j].id == productId)
            {
              allProducts[j].stock += removeQuantity;
            }
            else
            {
              
            }

          }

          allOrders[orderId].price -= getPrice(productId, removeQuantity);
          deleteStruct(orderId, i);
          break;
        }
        else
        {
          
        }

      }

    }

  }

}

void getOrderCost()
{
  int orderId;
  orderId = new_sym_var(sizeof(int) * 8);
  if (allOrders[orderId].id == (-1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", orderId);
  }
  else
  {
    printf("Custo da encomenda %d %d.\n", orderId, allOrders[orderId].price);
  }

}

void changePrice()
{
  int productId;
  int newPrice;
  int quantity;
  int i;
  int j;
  int inicialPrice;
  int totalDifference;
  productId = new_sym_var(sizeof(int) * 8);
  newPrice = new_sym_var(sizeof(int) * 8);
  if (allProducts[productId].price == 0)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", productId);
  }
  else
  {
    for (i = 0; i < countProd; i++)
    {
      if (allProducts[i].id == productId)
      {
        inicialPrice = allProducts[i].price;
        allProducts[i].price = newPrice;
      }
      else
      {
        
      }

    }

    for (i = 0; i < countOrd; i++)
    {
      for (j = 0; j < 200; j++)
      {
        if (allOrders[i].orderProducts[j].id == productId)
        {
          quantity = allOrders[i].orderProducts[j].quantity;
          totalDifference = (newPrice - inicialPrice) * quantity;
          allOrders[i].price += totalDifference;
          break;
        }
        else
        {
          
        }

      }

    }

  }

}

void giveDescription()
{
  int orderId;
  int productId;
  int i;
  int productQuantity = 0;
  char productDescription[63];
  orderId = new_sym_var(sizeof(int) * 8);
  productId = new_sym_var(sizeof(int) * 8);
  if (allOrders[orderId].id == (-1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", orderId);
  }
  else
  {
    if (allProducts[productId].price == 0)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", productId);
    }
    else
    {
      for (i = 0; i <= getNumOfProds(orderId); i++)
      {
        if (allOrders[orderId].orderProducts[i].id == productId)
        {
          productQuantity = allOrders[orderId].orderProducts[i].quantity;
          break;
        }
        else
        {
          
        }

      }

      for (i = 0; i < countProd; i++)
      {
        if (allProducts[i].id == productId)
        {
          memmove(productDescription, allProducts[i].description, strlen(allProducts[i].description) + 1);
        }
        else
        {
          
        }

      }

      printf("%s %d.\n", productDescription, productQuantity);
    }

  }

}

void maxOccurrence()
{
  int productId;
  int biggestOrder;
  int biggestQuantity = 0;
  int i;
  int j;
  productId = new_sym_var(sizeof(int) * 8);
  if (allProducts[productId].price == 0)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", productId);
  }
  else
  {
    for (i = 0; i < countOrd; i++)
    {
      for (j = 0; j <= getNumOfProds(i); j++)
      {
        if (allOrders[i].orderProducts[j].id == productId)
        {
          if (allOrders[i].orderProducts[j].quantity > biggestQuantity)
          {
            biggestQuantity = allOrders[i].orderProducts[j].quantity;
            biggestOrder = i;
            break;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    if (biggestQuantity > 0)
    {
      printf("Maximo produto %d %d %d.\n", productId, biggestOrder, biggestQuantity);
    }
    else
    {
      
    }

  }

}

void insertionSortPrice(Product a[], int left, int right)
{
  int i;
  int j;
  Product aux[1] = {0};
  for (i = left + 1; i <= right; i++)
  {
    copyStructsProducts(aux, 0, a, i);
    j = i - 1;
    while (((j >= left) && (aux[0].price < a[j].price)) || (((j >= left) && (aux[0].price == a[j].price)) && (aux[0].id < a[j].id)))
    {
      copyStructsProducts(a, j + 1, a, j);
      j--;
    }

    copyStructsProducts(a, j + 1, aux, 0);
  }

}

void sortByPrice()
{
  int i;
  insertionSortPrice(allProducts, 0, countProd - 1);
  printf("Produtos\n");
  for (i = 0; i < countProd; i++)
  {
    printf("* %s %d %d\n", allProducts[i].description, allProducts[i].price, allProducts[i].stock);
  }

}

void insertionSortDescription(ProductInOrder a[], int left, int right)
{
  int i;
  int j;
  ProductInOrder aux[1] = {0};
  for (i = left + 1; i <= right; i++)
  {
    copyStructsOrders(aux, 0, a, i);
    j = i - 1;
    while ((j >= left) && (strcmp(allProducts[aux[0].id].description, allProducts[a[j].id].description) < 0))
    {
      copyStructsOrders(a, j + 1, a, j);
      j--;
    }

    copyStructsOrders(a, j + 1, aux, 0);
  }

}

void sortByDescription()
{
  int orderId;
  int i;
  orderId = new_sym_var(sizeof(int) * 8);
  if (allOrders[orderId].id == (-1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", orderId);
  }
  else
  {
    insertionSortDescription(allOrders[orderId].orderProducts, 0, getNumOfProds(orderId) - 1);
    printf("Encomenda %d\n", orderId);
    for (i = 0; i < getNumOfProds(orderId); i++)
    {
      printf("* %s %d %d\n", allProducts[allOrders[orderId].orderProducts[i].id].description, allProducts[allOrders[orderId].orderProducts[i].id].price, allOrders[orderId].orderProducts[i].quantity);
    }

  }

}

int main()
{
  int productQuantity;
  int orderId;
  int productId;
  char c;
  initOrder();
  do
  {
    switch (c = getchar())
    {
      case 'a':
        addProduct();
        break;

      case 'q':
        addStock();
        break;

      case 'N':
        createOrder();
        break;

      case 'A':
        orderId = new_sym_var(sizeof(int) * 8);
        productId = new_sym_var(sizeof(int) * 8);
        productQuantity = new_sym_var(sizeof(int) * 8);
        addProduct_2_Order(orderId, productId, productQuantity);
        break;

      case 'r':
        removeStock();
        break;

      case 'R':
        orderId = new_sym_var(sizeof(int) * 8);
        productId = new_sym_var(sizeof(int) * 8);
        removeProduct(orderId, productId);
        break;

      case 'C':
        getOrderCost();
        break;

      case 'p':
        changePrice();
        break;

      case 'E':
        giveDescription();
        break;

      case 'm':
        maxOccurrence();
        break;

      case 'l':
        sortByPrice();
        break;

      case 'L':
        sortByDescription();
        break;

      default:
        break;

    }

  }
  while (c != 'x');
  return 0;
}

