#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


int z = 0;
int i = 0;
int t = 0;
int novo[10000];
struct produtos
{
  char descricao[63];
  int preco;
  int peso;
  int qtd;
};
struct produtos produtos[10000];
struct encomendas
{
  struct produtos produto[200];
  int chegada[200];
  int casamaxima;
};
struct encomendas encomendas[500];
void funcaoa(char arg1[], int arg2, int arg3, int arg4)
{
  strcpy(produtos[z].descricao, arg1);
  produtos[z].preco = arg2;
  produtos[z].peso = arg3;
  produtos[z].qtd = arg4;
  printf("Novo produto %d.\n", z);
}

void funcaoq(int arg2, int arg3)
{
  if (arg2 > (z - 1))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", arg2);
  }
  else
  {
    produtos[arg2].qtd = produtos[arg2].qtd + arg3;
  }

}

void funcaoN()
{
  printf("Nova encomenda %d.\n", i);
  i++;
}

int peso_da_encomenda(int ide)
{
  int x = 0;
  int t = 0;
  while (x != encomendas[ide].casamaxima)
  {
    t += encomendas[ide].produto[x].peso;
    x++;
  }

  return t;
}

void funcaoA(int ide, int idp, int qtd)
{
  int x = 0;
  if (ide > (i - 1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (idp > (z - 1))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      if (qtd > produtos[idp].qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        return;
      }
      else
      {
        if ((peso_da_encomenda(ide) + (produtos[idp].peso * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          return;
        }
        else
        {
          
        }

      }

    }

  }

  while (x != encomendas[ide].casamaxima)
  {
    if (idp == encomendas[ide].chegada[x])
    {
      encomendas[ide].produto[x].qtd += qtd;
      encomendas[ide].produto[x].preco = produtos[idp].preco * encomendas[ide].produto[x].qtd;
      encomendas[ide].produto[x].peso = produtos[idp].peso * encomendas[ide].produto[x].qtd;
      produtos[idp].qtd -= qtd;
      return;
    }
    else
    {
      
    }

    x++;
  }

  x = encomendas[ide].casamaxima;
  encomendas[ide].produto[x].qtd = qtd;
  encomendas[ide].produto[x].preco = produtos[idp].preco * encomendas[ide].produto[x].qtd;
  encomendas[ide].produto[x].peso = produtos[idp].peso * encomendas[ide].produto[x].qtd;
  encomendas[ide].chegada[x] = idp;
  produtos[idp].qtd -= qtd;
  strcpy(encomendas[ide].produto[x].descricao, produtos[idp].descricao);
  encomendas[ide].casamaxima++;
  return;
}

void funcaor(int idp, int qtd)
{
  if (idp > (z - 1))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    if ((produtos[idp].qtd - qtd) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
      return;
    }
    else
    {
      produtos[idp].qtd -= qtd;
    }

  }

}

void funcaoR(int ide, int idp)
{
  int x = 0;
  if (ide > (i - 1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (idp > (z - 1))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      
    }

  }

  while (x != encomendas[ide].casamaxima)
  {
    if (encomendas[ide].chegada[x] == idp)
    {
      produtos[idp].qtd += encomendas[ide].produto[x].qtd;
      encomendas[ide].produto[x].qtd = 0;
      encomendas[ide].produto[x].peso = 0;
      return;
    }
    else
    {
      
    }

    x++;
  }

}

void funcaoc(int ide)
{
  int x = 0;
  int total = 0;
  int idp = 0;
  if (ide > (i - 1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  while (x != encomendas[ide].casamaxima)
  {
    idp = encomendas[ide].chegada[x];
    encomendas[ide].produto[x].preco = produtos[idp].preco * encomendas[ide].produto[x].qtd;
    total = total + encomendas[ide].produto[x].preco;
    x = x + 1;
  }

  printf("Custo da encomenda %d %d.\n", ide, total);
}

void precos_encomendas(int idp)
{
  int x = 0;
  int y = 0;
  while (x < i)
  {
    while (y < encomendas[x].casamaxima)
    {
      if (encomendas[x].chegada[y] == idp)
      {
        encomendas[x].produto[y].preco = produtos[idp].preco * encomendas[x].produto[y].qtd;
      }
      else
      {
        
      }

      y = y + 1;
    }

    x++;
  }

}

void funcaop(int idp, int preco)
{
  if (idp > (z - 1))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  produtos[idp].preco = preco;
  precos_encomendas(idp);
}

void funcaoE(int ide, int idp)
{
  int x = 0;
  if (idp > (z - 1))
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    if (ide > (i - 1))
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      return;
    }
    else
    {
      
    }

  }

  while (x != encomendas[ide].casamaxima)
  {
    if (idp == encomendas[ide].chegada[x])
    {
      printf("%s %d.\n", produtos[idp].descricao, encomendas[ide].produto[x].qtd);
      return;
    }
    else
    {
      
    }

    x++;
  }

  printf("%s 0.\n", produtos[idp].descricao);
}

void funcaom(int idp)
{
  int x = 0;
  int p = 0;
  int max = 0;
  int idezao = 0;
  if (idp > (z - 1))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  while (p != i)
  {
    while (x < encomendas[p].casamaxima)
    {
      if ((idp == encomendas[p].chegada[x]) && (encomendas[p].produto[x].qtd > max))
      {
        max = encomendas[p].produto[x].qtd;
        idezao = p;
      }
      else
      {
        
      }

      x++;
    }

    p++;
    x = 0;
  }

  if (max == 0)
  {
    return;
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", idp, idezao, max);
}

int partition(int a[], int left, int right)
{
  int i = left - 1;
  int t[10000];
  int j = right;
  int v = a[right];
  while (i < j)
  {
    while ((produtos[a[++i]].preco < produtos[v].preco) || ((v > a[i]) && (produtos[v].preco == produtos[a[i]].preco)))
      ;

    while ((produtos[v].preco < produtos[a[--j]].preco) || ((v < a[j]) && (produtos[v].preco == produtos[a[j]].preco)))
    {
      if (j == left)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      t[0] = a[i];
      a[i] = a[j];
      a[j] = t[0];
    }
    else
    {
      
    }

  }

  t[0] = a[i];
  a[i] = a[right];
  a[right] = t[0];
  return i;
}

void quicksort(int a[], int left, int right)
{
  int i;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  i = partition(a, left, right);
  quicksort(a, left, i - 1);
  quicksort(a, i + 1, right);
}

void funcaol()
{
  int o = 0;
  int t = 0;
  while (o < z)
  {
    novo[o] = o;
    o++;
  }

  printf("Produtos\n");
  quicksort(novo, 0, z - 1);
  while (t < z)
  {
    printf("* %s %d %d\n", produtos[novo[t]].descricao, produtos[novo[t]].preco, produtos[novo[t]].qtd);
    t++;
  }

}

void mergedois(int a[], int left, int m, int right, int ide)
{
  int b;
  int j;
  int k;
  int aux[10000];
  for (b = m + 1; b > left; b--)
  {
    aux[b - 1] = a[b - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if ((strcmp(encomendas[ide].produto[aux[j]].descricao, encomendas[ide].produto[aux[b]].descricao) < 0) || (b > m))
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[b++];
    }

  }

}

void mergesortdois(int a[], int left, int right, int ide)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesortdois(a, left, m, ide);
  mergesortdois(a, m + 1, right, ide);
  mergedois(a, left, m, right, ide);
}

void funcaoL(int ide)
{
  int arg2 = 0;
  int t = 0;
  int idps = 0;
  if (ide > (i - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  printf("Encomenda %d\n", ide);
  while (arg2 != encomendas[ide].casamaxima)
  {
    novo[arg2] = arg2;
    arg2++;
  }

  mergesortdois(novo, 0, encomendas[ide].casamaxima - 1, ide);
  while (t < encomendas[ide].casamaxima)
  {
    idps = encomendas[ide].chegada[novo[t]];
    if (encomendas[ide].produto[novo[t]].qtd != 0)
    {
      printf("* %s %d %d\n", encomendas[ide].produto[novo[t]].descricao, produtos[idps].preco, encomendas[ide].produto[novo[t]].qtd);
    }
    else
    {
      
    }

    t++;
  }

}

int main()
{
  char c;
  char arg1[10000];
  int arg2;
  int arg3;
  int arg4;
  int ide;
  for (;;)
  {
    switch (c = getchar())
    {
      case 'a':
        for (int arg1_index = 0; arg1_index < 10; arg1_index++)
      {
        arg1[arg1_index] = new_sym_var(sizeof(char) * 8);
      }

        arg1[10 - 1] = '\0';
        arg2 = new_sym_var(sizeof(int) * 8);
        arg3 = new_sym_var(sizeof(int) * 8);
        arg4 = new_sym_var(sizeof(int) * 8);
        funcaoa(arg1, arg2, arg3, arg4);
        z++;
        break;

      case 'q':
        arg2 = new_sym_var(sizeof(int) * 8);
        arg3 = new_sym_var(sizeof(int) * 8);
        funcaoq(arg2, arg3);
        break;

      case 'N':
        funcaoN();
        break;

      case 'A':
        arg2 = new_sym_var(sizeof(int) * 8);
        arg3 = new_sym_var(sizeof(int) * 8);
        arg4 = new_sym_var(sizeof(int) * 8);
        funcaoA(arg2, arg3, arg4);
        break;

      case 'r':
        arg2 = new_sym_var(sizeof(int) * 8);
        arg3 = new_sym_var(sizeof(int) * 8);
        funcaor(arg2, arg3);
        break;

      case 'R':
        arg2 = new_sym_var(sizeof(int) * 8);
        arg3 = new_sym_var(sizeof(int) * 8);
        funcaoR(arg2, arg3);
        break;

      case 'C':
        arg2 = new_sym_var(sizeof(int) * 8);
        funcaoc(arg2);
        break;

      case 'p':
        arg2 = new_sym_var(sizeof(int) * 8);
        arg3 = new_sym_var(sizeof(int) * 8);
        funcaop(arg2, arg3);
        break;

      case 'E':
        arg2 = new_sym_var(sizeof(int) * 8);
        arg3 = new_sym_var(sizeof(int) * 8);
        funcaoE(arg2, arg3);
        break;

      case 'm':
        arg2 = new_sym_var(sizeof(int) * 8);
        funcaom(arg2);
        break;

      case 'l':
        funcaol();
        break;

      case 'L':
        ide = new_sym_var(sizeof(int) * 8);
        funcaoL(ide);
        break;

      case 'x':
        return 0;
        break;

      default:
        break;

    }

  }

  return 0;
}

