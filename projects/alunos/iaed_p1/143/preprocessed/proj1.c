/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct product
{
  int id;
  char description[64];
  int price;
  int weight;
  int qtd;
} Product;
typedef struct order
{
  int id;
  int weight;
  int number;
  int products[200][2];
} Order;
void init();
void a();
void q();
void N();
void A();
void r();
void R();
void C();
void p();
void E();
void m();
void l();
void L();
void k();
void K();
void quickSort_l(int v[], int left, int right);
void quickSort_L(int v[], int left, int right);
void swap(int v[], int i, int j);
int find_idp(int ide, int idp);
int cmp_description(int x, int y);
int cmp_price(int x, int y);
int productId;
int orderId;
Product stock[10000];
Order orders[500];
int main()
{
  int c;
  init();
  while (((c = getchar()) != EOF) && (c != 'x'))
  {
    getchar();
    switch (c)
    {
      case 'a':
        a();
        break;

      case 'q':
        q();
        break;

      case 'N':
        N();
        break;

      case 'A':
        A();
        break;

      case 'r':
        r();
        break;

      case 'R':
        R();
        break;

      case 'C':
        C();
        break;

      case 'p':
        p();
        break;

      case 'E':
        E();
        break;

      case 'm':
        m();
        break;

      case 'l':
        l();
        break;

      case 'L':
        L();
        break;

    }

  }

  return 0;
}

void init()
{
  int i;
  int j;
  for (i = 0; i < 500; i++)
    for (j = 0; j < 200; j++)
    orders[i].products[j][0] = -1;


}

void a()
{
  for (int stock_index = 0; stock_index < 10; stock_index++)
  {
    stock[productId].description[stock_index] = new_sym_var(sizeof(char) * 8);
  }

  stock[productId].description[10 - 1] = '\0';
  stock[productId].price = new_sym_var(sizeof(int) * 8);
  stock[productId].weight = new_sym_var(sizeof(int) * 8);
  stock[productId].qtd = new_sym_var(sizeof(int) * 8);
  stock[productId].id = productId;
  printf("Novo produto %d.\n", productId);
  productId++;
}

void q()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= productId)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  stock[idp].qtd += qtd;
}

void N()
{
  orders[orderId].id = orderId;
  printf("Nova encomenda %d.\n", orderId);
  orderId++;
}

void A()
{
  int i;
  int idp;
  int ide;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= orderId)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp >= productId)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (stock[idp].qtd < qtd)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if ((orders[ide].weight + (stock[idp].weight * qtd)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (qtd <= 0)
  {
    return;
  }
  else
  {
    
  }

  if ((i = find_idp(ide, idp)) < 0)
  {
    orders[ide].products[orders[ide].number][0] = idp;
    orders[ide].products[orders[ide].number][1] += qtd;
    orders[ide].number++;
  }
  else
  {
    orders[ide].products[i][1] += qtd;
  }

  orders[ide].weight += stock[idp].weight * qtd;
  stock[idp].qtd -= qtd;
}

void r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= productId)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (stock[idp].qtd < qtd)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    return;
  }
  else
  {
    
  }

  stock[idp].qtd -= qtd;
}

void R()
{
  int i;
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= orderId)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp >= productId)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if ((i = find_idp(ide, idp)) < 0)
  {
    return;
  }
  else
  {
    
  }

  orders[ide].weight -= stock[idp].weight * orders[ide].products[i][1];
  stock[idp].qtd += orders[ide].products[i][1];
  while (i < (orders[ide].number - 1))
  {
    orders[ide].products[i][0] = orders[ide].products[i + 1][0];
    orders[ide].products[i][1] = orders[ide].products[i + 1][1];
    i++;
  }

  orders[ide].products[i][0] = -1;
  orders[ide].products[i][1] = 0;
  orders[ide].number--;
}

void C()
{
  int i;
  int ide;
  int total;
  total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= orderId)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < 200; i++)
  {
    total += stock[orders[ide].products[i][0]].price * orders[ide].products[i][1];
  }

  printf("Custo da encomenda %d %d.\n", ide, total);
}

void p()
{
  int idp;
  int price;
  idp = new_sym_var(sizeof(int) * 8);
  price = new_sym_var(sizeof(int) * 8);
  if (idp >= productId)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  stock[idp].price = price;
}

void E()
{
  int i;
  int qtd;
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= orderId)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  if (idp >= productId)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if ((i = find_idp(ide, idp)) >= 0)
  {
    qtd = orders[ide].products[i][1];
  }
  else
  {
    qtd = 0;
  }

  printf("%s %d.\n", stock[idp].description, qtd);
}

void m()
{
  int i;
  int j;
  int idp;
  int higherQtd;
  int higherId;
  higherId = (higherQtd = 0);
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= productId)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < orderId; i++)
  {
    if ((j = find_idp(i, idp)) >= 0)
    {
      if (orders[i].products[j][1] > higherQtd)
      {
        higherId = i;
        higherQtd = orders[i].products[j][1];
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  if (higherQtd > 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, higherId, higherQtd);
  }
  else
  {
    
  }

}

void l()
{
  int i;
  int stockCopy[10000] = {0};
  for (i = 0; i < productId; i++)
    stockCopy[i] = i;

  quickSort_l(stockCopy, 0, productId - 1);
  printf("Produtos\n");
  for (i = 0; i < productId; i++)
    printf("* %s %d %d\n", stock[stockCopy[i]].description, stock[stockCopy[i]].price, stock[stockCopy[i]].qtd);

}

void L()
{
  int i;
  int j;
  int ide;
  int orderCopy[200] = {0};
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= orderId)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0, j = 0; i < orders[ide].number; i++)
    orderCopy[j++] = orders[ide].products[i][0];

  quickSort_L(orderCopy, 0, orders[ide].number - 1);
  printf("Encomenda %d\n", ide);
  for (i = 0; i < orders[ide].number; i++)
    printf("* %s %d %d\n", stock[orderCopy[i]].description, stock[orderCopy[i]].price, orders[ide].products[find_idp(ide, orderCopy[i])][1]);

}

void quickSort_l(int v[], int left, int right)
{
  int i;
  int last;
  if (left >= right)
  {
    return;
  }
  else
  {
    
  }

  swap(v, left, (left + right) / 2);
  last = left;
  for (i = left + 1; i <= right; i++)
    if (cmp_price(v[i], v[left]))
  {
    swap(v, ++last, i);
  }
  else
  {
    
  }


  swap(v, left, last);
  quickSort_l(v, left, last - 1);
  quickSort_l(v, last + 1, right);
}

void quickSort_L(int v[], int left, int right)
{
  int i;
  int last;
  if (left >= right)
  {
    return;
  }
  else
  {
    
  }

  swap(v, left, (left + right) / 2);
  last = left;
  for (i = left + 1; i <= right; i++)
    if (cmp_description(v[i], v[left]))
  {
    swap(v, ++last, i);
  }
  else
  {
    
  }


  swap(v, left, last);
  quickSort_L(v, left, last - 1);
  quickSort_L(v, last + 1, right);
}

void swap(int v[], int i, int j)
{
  int tmp;
  tmp = v[i];
  v[i] = v[j];
  v[j] = tmp;
}

int find_idp(int ide, int idp)
{
  int i;
  for (i = 0; i < 200; i++)
    if (orders[ide].products[i][0] == idp)
  {
    return i;
  }
  else
  {
    
  }


  return -1;
}

int cmp_description(int x, int y)
{
  return strcmp(stock[x].description, stock[y].description) < 0;
}

int cmp_price(int x, int y)
{
  return (stock[x].price < stock[y].price) || ((x < y) && (stock[x].price == stock[y].price));
}

