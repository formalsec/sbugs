#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  char descricao[64];
  int preco;
  int peso;
  int qtd;
} produto;
typedef struct 
{
  produto dados[10000];
  int ide;
  int idp;
  int qtd;
  int peso;
} encomenda;
int contador_encomendas = 0;
int contador_produtos = 0;
int A;
int B;
char ha[64];
char hb[64];
char vaz[64] = " ";
encomenda vetor_encomenda[500];
produto vetor_produto[10000];
void inicializa_vetor();
int compara_ids(int e, int i);
void sort(int i);
int procura_encomenda(int ide);
int procura_produto(int idp);
void mergesort(produto vetor_produto[10000], int left, int right);
void merge(produto vetor_produto[10000], int left, int y, int right);
void insertion(encomenda vetor_encomenda[500], int left, int right);
void adiciona_produto();
void adiciona_stock_produto();
void cria_encomenda();
void adiciona_produto_encomenda();
void remove_produto_encomenda();
void remove_stock_produto();
void calcula_custo();
void muda_preco_produto();
void lista_quantidade_produto_enc();
void imprime_encomendas();
void lista_produtos_existentes();
void lista_encomendas_alfabeticamente();
void inicializa_vetor()
{
  int i;
  int b;
  int g;
  int j;
  for (i = 0; i < 10000; i++)
  {
    vetor_produto[i].qtd = 0;
    vetor_produto[i].preco = 0;
    vetor_produto[i].peso = 0;
    for (j = 0; j < 64; j++)
      vetor_produto[i].descricao[j] = '\0';

  }

  for (b = 0; b < 500; b++)
  {
    vetor_encomenda[b].ide = 0;
    vetor_encomenda[b].idp = 0;
    vetor_encomenda[b].qtd = 0;
    for (g = 0; g < 10000; g++)
    {
      vetor_encomenda[b].dados[g].qtd = 0;
      vetor_encomenda[b].dados[g].preco = 0;
      vetor_encomenda[b].dados[g].peso = 0;
    }

  }

}

int compara_ids(int e, int i)
{
  if ((e - i) < 0)
  {
    return e;
  }
  else
  {
    return i;
  }

}

int procura_encomenda(int ide)
{
  int i;
  for (i = 0; i < contador_encomendas; i++)
  {
    if ((vetor_encomenda[i].ide - vetor_encomenda[ide].ide) == 0)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int procura_produto(int idp)
{
  int i;
  int b;
  for (i = 0; i < contador_encomendas; i++)
  {
    for (b = 0; b < contador_produtos; b++)
    {
      if ((vetor_encomenda[i].dados - idp) == 0)
      {
        break;
      }
      else
      {
        
      }

    }

  }

  if (i == contador_encomendas)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, i);
    return -1;
  }
  else
  {
    
  }

  return i;
}

int right;
int left;
int w;
int t;
int v;
int o;
int b;
int cicle;
int cond;
int i;
char help_i[64];
char help_j[64];
void insertion(encomenda vetor_encomenda[500], int left, int right)
{
  for (i = 0; i < contador_encomendas; i++)
  {
    for (b = 0; i < contador_produtos; b++)
    {
      for (cicle = left + 1; cicle <= right; i++)
      {
        strcpy(help_i, vetor_encomenda[i].dados[b].descricao);
        strcpy(help_j, vetor_encomenda[i + 1].dados[b].descricao);
        cond = cicle - 1;
        while ((cond >= left) && (strcmp(ha, hb) < 0))
        {
          cond--;
        }

        strcpy(help_i, vetor_encomenda[i + 1].dados[b].descricao);
      }

    }

  }

}

produto aux[10000];
void merge(produto vetor_produto[10000], int left, int v, int right)
{
  for (w = v + 1; w > left; w--)
  {
    aux[w - 1].preco = vetor_produto[w - 1].preco;
  }

  for (t = v; t < right; t++)
  {
    aux[(right + v) - t].preco = vetor_produto[t + 1].preco;
  }

  for (o = left; o <= right; o++)
  {
    if ((vetor_produto[aux[t].preco].preco < vetor_produto[aux[w].preco].preco) || (i > v))
    {
      vetor_produto[o].preco = aux[t--].preco;
    }
    else
    {
      vetor_produto[o].preco = aux[w++].preco;
    }

  }

}

void mergesort(produto vetor_produto[10000], int left, int right)
{
  v = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(vetor_produto, left, v);
  mergesort(vetor_produto, v + 1, right);
  merge(vetor_produto, left, v, right);
}

void adiciona_produto()
{
  for (int vetor_produto_index = 0; vetor_produto_index < 10; vetor_produto_index++)
  {
    vetor_produto[contador_produtos].descricao[vetor_produto_index] = new_sym_var(sizeof(char) * 8);
  }

  vetor_produto[contador_produtos].descricao[10 - 1] = '\0';
  vetor_produto[contador_produtos].preco = new_sym_var(sizeof(int) * 8);
  vetor_produto[contador_produtos].peso = new_sym_var(sizeof(int) * 8);
  vetor_produto[contador_produtos].qtd = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", contador_produtos);
  contador_produtos++;
}

int i;
int n;
void adiciona_stock_produto()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  i = procura_produto(idp);
  n = vetor_produto[i].qtd + qtd;
  if ((n * vetor_produto[i].peso) == 200)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    vetor_produto[i].qtd = n;
  }

}

void cria_encomenda()
{
  printf("Nova encomenda %d.\n", contador_encomendas);
  contador_encomendas++;
}

void adiciona_produto_encomenda()
{
  int ide;
  int idp;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if ((procura_encomenda(ide) > 0) && (procura_produto(idp) > 0))
  {
    if (vetor_encomenda[ide].dados[idp].qtd - qtd)
    {
      if (((vetor_produto[idp].qtd * vetor_produto[idp].peso) + vetor_encomenda[ide].peso) <= 200)
      {
        vetor_encomenda[ide].dados[200] = vetor_produto[idp];
        remove_stock_produto(idp, qtd);
        vetor_encomenda[ide].peso = (vetor_produto[idp].qtd * vetor_produto[idp].peso) + vetor_encomenda[ide].peso;
      }
      else
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    }

  }
  else
  {
    if ((procura_encomenda(ide) < 0) && (procura_produto(idp) > 0))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
    else
    {
      if ((procura_produto(idp) <= 0) && (procura_encomenda(ide) > 0))
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
      else
      {
        
      }

    }

  }

}

int i;
void remove_produto_encomenda()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if ((procura_encomenda(ide) > 0) && (procura_produto(idp) > 0))
  {
    vetor_encomenda[ide].peso = vetor_encomenda[ide].peso - vetor_produto[idp].peso;
    for (i = idp; i <= contador_encomendas; i++)
    {
      vetor_encomenda[ide].dados[idp] = vetor_encomenda[ide].dados[idp + 1];
    }

    contador_encomendas = contador_encomendas - 1;
  }
  else
  {
    if ((procura_encomenda(ide) < 0) && (procura_produto(idp) > 0))
    {
      printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    }
    else
    {
      if ((procura_produto(idp) < 0) && (procura_encomenda(ide) > 0))
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      }
      else
      {
        
      }

    }

  }

}

void remove_stock_produto()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (procura_produto(idp) > 0)
  {
    if (vetor_produto[idp].qtd - qtd)
    {
      vetor_produto[idp].qtd = vetor_produto[idp].qtd - qtd;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }

}

int K;
int c = 0;
void calcula_custo()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (procura_encomenda(ide) > 0)
  {
    for (K = 0; K <= ide; K++)
    {
      c = c + (vetor_encomenda[ide].dados[K].qtd * vetor_encomenda[ide].dados[K].preco);
      printf("Custo da encomenda %d %d.\n", ide, c);
    }

  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void muda_preco_produto()
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (procura_produto(idp) > 0)
  {
    vetor_produto[idp].preco = preco;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

int q;
char d[64];
void lista_quantidade_produto_enc()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if ((procura_encomenda(ide) > 0) && (procura_produto(idp) > 0))
  {
    strcpy(d, vetor_encomenda[ide].dados[idp].descricao);
    q = vetor_encomenda[ide].dados[idp].qtd;
    printf("%s %d.", d, q);
  }
  else
  {
    if ((procura_encomenda(ide) < 0) && (procura_produto(idp) > 0))
    {
      printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    }
    else
    {
      if ((procura_produto(idp) < 0) && (procura_encomenda(ide) > 0))
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      }
      else
      {
        
      }

    }

  }

}

int m;
int j[500];
int e;
int i;
void imprime_encomendas()
{
  int idp;
  idp = new_sym_var(sizeof(int) * 8);
  if (procura_produto(idp) > 0)
  {
    for (i = 0; i <= contador_encomendas; i++)
    {
      j[i] = j[i] + 1;
      if (m < j[i])
      {
        m = j[i];
        e = i;
        printf("Maximo produto %d %d %d.\n", idp, e, j[i]);
      }
      else
      {
        if (m == j[i])
        {
          compara_ids(e, i);
          printf("Maximo produto %d %d %d.\n", idp, m, j[m]);
        }
        else
        {
          
        }

      }

    }

    printf("Maximo produto %d %d %d.\n", idp, m, vetor_encomenda[m].dados[idp].qtd);
  }
  else
  {
    if (procura_produto(idp) < 0)
    {
      printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      
    }

  }

}

void lista_produtos_existentes()
{
  int idp;
  idp = new_sym_var(sizeof(int) * 8);
  left = idp % 2;
  right = left + 1;
  mergesort(vetor_produto, left, right);
  for (; i < idp; i++)
  {
    printf(" %s %d %d\n", vetor_produto[i].descricao, vetor_produto[i].preco, vetor_produto[i].qtd);
  }

  printf(" %s %d %d\n", vetor_produto[i].descricao, vetor_produto[i].preco, vetor_produto[i].qtd);
}

void lista_encomendas_alfabeticamente()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (procura_encomenda(ide) > 0)
  {
    for (i = 0; i < ide; i++)
    {
      for (b = 0; i < contador_produtos; b++)
      {
        insertion(vetor_encomenda, left, right);
        printf(" %s %d %d\n", vetor_encomenda[i].dados[b].descricao, vetor_encomenda[i].dados[b].preco, vetor_encomenda[i].dados[b].qtd);
      }

    }

    printf(" %s %d %d\n", vetor_encomenda[ide].dados[contador_produtos].descricao, vetor_encomenda[ide].dados[contador_produtos].preco, vetor_encomenda[ide].dados[contador_produtos].qtd);
  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

int main()
{
  char c;
  int trabalha = 1;
  inicializa_vetor();
  while (trabalha)
  {
    switch (c = getchar())
    {
      case 'a':
        adiciona_produto();
        break;

      case 'q':
        adiciona_stock_produto();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        adiciona_produto_encomenda();
        break;

      case 'R':
        remove_produto_encomenda();
        break;

      case 'r':
        remove_stock_produto();
        break;

      case 'C':
        calcula_custo();
        break;

      case 'p':
        muda_preco_produto();
        break;

      case 'E':
        lista_quantidade_produto_enc();
        break;

      case 'm':
        imprime_encomendas();
        break;

      case 'l':
        lista_produtos_existentes();
        break;

      case 'L':
        lista_encomendas_alfabeticamente();
        break;

      case 'x':
        trabalha = 0;
        break;

      default:
        break;

    }

  }

  return 0;
}

