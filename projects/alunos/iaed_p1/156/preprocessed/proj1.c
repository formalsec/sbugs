#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  int idp;
  int preco;
  int peso;
  int qtd;
  char desc[64];
  int qtd_uso;
  int qtd_encomendada[500];
} Produto;
typedef struct encomenda
{
  Produto prods[200];
  int peso;
} Encomenda;
Produto prods[10000] = {0};
Encomenda encomendas[500] = {0};
Produto cp_prods[10000] = {0};
int maior_idp;
Produto aux_l[10000];
Produto encomenda[200];
Produto aux_L[200];
void __a__(char desc[64], int preco, int peso, int qtd);
void __q__(int idp, int qtd);
void __N__();
void __A__(int ide, int idp, int qtd);
void __r__(int idp, int qtd);
void __R__(int ide, int idp);
void __C__(int ide);
void __p__(int idp, int preco);
void __E__(int ide, int idp);
void __m__(int idp);
void __l__();
void Merge_l(Produto a[], int left, int m, int right);
void MergeSort_l(Produto a[], int left, int right);
void __L__(int ide);
void Merge_L(Produto a[], int left, int m, int right);
void MergeSort_L(Produto a[], int left, int right);
int main()
{
  char c;
  char desc[64];
  int preco;
  int peso;
  int qtd;
  int idp;
  int ide;
  while ((c = getchar()) != 'x')
  {
    switch (c)
    {
      case 'a':
        for (int desc_index = 0; desc_index < 10; desc_index++)
      {
        desc[desc_index] = new_sym_var(sizeof(char) * 8);
      }

        desc[10 - 1] = '\0';
        preco = new_sym_var(sizeof(int) * 8);
        peso = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        __a__(desc, preco, peso, qtd);
        break;

      case 'q':
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        __q__(idp, qtd);
        break;

      case 'N':
        __N__();
        break;

      case 'A':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        __A__(ide, idp, qtd);
        break;

      case 'r':
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        __r__(idp, qtd);
        break;

      case 'R':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        __R__(ide, idp);
        break;

      case 'C':
        ide = new_sym_var(sizeof(int) * 8);
        __C__(ide);
        break;

      case 'p':
        idp = new_sym_var(sizeof(int) * 8);
        preco = new_sym_var(sizeof(int) * 8);
        __p__(idp, preco);
        break;

      case 'E':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        __E__(ide, idp);
        break;

      case 'm':
        idp = new_sym_var(sizeof(int) * 8);
        __m__(idp);
        break;

      case 'l':
        __l__();
        break;

      case 'L':
        ide = new_sym_var(sizeof(int) * 8);
        __L__(ide);
        break;

    }

  }

  return 0;
}

void __a__(char desc[64], int preco, int peso, int qtd)
{
  Produto p;
  static int i = 0;
  int j;
  strcpy(p.desc, desc);
  p.preco = preco;
  p.peso = peso;
  p.qtd = qtd;
  p.idp = i;
  p.qtd_uso = 0;
  for (j = 0; j < 500; j++)
    p.qtd_encomendada[j] = 0;

  prods[i] = p;
  maior_idp = i;
  i++;
  printf("Novo produto %d.\n", p.idp);
}

void __q__(int idp, int qtd)
{
  if (prods[idp].preco == 0)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    prods[idp].qtd += qtd;
  }

}

void __N__()
{
  static int i = 0;
  printf("Nova encomenda %d.\n", i);
  encomendas[i].prods[0].preco = -1;
  i++;
}

void __A__(int ide, int idp, int qtd)
{
  if (encomendas[ide].prods[0].preco == 0)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (prods[idp].preco == 0)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (prods[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((encomendas[ide].peso + (prods[idp].peso * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          int i;
          encomendas[ide].peso += prods[idp].peso * qtd;
          prods[idp].qtd -= qtd;
          prods[idp].qtd_uso += qtd;
          if (prods[idp].qtd_encomendada[ide] == 0)
          {
            for (i = 0; i < 200; i++)
            {
              if (encomendas[ide].prods[i].peso == 0)
              {
                encomendas[ide].prods[i] = prods[idp];
                break;
              }
              else
              {
                
              }

            }

          }
          else
          {
            
          }

          prods[idp].qtd_encomendada[ide] += qtd;
        }

      }

    }

  }

}

void __r__(int idp, int qtd)
{
  if (prods[idp].preco == 0)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if ((prods[idp].qtd - qtd) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      prods[idp].qtd -= qtd;
    }

  }

}

void __R__(int ide, int idp)
{
  if (encomendas[ide].prods[0].preco == 0)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (prods[idp].preco == 0)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (prods[idp].qtd_encomendada[ide] == 0)
      {
        return;
      }
      else
      {
        int i;
        encomendas[ide].peso -= prods[idp].qtd_encomendada[ide] * prods[idp].peso;
        prods[idp].qtd += prods[idp].qtd_encomendada[ide];
        prods[idp].qtd_uso -= prods[idp].qtd_encomendada[ide];
        prods[idp].qtd_encomendada[ide] = 0;
        for (i = 0; i < 200; i++)
        {
          if (encomendas[ide].prods[i].idp == idp)
          {
            encomendas[ide].prods[i].peso = 0;
            break;
          }
          else
          {
            
          }

        }

      }

    }

  }

}

void __C__(int ide)
{
  if (encomendas[ide].prods[0].preco == 0)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (encomendas[ide].peso == 0)
    {
      printf("Custo da encomenda %d 0.\n", ide);
    }
    else
    {
      int i;
      int custo = 0;
      for (i = 0; i < 200; i++)
      {
        if (encomendas[ide].prods[i].preco != 0)
        {
          if (encomendas[ide].prods[i].peso != 0)
          {
            int idp = encomendas[ide].prods[i].idp;
            custo += prods[idp].preco * prods[idp].qtd_encomendada[ide];
          }
          else
          {
            
          }

        }
        else
        {
          break;
        }

      }

      printf("Custo da encomenda %d %d.\n", ide, custo);
    }

  }

}

void __p__(int idp, int preco)
{
  if (prods[idp].preco == 0)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    prods[idp].preco = preco;
  }

}

void __E__(int ide, int idp)
{
  if (encomendas[ide].prods[0].preco == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (prods[idp].preco == 0)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      printf("%s %d.\n", prods[idp].desc, prods[idp].qtd_encomendada[ide]);
    }

  }

}

void __m__(int idp)
{
  if (prods[idp].preco == 0)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (prods[idp].qtd_uso == 0)
    {
      ;
    }
    else
    {
      int i;
      int ide;
      int qtd = 0;
      for (i = 0; i < 500; i++)
      {
        if (prods[idp].qtd_encomendada[i] > qtd)
        {
          ide = i;
          qtd = prods[idp].qtd_encomendada[i];
        }
        else
        {
          
        }

      }

      printf("Maximo produto %d %d %d.\n", idp, ide, qtd);
    }

  }

}

void __l__()
{
  printf("Produtos\n");
  if (prods[0].preco == 0)
  {
    return;
  }
  else
  {
    int i;
    for (i = 0; i <= maior_idp; i++)
    {
      strcpy(cp_prods[i].desc, prods[i].desc);
      cp_prods[i].preco = prods[i].preco;
      cp_prods[i].idp = prods[i].idp;
      cp_prods[i].qtd = prods[i].qtd;
    }

    MergeSort_l(cp_prods, 0, maior_idp);
    for (i = 0; i <= maior_idp; i++)
      printf("* %s %d %d\n", cp_prods[i].desc, cp_prods[i].preco, cp_prods[i].qtd);

  }

}

void MergeSort_l(Produto a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  MergeSort_l(a, left, m);
  MergeSort_l(a, m + 1, right);
  Merge_l(a, left, m, right);
}

void Merge_l(Produto a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux_l[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux_l[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
  {
    if ((aux_l[j].preco < aux_l[i].preco) || (i > m))
    {
      a[k] = aux_l[j--];
    }
    else
    {
      a[k] = aux_l[i++];
    }

  }

}

void __L__(int ide)
{
  if (encomendas[ide].prods[0].preco == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (encomendas[ide].peso == 0)
    {
      printf("Encomenda %d\n", ide);
    }
    else
    {
      int i = 0;
      int j;
      int idp;
      while (i < 200)
      {
        if (encomendas[ide].prods[i].preco != 0)
        {
          strcpy(encomenda[i].desc, encomendas[ide].prods[i].desc);
          encomenda[i].peso = encomendas[ide].prods[i].peso;
          encomenda[i].idp = encomendas[ide].prods[i].idp;
          i++;
        }
        else
        {
          break;
        }

      }

      MergeSort_L(encomenda, 0, i - 1);
      printf("Encomenda %d\n", ide);
      for (j = 0; j < i; j++)
      {
        if (encomenda[j].peso != 0)
        {
          idp = encomenda[j].idp;
          printf("* %s %d %d\n", prods[idp].desc, prods[idp].preco, prods[idp].qtd_encomendada[ide]);
        }
        else
        {
          
        }

      }

    }

  }

}

void MergeSort_L(Produto a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  MergeSort_L(a, left, m);
  MergeSort_L(a, m + 1, right);
  Merge_L(a, left, m, right);
}

void Merge_L(Produto a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux_L[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux_L[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
  {
    if (strcmp(aux_L[j].desc, aux_L[i].desc) < 0)
    {
      a[k] = aux_L[j--];
    }
    else
    {
      a[k] = aux_L[i++];
    }

  }

}

