#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  char descricao[63];
  int preco;
  int peso;
  int qtd;
} produto;
typedef struct encomenda
{
  produto produtos[10000];
  int peso;
} encomenda;
int numero_prod = -1;
int numero_enc = -1;
char comando;
produto lista_prod[10000];
encomenda lista_enc[500];
produto lista_ord[10000];
produto lista_esq[10000 / 2];
produto lista_dir[10000 / 2];
void merge(int esq, int m, int dir, int key);
void mergesort(int esq, int dir, int key);
void adiciona_produto();
void add_stock();
void cria_encomenda();
void adiciona_prod_enc();
void remove_stock();
void remove_produto_enc();
void calcula_custo_enc();
void altera_preco();
void lista_desc_qtd();
void lista_ident();
void ordena_prod_preco();
void ordena_enc_alf();
int main()
{
  while ((comando = getchar()) != 'x')
  {
    switch (comando)
    {
      case 'a':
        adiciona_produto();
        break;

      case 'q':
        add_stock();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        adiciona_prod_enc();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_produto_enc();
        break;

      case 'C':
        calcula_custo_enc();
        break;

      case 'p':
        altera_preco();
        break;

      case 'E':
        lista_desc_qtd();
        break;

      case 'm':
        lista_ident();
        break;

      case 'l':
        ordena_prod_preco();
        break;

      case 'L':
        ordena_enc_alf();
        break;

      default:
        break;

    }

  }

  return 0;
}

void adiciona_produto()
{
  produto novo;
  for (int novo_index = 0; novo_index < 10; novo_index++)
  {
    novo.descricao[novo_index] = new_sym_var(sizeof(char) * 8);
  }

  novo.descricao[10 - 1] = '\0';
  novo.preco = new_sym_var(sizeof(int) * 8);
  novo.peso = new_sym_var(sizeof(int) * 8);
  novo.qtd = new_sym_var(sizeof(int) * 8);
  numero_prod++;
  lista_prod[numero_prod] = novo;
  printf("Novo produto %d.\n", numero_prod);
}

void add_stock()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp > numero_prod)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    lista_prod[idp].qtd += qtd;
  }

}

void cria_encomenda()
{
  numero_enc++;
  printf("Nova encomenda %d.\n", numero_enc);
}

void adiciona_prod_enc()
{
  int ide;
  int idp;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide > numero_enc)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp > numero_prod)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (lista_prod[idp].qtd < qtd)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if ((lista_enc[ide].peso + (lista_prod[idp].peso * qtd)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (lista_enc[ide].produtos[idp].qtd == 0)
  {
    strcpy(lista_enc[ide].produtos[idp].descricao, lista_prod[idp].descricao);
    lista_enc[ide].produtos[idp].preco = lista_prod[idp].preco;
    lista_enc[ide].produtos[idp].qtd = qtd;
  }
  else
  {
    lista_enc[ide].produtos[idp].qtd += qtd;
  }

  lista_enc[ide].peso += lista_prod[idp].peso * qtd;
  lista_prod[idp].qtd -= qtd;
}

void remove_stock()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp > numero_prod)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (lista_prod[idp].qtd < qtd)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    return;
  }
  else
  {
    
  }

  lista_prod[idp].qtd -= qtd;
}

void remove_produto_enc()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > numero_enc)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp > numero_prod)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  lista_enc[ide].peso -= lista_enc[ide].produtos[idp].qtd * lista_prod[idp].peso;
  lista_prod[idp].qtd += lista_enc[ide].produtos[idp].qtd;
  memset(lista_enc[ide].produtos[idp].descricao, 0, 63);
  lista_enc[ide].produtos[idp].preco = 0;
  lista_enc[ide].produtos[idp].qtd = 0;
}

void calcula_custo_enc()
{
  int ide;
  int i = 0;
  int soma = 0;
  int max_prod = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > numero_enc)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  while ((i <= numero_prod) && (max_prod != 200))
  {
    if (lista_enc[ide].produtos[i].qtd != 0)
    {
      soma += lista_enc[ide].produtos[i].qtd * lista_prod[i].preco;
      max_prod++;
    }
    else
    {
      
    }

    i++;
  }

  printf("Custo da encomenda %d %d.\n", ide, soma);
}

void altera_preco()
{
  int idp;
  int preco;
  int i;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp > numero_prod)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  lista_prod[idp].preco = preco;
  for (i = 0; i <= numero_enc; i++)
  {
    if (lista_enc[i].produtos[idp].qtd != 0)
    {
      lista_enc[i].produtos[idp].preco = preco;
    }
    else
    {
      
    }

  }

}

void lista_desc_qtd()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > numero_enc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  if (idp > numero_prod)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  printf("%s %d.\n", lista_prod[idp].descricao, lista_enc[ide].produtos[idp].qtd);
}

void lista_ident()
{
  int i;
  int idp;
  int max = 0;
  int ide;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp > numero_prod)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i <= numero_enc; i++)
  {
    if (lista_enc[i].produtos[idp].qtd > max)
    {
      max = lista_enc[i].produtos[idp].qtd;
      ide = i;
    }
    else
    {
      
    }

  }

  if (max > 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, ide, max);
  }
  else
  {
    
  }

}

void ordena_prod_preco()
{
  int i;
  for (i = 0; i <= numero_prod; i++)
  {
    lista_ord[i] = lista_prod[i];
  }

  mergesort(0, numero_prod, 1);
  puts("Produtos");
  for (i = 0; i <= numero_prod; i++)
  {
    printf("* %s %d %d\n", lista_ord[i].descricao, lista_ord[i].preco, lista_ord[i].qtd);
  }

}

void ordena_enc_alf()
{
  int ide;
  int i;
  int n_prod_enc_ord = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > numero_enc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i <= numero_prod; i++)
  {
    if (lista_enc[ide].produtos[i].qtd != 0)
    {
      lista_ord[n_prod_enc_ord] = lista_enc[ide].produtos[i];
      n_prod_enc_ord++;
    }
    else
    {
      
    }

    if (n_prod_enc_ord == 200)
    {
      break;
    }
    else
    {
      
    }

  }

  mergesort(0, n_prod_enc_ord - 1, 0);
  printf("Encomenda %d\n", ide);
  for (i = 0; i < n_prod_enc_ord; i++)
    printf("* %s %d %d\n", lista_ord[i].descricao, lista_ord[i].preco, lista_ord[i].qtd);

}

void merge(int esq, int m, int dir, int key)
{
  int i;
  int j;
  int k;
  int tam_v_esq = (m - esq) + 1;
  int tam_v_dir = dir - m;
  for (i = 0; i < tam_v_esq; i++)
    lista_esq[i] = lista_ord[esq + i];

  for (j = 0; j < tam_v_dir; j++)
    lista_dir[j] = lista_ord[(m + j) + 1];

  i = 0;
  j = 0;
  k = esq;
  while ((i < tam_v_esq) && (j < tam_v_dir))
  {
    if (key == 1)
    {
      if (lista_esq[i].preco <= lista_dir[j].preco)
      {
        lista_ord[k] = lista_esq[i++];
      }
      else
      {
        lista_ord[k] = lista_dir[j++];
      }

    }
    else
    {
      if (strcmp(lista_esq[i].descricao, lista_dir[j].descricao) < 0)
      {
        lista_ord[k] = lista_esq[i++];
      }
      else
      {
        lista_ord[k] = lista_dir[j++];
      }

    }

    k++;
  }

  while (i < tam_v_esq)
  {
    lista_ord[k] = lista_esq[i++];
    k++;
  }

  while (j < tam_v_dir)
  {
    lista_ord[k] = lista_dir[j++];
    k++;
  }

}

void mergesort(int esq, int dir, int key)
{
  if (esq < dir)
  {
    int m = (dir + esq) / 2;
    mergesort(esq, m, key);
    mergesort(m + 1, dir, key);
    merge(esq, m, dir, key);
  }
  else
  {
    
  }

}

