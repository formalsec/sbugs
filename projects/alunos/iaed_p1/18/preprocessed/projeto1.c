#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>


typedef struct produto
{
  int idp;
  int preco;
  int peso;
  int qtd;
  int pedidos;
  char desc[64];
} produto;
typedef struct infoProduto
{
  int idp;
  int qtd;
} infoProduto;
typedef struct encomenda
{
  infoProduto produtos[200];
  int peso;
  int n_produtos;
  int ide;
} encomenda;
produto bdProdutos[10000];
encomenda bdEncomendas[500];
int IDProduto = 0;
int IDEncomenda = 0;
void copiaString(char origem[], char destino[]);
int comparaString(char str1[], char str2[]);
int converteParaMinusculas(int a);
void criaProduto(char desc[], int preco, int peso, int qtd);
produto aux_criaProduto(char desc[], int preco, int peso, int qtd);
void adicionaStock(int idp, int qtd);
void criaEncomenda();
encomenda aux_criaEncomenda();
void adicionaProdutoEncomenda(int ide, int idp, int qtd);
void removeStock(int idp, int qtd);
void removeProdutoEncomenda(int ide, int idp);
void aux_removeProduto(int ide, int idp);
void custoEncomenda(int ide);
void alteraPreco(int idp, int preco);
void infoProdutoEncomenda(int ide, int idp);
void maiorEncomendaProduto(int idp);
void ordProdutosPreco();
void mergesortProdutos(produto num[], int l, int r);
void aux_mergesortProdutos(produto num[], int l, int m, int r);
void reordenaProdutos(produto lista[], int end);
void ordEncomendaDesc(int ide);
void mergesortEncomendas(infoProduto list[], int l, int r);
void aux_mergesortEncomendas(infoProduto list[], int l, int m, int r);
int main()
{
  char s[64];
  int estado = 1;
  int c;
  int a;
  int b;
  while (estado)
  {
    switch (c = getchar())
    {
      case 'a':
        for (int s_index = 0; s_index < 10; s_index++)
      {
        s[s_index] = new_sym_var(sizeof(char) * 8);
      }

        s[10 - 1] = '\0';
        a = new_sym_var(sizeof(int) * 8);
        b = new_sym_var(sizeof(int) * 8);
        c = new_sym_var(sizeof(int) * 8);
        criaProduto(s, a, b, c);
        break;

      case 'q':
        a = new_sym_var(sizeof(int) * 8);
        b = new_sym_var(sizeof(int) * 8);
        adicionaStock(a, b);
        break;

      case 'N':
        criaEncomenda();
        break;

      case 'A':
        a = new_sym_var(sizeof(int) * 8);
        b = new_sym_var(sizeof(int) * 8);
        c = new_sym_var(sizeof(int) * 8);
        adicionaProdutoEncomenda(a, b, c);
        break;

      case 'r':
        a = new_sym_var(sizeof(int) * 8);
        b = new_sym_var(sizeof(int) * 8);
        removeStock(a, b);
        break;

      case 'R':
        a = new_sym_var(sizeof(int) * 8);
        b = new_sym_var(sizeof(int) * 8);
        removeProdutoEncomenda(a, b);
        break;

      case 'C':
        a = new_sym_var(sizeof(int) * 8);
        custoEncomenda(a);
        break;

      case 'p':
        a = new_sym_var(sizeof(int) * 8);
        b = new_sym_var(sizeof(int) * 8);
        alteraPreco(a, b);
        break;

      case 'E':
        a = new_sym_var(sizeof(int) * 8);
        b = new_sym_var(sizeof(int) * 8);
        infoProdutoEncomenda(a, b);
        break;

      case 'm':
        a = new_sym_var(sizeof(int) * 8);
        maiorEncomendaProduto(a);
        break;

      case 'l':
        ordProdutosPreco();
        break;

      case 'L':
        a = new_sym_var(sizeof(int) * 8);
        ordEncomendaDesc(a);
        break;

      case 'x':
        estado = 0;

      default:
        break;

    }

  }

  return 0;
}

void criaProduto(char desc[], int preco, int peso, int qtd)
{
  bdProdutos[IDProduto] = aux_criaProduto(desc, preco, peso, qtd);
  printf("Novo produto %d.\n", IDProduto);
  IDProduto++;
}

produto aux_criaProduto(char desc[], int preco, int peso, int qtd)
{
  produto res;
  res.preco = preco;
  res.peso = peso;
  res.qtd = qtd;
  res.pedidos = 0;
  res.idp = IDProduto;
  copiaString(desc, res.desc);
  return res;
}

void adicionaStock(int idp, int qtd)
{
  if (idp >= IDProduto)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    bdProdutos[idp].qtd += qtd;
  }

}

void criaEncomenda()
{
  bdEncomendas[IDEncomenda] = aux_criaEncomenda();
  printf("Nova encomenda %d.\n", IDEncomenda);
  IDEncomenda++;
}

encomenda aux_criaEncomenda()
{
  encomenda res;
  res.n_produtos = 0;
  res.peso = 0;
  res.ide = IDEncomenda;
  return res;
}

void adicionaProdutoEncomenda(int ide, int idp, int qtd)
{
  int i;
  int produtoExiste;
  if (ide >= IDEncomenda)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= IDProduto)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if ((bdProdutos[idp].qtd - qtd) < bdProdutos[idp].pedidos)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((bdEncomendas[ide].peso + (bdProdutos[idp].peso * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          produtoExiste = 0;
          for (i = 0; i < bdEncomendas[ide].n_produtos; i++)
            if (idp == bdEncomendas[ide].produtos[i].idp)
          {
            produtoExiste++;
            bdEncomendas[ide].produtos[i].qtd += qtd;
            bdEncomendas[ide].peso += qtd * bdProdutos[idp].peso;
            bdProdutos[idp].pedidos += qtd;
            return;
          }
          else
          {
            
          }


          if (!produtoExiste)
          {
            produtoExiste = bdEncomendas[ide].n_produtos++;
            bdEncomendas[ide].produtos[produtoExiste].idp = idp;
            bdEncomendas[ide].produtos[produtoExiste].qtd = qtd;
            bdEncomendas[ide].peso += qtd * bdProdutos[idp].peso;
            bdProdutos[idp].pedidos += qtd;
          }
          else
          {
            
          }

        }

      }

    }

  }

}

void removeStock(int idp, int qtd)
{
  if (idp >= IDProduto)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if ((bdProdutos[idp].qtd - qtd) < bdProdutos[idp].pedidos)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      bdProdutos[idp].qtd -= qtd;
    }

  }

}

void removeProdutoEncomenda(int ide, int idp)
{
  int peso;
  int qtd;
  int i;
  if (ide >= IDEncomenda)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= IDProduto)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      for (i = 0; i < bdEncomendas[ide].n_produtos; i++)
      {
        if (idp == bdEncomendas[ide].produtos[i].idp)
        {
          peso = bdProdutos[idp].peso;
          qtd = bdEncomendas[ide].produtos[i].qtd;
          bdEncomendas[ide].peso -= qtd * peso;
          bdProdutos[idp].pedidos -= qtd;
          aux_removeProduto(ide, i);
          break;
        }
        else
        {
          
        }

      }

    }

  }

}

void aux_removeProduto(int ide, int idp)
{
  int n;
  n = bdEncomendas[ide].n_produtos - 1;
  bdEncomendas[ide].produtos[idp] = bdEncomendas[ide].produtos[n];
  bdEncomendas[ide].n_produtos--;
}

void custoEncomenda(int ide)
{
  int res;
  int idp;
  int qtd;
  int i;
  if (ide >= IDEncomenda)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    res = 0;
    for (i = 0; i < bdEncomendas[ide].n_produtos; i++)
    {
      qtd = bdEncomendas[ide].produtos[i].qtd;
      idp = bdEncomendas[ide].produtos[i].idp;
      res += bdProdutos[idp].preco * qtd;
    }

    printf("Custo da encomenda %d %d.\n", ide, res);
  }

}

void alteraPreco(int idp, int preco)
{
  if (idp >= IDProduto)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    bdProdutos[idp].preco = preco;
  }

}

void infoProdutoEncomenda(int ide, int idp)
{
  int i;
  int produtoEncomendado;
  if (ide >= IDEncomenda)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= IDProduto)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      produtoEncomendado = 0;
      for (i = 0; i < bdEncomendas[ide].n_produtos; i++)
        if (idp == bdEncomendas[ide].produtos[i].idp)
      {
        produtoEncomendado++;
        printf("%s %d.\n", bdProdutos[idp].desc, bdEncomendas[ide].produtos[i].qtd);
      }
      else
      {
        
      }


      if (!produtoEncomendado)
      {
        printf("%s 0.\n", bdProdutos[idp].desc);
      }
      else
      {
        
      }

    }

  }

}

void maiorEncomendaProduto(int idp)
{
  int i;
  int j;
  int ide;
  int qtd;
  if (idp >= IDProduto)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if ((IDEncomenda > 0) && (bdProdutos[idp].pedidos > 0))
    {
      qtd = 0;
      for (i = 0; i < IDEncomenda; i++)
        for (j = 0; j < bdEncomendas[i].n_produtos; j++)
        if ((idp == bdEncomendas[i].produtos[j].idp) && (bdEncomendas[i].produtos[j].qtd > qtd))
      {
        qtd = bdEncomendas[i].produtos[j].qtd;
        ide = i;
      }
      else
      {
        
      }



      printf("Maximo produto %d %d %d.\n", idp, ide, qtd);
    }
    else
    {
      
    }

  }

}

void ordProdutosPreco()
{
  int i;
  mergesortProdutos(bdProdutos, 0, IDProduto - 1);
  printf("Produtos\n");
  for (i = 0; i < IDProduto; i++)
    printf("* %s %d %d\n", bdProdutos[i].desc, bdProdutos[i].preco, bdProdutos[i].qtd - bdProdutos[i].pedidos);

  reordenaProdutos(bdProdutos, IDProduto - 1);
}

void mergesortProdutos(produto vetor[], int l, int r)
{
  if (l < r)
  {
    int m = (l + r) / 2;
    mergesortProdutos(vetor, l, m);
    mergesortProdutos(vetor, m + 1, r);
    aux_mergesortProdutos(vetor, l, m, r);
  }
  else
  {
    
  }

}

void aux_mergesortProdutos(produto vetor[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  produto aux[10000];
  for (i = l; i <= r; i++)
    aux[i] = vetor[i];

  i = l;
  j = m + 1;
  k = l;
  while ((i <= m) && (j <= r))
  {
    if (aux[i].preco <= aux[j].preco)
    {
      vetor[k++] = aux[i++];
    }
    else
    {
      vetor[k++] = aux[j++];
    }

  }

  while (i <= m)
    vetor[k++] = aux[i++];

}

void reordenaProdutos(produto vetor[], int end)
{
  int i = 0;
  int idp;
  produto aux;
  while (i < end)
  {
    if (vetor[i].idp != i)
    {
      idp = vetor[i].idp;
      aux = vetor[idp];
      vetor[idp] = vetor[i];
      vetor[i] = aux;
    }
    else
    {
      i++;
    }

  }

}

void mergesortEncomendas(infoProduto vetor[], int l, int r)
{
  if (l < r)
  {
    int m;
    m = (l + r) / 2;
    mergesortEncomendas(vetor, l, m);
    mergesortEncomendas(vetor, m + 1, r);
    aux_mergesortEncomendas(vetor, l, m, r);
  }
  else
  {
    
  }

}

void aux_mergesortEncomendas(infoProduto vetor[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int idp1;
  int idp2;
  infoProduto aux[200];
  for (i = l; i <= r; i++)
    aux[i] = vetor[i];

  i = l;
  j = m + 1;
  k = l;
  while ((i <= m) && (j <= r))
  {
    idp1 = aux[i].idp;
    idp2 = aux[j].idp;
    if (comparaString(bdProdutos[idp1].desc, bdProdutos[idp2].desc) <= 0)
    {
      vetor[k++] = aux[i++];
    }
    else
    {
      vetor[k++] = aux[j++];
    }

  }

  while (i <= m)
    vetor[k++] = aux[i++];

}

void ordEncomendaDesc(int ide)
{
  int i;
  int idp;
  int qtd;
  if (ide >= IDEncomenda)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    mergesortEncomendas(bdEncomendas[ide].produtos, 0, bdEncomendas[ide].n_produtos - 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < bdEncomendas[ide].n_produtos; i++)
    {
      idp = bdEncomendas[ide].produtos[i].idp;
      qtd = bdEncomendas[ide].produtos[i].qtd;
      printf("* %s %d %d\n", bdProdutos[idp].desc, bdProdutos[idp].preco, qtd);
    }

  }

}

void copiaString(char origem[], char destino[])
{
  int c;
  int i;
  i = 0;
  while ((c = origem[i]) != '\0')
    destino[i++] = c;

  destino[i] = '\0';
}

int converteParaMinusculas(int a)
{
  if ((a >= 'A') && (a <= 'Z'))
  {
    a += 'a' - 'A';
  }
  else
  {
    
  }

  return a;
}

int comparaString(char str1[], char str2[])
{
  int a;
  int b;
  int i;
  int res;
  i = 0;
  res = 0;
  while (((!res) && ((a = str1[i]) != '\0')) && ((b = str2[i]) != '\0'))
  {
    res = converteParaMinusculas(a) - converteParaMinusculas(b);
    i++;
  }

  return res;
}

