/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct Produto
{
  int id;
  char descricao[64];
  int preco;
  int peso;
  int quantidade;
} Produto;
typedef struct Encomenda
{
  int produtos[200][2];
  int peso_total;
  int proximo_id;
} Encomenda;
void obter_comando();
void adicionar_produto();
void adicionar_stock();
void cria_encomenda();
void adicionar_produto_encomenda();
void remove_quantidade();
void remove_produto_encomenda();
void custo_encomenda();
void altera_preco();
void lista_produto_encomanda();
void maior_quantidade_produto();
void lista_produtos();
void lista_produtos_encomanda();
void merge_sort();
void merge();
int obter_pos_produto();
int encomenda_naoExiste();
int produto_naoExiste();
int a_correr = 1;
int num_produtos = 0;
int num_encomendas = 0;
Produto produtos[10000];
Encomenda encomendas[500];
int main()
{
  while (a_correr)
    obter_comando();

  return 0;
}

void obter_comando()
{
  char comando;
  comando = getchar();
  switch (comando)
  {
    case 'a':
      adicionar_produto();
      break;

    case 'q':
      adicionar_stock();
      break;

    case 'N':
      cria_encomenda();
      break;

    case 'A':
      adicionar_produto_encomenda();
      break;

    case 'r':
      remove_quantidade();
      break;

    case 'R':
      remove_produto_encomenda();
      break;

    case 'C':
      custo_encomenda();
      break;

    case 'p':
      altera_preco();
      break;

    case 'E':
      lista_produto_encomanda();
      break;

    case 'm':
      maior_quantidade_produto();
      break;

    case 'l':
      lista_produtos();
      break;

    case 'L':
      lista_produtos_encomanda();
      break;

    case 'x':
      a_correr = 0;
      break;

  }

}

void adicionar_produto()
{
  for (int produtos_index = 0; produtos_index < 10; produtos_index++)
  {
    produtos[num_produtos].descricao[produtos_index] = new_sym_var(sizeof(char) * 8);
  }

  produtos[num_produtos].descricao[10 - 1] = '\0';
  produtos[num_produtos].preco = new_sym_var(sizeof(int) * 8);
  produtos[num_produtos].peso = new_sym_var(sizeof(int) * 8);
  produtos[num_produtos].quantidade = new_sym_var(sizeof(int) * 8);
  produtos[num_produtos].id = num_produtos;
  printf("Novo produto %d.\n", num_produtos);
  num_produtos++;
}

void adicionar_stock()
{
  int idp;
  int quantidade;
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (produto_naoExiste(idp))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].quantidade += quantidade;
  }

}

void cria_encomenda()
{
  printf("Nova encomenda %d.\n", num_encomendas);
  num_encomendas++;
}

void adicionar_produto_encomenda()
{
  int ide;
  int idp;
  int qnt_aAdicionar;
  int pos_produto;
  int peso_produtos;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qnt_aAdicionar = new_sym_var(sizeof(int) * 8);
  if (encomenda_naoExiste(ide))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (produto_naoExiste(idp))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (produtos[idp].quantidade < qnt_aAdicionar)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((encomendas[ide].peso_total + (produtos[idp].peso * qnt_aAdicionar)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          peso_produtos = qnt_aAdicionar * produtos[idp].peso;
          pos_produto = obter_pos_produto(ide, idp);
          produtos[idp].quantidade -= qnt_aAdicionar;
          if (pos_produto != (-1))
          {
            encomendas[ide].produtos[pos_produto][1] += qnt_aAdicionar;
            encomendas[ide].peso_total += peso_produtos;
          }
          else
          {
            pos_produto = encomendas[ide].proximo_id;
            encomendas[ide].produtos[pos_produto][0] = idp;
            encomendas[ide].produtos[pos_produto][1] = qnt_aAdicionar;
            encomendas[ide].peso_total += peso_produtos;
            encomendas[ide].proximo_id++;
          }

        }

      }

    }

  }

}

void remove_quantidade()
{
  int idp;
  int qnt_remover;
  idp = new_sym_var(sizeof(int) * 8);
  qnt_remover = new_sym_var(sizeof(int) * 8);
  if (produto_naoExiste(idp))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (produtos[idp].quantidade < qnt_remover)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qnt_remover, idp);
    }
    else
    {
      produtos[idp].quantidade -= qnt_remover;
    }

  }

}

void remove_produto_encomenda()
{
  int ide;
  int idp;
  int pos_produto;
  int qnt_aRemover;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (encomenda_naoExiste(ide))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (produto_naoExiste(idp))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      pos_produto = obter_pos_produto(ide, idp);
      if (pos_produto != (-1))
      {
        qnt_aRemover = encomendas[ide].produtos[pos_produto][1];
        produtos[idp].quantidade += qnt_aRemover;
        encomendas[ide].peso_total -= qnt_aRemover * produtos[idp].peso;
        encomendas[ide].produtos[pos_produto][1] = 0;
      }
      else
      {
        
      }

    }

  }

}

void custo_encomenda()
{
  int ide;
  int idp;
  int i;
  int quantidade;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (encomenda_naoExiste(ide))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < encomendas[ide].proximo_id; i++)
    {
      idp = encomendas[ide].produtos[i][0];
      quantidade = encomendas[ide].produtos[i][1];
      total += quantidade * produtos[idp].preco;
    }

    printf("Custo da encomenda %d %d.\n", ide, total);
  }

}

void altera_preco()
{
  int idp;
  int novo_preco;
  idp = new_sym_var(sizeof(int) * 8);
  novo_preco = new_sym_var(sizeof(int) * 8);
  if (produto_naoExiste(idp))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].preco = novo_preco;
  }

}

void lista_produto_encomanda()
{
  int ide;
  int idp;
  int pos_produto;
  int quantidade;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (encomenda_naoExiste(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (produto_naoExiste(idp))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      pos_produto = obter_pos_produto(ide, idp);
      if (pos_produto != (-1))
      {
        quantidade = encomendas[ide].produtos[pos_produto][1];
      }
      else
      {
        quantidade = 0;
      }

      printf("%s %d.\n", produtos[idp].descricao, quantidade);
    }

  }

}

void maior_quantidade_produto()
{
  int idp;
  int ide_max = -1;
  int qnt_max = 0;
  int ide;
  int pos_produto;
  idp = new_sym_var(sizeof(int) * 8);
  if (produto_naoExiste(idp))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  for (ide = 0; ide < num_encomendas; ide++)
  {
    pos_produto = obter_pos_produto(ide, idp);
    if ((pos_produto != (-1)) && (qnt_max < encomendas[ide].produtos[pos_produto][1]))
    {
      qnt_max = encomendas[ide].produtos[pos_produto][1];
      ide_max = ide;
    }
    else
    {
      
    }

  }

  if (ide_max != (-1))
  {
    printf("Maximo produto %d %d %d.\n", idp, ide_max, qnt_max);
  }
  else
  {
    
  }

}

void lista_produtos()
{
  int lista_idProdutos[10000];
  int idp;
  int i;
  for (idp = 0; idp < num_produtos; idp++)
    lista_idProdutos[idp] = idp;

  merge_sort(lista_idProdutos, 0, num_produtos - 1);
  printf("Produtos\n");
  for (i = 0; i < num_produtos; i++)
  {
    idp = lista_idProdutos[i];
    printf("* %s %d %d\n", produtos[idp].descricao, produtos[idp].preco, produtos[idp].quantidade);
  }

}

void merge_sort(int array[], int lim_inf, int lim_sup)
{
  int meio = (lim_sup + lim_inf) / 2;
  if (lim_sup <= lim_inf)
  {
    return;
  }
  else
  {
    
  }

  merge_sort(array, lim_inf, meio);
  merge_sort(array, meio + 1, lim_sup);
  merge(array, lim_inf, meio, lim_sup);
}

void merge(int array[], int lim_inf, int meio, int lim_sup)
{
  int i;
  int j;
  int tamanho_array = lim_inf;
  int tamanho_esquerda = (meio - lim_inf) + 1;
  int tamanho_direita = lim_sup - meio;
  int esquerda[10000 / 2];
  int direita[10000 / 2];
  for (i = 0; i < tamanho_esquerda; i++)
    esquerda[i] = array[lim_inf + i];

  for (j = 0; j < tamanho_direita; j++)
    direita[j] = array[(meio + 1) + j];

  i = 0;
  j = 0;
  while ((i < tamanho_esquerda) && (j < tamanho_direita))
  {
    if (produtos[esquerda[i]].preco <= produtos[direita[j]].preco)
    {
      array[tamanho_array++] = esquerda[i++];
    }
    else
    {
      array[tamanho_array++] = direita[j++];
    }

  }

  while (i < tamanho_esquerda)
    array[tamanho_array++] = esquerda[i++];

  while (j < tamanho_direita)
    array[tamanho_array++] = direita[j++];

}

void lista_produtos_encomanda()
{
  int ide;
  int idp;
  int quantidade;
  int lista_idProdutos[200];
  int i;
  int j;
  int pos_atual;
  char decricao_atual[64];
  char descricao_aComparar[64];
  ide = new_sym_var(sizeof(int) * 8);
  if (encomenda_naoExiste(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < encomendas[ide].proximo_id; i++)
    {
      lista_idProdutos[i] = i;
    }

    for (i = 0; i < encomendas[ide].proximo_id; i++)
    {
      pos_atual = lista_idProdutos[i];
      j = i - 1;
      strcpy(decricao_atual, produtos[encomendas[ide].produtos[pos_atual][0]].descricao);
      strcpy(descricao_aComparar, produtos[encomendas[ide].produtos[lista_idProdutos[j]][0]].descricao);
      while ((j >= 0) && (strcmp(decricao_atual, descricao_aComparar) < 0))
      {
        lista_idProdutos[j + 1] = lista_idProdutos[j];
        j--;
        strcpy(descricao_aComparar, produtos[encomendas[ide].produtos[lista_idProdutos[j]][0]].descricao);
      }

      lista_idProdutos[j + 1] = pos_atual;
    }

    printf("Encomenda %d\n", ide);
    for (i = 0; i < encomendas[ide].proximo_id; i++)
    {
      idp = encomendas[ide].produtos[lista_idProdutos[i]][0];
      quantidade = encomendas[ide].produtos[lista_idProdutos[i]][1];
      if (quantidade)
      {
        printf("* %s %d %d\n", produtos[idp].descricao, produtos[idp].preco, quantidade);
      }
      else
      {
        
      }

    }

  }

}

int encomenda_naoExiste(int ide)
{
  if (ide >= num_encomendas)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int produto_naoExiste(int idp)
{
  if (idp >= num_produtos)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int obter_pos_produto(int ide, int idp)
{
  int pos_produto;
  int qnt_produtos = encomendas[ide].proximo_id;
  for (pos_produto = 0; pos_produto < qnt_produtos; pos_produto++)
    if (encomendas[ide].produtos[pos_produto][0] == idp)
  {
    return pos_produto;
  }
  else
  {
    
  }


  return -1;
}

