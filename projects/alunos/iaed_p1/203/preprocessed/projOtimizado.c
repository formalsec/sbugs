#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  int preco;
  int peso;
  int qtd;
  int idp;
  char nome[64];
} prod;
int idp = 0;
prod produtos[10000];
typedef struct encomenda
{
  int peso;
  int num_prod_enc;
  prod prods_enc[200];
} enc;
int ide = 0;
enc encomendas[500];
int obtem_pesoP();
int obtem_qtd();
int obtem_preco();
void a_add_prod();
void q_add_stock();
void N_cria_encomenda();
void A_add_prod_enc();
void r_remove_stock();
void R_remove_produto_encomenda();
void C_calcula_custo_encomenda();
void p_altera_preco_produto();
void E_lista_produtos_por_encomenda();
void m_lista_mais_requisitado();
void mergeSort();
void printArray();
void merge();
void l_lista_prod_preco();
void L_lista_prod_enc_ordemAlfabetica();
int less();
int main()
{
  char n;
  n = getchar();
  while (n != 'x')
  {
    switch (n)
    {
      case 'a':
        a_add_prod();
        break;

      case 'q':
        q_add_stock();
        break;

      case 'N':
        N_cria_encomenda();
        break;

      case 'A':
        A_add_prod_enc();
        break;

      case 'r':
        r_remove_stock();
        break;

      case 'R':
        R_remove_produto_encomenda();
        break;

      case 'C':
        C_calcula_custo_encomenda();
        break;

      case 'p':
        p_altera_preco_produto();
        break;

      case 'E':
        E_lista_produtos_por_encomenda();
        break;

      case 'm':
        m_lista_mais_requisitado();
        break;

      case 'l':
        l_lista_prod_preco();
        break;

      case 'L':
        L_lista_prod_enc_ordemAlfabetica();

    }

    n = getchar();
  }

  return 0;
}

void a_add_prod()
{
  prod produto;
  for (int produto_index = 0; produto_index < 10; produto_index++)
  {
    produto.nome[produto_index] = new_sym_var(sizeof(char) * 8);
  }

  produto.nome[10 - 1] = '\0';
  produto.preco = new_sym_var(sizeof(int) * 8);
  produto.peso = new_sym_var(sizeof(int) * 8);
  produto.qtd = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", idp);
  produtos[idp] = produto;
  produtos[idp].idp = idp;
  idp++;
}

void q_add_stock()
{
  int qtd;
  int idp_aux;
  idp_aux = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp_aux < idp)
  {
    produtos[idp_aux].qtd += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp_aux);
  }

}

void N_cria_encomenda()
{
  printf("Nova encomenda %d.\n", ide);
  encomendas[ide].peso = 0;
  encomendas[ide].num_prod_enc = 0;
  ide++;
}

void A_add_prod_enc()
{
  int ide_aux;
  int idp_aux;
  int qtd;
  int i;
  int existe_na_encomenda;
  int n_prod_enc;
  existe_na_encomenda = 0;
  ide_aux = new_sym_var(sizeof(int) * 8);
  idp_aux = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  n_prod_enc = encomendas[ide_aux].num_prod_enc;
  if (ide_aux >= ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp_aux, ide_aux);
  }
  else
  {
    if (idp_aux >= idp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp_aux, ide_aux);
    }
    else
    {
      if (produtos[idp_aux].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp_aux, ide_aux);
      }
      else
      {
        if ((encomendas[ide_aux].peso + (qtd * produtos[idp_aux].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp_aux, ide_aux);
        }
        else
        {
          for (i = 0; i < n_prod_enc; i++)
          {
            if (encomendas[ide_aux].prods_enc[i].idp == produtos[idp_aux].idp)
            {
              encomendas[ide_aux].prods_enc[i].qtd += qtd;
              existe_na_encomenda = 1;
              break;
            }
            else
            {
              
            }

          }

          if (!existe_na_encomenda)
          {
            encomendas[ide_aux].prods_enc[n_prod_enc] = produtos[idp_aux];
            encomendas[ide_aux].prods_enc[n_prod_enc].qtd = qtd;
            encomendas[ide_aux].num_prod_enc++;
          }
          else
          {
            
          }

          encomendas[ide_aux].peso += qtd * produtos[idp_aux].peso;
          produtos[idp_aux].qtd -= qtd;
        }

      }

    }

  }

}

void r_remove_stock()
{
  int idp_aux;
  int qtd;
  idp_aux = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp_aux >= idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp_aux);
  }
  else
  {
    if (produtos[idp_aux].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp_aux);
    }
    else
    {
      produtos[idp_aux].qtd -= qtd;
    }

  }

}

void R_remove_produto_encomenda()
{
  int ide_aux;
  int idp_aux;
  int i;
  int j;
  int esta_na_encomenda = 0;
  ide_aux = new_sym_var(sizeof(int) * 8);
  idp_aux = new_sym_var(sizeof(int) * 8);
  if (ide_aux >= ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp_aux, ide_aux);
  }
  else
  {
    if (idp_aux >= idp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp_aux, ide_aux);
    }
    else
    {
      for (i = 0; i < encomendas[ide_aux].num_prod_enc; i++)
      {
        if (encomendas[ide_aux].prods_enc[i].idp == produtos[idp_aux].idp)
        {
          produtos[idp_aux].qtd += encomendas[ide_aux].prods_enc[i].qtd;
          encomendas[ide_aux].peso -= encomendas[ide_aux].prods_enc[i].qtd * encomendas[ide_aux].prods_enc[i].peso;
          esta_na_encomenda = 1;
          for (j = i; j < encomendas[ide_aux].num_prod_enc; j++)
          {
            encomendas[ide_aux].prods_enc[j] = encomendas[ide_aux].prods_enc[j + 1];
          }

          break;
        }
        else
        {
          
        }

      }

      if (esta_na_encomenda)
      {
        encomendas[ide_aux].num_prod_enc--;
      }
      else
      {
        
      }

    }

  }

}

void C_calcula_custo_encomenda()
{
  int ide_aux;
  int i;
  int custo_total;
  custo_total = 0;
  ide_aux = new_sym_var(sizeof(int) * 8);
  if (ide_aux >= ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide_aux);
  }
  else
  {
    for (i = 0; i < encomendas[ide_aux].num_prod_enc; i++)
    {
      if (encomendas[ide_aux].prods_enc[i].qtd != 0)
      {
        custo_total += encomendas[ide_aux].prods_enc[i].qtd * encomendas[ide_aux].prods_enc[i].preco;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d %d.\n", ide_aux, custo_total);
  }

}

void p_altera_preco_produto()
{
  int idp_aux;
  int preco;
  int i;
  int j;
  idp_aux = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp_aux >= idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp_aux);
  }
  else
  {
    produtos[idp_aux].preco = preco;
    for (j = 0; j < ide; j++)
    {
      for (i = 0; i < encomendas[j].num_prod_enc; i++)
      {
        if (encomendas[j].prods_enc[i].idp == idp_aux)
        {
          encomendas[j].prods_enc[i].preco = preco;
          break;
        }
        else
        {
          
        }

      }

    }

  }

}

void E_lista_produtos_por_encomenda()
{
  int ide_aux;
  int idp_aux;
  int i;
  int esta_na_encomenda = 0;
  ide_aux = new_sym_var(sizeof(int) * 8);
  idp_aux = new_sym_var(sizeof(int) * 8);
  if (ide_aux >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide_aux);
  }
  else
  {
    if (idp_aux >= idp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp_aux);
    }
    else
    {
      for (i = 0; i < encomendas[ide_aux].num_prod_enc; i++)
      {
        if (encomendas[ide_aux].prods_enc[i].idp == idp_aux)
        {
          esta_na_encomenda = 1;
          printf("%s %d.\n", encomendas[ide_aux].prods_enc[i].nome, encomendas[ide_aux].prods_enc[i].qtd);
          break;
        }
        else
        {
          
        }

      }

      if (!esta_na_encomenda)
      {
        printf("%s %d.\n", produtos[idp_aux].nome, 0);
      }
      else
      {
        
      }

    }

  }

}

void m_lista_mais_requisitado()
{
  int i;
  int j;
  int idp_aux;
  int id_encomenda = 0;
  int esta_na_encomenda = 0;
  int maior = 0;
  idp_aux = new_sym_var(sizeof(int) * 8);
  if (idp_aux >= idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp_aux);
  }
  else
  {
    for (j = 0; j < ide; j++)
    {
      for (i = 0; i < encomendas[j].num_prod_enc; i++)
      {
        if ((encomendas[j].prods_enc[i].idp == idp_aux) && (encomendas[j].prods_enc[i].qtd > maior))
        {
          esta_na_encomenda = 1;
          maior = encomendas[j].prods_enc[i].qtd;
          id_encomenda = j;
          break;
        }
        else
        {
          
        }

      }

    }

    if (esta_na_encomenda)
    {
      printf("Maximo produto %d %d %d.\n", idp_aux, id_encomenda, maior);
    }
    else
    {
      
    }

  }

}

void l_lista_prod_preco()
{
  int i;
  prod arr[10000];
  printf("Produtos\n");
  for (i = 0; i < idp; i++)
  {
    arr[i] = produtos[i];
  }

  mergeSort(arr, 0, idp - 1);
  printArray(arr, idp);
}

int flag_str = 0;
void L_lista_prod_enc_ordemAlfabetica()
{
  int ide_aux;
  int i;
  prod array[200];
  ide_aux = new_sym_var(sizeof(int) * 8);
  if (ide_aux >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide_aux);
  }
  else
  {
    for (i = 0; i < encomendas[ide_aux].num_prod_enc; i++)
    {
      array[i] = encomendas[ide_aux].prods_enc[i];
    }

    printf("Encomenda %d\n", ide_aux);
    flag_str = 1;
    mergeSort(array, 0, encomendas[ide_aux].num_prod_enc - 1);
    printArray(array, encomendas[ide_aux].num_prod_enc);
    flag_str = 0;
  }

}

prod aux[10000];
void merge(prod arr[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = arr[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = arr[j + 1];

  for (k = left; k <= right; k++)
    if (less(aux[j], aux[i]))
  {
    arr[k] = aux[j--];
  }
  else
  {
    arr[k] = aux[i++];
  }


}

void mergeSort(prod arr[], int left, int right)
{
  if (left < right)
  {
    int m = (left + right) / 2;
    if (right <= left)
    {
      return;
    }
    else
    {
      
    }

    mergeSort(arr, left, m);
    mergeSort(arr, m + 1, right);
    merge(arr, left, m, right);
  }
  else
  {
    
  }

}

int less(prod A, prod B)
{
  if (flag_str)
  {
    return strcmp(A.nome, B.nome) < 0;
  }
  else
  {
    if (A.preco == B.preco)
    {
      return A.idp < B.idp;
    }
    else
    {
      return A.preco < B.preco;
    }

  }

}

void printArray(prod A[], int n)
{
  int i;
  for (i = 0; i < n; i++)
    printf("* %s %d %d\n", A[i].nome, A[i].preco, A[i].qtd);

}

