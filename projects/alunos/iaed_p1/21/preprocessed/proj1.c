#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>


int idp_atual = -1;
int ide_atual = -1;
int i;
int j;
int k;
struct produto
{
  int idp;
  char desc[64];
  int preco;
  int peso;
  int qtd;
};
struct produto produtos[10000];
struct produto produtos_enc[10000];
struct encomenda
{
  int ide;
  struct produto produtos_enc[10000];
  int peso;
};
struct encomenda encomendas[500];
int funcaoloop();
int comando_a()
{
  if (idp_atual < (10000 - 1))
  {
    char desc[64];
    int c;
    int i;
    int preco;
    int peso;
    int qtd;
    idp_atual++;
    c = getchar();
    for (i = 0; (i < (64 - 1)) && (c != ':'); i++)
    {
      desc[i] = c;
      c = getchar();
    }

    desc[i + 1] = '\0';
    preco = new_sym_var(sizeof(int) * 8);
    peso = new_sym_var(sizeof(int) * 8);
    qtd = new_sym_var(sizeof(int) * 8);
    produtos[idp_atual].idp = idp_atual;
    for (i = 0; i < 64; i++)
      produtos[idp_atual].desc[i] = desc[i];

    produtos[idp_atual].preco = preco;
    produtos[idp_atual].peso = peso;
    produtos[idp_atual].qtd = qtd;
    printf("Novo produto %d", idp_atual);
  }
  else
  {
    
  }

  return funcaoloop();
}

int comando_q()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp > idp_atual)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.", idp);
  }
  else
  {
    produtos[idp].qtd += qtd;
  }

  return funcaoloop();
}

int comando_N()
{
  ide_atual++;
  encomendas[ide_atual].ide = ide_atual;
  printf("Nova encomenda %d", ide_atual);
  return funcaoloop();
}

int comando_A()
{
  int ide;
  int idp;
  int qtd;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide > ide_atual)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.", idp, ide);
  }
  else
  {
    if (idp > idp_atual)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.", idp, ide);
    }
    else
    {
      if (qtd > produtos[idp].qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.", idp, ide);
      }
      else
      {
        if ((encomendas[ide].peso + (produtos[idp].peso * qtd)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.", idp, ide);
        }
        else
        {
          if (encomendas[ide].produtos_enc[idp].idp != (-1))
          {
            encomendas[ide].produtos_enc[idp].qtd += qtd;
          }
          else
          {
            encomendas[ide].produtos_enc[idp].idp = produtos[idp].idp;
            for (i = 0; i < 64; i++)
              encomendas[ide].produtos_enc[idp].desc[i] = produtos[idp].desc[i];

            encomendas[ide].produtos_enc[idp].preco = produtos[idp].preco;
            encomendas[ide].produtos_enc[idp].peso = produtos[idp].preco;
            encomendas[ide].produtos_enc[idp].qtd = qtd;
            produtos[idp].qtd -= qtd;
          }

        }

      }

    }

  }

  return funcaoloop();
}

int comando_r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp > idp_atual)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.", idp);
  }
  else
  {
    if (produtos[idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.", qtd, idp);
    }
    else
    {
      produtos[idp].qtd -= qtd;
    }

  }

  return funcaoloop();
}

int comando_R()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > ide_atual)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.", idp, ide);
  }
  else
  {
    if (idp > idp_atual)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.", idp, ide);
    }
    else
    {
      encomendas[ide].produtos_enc[idp].idp = -1;
      for (i = 0; i < 64; i++)
        encomendas[ide].produtos_enc[idp].desc[i] = ' ';

      encomendas[ide].produtos_enc[idp].preco = 0;
      encomendas[ide].produtos_enc[idp].peso = 0;
      encomendas[ide].produtos_enc[idp].qtd = 0;
    }

  }

  return funcaoloop();
}

int comando_C()
{
  int ide;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > ide_atual)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.", ide);
  }
  else
  {
    int i;
    for (i = 0; i < 10000; i++)
    {
      if (encomendas[ide].produtos_enc[i].idp != (-1))
      {
        total += encomendas[ide].produtos_enc[i].preco * encomendas[ide].produtos_enc[i].qtd;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d : %d", ide, total);
  }

  return funcaoloop();
}

int comando_p()
{
  int idp;
  int preco;
  int i;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp > idp_atual)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.", idp);
  }
  else
  {
    produtos[idp].preco = preco;
    for (i = 0; i <= ide_atual; i++)
    {
      if (encomendas[i].produtos_enc[idp].idp == idp)
      {
        encomendas[i].produtos_enc[idp].preco = preco;
      }
      else
      {
        
      }

    }

  }

  return funcaoloop();
}

int comando_E()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > ide_atual)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.", idp, ide);
  }
  else
  {
    if (idp > idp_atual)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.", idp, ide);
    }
    else
    {
      printf("%s %d", encomendas[ide].produtos_enc[idp].desc, encomendas[ide].produtos_enc[idp].qtd);
    }

  }

  return funcaoloop();
}

int comando_m()
{
  int idp;
  int max_qtd = 0;
  int max_ide = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp > idp_atual)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.", idp);
  }
  else
  {
    for (i = 0; i < 500; i++)
    {
      if (((encomendas[i].ide != (-1)) && (encomendas[i].produtos_enc[idp].idp != (-1))) && (encomendas[i].produtos_enc[idp].qtd > max_qtd))
      {
        max_qtd = encomendas[i].produtos_enc[idp].qtd;
        max_ide = i;
      }
      else
      {
        
      }

    }

    printf("Maximo produto %d %d %d", idp, max_ide, max_qtd);
  }

  return funcaoloop();
}

int comando_l()
{
  int i;
  int contador_prods = 0;
  int left = 0;
  int right = contador_prods - 1;
  int j;
  int done;
  struct produto ordenados_preco[10000];
  struct produto t;
  for (i = 0; i < 10000; i++)
  {
    if (produtos[i].idp != (-1))
    {
      ordenados_preco[contador_prods].idp = produtos[i].idp;
      for (j = 0; j < 64; j++)
        ordenados_preco[contador_prods].desc[j] = produtos[i].desc[j];

      ordenados_preco[contador_prods].preco = produtos[i].preco;
      ordenados_preco[contador_prods].peso = produtos[i].peso;
      ordenados_preco[contador_prods].qtd = produtos[i].qtd;
      contador_prods += 1;
    }
    else
    {
      
    }

  }

  for (i = left; i < right; i++)
  {
    done = 1;
    for (j = right; j > i; j--)
    {
      if (ordenados_preco[j].preco < ordenados_preco[j - 1].preco)
      {
        t = ordenados_preco[j - 1];
        ordenados_preco[j - 1] = ordenados_preco[j];
        ordenados_preco[j] = t;
        done = 0;
      }
      else
      {
        if ((ordenados_preco[j].preco == ordenados_preco[j - 1].preco) && (ordenados_preco[j].idp < ordenados_preco[j - 1].idp))
        {
          t = ordenados_preco[j - 1];
          ordenados_preco[j - 1] = ordenados_preco[j];
          ordenados_preco[j] = t;
          ;
          done = 0;
        }
        else
        {
          
        }

      }

      if (done)
      {
        break;
      }
      else
      {
        
      }

    }

  }

  printf("Produtos\n");
  for (i = 0; i < contador_prods; i++)
    printf("* %s %d %d\n", ordenados_preco[i].desc, ordenados_preco[i].preco, ordenados_preco[i].qtd);

  return funcaoloop();
}

int comando_L()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > ide_atual)
  {
    printf("Impossivel listar encomenda %d Encomenda inexistente.", ide);
  }
  else
  {
    int contador_prods = 0;
    int i;
    int left = 0;
    int right = contador_prods - 1;
    int j;
    int k;
    int done;
    struct produto ordenados_alfab[10000];
    struct produto t;
    for (i = 0; i < 10000; i++)
    {
      if (encomendas[ide].produtos_enc[i].idp != (-1))
      {
        ordenados_alfab[contador_prods].idp = encomendas[ide].produtos_enc[i].idp;
        for (j = 0; j < 64; j++)
          ordenados_alfab[contador_prods].desc[j] = encomendas[ide].produtos_enc[i].desc[j];

        ordenados_alfab[contador_prods].preco = encomendas[ide].produtos_enc[i].preco;
        ordenados_alfab[contador_prods].peso = encomendas[ide].produtos_enc[i].peso;
        ordenados_alfab[contador_prods].qtd = encomendas[ide].produtos_enc[i].qtd;
        contador_prods += 1;
      }
      else
      {
        
      }

    }

    for (i = left; i < right; i++)
    {
      done = 1;
      for (j = right; j > i; j--)
      {
        for (k = 0; k < 64; k++)
        {
          if (ordenados_alfab[j].desc[k] < ordenados_alfab[j - 1].desc[k])
          {
            t = ordenados_alfab[j - 1];
            ordenados_alfab[j - 1] = ordenados_alfab[j];
            ordenados_alfab[j] = t;
            done = 0;
            break;
          }
          else
          {
            if (ordenados_alfab[j].desc[k] > ordenados_alfab[j - 1].desc[k])
            {
              done = 0;
              break;
            }
            else
            {
              
            }

          }

        }

        if (done)
        {
          break;
        }
        else
        {
          
        }

      }

    }

    printf("Encomenda %d\n", ide);
    for (i = 0; i < contador_prods; i++)
      printf("* %s %d %d\n", ordenados_alfab[i].desc, ordenados_alfab[i].preco, ordenados_alfab[i].qtd);

  }

  return funcaoloop();
}

int comando_x()
{
  exit(0);
}

int main()
{
  for (i = 0; i < 500; i++)
  {
    encomendas[i].ide = -1;
    encomendas[i].peso = 0;
  }

  for (j = 0; j < 10000; j++)
  {
    for (k = 0; k < (64 - 1); k++)
    {
      produtos_enc[j].desc[k] = ' ';
    }

    produtos_enc[j].idp = -1;
    produtos_enc[j].preco = 0;
    produtos_enc[j].peso = 0;
    produtos_enc[j].qtd = 0;
  }

  return funcaoloop();
}

int funcaoloop()
{
  int entrada[3];
  int c;
  c = getchar();
  entrada[0] = c;
  c = getchar();
  entrada[1] = c;
  entrada[2] = '\0';
  if (entrada[0] == 'a')
  {
    return comando_a();
  }
  else
  {
    
  }

  if (entrada[0] == 'q')
  {
    return comando_q();
  }
  else
  {
    
  }

  if (entrada[0] == 'N')
  {
    return comando_N();
  }
  else
  {
    
  }

  if (entrada[0] == 'A')
  {
    return comando_A();
  }
  else
  {
    
  }

  if (entrada[0] == 'r')
  {
    return comando_r();
  }
  else
  {
    
  }

  if (entrada[0] == 'R')
  {
    return comando_R();
  }
  else
  {
    
  }

  if (entrada[0] == 'C')
  {
    return comando_C();
  }
  else
  {
    
  }

  if (entrada[0] == 'p')
  {
    return comando_p();
  }
  else
  {
    
  }

  if (entrada[0] == 'E')
  {
    return comando_E();
  }
  else
  {
    
  }

  if (entrada[0] == 'm')
  {
    return comando_m();
  }
  else
  {
    
  }

  if (entrada[0] == 'l')
  {
    return comando_l();
  }
  else
  {
    
  }

  if (entrada[0] == 'L')
  {
    return comando_L();
  }
  else
  {
    
  }

  if (entrada[0] == 'x')
  {
    return comando_x();
  }
  else
  {
    
  }

  return 0;
}

