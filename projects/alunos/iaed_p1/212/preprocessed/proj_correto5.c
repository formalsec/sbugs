/*File generated by PreProcessor.py*/


#include <math.h>
#include <string.h>
#include <stdio.h>


int i = 0;
int y = 0;
typedef struct product
{
  int ident;
  char desc[64];
  int price;
  int weight;
  int quant;
  int state_prod;
} product;
typedef struct order
{
  int ident_o;
  product set_prod[200];
  int state;
  int peso_order;
} order;
product aux[10000];
product sistem[10000];
order sistem_orders[500];
product sistem2[10000];
product sistem3[200];
int indentify_prod(product s[], int idp);
product make_product(char *desc, int price, int weight, int quant);
order make_order(product s[]);
int product_in_order(int ide, order s[], int idp);
int product_in_system(int idp);
int order_in_system(int ide);
void copy_el(product source[], product dest[], int size);
int product_already_system(char *desc);
void mergesort_price(product a[], int low, int high);
void merge_price(product a[], int low, int mid, int high);
void swap(product *xp, product *yp);
void quicksort_str(product a[], int left, int right);
int partition_str(product a[], int left, int right);
void a(char *desc, int price, int weight, int quant);
void q(int idp, int quant);
void r(int idp, int quant);
void p(int idp, int price);
void l(product a[]);
void N(product s[]);
void A(int ide, int idp, int quant);
void R(int ide, int idp);
void C(int ide);
void E(int ide, int idp);
void m(int idp);
void L(int ide, product a[]);
int main()
{
  char c;
  int weight;
  char desc[64];
  int quant;
  int price;
  int idp;
  int ide;
  product new_order[10000];
  while ((c = getchar()) != 'x')
  {
    switch (c)
    {
      case 'a':
      {
        for (int desc_index = 0; desc_index < 10; desc_index++)
        {
          desc[desc_index] = new_sym_var(sizeof(char) * 8);
        }

        desc[10 - 1] = '\0';
        price = new_sym_var(sizeof(int) * 8);
        weight = new_sym_var(sizeof(int) * 8);
        quant = new_sym_var(sizeof(int) * 8);
        a(desc, price, weight, quant);
        break;
      }

      case 'q':
      {
        idp = new_sym_var(sizeof(int) * 8);
        quant = new_sym_var(sizeof(int) * 8);
        q(idp, quant);
        break;
      }

      case 'r':
      {
        idp = new_sym_var(sizeof(int) * 8);
        quant = new_sym_var(sizeof(int) * 8);
        r(idp, quant);
        break;
      }

      case 'p':
      {
        idp = new_sym_var(sizeof(int) * 8);
        price = new_sym_var(sizeof(int) * 8);
        p(idp, price);
        break;
      }

      case 'l':
      {
        copy_el(sistem, sistem2, 10000);
        mergesort_price(sistem2, 0, 200 - 1);
        printf("Produtos\n");
        l(sistem2);
        break;
      }

      case 'N':
      {
        N(new_order);
        break;
      }

      case 'A':
      {
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        quant = new_sym_var(sizeof(int) * 8);
        A(ide, idp, quant);
        break;
      }

      case 'R':
      {
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        R(ide, idp);
        break;
      }

      case 'C':
      {
        ide = new_sym_var(sizeof(int) * 8);
        C(ide);
        break;
      }

      case 'E':
      {
        int r = 0;
        int c = 0;
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        while (r < 500)
        {
          while (c < 200)
          {
            strcpy(sistem_orders[r].set_prod[c].desc, sistem[c].desc);
            c++;
          }

          c = 0;
          r++;
        }

        E(ide, idp);
        break;
      }

      case 'm':
      {
        idp = new_sym_var(sizeof(int) * 8);
        m(idp);
        break;
      }

      case 'L':
      {
        ide = new_sym_var(sizeof(int) * 8);
        if (order_in_system(ide) == 1)
        {
          copy_el(sistem_orders[ide].set_prod, sistem3, 200);
          quicksort_str(sistem3, 0, 200 - 1);
          printf("Encomenda %d\n", ide);
          L(ide, sistem3);
        }
        else
        {
          printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
        }

        break;
      }

    }

  }

  return 0;
}

void a(char *desc, int price, int weight, int quant)
{
  product test_product = make_product(desc, price, weight, quant);
  if (product_already_system(test_product.desc) == 1)
  {
  }
  else
  {
    if ((((((i >= 0) && (i < 10000)) && (strlen(desc) <= 64)) && (price > 0)) && (weight > 0)) && (quant >= 0))
    {
      printf("Novo produto %d.\n", i);
      sistem[i] = make_product(desc, price, weight, quant);
      i++;
    }
    else
    {
      
    }

  }

}

void q(int idp, int quant)
{
  if (indentify_prod(sistem, idp) == 1)
  {
    sistem[idp].quant += quant;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void r(int idp, int quant)
{
  int new_quant = sistem[idp].quant;
  if ((product_already_system(sistem[idp].desc) == 1) && ((new_quant -= quant) >= 0))
  {
    sistem[idp].quant -= quant;
  }
  else
  {
    if ((indentify_prod(sistem, idp) == 1) && ((new_quant -= quant) < 0))
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quant, idp);
    }
    else
    {
      printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    }

  }

}

void l(product a[])
{
  int i;
  for (i = 0; i < 10000; i++)
    if ((indentify_prod(a, i) == 1) && (a[i].price > 0))
  {
    printf("* %s %d %d\n", a[i].desc, a[i].price, a[i].quant);
  }
  else
  {
    
  }


}

void p(int idp, int price)
{
  if ((indentify_prod(sistem, idp) == 1) && (price > 0))
  {
    int i = 0;
    sistem[idp].price = price;
    while (i < 200)
    {
      if (sistem[idp].ident == sistem_orders[i].set_prod[idp].ident)
      {
        if ((product_in_order(i, sistem_orders, idp) == 1) && (product_in_system(idp) == 1))
        {
          sistem_orders[i].set_prod[idp].price = price;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      i++;
    }

  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

void N(product ar[])
{
  printf("Nova encomenda %d.\n", y);
  sistem_orders[y] = make_order(ar);
  sistem_orders[y].state = 1;
  y++;
}

void A(int ide, int idp, int quant)
{
  sistem_orders[ide].peso_order = (sistem[idp].weight * quant) + sistem_orders[ide].peso_order;
  if (order_in_system(ide) == 0)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    sistem_orders[ide].peso_order -= sistem[idp].weight * quant;
  }
  else
  {
    if (product_in_system(idp) == 0)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      sistem_orders[ide].peso_order -= sistem[idp].weight * quant;
    }
    else
    {
      if (quant > sistem[idp].quant)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        sistem_orders[ide].peso_order -= sistem[idp].weight * quant;
      }
      else
      {
        if ((product_in_order(ide, sistem_orders, idp) == 0) && (sistem_orders[ide].peso_order <= 200))
        {
          sistem_orders[ide].set_prod[idp] = sistem[idp];
          sistem_orders[ide].set_prod[idp].quant = quant;
          sistem[idp].quant -= quant;
        }
        else
        {
          if ((product_in_order(ide, sistem_orders, idp) == 1) && (sistem_orders[ide].peso_order <= 200))
          {
            sistem_orders[ide].set_prod[idp].quant += quant;
            sistem[idp].quant -= quant;
          }
          else
          {
            if (sistem_orders[ide].peso_order > 200)
            {
              printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
              sistem_orders[ide].peso_order -= sistem[idp].weight * quant;
            }
            else
            {
              
            }

          }

        }

      }

    }

  }

}

void R(int ide, int idp)
{
  if (order_in_system(ide) == 0)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (product_in_system(idp) == 0)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      sistem_orders[ide].peso_order -= sistem[idp].weight * sistem_orders[ide].set_prod[idp].quant;
      sistem[idp].quant += sistem_orders[ide].set_prod[idp].quant;
      sistem_orders[ide].set_prod[idp].quant = 0;
    }

  }

}

void C(int ide)
{
  if (order_in_system(ide) == 0)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    int i = 0;
    int total = 0;
    while (i < 200)
    {
      total += sistem_orders[ide].set_prod[i].price * sistem_orders[ide].set_prod[i].quant;
      i++;
    }

    printf("Custo da encomenda %d %d.\n", ide, total);
  }

}

void E(int ide, int idp)
{
  if (order_in_system(ide) == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (product_in_system(idp) == 0)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      printf("%s %d.\n", sistem[idp].desc, sistem_orders[ide].set_prod[idp].quant);
    }

  }

}

void m(int idp)
{
  if (product_in_system(idp) == 0)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    int i = 0;
    int max = 0;
    int index;
    while (i < 500)
    {
      if (sistem_orders[i].set_prod[idp].quant > max)
      {
        max = sistem_orders[i].set_prod[idp].quant;
        index = i;
      }
      else
      {
        if (sistem_orders[i].set_prod[idp].quant == max)
        {
          if (i < index)
          {
            index = i;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

      i++;
    }

    if (max > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, index, max);
    }
    else
    {
      
    }

  }

}

void L(int ide, product a[])
{
  int i = 0;
  while (i < 200)
  {
    if ((order_in_system(ide) == 1) && (a[i].quant > 0))
    {
      printf("* %s %d %d\n", a[i].desc, a[i].price, a[i].quant);
    }
    else
    {
      
    }

    i++;
  }

}

void remove_white(char *str)
{
  char ch = ' ';
  int len = strlen(str);
  int i;
  int j;
  for (i = 0; i < len; i++)
  {
    if (str[i] == ch)
    {
      for (j = i; j < len; j++)
      {
        str[j] = str[j + 1];
      }

      len--;
      i--;
    }
    else
    {
      
    }

  }

}

int product_already_system(char *desc)
{
  int i = 0;
  int res = 0;
  while (i < 10000)
  {
    if ((strcmp(desc, sistem[i].desc) == 0) && (sistem[i].state_prod == 1))
    {
      res = 1;
    }
    else
    {
      
    }

    i++;
  }

  return res;
}

product make_product(char *desc, int price, int weight, int quant)
{
  product p1 = {0, "", 0, 0, 0, 1};
  p1.ident = i;
  p1.price = price;
  p1.weight = weight;
  p1.quant = quant;
  strcpy(p1.desc, desc);
  remove_white(p1.desc);
  return p1;
}

int indentify_prod(product s[], int idp)
{
  if ((s[idp].price != 0) && (s[idp].weight != 0))
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

void copy_el(product source[], product dest[], int size)
{
  int i;
  for (i = 0; i < size; i++)
  {
    dest[i] = source[i];
  }

}

order make_order(product s[])
{
  order p1 = {0};
  p1.ident_o = y;
  copy_el(s, p1.set_prod, 200);
  return p1;
}

int product_in_order(int ide, order s[], int idp)
{
  if (s[ide].set_prod[idp].state_prod == 1)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int product_in_system(int idp)
{
  if (sistem[idp].state_prod == 1)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

int order_in_system(int ide)
{
  if (sistem_orders[ide].state == 1)
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

void mergesort_price(product a[], int low, int high)
{
  int mid = (high + low) / 2;
  if (high <= low)
  {
    return;
  }
  else
  {
    
  }

  mergesort_price(a, low, mid);
  mergesort_price(a, mid + 1, high);
  merge_price(a, low, mid, high);
}

void merge_price(product a[], int low, int mid, int high)
{
  int right;
  int left;
  int k;
  int i;
  k = 0;
  left = low;
  right = mid + 1;
  for (; (left <= mid) && (right <= high); ++k)
  {
    if (a[left].price <= a[right].price)
    {
      aux[k] = a[left++];
    }
    else
    {
      aux[k] = a[right++];
    }

  }

  for (; left <= mid; ++left, ++k)
    aux[k] = a[left];

  for (; right <= high; ++right, ++k)
    aux[k] = a[right];

  k = low;
  i = 0;
  for (; k <= high; ++k, ++i)
    a[k] = aux[i];

}

void swap(product *xp, product *yp)
{
  product temp = *xp;
  *xp = *yp;
  *yp = temp;
}

void quicksort_str(product a[], int left, int right)
{
  int i;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  i = partition_str(a, left, right);
  quicksort_str(a, left, i - 1);
  quicksort_str(a, i + 1, right);
}

int partition_str(product a[], int left, int right)
{
  int i = left - 1;
  int j = right;
  product v = a[right];
  while (i < j)
  {
    while (strcmp(a[++i].desc, v.desc) < 0)
      ;

    while (strcmp(v.desc, a[--j].desc) < 0)
      if (j == left)
    {
      break;
    }
    else
    {
      
    }


    if (i < j)
    {
      swap(&a[i], &a[j]);
    }
    else
    {
      
    }

  }

  swap(&a[i], &a[right]);
  return i;
}

