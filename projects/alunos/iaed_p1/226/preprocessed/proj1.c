#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>


struct product
{
  int idp;
  char description[63];
  int price;
  int weight;
  int amountInStock;
};
struct order
{
  int ide;
  int orderWeight;
  int orderCost;
  int numberOfProducts;
  struct product productsInOrder[200];
};
void a_addNewProduct();
void q_addStockToExistingProduct();
void N_createNewOrder();
void A_addProductToOrder();
void r_removeStockFromExistingProduct();
void R_removeProductFromOrder();
void C_calculatePriceOfOrder();
void p_chancePriceOfExistingProduct();
void E_showProductOrderDetails();
void m_returnOrderWithMoreProductPQuantity();
void l_listAllProdutsByPriceAscendingOrder();
void L_listAllProductsFromOrderByDescriptionAlphabeticalOrder();
void x_exitApp();
int productsVectorSize = 0;
int ordersVectorSize = 0;
struct product systemProducts[10000];
struct product sortedSystemProducts[10000];
struct product aux1[10000];
struct order orders[500];
struct order sortedProductsInOrder[500];
struct order aux2[500];
int main()
{
  char command;
  while (1)
  {
    command = getchar();
    switch (command)
    {
      case 'a':
        a_addNewProduct();
        productsVectorSize++;
        break;

      case 'q':
        q_addStockToExistingProduct();
        break;

      case 'N':
        N_createNewOrder();
        ordersVectorSize++;
        break;

      case 'A':
        A_addProductToOrder();
        break;

      case 'r':
        r_removeStockFromExistingProduct();
        break;

      case 'R':
        R_removeProductFromOrder();
        break;

      case 'C':
        C_calculatePriceOfOrder();
        break;

      case 'p':
        p_chancePriceOfExistingProduct();
        break;

      case 'E':
        E_showProductOrderDetails();
        break;

      case 'm':
        m_returnOrderWithMoreProductPQuantity();
        break;

      case 'l':
        l_listAllProdutsByPriceAscendingOrder();
        break;

      case 'L':
        L_listAllProductsFromOrderByDescriptionAlphabeticalOrder();
        break;

      case 'x':
        x_exitApp();
        return 0;

      default:
        puts("Invalid command.");

    }

  }

  return -1;
}

void a_addNewProduct()
{
  int productId = productsVectorSize;
  getchar();
  systemProducts[productsVectorSize].idp = productId;
  for (int systemProducts_index = 0; systemProducts_index < 10; systemProducts_index++)
  {
    systemProducts[productId].description[systemProducts_index] = new_sym_var(sizeof(char) * 8);
  }

  systemProducts[productId].description[10 - 1] = '\0';
  systemProducts[productId].price = new_sym_var(sizeof(int) * 8);
  systemProducts[productId].weight = new_sym_var(sizeof(int) * 8);
  systemProducts[productId].amountInStock = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", systemProducts[productId].idp);
  getchar();
}

void q_addStockToExistingProduct()
{
  int productId;
  int productQt;
  getchar();
  productId = new_sym_var(sizeof(int) * 8);
  productQt = new_sym_var(sizeof(int) * 8);
  if (productId > (productsVectorSize - 1))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", productId);
    getchar();
    return;
  }
  else
  {
    systemProducts[productId].amountInStock += productQt;
  }

  getchar();
}

void N_createNewOrder()
{
  int orderId = ordersVectorSize;
  orders[orderId].ide = orderId;
  orders[orderId].orderWeight = 0;
  orders[orderId].orderCost = 0;
  orders[orderId].numberOfProducts = 0;
  printf("Nova encomenda %d.\n", orders[orderId].ide);
  getchar();
}

void A_addProductToOrder()
{
  int orderId = 0;
  int productId;
  int productQt;
  int i;
  int indexProd;
  int productsInOrderVectorSize = 0;
  bool productIsInOrder = false;
  getchar();
  orderId = new_sym_var(sizeof(int) * 8);
  productId = new_sym_var(sizeof(int) * 8);
  productQt = new_sym_var(sizeof(int) * 8);
  productsInOrderVectorSize = orders[orderId].numberOfProducts;
  if (orderId > (ordersVectorSize - 1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", productId, orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  if (productId > (productsVectorSize - 1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", productId, orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  if (productQt > systemProducts[productId].amountInStock)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", productId, orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  if (((productQt * systemProducts[productId].weight) + orders[orderId].orderWeight) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", productId, orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  for (i = 0; i < productsInOrderVectorSize; i++)
  {
    if (orders[orderId].productsInOrder[i].idp == productId)
    {
      indexProd = i;
      productIsInOrder = true;
      break;
    }
    else
    {
      
    }

  }

  if (productIsInOrder)
  {
    orders[orderId].productsInOrder[indexProd].amountInStock += productQt;
  }
  else
  {
    orders[orderId].productsInOrder[productsInOrderVectorSize].idp = productId;
    strcpy(orders[orderId].productsInOrder[productsInOrderVectorSize].description, systemProducts[productId].description);
    orders[orderId].productsInOrder[productsInOrderVectorSize].price = systemProducts[productId].price;
    orders[orderId].productsInOrder[productsInOrderVectorSize].weight = systemProducts[productId].weight;
    orders[orderId].productsInOrder[productsInOrderVectorSize].amountInStock = productQt;
    orders[orderId].numberOfProducts++;
  }

  orders[orderId].orderWeight += productQt * systemProducts[productId].weight;
  orders[orderId].orderCost += productQt * systemProducts[productId].price;
  systemProducts[productId].amountInStock -= productQt;
  getchar();
}

void r_removeStockFromExistingProduct()
{
  int productId;
  int productQt;
  getchar();
  productId = new_sym_var(sizeof(int) * 8);
  productQt = new_sym_var(sizeof(int) * 8);
  if (productId > (productsVectorSize - 1))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", productId);
    getchar();
    return;
  }
  else
  {
    
  }

  if (productQt > systemProducts[productId].amountInStock)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", productQt, productId);
    getchar();
    return;
  }
  else
  {
    
  }

  systemProducts[productId].amountInStock -= productQt;
  getchar();
}

void R_removeProductFromOrder()
{
  int productId;
  int orderId;
  int i;
  int indexProd;
  int productsInOrderVectorSize = 0;
  bool productIsInOrder = false;
  orderId = new_sym_var(sizeof(int) * 8);
  productId = new_sym_var(sizeof(int) * 8);
  productsInOrderVectorSize = orders[orderId].numberOfProducts;
  if (orderId > (ordersVectorSize - 1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", productId, orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  if (productId > (productsVectorSize - 1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", productId, orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  for (i = 0; i < productsInOrderVectorSize; i++)
  {
    if (orders[orderId].productsInOrder[i].idp == productId)
    {
      indexProd = i;
      productIsInOrder = true;
      break;
    }
    else
    {
      
    }

  }

  if (productIsInOrder)
  {
    systemProducts[productId].amountInStock += orders[orderId].productsInOrder[indexProd].amountInStock;
    orders[orderId].orderWeight -= orders[orderId].productsInOrder[indexProd].amountInStock * orders[orderId].productsInOrder[indexProd].weight;
    orders[orderId].productsInOrder[indexProd].amountInStock = 0;
    for (i = indexProd; i < productsInOrderVectorSize; i++)
    {
      orders[orderId].productsInOrder[i] = orders[orderId].productsInOrder[i + 1];
    }

    orders[orderId].numberOfProducts--;
  }
  else
  {
    
  }

  getchar();
}

void C_calculatePriceOfOrder()
{
  int i;
  int orderId;
  int totalCost = 0;
  int productsInOrderVectorSize = 0;
  orderId = new_sym_var(sizeof(int) * 8);
  productsInOrderVectorSize = orders[orderId].numberOfProducts;
  if (orderId > (ordersVectorSize - 1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  for (i = 0; i < productsInOrderVectorSize; i++)
  {
    totalCost += orders[orderId].productsInOrder[i].price * orders[orderId].productsInOrder[i].amountInStock;
    orders[orderId].orderCost = totalCost;
  }

  printf("Custo da encomenda %d %d.\n", orderId, totalCost);
  getchar();
}

void p_chancePriceOfExistingProduct()
{
  int i;
  int j;
  int productId;
  int productPrice;
  getchar();
  productId = new_sym_var(sizeof(int) * 8);
  productPrice = new_sym_var(sizeof(int) * 8);
  if (productId > (productsVectorSize - 1))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", productId);
    getchar();
    return;
  }
  else
  {
    for (i = 0; i < ordersVectorSize; i++)
    {
      for (j = 0; j < orders[i].numberOfProducts; j++)
      {
        if (orders[i].productsInOrder[j].idp == productId)
        {
          orders[i].productsInOrder[j].price = productPrice;
          break;
        }
        else
        {
          
        }

      }

    }

    systemProducts[productId].price = productPrice;
  }

  getchar();
}

void E_showProductOrderDetails()
{
  int i;
  int productId;
  int orderId;
  int productAmountInStock = 0;
  int productsInOrderVectorSize = 0;
  bool productIsInOrder = false;
  char productDescription[63];
  orderId = new_sym_var(sizeof(int) * 8);
  productId = new_sym_var(sizeof(int) * 8);
  productsInOrderVectorSize = orders[orderId].numberOfProducts;
  if (orderId > (ordersVectorSize - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  if (productId > (productsVectorSize - 1))
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", productId);
    getchar();
    return;
  }
  else
  {
    
  }

  for (i = 0; i < productsInOrderVectorSize; i++)
  {
    if (orders[orderId].productsInOrder[i].idp == productId)
    {
      productIsInOrder = true;
      strcpy(productDescription, orders[orderId].productsInOrder[i].description);
      productAmountInStock = orders[orderId].productsInOrder[i].amountInStock;
      break;
    }
    else
    {
      
    }

  }

  if (!productIsInOrder)
  {
    strcpy(productDescription, systemProducts[productId].description);
    productAmountInStock = 0;
  }
  else
  {
    
  }

  printf("%s %d.\n", productDescription, productAmountInStock);
  getchar();
}

void m_returnOrderWithMoreProductPQuantity()
{
  int productId;
  int orderId;
  int i;
  int j;
  int maxQt = 0;
  bool productIsInOrder = false;
  productId = new_sym_var(sizeof(int) * 8);
  if (productId > (productsVectorSize - 1))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", productId);
    getchar();
    return;
  }
  else
  {
    
  }

  if (ordersVectorSize < 0)
  {
    return;
  }
  else
  {
    
  }

  for (i = 0; i < ordersVectorSize; i++)
  {
    for (j = 0; j < orders[i].numberOfProducts; j++)
    {
      if (orders[i].productsInOrder[j].idp == productId)
      {
        productIsInOrder = true;
        if (orders[i].productsInOrder[j].amountInStock > maxQt)
        {
          maxQt = orders[i].productsInOrder[j].amountInStock;
          orderId = i;
          break;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  if (productIsInOrder)
  {
    printf("Maximo produto %d %d %d.\n", productId, orderId, maxQt);
  }
  else
  {
    
  }

  getchar();
  return;
}

void mergePrice(struct product sortedSystemProducts[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
  {
    aux1[i - 1] = sortedSystemProducts[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux1[(r + m) - j] = sortedSystemProducts[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if ((aux1[j].price < aux1[i].price) || ((aux1[j].price == aux1[i].price) && (aux1[j].idp < aux1[i].idp)))
    {
      sortedSystemProducts[k] = aux1[j--];
    }
    else
    {
      sortedSystemProducts[k] = aux1[i++];
    }

  }

}

void mergesortPrice(struct product sortedSystemProducts[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesortPrice(sortedSystemProducts, l, m);
  mergesortPrice(sortedSystemProducts, m + 1, r);
  mergePrice(sortedSystemProducts, l, m, r);
}

void l_listAllProdutsByPriceAscendingOrder()
{
  int i;
  for (i = 0; i < productsVectorSize; i++)
  {
    sortedSystemProducts[i].idp = systemProducts[i].idp;
    strcpy(sortedSystemProducts[i].description, systemProducts[i].description);
    sortedSystemProducts[i].price = systemProducts[i].price;
    sortedSystemProducts[i].weight = systemProducts[i].weight;
    sortedSystemProducts[i].amountInStock = systemProducts[i].amountInStock;
  }

  mergesortPrice(sortedSystemProducts, 0, productsVectorSize - 1);
  printf("Produtos\n");
  for (i = 0; i < productsVectorSize; i++)
  {
    printf("* %s %d %d\n", sortedSystemProducts[i].description, sortedSystemProducts[i].price, sortedSystemProducts[i].amountInStock);
  }

  getchar();
}

void mergeDescription(struct order sortedProductsInOrder[], int l, int m, int r, int orderId)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
  {
    aux2[orderId].productsInOrder[i - 1] = sortedProductsInOrder[orderId].productsInOrder[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux2[orderId].productsInOrder[(r + m) - j] = sortedProductsInOrder[orderId].productsInOrder[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if ((strcmp(aux2[orderId].productsInOrder[j].description, aux2[orderId].productsInOrder[i].description) < 0) || ((strcmp(aux2[orderId].productsInOrder[j].description, aux2[orderId].productsInOrder[i].description) == 0) && (aux2[orderId].productsInOrder[j].idp < aux2[orderId].productsInOrder[i].idp)))
    {
      sortedProductsInOrder[orderId].productsInOrder[k] = aux2[orderId].productsInOrder[j--];
    }
    else
    {
      sortedProductsInOrder[orderId].productsInOrder[k] = aux2[orderId].productsInOrder[i++];
    }

  }

}

void mergesortDescription(struct order sortedProductsInOrder[], int l, int r, int orderId)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesortDescription(sortedProductsInOrder, l, m, orderId);
  mergesortDescription(sortedProductsInOrder, m + 1, r, orderId);
  mergeDescription(sortedProductsInOrder, l, m, r, orderId);
}

void L_listAllProductsFromOrderByDescriptionAlphabeticalOrder()
{
  int i;
  int orderId;
  int productsInOrderVectorSize = 0;
  orderId = new_sym_var(sizeof(int) * 8);
  productsInOrderVectorSize = orders[orderId].numberOfProducts;
  if (orderId > (ordersVectorSize - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", orderId);
    getchar();
    return;
  }
  else
  {
    
  }

  for (i = 0; i < productsInOrderVectorSize; i++)
  {
    sortedProductsInOrder[orderId].productsInOrder[i].idp = orders[orderId].productsInOrder[i].idp;
    strcpy(sortedProductsInOrder[orderId].productsInOrder[i].description, orders[orderId].productsInOrder[i].description);
    sortedProductsInOrder[orderId].productsInOrder[i].price = orders[orderId].productsInOrder[i].price;
    sortedProductsInOrder[orderId].productsInOrder[i].weight = orders[orderId].productsInOrder[i].weight;
    sortedProductsInOrder[orderId].productsInOrder[i].amountInStock = orders[orderId].productsInOrder[i].amountInStock;
  }

  mergesortDescription(sortedProductsInOrder, 0, productsInOrderVectorSize - 1, orderId);
  printf("Encomenda %d\n", orderId);
  for (i = 0; i < productsInOrderVectorSize; i++)
  {
    printf("* %s %d %d\n", sortedProductsInOrder[orderId].productsInOrder[i].description, sortedProductsInOrder[orderId].productsInOrder[i].price, sortedProductsInOrder[orderId].productsInOrder[i].amountInStock);
  }

  getchar();
}

void x_exitApp()
{
  return;
}

