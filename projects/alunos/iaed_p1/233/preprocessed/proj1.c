/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct produto
{
  int id;
  char descricao[63];
  int preco;
  int peso;
  int qtd;
} Produto;
typedef struct encomenda
{
  Produto lista[10000];
  int nProds;
  int id;
  int peso;
} Encomenda;
Produto produtos[10000];
Encomenda encomendas[500];
int idAtualProd = 0;
int idAtualEnc = 0;
int verificaSeExiste(int idp, int nProds, Produto lista[10000])
{
  int i;
  for (i = 0; i < nProds; i++)
  {
    if (idp == lista[i].id)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void merge(Produto arr[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  Produto L[10000 / 2];
  Produto R[10000 / 2];
  for (i = 0; i < n1; i++)
  {
    L[i] = arr[l + i];
  }

  for (j = 0; j < n2; j++)
  {
    R[j] = arr[(m + 1) + j];
  }

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (L[i].preco < R[j].preco)
    {
      arr[k] = L[i];
      i++;
      k++;
      continue;
    }
    else
    {
      if (L[i].preco > R[j].preco)
      {
        arr[k] = R[j];
        j++;
        k++;
        continue;
      }
      else
      {
        if (L[i].id < R[j].id)
        {
          arr[k] = L[i];
          i++;
        }
        else
        {
          arr[k] = R[j];
          j++;
        }

        k++;
      }

    }

  }

  while (i < n1)
  {
    arr[k] = L[i];
    i++;
    k++;
  }

  while (j < n2)
  {
    arr[k] = R[j];
    j++;
    k++;
  }

}

void mergeSort(Produto arr[], int l, int r)
{
  int m;
  if (l < r)
  {
    m = l + ((r - l) / 2);
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    merge(arr, l, m, r);
  }
  else
  {
    
  }

}

void executa_a()
{
  produtos[idAtualProd].id = idAtualProd;
  for (int produtos_index = 0; produtos_index < 10; produtos_index++)
  {
    produtos[idAtualProd].descricao[produtos_index] = new_sym_var(sizeof(char) * 8);
  }

  produtos[idAtualProd].descricao[10 - 1] = '\0';
  produtos[idAtualProd].preco = new_sym_var(sizeof(int) * 8);
  produtos[idAtualProd].peso = new_sym_var(sizeof(int) * 8);
  produtos[idAtualProd].qtd = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", idAtualProd);
  idAtualProd++;
}

void executa_q()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= idAtualProd)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].qtd += qtd;
  }

}

void executa_N()
{
  encomendas[idAtualEnc].id = idAtualEnc;
  encomendas[idAtualEnc].nProds = 0;
  encomendas[idAtualEnc].peso = 0;
  printf("Nova encomenda %d.\n", idAtualEnc);
  idAtualEnc++;
}

void executa_A()
{
  int ide;
  int idp;
  int qtd;
  int idAux;
  int n;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  n = encomendas[ide].nProds;
  idAux = verificaSeExiste(idp, n, encomendas[ide].lista);
  if (ide >= idAtualEnc)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= idAtualProd)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (((idAux < 0) && (qtd > produtos[idp].qtd)) || ((idAux >= 0) && (qtd > produtos[idp].qtd)))
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((encomendas[ide].peso + (qtd * produtos[idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          if (idAux >= 0)
          {
            encomendas[ide].lista[idAux].qtd += qtd;
            encomendas[ide].peso += qtd * produtos[idp].peso;
            produtos[idp].qtd -= qtd;
          }
          else
          {
            encomendas[ide].lista[n] = produtos[idp];
            encomendas[ide].lista[n].qtd = qtd;
            encomendas[ide].nProds++;
            encomendas[ide].peso += qtd * produtos[idp].peso;
            produtos[idp].qtd -= qtd;
          }

        }

      }

    }

  }

}

void executa_r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= idAtualProd)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (qtd > produtos[idp].qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      produtos[idp].qtd -= qtd;
    }

  }

}

void executa_R()
{
  int ide;
  int idp;
  int n;
  int idAux;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= idAtualEnc)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= idAtualProd)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      n = encomendas[ide].nProds;
      idAux = verificaSeExiste(idp, n, encomendas[ide].lista);
      if (idAux >= 0)
      {
        encomendas[ide].peso -= encomendas[ide].lista[idAux].qtd * produtos[idp].peso;
        produtos[idp].qtd += encomendas[ide].lista[idAux].qtd;
        for (i = idAux; i < n; i++)
        {
          encomendas[ide].lista[i] = encomendas[ide].lista[i + 1];
        }

        encomendas[ide].nProds--;
      }
      else
      {
        
      }

    }

  }

}

void executa_C()
{
  int ide;
  int n;
  int i;
  int precoProd;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= idAtualEnc)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    n = encomendas[ide].nProds;
    for (i = 0; i < n; i++)
    {
      precoProd = encomendas[ide].lista[i].preco * encomendas[ide].lista[i].qtd;
      total += precoProd;
    }

    printf("Custo da encomenda %d %d.\n", ide, total);
  }

}

void executa_p()
{
  int idp;
  int preco;
  int i;
  int idAux;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= idAtualProd)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].preco = preco;
    for (i = 0; i < idAtualEnc; i++)
    {
      idAux = verificaSeExiste(idp, encomendas[i].nProds, encomendas[i].lista);
      if (idAux >= 0)
      {
        encomendas[i].lista[idAux].preco = preco;
      }
      else
      {
        
      }

    }

  }

}

void executa_E()
{
  int ide;
  int idp;
  int n;
  int idAux;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= idAtualEnc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= idAtualProd)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      n = encomendas[ide].nProds;
      idAux = verificaSeExiste(idp, n, encomendas[ide].lista);
      if (idAux >= 0)
      {
        printf("%s %d.\n", encomendas[ide].lista[idAux].descricao, encomendas[ide].lista[idAux].qtd);
      }
      else
      {
        printf("%s 0.\n", produtos[idp].descricao);
      }

    }

  }

}

void executa_m()
{
  int idp;
  int enc;
  int i;
  int idAux;
  int n;
  int counter = 0;
  int max = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= idAtualProd)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; i < idAtualEnc; i++)
    {
      n = encomendas[i].nProds;
      idAux = verificaSeExiste(idp, n, encomendas[i].lista);
      if (idAux >= 0)
      {
        if (encomendas[i].lista[idAux].qtd > max)
        {
          max = encomendas[i].lista[idAux].qtd;
          enc = i;
          counter++;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (counter > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, enc, max);
    }
    else
    {
      
    }

  }

}

void executa_l()
{
  int i;
  Produto produtosOrd[10000];
  for (i = 0; i < idAtualProd; i++)
  {
    produtosOrd[i] = produtos[i];
  }

  mergeSort(produtosOrd, 0, idAtualProd - 1);
  printf("Produtos\n");
  for (i = 0; i < idAtualProd; i++)
  {
    printf("* %s %d %d\n", produtosOrd[i].descricao, produtosOrd[i].preco, produtosOrd[i].qtd);
  }

}

void executa_L()
{
  int ide;
  int n;
  int i;
  int j;
  Produto tmp;
  Produto produtosOrd[10000];
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= idAtualEnc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    n = encomendas[ide].nProds;
    for (i = 0; i < n; i++)
    {
      produtosOrd[i] = encomendas[ide].lista[i];
    }

    for (i = 0; i < n; i++)
    {
      for (j = i + 1; j < n; j++)
      {
        if (strcmp(produtosOrd[i].descricao, produtosOrd[j].descricao) > 0)
        {
          tmp = produtosOrd[i];
          produtosOrd[i] = produtosOrd[j];
          produtosOrd[j] = tmp;
        }
        else
        {
          
        }

      }

    }

    printf("Encomenda %d\n", ide);
    for (i = 0; i < n; i++)
    {
      printf("* %s %d %d\n", produtosOrd[i].descricao, produtosOrd[i].preco, produtosOrd[i].qtd);
    }

  }

}

int main()
{
  char c;
  while (1)
  {
    switch (c = getchar())
    {
      case 'a':
        executa_a();
        break;

      case 'q':
        executa_q();
        break;

      case 'N':
        executa_N();
        break;

      case 'A':
        executa_A();
        break;

      case 'r':
        executa_r();
        break;

      case 'R':
        executa_R();
        break;

      case 'C':
        executa_C();
        break;

      case 'p':
        executa_p();
        break;

      case 'E':
        executa_E();
        break;

      case 'm':
        executa_m();
        break;

      case 'l':
        executa_l();
        break;

      case 'L':
        executa_L();
        break;

      case 'x':
        return 0;

      default:
        printf("Erro: Comando desconhecido\n");

    }

    getchar();
  }

  return 1;
}

