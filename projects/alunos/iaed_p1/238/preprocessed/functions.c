#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "functions.h"


void strtoken(char line[5][100], int input)
{
  const char s[2] = ":";
  char *token;
  char aux[100];
  int i = 1;
  strcpy(aux, line[0]);
  *line[0] = '\0';
  token = strtok(aux, s);
  strcpy(line[0], token);
  while (i < input)
  {
    token = strtok(0, s);
    *line[i] = '\0';
    strcpy(line[i], token);
    i++;
  }

}

int a(struct Product prodList[10000], char line[5][100], int idp)
{
  strtoken(line, 4);
  strcpy(prodList[idp].desc, line[0]);
  prodList[idp].price = atoi(line[1]);
  prodList[idp].weight = atoi(line[2]);
  prodList[idp].qtd = atoi(line[3]);
  prodList[idp].idp = idp;
  printf("Novo produto %i.\n", idp);
  return ++idp;
}

void q(struct Product prodList[10000], char line[5][100], int idp)
{
  int auxIdp;
  int auxQtd;
  strtoken(line, 2);
  auxIdp = atoi(line[0]);
  auxQtd = atoi(line[1]);
  (auxIdp < idp) ? (prodList[auxIdp].qtd += auxQtd) : (printf("Impossivel adicionar produto %i ao stock. Produto inexistente.\n", auxIdp));
}

void A(struct Product prodList[10000], char line[5][100], int idp, int ide, struct Encomenda encomendas[500])
{
  int auxIde;
  int auxIdp;
  int auxQtd;
  int pesoTotal;
  int i = 0;
  strtoken(line, 3);
  auxIde = atoi(line[0]);
  auxIdp = atoi(line[1]);
  auxQtd = atoi(line[2]);
  if (auxIde > ide)
  {
    printf("Impossivel adicionar produto %i a encomenda %i. Encomenda inexistente.\n", auxIdp, auxIde);
    return;
  }
  else
  {
    
  }

  if (auxIdp >= idp)
  {
    printf("Impossivel adicionar produto %i a encomenda %i. Produto inexistente.\n", auxIdp, auxIde);
    return;
  }
  else
  {
    
  }

  if (auxQtd > prodList[auxIdp].qtd)
  {
    printf("Impossivel adicionar produto %i a encomenda %i. Quantidade em stock insuficiente.\n", auxIdp, auxIde);
    return;
  }
  else
  {
    
  }

  pesoTotal = pesoEncomenda(prodList, encomendas[auxIde]);
  if ((pesoTotal + (prodList[auxIdp].weight * auxQtd)) > 200)
  {
    printf("Impossivel adicionar produto %i a encomenda %i. Peso da encomenda excede o maximo de 200.\n", auxIdp, auxIde);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[auxIde].prodTotal; i++)
  {
    if (encomendas[auxIde].prodIdp[i] == auxIdp)
    {
      encomendas[auxIde].prodQtd[i] += auxQtd;
      prodList[auxIdp].qtd -= auxQtd;
      return;
    }
    else
    {
      
    }

  }

  encomendas[auxIde].prodIdp[encomendas[auxIde].prodTotal] = auxIdp;
  encomendas[auxIde].prodQtd[encomendas[auxIde].prodTotal] = auxQtd;
  prodList[auxIdp].qtd -= auxQtd;
  encomendas[auxIde].prodTotal++;
}

int pesoEncomenda(struct Product prodList[10000], struct Encomenda order)
{
  int i;
  int peso = 0;
  for (i = 0; i <= order.prodTotal; i++)
  {
    peso += order.prodQtd[i] * prodList[order.prodIdp[i]].weight;
  }

  return peso;
}

void r(struct Product prodList[10000], char line[5][100], int idp)
{
  int auxIdp;
  int auxQtd;
  strtoken(line, 2);
  auxIdp = atoi(line[0]);
  auxQtd = atoi(line[1]);
  if (auxIdp >= idp)
  {
    printf("Impossivel remover stock do produto %i. Produto inexistente.\n", auxIdp);
    return;
  }
  else
  {
    
  }

  if (prodList[auxIdp].qtd < auxQtd)
  {
    printf("Impossivel remover %i unidades do produto %i do stock. Quantidade insuficiente.\n", auxQtd, auxIdp);
    return;
  }
  else
  {
    
  }

  prodList[auxIdp].qtd -= auxQtd;
}

void R(char line[5][100], int idp, int ide, struct Encomenda encomendas[500], struct Product prodList[10000])
{
  int auxIdp;
  int auxIde;
  int pos;
  strtoken(line, 2);
  auxIde = atoi(line[0]);
  auxIdp = atoi(line[1]);
  if (auxIde > ide)
  {
    printf("Impossivel remover produto %i a encomenda %i. Encomenda inexistente.\n", auxIdp, auxIde);
    return;
  }
  else
  {
    
  }

  if (auxIdp >= idp)
  {
    printf("Impossivel remover produto %i a encomenda %i. Produto inexistente.\n", auxIdp, auxIde);
    return;
  }
  else
  {
    
  }

  for (pos = 0; pos < encomendas[auxIde].prodTotal; pos++)
  {
    if (encomendas[auxIde].prodIdp[pos] == auxIdp)
    {
      prodList[auxIdp].qtd += encomendas[auxIde].prodQtd[pos];
      encomendas[auxIde].prodQtd[pos] = 0;
      return;
    }
    else
    {
      
    }

  }

}

void C(int ide, struct Encomenda encomendas[500], char line[5][100], struct Product prodList[10000])
{
  int auxIde;
  int i;
  int price = 0;
  auxIde = atoi(line[0]);
  if (auxIde > ide)
  {
    printf("Impossivel calcular custo da encomenda %i. Encomenda inexistente.\n", auxIde);
    return;
  }
  else
  {
    
  }

  for (i = 0; i <= encomendas[auxIde].prodTotal; i++)
  {
    price += prodList[encomendas[auxIde].prodIdp[i]].price * encomendas[auxIde].prodQtd[i];
  }

  printf("Custo da encomenda %i %i.\n", auxIde, price);
}

void p(struct Product prodList[10000], char line[5][100], int idp)
{
  int auxIdp;
  int price;
  strtoken(line, 2);
  auxIdp = atoi(line[0]);
  price = atoi(line[1]);
  if (auxIdp >= idp)
  {
    printf("Impossivel alterar preco do produto %i. Produto inexistente.\n", auxIdp);
    return;
  }
  else
  {
    
  }

  prodList[auxIdp].price = price;
}

void E(int ide, struct Encomenda encomendas[500], char line[5][100], struct Product prodList[10000], int idp)
{
  int auxIdp;
  int auxIde;
  int pos;
  strtoken(line, 2);
  auxIde = atoi(line[0]);
  auxIdp = atoi(line[1]);
  if (auxIde > ide)
  {
    printf("Impossivel listar encomenda %i. Encomenda inexistente.\n", auxIde);
    return;
  }
  else
  {
    
  }

  if (auxIdp >= idp)
  {
    printf("Impossivel listar produto %i. Produto inexistente.\n", auxIdp);
    return;
  }
  else
  {
    
  }

  for (pos = 0; pos <= encomendas[auxIde].prodTotal; pos++)
  {
    if (encomendas[auxIde].prodIdp[pos] == auxIdp)
    {
      printf("%s %i.\n", prodList[auxIdp].desc, encomendas[auxIde].prodQtd[pos]);
      return;
    }
    else
    {
      
    }

  }

  printf("%s 0.\n", prodList[auxIdp].desc);
}

void m(int ide, struct Encomenda encomendas[500], char line[5][100], int idp)
{
  int auxIdp;
  int qtd = 0;
  int i = 0;
  int p = 0;
  int auxIde;
  auxIdp = atoi(line[0]);
  if (auxIdp >= idp)
  {
    printf("Impossivel listar maximo do produto %i. Produto inexistente.\n", auxIdp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i <= ide; i++)
  {
    for (p = 0; p <= encomendas[i].prodTotal; p++)
    {
      if (encomendas[i].prodIdp[p] == auxIdp)
      {
        if (encomendas[i].prodQtd[p] > qtd)
        {
          qtd = encomendas[i].prodQtd[p];
          auxIde = i;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  if (qtd != 0)
  {
    printf("Maximo produto %i %i %i.\n", auxIdp, auxIde, qtd);
  }
  else
  {
    
  }

}

void quicksort1(struct Product prodListSorted[10000], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition(prodListSorted, l, r);
  quicksort1(prodListSorted, l, i - 1);
  quicksort1(prodListSorted, i + 1, r);
}

int partition(struct Product prodListSorted[10000], int l, int r)
{
  int i = l - 1;
  int j = r;
  while (i < j)
  {
    while ((prodListSorted[++i].price < prodListSorted[r].price) || ((prodListSorted[i].price == prodListSorted[r].price) && (prodListSorted[i].idp < prodListSorted[r].idp)))
      ;

    while ((prodListSorted[r].price < prodListSorted[--j].price) || ((prodListSorted[j].price == prodListSorted[r].price) && (prodListSorted[r].idp < prodListSorted[j].idp)))
      if (j == l)
    {
      break;
    }
    else
    {
      
    }


    if (i < j)
    {
      struct Product tmp;
      tmp = prodListSorted[i];
      prodListSorted[i] = prodListSorted[j];
      prodListSorted[j] = tmp;
    }
    else
    {
      
    }

    ;
  }

  {
    struct Product tmp;
    tmp = prodListSorted[i];
    prodListSorted[i] = prodListSorted[r];
    prodListSorted[r] = tmp;
  }
  ;
  return i;
}

void l(struct Product prodList[10000], int idp)
{
  int i = 0;
  int p;
  struct Product prodListSorted[10000];
  for (p = 0; p < idp; p++)
  {
    strcpy(prodListSorted[p].desc, prodList[p].desc);
    prodListSorted[p].price = prodList[p].price;
    prodListSorted[p].weight = prodList[p].weight;
    prodListSorted[p].qtd = prodList[p].qtd;
    prodListSorted[p].idp = prodList[p].idp;
  }

  quicksort1(prodListSorted, 0, idp - 1);
  printf("Produtos\n");
  for (i = 0; i < idp; i++)
  {
    printf("* %s %i %i\n", prodListSorted[i].desc, prodListSorted[i].price, prodListSorted[i].qtd);
  }

}

void quicksort2(struct Product produ[1000], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition1(produ, l, r);
  quicksort2(produ, l, i - 1);
  quicksort2(produ, i + 1, r);
}

int partition1(struct Product produ[1000], int l, int r)
{
  int i = l - 1;
  int j = r;
  struct Product pAux = produ[r];
  while (i < j)
  {
    while (strcmp(produ[++i].desc, pAux.desc) < 0)
      ;

    while (strcmp(pAux.desc, produ[--j].desc) < 0)
      if (j == l)
    {
      break;
    }
    else
    {
      
    }


    if (i < j)
    {
      struct Product tmp;
      tmp = produ[i];
      produ[i] = produ[j];
      produ[j] = tmp;
    }
    else
    {
      
    }

    ;
  }

  {
    struct Product tmp;
    tmp = produ[i];
    produ[i] = produ[r];
    produ[r] = tmp;
  }
  ;
  return i;
}

void L(int ide, struct Encomenda encomendas[500], char line[5][100], struct Product prodList[10000])
{
  int auxIde;
  int p = 0;
  int i = 0;
  struct EncomendaUnica singleEncomenda;
  auxIde = atoi(line[0]);
  if (auxIde > ide)
  {
    printf("Impossivel listar encomenda %i. Encomenda inexistente.\n", auxIde);
    return;
  }
  else
  {
    
  }

  for (p = 0; p < encomendas[auxIde].prodTotal; p++)
  {
    singleEncomenda.prods[p] = prodList[encomendas[auxIde].prodIdp[p]];
    singleEncomenda.prods[p].qtd = encomendas[auxIde].prodQtd[p];
  }

  singleEncomenda.prodTotal = encomendas[auxIde].prodTotal;
  quicksort2(singleEncomenda.prods, 0, singleEncomenda.prodTotal - 1);
  printf("Encomenda %i\n", auxIde);
  for (i = 0; i < encomendas[auxIde].prodTotal; i++)
  {
    if (singleEncomenda.prods[i].qtd != 0)
    {
      printf("* %s %i %i\n", singleEncomenda.prods[i].desc, singleEncomenda.prods[i].price, singleEncomenda.prods[i].qtd);
    }
    else
    {
      
    }

  }

}

