/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>


int idp_final = 0;
int ide_final = 0;
struct Produto
{
  int id;
  int preco;
  int peso;
  int qtd_stock;
  char descricao[63];
};
struct Encomenda
{
  struct Produto produtos_e[10000];
  int peso;
  int id;
};
struct Produto produtos[10000];
struct Encomenda encomendas[500];
void adiciona_produto(char argv[1024])
{
  struct Produto produto_x;
  char delimt[2] = ":";
  char *dscr;
  char *prc;
  char *ps;
  char *qtd;
  dscr = strtok(argv, delimt);
  prc = strtok(0, delimt);
  ps = strtok(0, delimt);
  qtd = strtok(0, delimt);
  strcpy(produto_x.descricao, dscr);
  produto_x.preco = strtol(prc, 0, 10);
  produto_x.peso = strtol(ps, 0, 10);
  produto_x.qtd_stock = strtol(qtd, 0, 10);
  produto_x.id = idp_final;
  produtos[idp_final] = produto_x;
  idp_final++;
  printf("%s%d%s\n", "Novo produto ", produto_x.id, ".");
}

void adiciona_stock(char argv[1024])
{
  char delimt[2] = ":";
  char *idp;
  char *qtd;
  int idp_i;
  int qtd_i;
  idp = strtok(argv, delimt);
  qtd = strtok(0, delimt);
  idp_i = strtol(idp, 0, 10);
  qtd_i = strtol(qtd, 0, 10);
  if (produtos[idp_i].id == idp_i)
  {
    produtos[idp_i].qtd_stock += qtd_i;
  }
  else
  {
    printf("%s%d%s\n", "Impossivel adicionar produto ", idp_i, " ao stock. Produto inexistente.");
  }

}

void cria_encomenda()
{
  struct Encomenda encomenda_x;
  encomenda_x.id = ide_final;
  encomenda_x.peso = 0;
  encomendas[ide_final] = encomenda_x;
  printf("%s%d%s\n", "Nova encomenda ", ide_final, ".");
  ide_final++;
}

void adiciona_prd_a_enc(char argv[1024])
{
  char delimt[2] = ":";
  char *ide;
  char *idp;
  char *qtd;
  int ide_i;
  int idp_i;
  int qtd_i;
  int peso_adc;
  ide = strtok(argv, delimt);
  idp = strtok(0, delimt);
  qtd = strtok(0, delimt);
  ide_i = strtol(ide, 0, 10);
  idp_i = strtol(idp, 0, 10);
  qtd_i = strtol(qtd, 0, 10);
  peso_adc = produtos[idp_i].peso * qtd_i;
  if (encomendas[ide_i].id != ide_i)
  {
    printf("%s%d%s%d%s\n", "Impossivel adicionar produto ", idp_i, " a encomenda ", ide_i, ". Encomenda inexistente.");
  }
  else
  {
    if (produtos[idp_i].id != idp_i)
    {
      printf("%s%d%s%d%s\n", "Impossivel adicionar produto ", idp_i, " a encomenda ", ide_i, ". Produto inexistente.");
    }
    else
    {
      if (produtos[idp_i].qtd_stock < qtd_i)
      {
        printf("%s%d%s%d%s\n", "Impossivel adicionar produto ", idp_i, " a encomenda ", ide_i, ". Quantidade em stock insuficiente.");
      }
      else
      {
        if ((encomendas[ide_i].peso + peso_adc) > 200)
        {
          printf("%s%d%s%d%s\n", "Impossivel adicionar produto ", idp_i, " a encomenda ", ide_i, ". Peso da encomenda excede o maximo de 200.");
        }
        else
        {
          if (encomendas[ide_i].produtos_e[idp_i].id != idp_i)
          {
            encomendas[ide_i].produtos_e[idp_i] = produtos[idp_i];
            encomendas[ide_i].produtos_e[idp_i].qtd_stock = qtd_i;
            produtos[idp_i].qtd_stock -= qtd_i;
          }
          else
          {
            encomendas[ide_i].produtos_e[idp_i].qtd_stock += qtd_i;
            produtos[idp_i].qtd_stock -= qtd_i;
          }

        }

      }

    }

  }

}

void remove_stock(char argv[1024])
{
  char delimt[2] = ":";
  char *idp;
  char *qtd;
  int idp_i;
  int qtd_i;
  idp = strtok(argv, delimt);
  qtd = strtok(0, delimt);
  idp_i = strtol(idp, 0, 10);
  qtd_i = strtol(qtd, 0, 10);
  if (produtos[idp_i].id != idp_i)
  {
    printf("%s%d%s\n", "Impossivel remover stock do produto ", idp_i, ". Produto inexistente.");
  }
  else
  {
    if (produtos[idp_i].qtd_stock < qtd_i)
    {
      printf("%s%d%s%d%s\n", "Impossivel remover ", qtd_i, " unidades do produto ", idp_i, " do stock. Quantidade insuficiente.");
    }
    else
    {
      produtos[idp_i].qtd_stock -= qtd_i;
    }

  }

}

void remove_prd_enc(char argv[1024])
{
  char delimt[2] = ":";
  char rem[2] = " ";
  char *ide;
  char *idp;
  int ide_i;
  int idp_i;
  ide = strtok(argv, delimt);
  idp = strtok(0, delimt);
  ide_i = strtol(ide, 0, 10);
  idp_i = strtol(idp, 0, 10);
  if (produtos[idp_i].id != idp_i)
  {
    printf("%s%d%s%d%s\n", "Impossivel remover produto ", idp_i, " a encomenda ", ide_i, ". Produto inexistente.");
  }
  else
  {
    if (encomendas[ide_i].id != ide_i)
    {
      printf("%s%d%s%d%s\n", "Impossivel remover produto ", idp_i, " a encomenda ", ide_i, ". Encomenda inexistente.");
    }
    else
    {
      encomendas[ide_i].produtos_e[idp_i].id = produtos[10000].id;
      encomendas[ide_i].produtos_e[idp_i].preco = produtos[10000].preco;
      encomendas[ide_i].produtos_e[idp_i].peso = produtos[10000].peso;
      encomendas[ide_i].produtos_e[idp_i].qtd_stock = produtos[10000].qtd_stock;
      strcat(encomendas[ide_i].produtos_e[idp_i].descricao, rem);
    }

  }

}

void custo_encomenda(char argv[1024])
{
  char delimt[2] = ":";
  char *ide;
  int ide_i;
  int i;
  int preco_e;
  ide = strtok(argv, delimt);
  ide_i = strtol(ide, 0, 10);
  for (i = 0; i < ide_final; i++)
  {
    preco_e += encomendas[ide_i].produtos_e[i].preco * encomendas[ide_i].produtos_e[i].qtd_stock;
  }

  if (encomendas[ide_i].id != ide_i)
  {
    printf("%s%d%s\n", "Impossivel calcular custo da encomenda ", ide_i, ". Encomenda inexistente.");
  }
  else
  {
    printf("%s%d %d%s\n", "Custo da encomenda ", ide_i, preco_e, ".");
  }

}

void altera_preco(char argv[1024])
{
  char delimt[2] = ":";
  char *idp;
  char *preco;
  int idp_i;
  int preco_i;
  int i;
  idp = strtok(argv, delimt);
  preco = strtok(0, delimt);
  idp_i = strtol(idp, 0, 10);
  preco_i = strtol(preco, 0, 10);
  if (produtos[idp_i].id != idp_i)
  {
    printf("%s%d%s\n", "Impossivel alterar preco do produto ", idp_i, ". Produto inexistente.");
  }
  else
  {
    produtos[idp_i].preco = preco_i;
    for (i = 0; i < ide_final; i++)
    {
      encomendas[i].produtos_e[idp_i].preco = preco_i;
    }

  }

}

void lista_prd_enc(char argv[1024])
{
  char delimt[2] = ":";
  char *ide;
  char *idp;
  int ide_i;
  int idp_i;
  ide = strtok(argv, delimt);
  idp = strtok(0, delimt);
  ide_i = strtol(ide, 0, 10);
  idp_i = strtol(idp, 0, 10);
  if (produtos[idp_i].id != idp_i)
  {
    printf("%s%d%s\n", "Impossivel listar produto ", idp_i, ". Produto inexistente.");
  }
  else
  {
    if (encomendas[ide_i].id != ide_i)
    {
      printf("%s%d%s\n", "Impossivel listar encomenda ", ide_i, ". Encomenda inexistente.");
    }
    else
    {
      printf("%s%s%d\n", encomendas[ide_i].produtos_e[idp_i].descricao, " ", encomendas[ide_i].produtos_e[idp_i].qtd_stock);
    }

  }

}

void lista_prd_maior_qtd(char argv[1024])
{
  char delimt[2] = ":";
  char *idp;
  int idp_i;
  int ide_maior = 0;
  int i;
  idp = strtok(argv, delimt);
  idp_i = strtol(idp, 0, 10);
  if (produtos[idp_i].id != idp_i)
  {
    printf("%s%d%s\n", "Impossivel listar maximo do produto ", idp_i, ". Produto inexistente.");
  }
  else
  {
    for (i = 0; i < ide_final; i++)
    {
      if (encomendas[i].produtos_e[idp_i].qtd_stock > encomendas[ide_maior].produtos_e[idp_i].qtd_stock)
      {
        ide_maior = encomendas[i].id;
      }
      else
      {
        if (encomendas[i].produtos_e[idp_i].qtd_stock == encomendas[ide_maior].produtos_e[idp_i].qtd_stock)
        {
          if (encomendas[i].id < encomendas[ide_maior].id)
          {
            ide_maior = encomendas[i].id;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    printf("%s%d %d %d\n", "Maximo produto ", idp_i, ide_maior, encomendas[ide_maior].produtos_e[idp_i].qtd_stock);
  }

}

void lista_prd_ordem_cresc()
{
  struct Produto produtos_x[10000];
  struct Produto produto_temp;
  int i;
  int j;
  int n = idp_final;
  for (i = 0; i < idp_final; i++)
  {
    produtos_x[i] = produtos[i];
  }

  for (i = 0; i < (n - 1); i++)
  {
    for (j = 0; j < ((n - i) - 1); j++)
    {
      if (produtos_x[j].preco > produtos_x[j + 1].preco)
      {
        produto_temp = produtos_x[j];
        produtos_x[j] = produtos_x[j + 1];
        produtos_x[j + 1] = produto_temp;
      }
      else
      {
        
      }

    }

  }

  printf("%s\n", "Produtos");
  for (i = 0; i < n; i++)
  {
    printf("* %s %d %d\n", produtos_x[i].descricao, produtos_x[i].preco, produtos_x[i].qtd_stock);
  }

}

void lista_enc_ordem_alfab(char argv[1024])
{
  struct Encomenda encomendas_x[500];
  struct Encomenda encomenda_temp;
  char delimt[2] = ":";
  int i;
  int j;
  int n = ide_final;
  char *ide;
  int ide_i;
  ide = strtok(argv, delimt);
  ide_i = strtol(ide, 0, 10);
  for (i = 0; i < ide_final; i++)
  {
    encomendas_x[i] = encomendas[i];
  }

  for (i = 0; i < (n - 1); i++)
  {
    for (j = 0; j < ((n - i) - 1); j++)
    {
      if (strcmp(encomendas[ide_i].produtos_e[j].descricao, encomendas[ide_i].produtos_e[j + 1].descricao) > 0)
      {
        encomenda_temp = encomendas_x[j];
        encomendas_x[j] = encomendas_x[j + 1];
        encomendas_x[j + 1] = encomenda_temp;
      }
      else
      {
        
      }

    }

  }

  printf("%s%d\n", "Encomenda ", ide_i);
  for (i = 0; i < n; i++)
  {
    printf("* %s %d %d\n", encomendas_x[ide_i].produtos_e[i].descricao, encomendas_x[i].produtos_e[i].preco, encomendas_x[i].produtos_e[i].qtd_stock);
  }

}

int main()
{
  char instruction[1024];
  char cmd = ' ';
  while (cmd != 'x')
  {
    cmd = getchar();
    switch (cmd)
    {
      case 'a':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        adiciona_produto(instruction);
        break;

      case 'q':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        adiciona_stock(instruction);
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        adiciona_prd_a_enc(instruction);
        break;

      case 'r':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        remove_stock(instruction);
        break;

      case 'R':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        remove_prd_enc(instruction);
        break;

      case 'C':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        custo_encomenda(instruction);
        break;

      case 'p':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        altera_preco(instruction);
        break;

      case 'E':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        lista_prd_enc(instruction);
        break;

      case 'm':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        lista_prd_maior_qtd(instruction);
        break;

      case 'l':
        lista_prd_ordem_cresc();
        break;

      case 'L':
        getchar();
        for (int instruction_index = 0; instruction_index < 10; instruction_index++)
      {
        instruction[instruction_index] = new_sym_var(sizeof(char) * 8);
      }

        instruction[10 - 1] = '\0';
        lista_enc_ordem_alfab(instruction);
        break;

    }

  }

  return 0;
}

