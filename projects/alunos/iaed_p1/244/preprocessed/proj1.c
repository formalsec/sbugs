#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include<stdlib.h>


struct Product
{
  int id;
  char description[64];
  int price;
  int weight;
  int stock;
} Product;
struct Package
{
  struct Product contents[10000];
  int contentsCount;
  int id;
  int weight;
} Package;
struct Product allProducts[10000];
int ProductCounter;
struct Package allPackages[500];
int PackageCounter;
void addProduct(char command[64])
{
  char delim[2] = ":";
  struct Product temp;
  char *token;
  token = strtok(command, delim);
  temp.id = ProductCounter;
  strcpy(temp.description, token);
  token = strtok(0, delim);
  temp.price = strtol(token, 0, 10);
  token = strtok(0, delim);
  temp.weight = strtol(token, 0, 10);
  token = strtok(0, delim);
  temp.stock = strtol(token, 0, 10);
  allProducts[ProductCounter] = temp;
  printf("%s%d%s\n", "Novo produto ", temp.id, ".");
  ProductCounter = ProductCounter + 1;
}

void addStock(char command[64])
{
  int idp;
  int i;
  int found = 0;
  int qtd;
  char delim[2] = ":";
  char *token;
  token = strtok(command, delim);
  idp = strtol(token, 0, 10);
  token = strtok(0, delim);
  qtd = strtol(token, 0, 10);
  for (i = 0; i < ProductCounter; ++i)
  {
    if (allProducts[i].id == idp)
    {
      allProducts[i].stock = allProducts[i].stock + qtd;
      found = 1;
    }
    else
    {
      
    }

  }

  if (found == 0)
  {
    printf("%s%d%s\n", "Impossivel adicionar produto ", idp, " ao stock. Produto inexistente.");
  }
  else
  {
    
  }

}

void newPackage()
{
  struct Package temp;
  temp.id = PackageCounter;
  temp.weight = 0;
  temp.contentsCount = 0;
  allPackages[PackageCounter] = temp;
  PackageCounter = PackageCounter + 1;
  printf("%s%d%s\n", "Nova encomenda ", temp.id, ".");
}

void addToPackage(char command[64])
{
  int idp;
  int ide;
  int qtd;
  int inConNum;
  char *token;
  int packageNum = -1;
  int productNum = -1;
  char delim[2] = ":";
  int i;
  int exists = 0;
  token = strtok(command, delim);
  ide = strtol(token, 0, 10);
  token = strtok(0, delim);
  idp = strtol(token, 0, 10);
  token = strtok(0, delim);
  qtd = strtol(token, 0, 10);
  for (i = 0; i < PackageCounter; ++i)
  {
    if (ide == allPackages[i].id)
    {
      packageNum = i;
    }
    else
    {
      
    }

  }

  for (i = 0; i < ProductCounter; ++i)
  {
    if (idp == allProducts[i].id)
    {
      productNum = i;
    }
    else
    {
      
    }

  }

  if (packageNum == (-1))
  {
    printf("%s%d%s%d%s\n", "Impossivel adicionar produto ", idp, " a encomenda ", ide, ". Encomenda inexistente.");
  }
  else
  {
    if (productNum == (-1))
    {
      printf("%s%d%s%d%s\n", "Impossivel adicionar produto ", idp, " a encomenda ", ide, ". Produto inexistente.");
    }
    else
    {
      if (allProducts[productNum].stock < qtd)
      {
        printf("%s%d%s%d%s\n", "Impossivel adicionar produto ", idp, " a encomenda ", ide, ". Quantidade em stock insuficiente.");
      }
      else
      {
        if ((allPackages[packageNum].weight + (allProducts[productNum].weight * qtd)) > 200)
        {
          printf("%s%d%s%d%s\n", "Impossivel adicionar produto ", idp, " a encomenda ", ide, ". Peso da encomenda excede o maximo de 200.");
        }
        else
        {
          for (i = 0; i < allPackages[packageNum].contentsCount; ++i)
          {
            if (allPackages[packageNum].contents[i].id == allProducts[productNum].id)
            {
              inConNum = i;
              exists = 1;
            }
            else
            {
              
            }

          }

          if (exists == 0)
          {
            allPackages[packageNum].contents[allPackages[packageNum].contentsCount] = allProducts[productNum];
            allPackages[packageNum].contents[allPackages[packageNum].contentsCount].stock = qtd;
            allPackages[packageNum].weight = allPackages[packageNum].weight + (allProducts[productNum].weight * qtd);
            allPackages[packageNum].contentsCount = allPackages[packageNum].contentsCount + 1;
            allProducts[productNum].stock = allProducts[productNum].stock - qtd;
          }
          else
          {
            allPackages[packageNum].contents[inConNum].stock = allPackages[packageNum].contents[inConNum].stock + qtd;
            allPackages[packageNum].weight = allPackages[packageNum].weight + (allProducts[productNum].weight * qtd);
            allProducts[productNum].stock = allProducts[productNum].stock - qtd;
          }

        }

      }

    }

  }

}

void removeStock(char command[64])
{
  int idp;
  int qtd;
  char *token;
  char delim[2] = ":";
  int i;
  int productNum = -1;
  token = strtok(command, delim);
  idp = strtol(token, 0, 10);
  token = strtok(0, delim);
  qtd = strtol(token, 0, 10);
  for (i = 0; i < ProductCounter; ++i)
  {
    if (idp == allProducts[i].id)
    {
      productNum = i;
    }
    else
    {
      
    }

  }

  if (productNum == (-1))
  {
    printf("%s%d%s\n", "Impossivel remover stock do produto ", idp, ". Produto inexistente.");
  }
  else
  {
    if (allProducts[productNum].stock < qtd)
    {
      printf("%s%d%s%d%s\n", "Impossivel remover ", qtd, " unidades do produto ", idp, " do stock. Quantidade insuficiente.");
    }
    else
    {
      allProducts[productNum].stock = allProducts[productNum].stock - qtd;
    }

  }

}

void removeFromPackage(char command[64])
{
  int ide;
  int idp;
  char *token;
  int packageNum = -1;
  int productNum = -1;
  char delim[2] = ":";
  int i;
  int inPackNum;
  token = strtok(command, delim);
  ide = strtol(token, 0, 10);
  token = strtok(0, delim);
  idp = strtol(token, 0, 10);
  for (i = 0; i < PackageCounter; ++i)
  {
    if (ide == allPackages[i].id)
    {
      packageNum = i;
    }
    else
    {
      
    }

  }

  for (i = 0; i < ProductCounter; ++i)
  {
    if (idp == allProducts[i].id)
    {
      productNum = i;
    }
    else
    {
      
    }

  }

  if (packageNum == (-1))
  {
    printf("%s%d%s%d%s\n", "Impossivel remover produto ", idp, " a encomenda ", ide, ". Encomenda inexistente.");
  }
  else
  {
    if (productNum == (-1))
    {
      printf("%s%d%s%d%s\n", "Impossivel remover produto ", idp, " a encomenda ", ide, ". Produto inexistente.");
    }
    else
    {
      for (i = 0; i < allPackages[packageNum].contentsCount; ++i)
      {
        if (allPackages[packageNum].contents[i].id == idp)
        {
          inPackNum = i;
        }
        else
        {
          
        }

      }

      allPackages[packageNum].weight = allPackages[packageNum].weight - (allPackages[packageNum].contents[inPackNum].weight * allPackages[packageNum].contents[inPackNum].stock);
      allProducts[productNum].stock = allProducts[productNum].stock + allPackages[packageNum].contents[inPackNum].stock;
      for (i = inPackNum; i < allPackages[packageNum].contentsCount; ++i)
      {
        allPackages[packageNum].contents[i] = allPackages[packageNum].contents[i + 1];
      }

      allPackages[packageNum].contentsCount = allPackages[packageNum].contentsCount - 1;
    }

  }

}

void calcCost(int ide)
{
  int i;
  int packageNum = -1;
  int total = 0;
  for (i = 0; i < PackageCounter; ++i)
  {
    if (ide == allPackages[i].id)
    {
      packageNum = i;
    }
    else
    {
      
    }

  }

  if (packageNum == (-1))
  {
    printf("%s%d%s\n", "Impossivel calcular custo da encomenda ", ide, ". Encomenda inexistente.");
  }
  else
  {
    for (i = 0; i < allPackages[packageNum].contentsCount; ++i)
    {
      total = total + (allPackages[packageNum].contents[i].price * allPackages[packageNum].contents[i].stock);
    }

    printf("%s%d%s%d%s\n", "Custo da encomenda ", ide, " ", total, ".");
  }

}

void changePrice(char command[64])
{
  int idp;
  int Nprice;
  char *token;
  char delim[2] = ":";
  int i;
  int q;
  int productNum = -1;
  token = strtok(command, delim);
  idp = strtol(token, 0, 10);
  token = strtok(0, delim);
  Nprice = strtol(token, 0, 10);
  for (i = 0; i < ProductCounter; ++i)
  {
    if (idp == allProducts[i].id)
    {
      productNum = i;
    }
    else
    {
      
    }

  }

  if (productNum == (-1))
  {
    printf("%s%d%s\n", "Impossivel alterar preco do produto ", idp, ". Produto inexistente.");
  }
  else
  {
    allProducts[productNum].price = Nprice;
    for (i = 0; i < PackageCounter; ++i)
    {
      for (q = 0; q < allPackages[i].contentsCount; ++q)
      {
        if (allPackages[i].contents[q].id == allProducts[productNum].id)
        {
          allPackages[i].contents[q].price = Nprice;
        }
        else
        {
          
        }

      }

    }

  }

}

void inPackProdInfo(char command[64])
{
  int idp;
  int ide;
  char *token;
  char delim[2] = ":";
  int i;
  int productNum = -1;
  int packageNum = -1;
  token = strtok(command, delim);
  ide = strtol(token, 0, 10);
  token = strtok(0, delim);
  idp = strtol(token, 0, 10);
  for (i = 0; i < PackageCounter; ++i)
  {
    if (ide == allPackages[i].id)
    {
      packageNum = i;
    }
    else
    {
      
    }

  }

  for (i = 0; i < ProductCounter; ++i)
  {
    if (idp == allProducts[i].id)
    {
      productNum = i;
    }
    else
    {
      
    }

  }

  if (packageNum == (-1))
  {
    printf("%s%d%s\n", "Impossivel listar encomenda ", ide, ". Encomenda inexistente.");
  }
  else
  {
    if (productNum == (-1))
    {
      printf("%s%d%s\n", "Impossivel listar produto ", idp, ". Produto inexistente.");
    }
    else
    {
      for (i = 0; i < allPackages[packageNum].contentsCount; ++i)
      {
        if (allPackages[packageNum].contents[i].id == idp)
        {
          printf("%s%s%d%s\n", allPackages[packageNum].contents[i].description, " ", allPackages[packageNum].contents[i].stock, ".");
        }
        else
        {
          
        }

      }

    }

  }

}

void findMode(int idp)
{
  int i;
  int q;
  int productNum = -1;
  int packageNum = -1;
  int pInStock = 0;
  for (i = 0; i < ProductCounter; ++i)
  {
    if (idp == allProducts[i].id)
    {
      productNum = i;
    }
    else
    {
      
    }

  }

  if (productNum == (-1))
  {
    printf("%s%d%s\n", "Impossivel listar maximo do produto ", idp, ". Produto inexistente.");
  }
  else
  {
    for (i = 0; i < PackageCounter; ++i)
    {
      for (q = 0; q < allPackages[i].contentsCount; ++q)
      {
        if (allPackages[i].contents[q].id == idp)
        {
          if (allPackages[i].contents[q].stock > pInStock)
          {
            packageNum = i;
            pInStock = allPackages[i].contents[q].stock;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    if (packageNum == (-1))
    {
    }
    else
    {
      printf("%s%d%s%d%s%d%s\n", "Maximo produto ", idp, " ", allPackages[packageNum].id, " ", pInStock, ".");
    }

  }

}

void listPrice(struct Product listt[10000])
{
  int i;
  int q;
  struct Product tempy;
  for (i = 0; i < (ProductCounter - 1); ++i)
  {
    for (q = 0; q < ((ProductCounter - i) - 1); ++q)
    {
      if (listt[q].price > listt[q + 1].price)
      {
        tempy = listt[q];
        listt[q] = listt[q + 1];
        listt[q + 1] = tempy;
      }
      else
      {
        
      }

    }

  }

  printf("%s\n", "Produtos");
  for (i = 0; i < ProductCounter; ++i)
  {
    printf("%s%s%s%d%s%d\n", "* ", listt[i].description, " ", listt[i].price, " ", listt[i].stock);
  }

}

void alphaList(int ide, struct Package listt[10000])
{
  int i;
  int q;
  int packageNum = -1;
  struct Product tempy;
  for (i = 0; i < PackageCounter; ++i)
  {
    if (ide == allPackages[i].id)
    {
      packageNum = i;
    }
    else
    {
      
    }

  }

  if (packageNum == (-1))
  {
    printf("%s%d%s\n", "Impossivel listar encomenda ", ide, ". Encomenda inexistente.");
  }
  else
  {
    for (i = 0; i < (listt[packageNum].contentsCount - 1); ++i)
    {
      for (q = 0; q < ((listt[packageNum].contentsCount - i) - 1); ++q)
      {
        if (strcmp(listt[packageNum].contents[q].description, listt[packageNum].contents[q + 1].description) > 0)
        {
          tempy = listt[packageNum].contents[q];
          listt[packageNum].contents[q] = listt[packageNum].contents[q + 1];
          listt[packageNum].contents[q + 1] = tempy;
        }
        else
        {
          
        }

      }

    }

    printf("%s%d\n", "Encomenda ", ide);
    for (i = 0; i < listt[packageNum].contentsCount; ++i)
    {
      printf("%s%s%s%d%s%d\n", "* ", listt[packageNum].contents[i].description, " ", listt[packageNum].contents[i].price, " ", listt[packageNum].contents[i].stock);
    }

  }

}

int main()
{
  char arg[64];
  char mander = ' ';
  int grail;
  PackageCounter = 0;
  ProductCounter = 0;
  while (mander != 'x')
  {
    mander = getchar();
    switch (mander)
    {
      case 'a':
        getchar();
        for (int arg_index = 0; arg_index < 10; arg_index++)
      {
        arg[arg_index] = new_sym_var(sizeof(char) * 8);
      }

        arg[10 - 1] = '\0';
        addProduct(arg);
        break;

      case 'q':
        getchar();
        for (int arg_index = 0; arg_index < 10; arg_index++)
      {
        arg[arg_index] = new_sym_var(sizeof(char) * 8);
      }

        arg[10 - 1] = '\0';
        addStock(arg);
        break;

      case 'N':
        newPackage();
        break;

      case 'A':
        getchar();
        for (int arg_index = 0; arg_index < 10; arg_index++)
      {
        arg[arg_index] = new_sym_var(sizeof(char) * 8);
      }

        arg[10 - 1] = '\0';
        addToPackage(arg);
        break;

      case 'r':
        getchar();
        for (int arg_index = 0; arg_index < 10; arg_index++)
      {
        arg[arg_index] = new_sym_var(sizeof(char) * 8);
      }

        arg[10 - 1] = '\0';
        removeStock(arg);
        break;

      case 'R':
        getchar();
        for (int arg_index = 0; arg_index < 10; arg_index++)
      {
        arg[arg_index] = new_sym_var(sizeof(char) * 8);
      }

        arg[10 - 1] = '\0';
        removeFromPackage(arg);
        break;

      case 'C':
        getchar();
        grail = new_sym_var(sizeof(int) * 8);
        calcCost(grail);
        break;

      case 'p':
        getchar();
        for (int arg_index = 0; arg_index < 10; arg_index++)
      {
        arg[arg_index] = new_sym_var(sizeof(char) * 8);
      }

        arg[10 - 1] = '\0';
        changePrice(arg);
        break;

      case 'E':
        getchar();
        for (int arg_index = 0; arg_index < 10; arg_index++)
      {
        arg[arg_index] = new_sym_var(sizeof(char) * 8);
      }

        arg[10 - 1] = '\0';
        inPackProdInfo(arg);
        break;

      case 'm':
        getchar();
        grail = new_sym_var(sizeof(int) * 8);
        findMode(grail);
        break;

      case 'l':
        listPrice(allProducts);
        break;

      case 'L':
        getchar();
        grail = new_sym_var(sizeof(int) * 8);
        alphaList(grail, allPackages);
        break;

    }

  }

  return 0;
}

