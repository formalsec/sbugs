#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct 
{
  int id;
  int price;
  int weight;
  int stock;
  char description[63];
} Product;
typedef struct 
{
  Product products[500];
  int productCounter;
  int totalOrderWeight;
} Order;
Product products[10000];
Order orders[500];
int productCounter = 0;
int orderCounter = 0;
int prodInPacksCounter = 0;
char tokArray[10][100];
void sepWords()
{
  int i;
  char *token;
  char str[1000];
  fgets(str, 1000, stdin);
  token = strtok(str, " ");
  for (i = 0; token != 0; i++)
  {
    strcpy(tokArray[i], token);
    token = strtok(0, ":");
  }

}

void addProduct(char d[], int p, int w, int s)
{
  if ((((d == 0) || (p <= 0)) || (w <= 0)) || (s <= 0))
  {
    printf("Argumentos nao sao validos\n");
  }
  else
  {
    
  }

  strcpy(products[productCounter].description, d);
  products[productCounter].price = p;
  products[productCounter].weight = w;
  products[productCounter].stock = s;
  products[productCounter].id = productCounter;
  printf("Novo produto %d.\n", productCounter);
  productCounter++;
}

void addStock(int idp, int s)
{
  if (idp >= productCounter)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  products[idp].stock += s;
}

void createOrder()
{
  printf("Nova encomenda %d.\n", orderCounter);
  orderCounter++;
}

void addToOrder(int idOrder, int idProduct, int quantity)
{
  int i;
  if (idOrder >= orderCounter)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idProduct, idOrder);
    return;
  }
  else
  {
    
  }

  if (idProduct >= productCounter)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idProduct, idOrder);
    return;
  }
  else
  {
    
  }

  if ((products[idProduct].stock < quantity) || (products[idProduct].stock < 0))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idProduct, idOrder);
    return;
  }
  else
  {
    
  }

  if ((orders[idOrder].totalOrderWeight + (products[idProduct].weight * quantity)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idProduct, idOrder);
    return;
  }
  else
  {
    
  }

  if (orders[idOrder].productCounter == 0)
  {
    strcpy(orders[idOrder].products[orders[idOrder].productCounter].description, products[idProduct].description);
    orders[idOrder].products[orders[idOrder].productCounter].price = products[idProduct].price;
    orders[idOrder].products[orders[idOrder].productCounter].weight = products[idProduct].weight;
    orders[idOrder].products[orders[idOrder].productCounter].stock = quantity;
    orders[idOrder].products[orders[idOrder].productCounter].id = products[idProduct].id;
    orders[idOrder].totalOrderWeight += products[idProduct].weight * quantity;
    products[idProduct].stock -= quantity;
    orders[idOrder].productCounter++;
    return;
  }
  else
  {
    
  }

  for (i = 0; i < orders[idOrder].productCounter; i++)
  {
    if (orders[idOrder].products[i].id == idProduct)
    {
      products[idProduct].stock -= quantity;
      orders[idOrder].products[i].stock += quantity;
      orders[idOrder].totalOrderWeight += products[idProduct].weight * quantity;
      return;
    }
    else
    {
      
    }

  }

  strcpy(orders[idOrder].products[orders[idOrder].productCounter].description, products[idProduct].description);
  orders[idOrder].products[orders[idOrder].productCounter].price = products[idProduct].price;
  orders[idOrder].products[orders[idOrder].productCounter].weight = products[idProduct].weight;
  orders[idOrder].products[orders[idOrder].productCounter].stock = quantity;
  orders[idOrder].products[orders[idOrder].productCounter].id = products[idProduct].id;
  orders[idOrder].totalOrderWeight += products[idProduct].weight * quantity;
  products[idProduct].stock -= quantity;
  orders[idOrder].productCounter++;
  return;
}

void rmStock(int idProduct, int s)
{
  if (idProduct >= productCounter)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idProduct);
    return;
  }
  else
  {
    
  }

  if ((products[idProduct].stock - s) < 0)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", s, idProduct);
    return;
  }
  else
  {
    
  }

  products[idProduct].stock -= s;
}

void rmProduct(int idOrder, int idProduct)
{
  int i;
  if (idOrder >= orderCounter)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idProduct, idOrder);
    return;
  }
  else
  {
    
  }

  if (idProduct >= productCounter)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idProduct, idOrder);
    return;
  }
  else
  {
    
  }

  for (i = 0; (i < orders[idOrder].productCounter) && (orders[idOrder].products[i].id != idProduct); i++)
    ;

  if (i < orders[idOrder].productCounter)
  {
    products[idProduct].stock += orders[idOrder].products[i].stock;
    orders[idOrder].totalOrderWeight -= products[idProduct].weight * orders[idOrder].products[i].stock;
    orders[idOrder].products[i].stock = 0;
  }
  else
  {
    
  }

}

void orderCost(int idOrder)
{
  int i;
  int cost = 0;
  if (idOrder >= orderCounter)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", idOrder);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < orders[idOrder].productCounter; i++)
  {
    cost += orders[idOrder].products[i].price * orders[idOrder].products[i].stock;
  }

  printf("Custo da encomenda %d %d.\n", idOrder, cost);
}

void changePrice(int idProduct, int newPrice)
{
  int i;
  int n;
  if (idProduct >= productCounter)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idProduct);
  }
  else
  {
    
  }

  products[idProduct].price = newPrice;
  for (i = 0; i < orderCounter; i++)
  {
    for (n = 0; n < orders[i].productCounter; n++)
    {
      if (orders[i].products[n].id == idProduct)
      {
        orders[i].products[n].price = newPrice;
      }
      else
      {
        
      }

    }

  }

}

void listOrder(int idOrder, int idProduct)
{
  int i;
  if (idOrder >= orderCounter)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idOrder);
    return;
  }
  else
  {
    
  }

  if (idProduct >= productCounter)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idProduct);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < orders[idOrder].productCounter; i++)
  {
    if (orders[idOrder].products[i].id == idProduct)
    {
      printf("%s %d.\n", orders[idOrder].products[i].description, orders[idOrder].products[i].stock);
      return;
    }
    else
    {
      
    }

  }

  printf("%s %d.\n", products[idProduct].description, 0);
  return;
}

void orderWithMoreProducts(int idProduct)
{
  int i;
  int n;
  int orderWithMoreProducts = -1;
  int maxProducts = 0;
  if (idProduct >= productCounter)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idProduct);
    return;
  }
  else
  {
    
  }

  for (i = orderCounter - 1; i >= 0; i--)
  {
    for (n = 0; n < orders[i].productCounter; n++)
    {
      if (((orders[i].products[n].id == idProduct) && (orders[i].products[n].stock > 0)) && (orders[i].products[n].stock >= maxProducts))
      {
        maxProducts = orders[i].products[n].stock;
        orderWithMoreProducts = i;
      }
      else
      {
        
      }

    }

  }

  if (orderWithMoreProducts != (-1))
  {
    printf("Maximo produto %d %d %d.\n", idProduct, orderWithMoreProducts, maxProducts);
  }
  else
  {
    
  }

}

void mergePrice(Product arr[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  Product L[10000 / 2];
  Product R[10000 / 2];
  for (i = 0; i < n1; i++)
  {
    L[i].id = arr[l + i].id;
    L[i].price = arr[l + i].price;
    L[i].weight = arr[l + i].weight;
    L[i].stock = arr[l + i].stock;
    strcpy(L[i].description, arr[l + i].description);
  }

  for (j = 0; j < n2; j++)
  {
    R[j].id = arr[(m + 1) + j].id;
    R[j].price = arr[(m + 1) + j].price;
    R[j].weight = arr[(m + 1) + j].weight;
    R[j].stock = arr[(m + 1) + j].stock;
    strcpy(R[j].description, arr[(m + 1) + j].description);
  }

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (L[i].price <= R[j].price)
    {
      arr[k].id = L[i].id;
      arr[k].price = L[i].price;
      arr[k].weight = L[i].weight;
      arr[k].stock = L[i].stock;
      strcpy(arr[k].description, L[i].description);
      i++;
    }
    else
    {
      arr[k].id = R[j].id;
      arr[k].price = R[j].price;
      arr[k].weight = R[j].weight;
      arr[k].stock = R[j].stock;
      strcpy(arr[k].description, R[j].description);
      j++;
    }

    k++;
  }

  while (i < n1)
  {
    arr[k].id = L[i].id;
    arr[k].price = L[i].price;
    arr[k].weight = L[i].weight;
    arr[k].stock = L[i].stock;
    strcpy(arr[k].description, L[i].description);
    i++;
    k++;
  }

  while (j < n2)
  {
    arr[k].id = R[j].id;
    arr[k].price = R[j].price;
    arr[k].weight = R[j].weight;
    arr[k].stock = R[j].stock;
    strcpy(arr[k].description, R[j].description);
    j++;
    k++;
  }

}

void mergeSortPrice(Product arr[], int l, int r)
{
  if (l < r)
  {
    int m = l + ((r - l) / 2);
    mergeSortPrice(arr, l, m);
    mergeSortPrice(arr, m + 1, r);
    mergePrice(arr, l, m, r);
  }
  else
  {
    
  }

}

void listProductsByPrice()
{
  int i;
  Product productsSorted[10000];
  memcpy(productsSorted, products, (sizeof(Product)) * productCounter);
  mergeSortPrice(productsSorted, 0, productCounter - 1);
  printf("Produtos\n");
  for (i = 0; i < productCounter; i++)
  {
    printf("* %s %d %d\n", productsSorted[i].description, productsSorted[i].price, productsSorted[i].stock);
  }

}

void mergeDescription(Product arr[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  Product L[10000 / 2];
  Product R[10000 / 2];
  for (i = 0; i < n1; i++)
  {
    L[i].id = arr[l + i].id;
    L[i].price = arr[l + i].price;
    L[i].weight = arr[l + i].weight;
    L[i].stock = arr[l + i].stock;
    strcpy(L[i].description, arr[l + i].description);
  }

  for (j = 0; j < n2; j++)
  {
    R[j].id = arr[(m + 1) + j].id;
    R[j].price = arr[(m + 1) + j].price;
    R[j].weight = arr[(m + 1) + j].weight;
    R[j].stock = arr[(m + 1) + j].stock;
    strcpy(R[j].description, arr[(m + 1) + j].description);
  }

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (strcmp(L[i].description, R[j].description) < 0)
    {
      arr[k].id = L[i].id;
      arr[k].price = L[i].price;
      arr[k].weight = L[i].weight;
      arr[k].stock = L[i].stock;
      strcpy(arr[k].description, L[i].description);
      i++;
    }
    else
    {
      arr[k].id = R[j].id;
      arr[k].price = R[j].price;
      arr[k].weight = R[j].weight;
      arr[k].stock = R[j].stock;
      strcpy(arr[k].description, R[j].description);
      j++;
    }

    k++;
  }

  while (i < n1)
  {
    arr[k].id = L[i].id;
    arr[k].price = L[i].price;
    arr[k].weight = L[i].weight;
    arr[k].stock = L[i].stock;
    strcpy(arr[k].description, L[i].description);
    i++;
    k++;
  }

  while (j < n2)
  {
    arr[k].id = R[j].id;
    arr[k].price = R[j].price;
    arr[k].weight = R[j].weight;
    arr[k].stock = R[j].stock;
    strcpy(arr[k].description, R[j].description);
    j++;
    k++;
  }

}

void mergeSortDescription(Product arr[], int l, int r)
{
  if (l < r)
  {
    int m = l + ((r - l) / 2);
    mergeSortDescription(arr, l, m);
    mergeSortDescription(arr, m + 1, r);
    mergeDescription(arr, l, m, r);
  }
  else
  {
    
  }

}

void listOrderProducts(int idOrder)
{
  int i;
  Product productsOrdered[500];
  if (idOrder >= orderCounter)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idOrder);
    return;
  }
  else
  {
    
  }

  memcpy(productsOrdered, orders[idOrder].products, (sizeof(Product)) * orders[idOrder].productCounter);
  for (i = 0; i < orders[idOrder].productCounter; i++)
  {
    mergeSortDescription(productsOrdered, 0, orders[idOrder].productCounter - 1);
  }

  printf("Encomenda %d\n", idOrder);
  for (i = 0; i < orders[idOrder].productCounter; i++)
  {
    if (productsOrdered[i].stock != 0)
    {
      printf("* %s %d %d\n", productsOrdered[i].description, productsOrdered[i].price, productsOrdered[i].stock);
    }
    else
    {
      
    }

  }

}

int main()
{
  while (1)
  {
    char *x = malloc(sizeof(char));
    sepWords();
    strcpy(x, tokArray[0]);
    switch (*x)
    {
      case 'a':
        addProduct(tokArray[1], atoi(tokArray[2]), atoi(tokArray[3]), atoi(tokArray[4]));
        break;

      case 'q':
        addStock(atoi(tokArray[1]), atoi(tokArray[2]));
        break;

      case 'N':
        createOrder();
        break;

      case 'A':
        addToOrder(atoi(tokArray[1]), atoi(tokArray[2]), atoi(tokArray[3]));
        break;

      case 'r':
        rmStock(atoi(tokArray[1]), atoi(tokArray[2]));
        break;

      case 'R':
        rmProduct(atoi(tokArray[1]), atoi(tokArray[2]));
        break;

      case 'C':
        orderCost(atoi(tokArray[1]));
        break;

      case 'p':
        changePrice(atoi(tokArray[1]), atoi(tokArray[2]));
        break;

      case 'E':
        listOrder(atoi(tokArray[1]), atoi(tokArray[2]));
        break;

      case 'm':
        orderWithMoreProducts(atoi(tokArray[1]));
        break;

      case 'l':
        listProductsByPrice();
        break;

      case 'L':
        listOrderProducts(atoi(tokArray[1]));
        break;

      case 'x':
        exit(0);

    }

  }

  return 0;
}

