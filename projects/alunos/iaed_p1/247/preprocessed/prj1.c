#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>


typedef struct Produto
{
  int id;
  int preco;
  int peso;
  int stock;
  char descricao[63];
} Produto;
typedef struct itemEncomenda
{
  int id;
  int qnt;
  struct itemEncomenda *next;
} itemEncomenda;
typedef struct Encomenda
{
  int id;
  int nprodutos;
  int peso;
  itemEncomenda *head;
} Encomenda;
Produto produtos[10000];
Encomenda encomendas[500];
int pid = 0;
int pide = 0;
void adicionaProduto(char args[])
{
  char descricao[63];
  int preco;
  int peso;
  int qnt;
  for (int descricao_index = 0; descricao_index < 10; descricao_index++)
  {
    descricao[descricao_index] = new_sym_var(sizeof(char) * 8);
  }

  descricao[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  produtos[pid].id = pid;
  strcpy(produtos[pid].descricao, descricao);
  produtos[pid].preco = preco;
  produtos[pid].peso = peso;
  produtos[pid].stock = qnt;
  printf("Novo produto %d.\n", pid);
  pid++;
  return;
}

void adicionaStock(char args[])
{
  int id;
  int qnt;
  int i;
  id = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  for (i = 0; i < 10000; i++)
  {
    if (produtos[i].id == id)
    {
      produtos[i].stock += qnt;
      return;
    }
    else
    {
      
    }

  }

  printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  return;
}

void adicionaEncomenda()
{
  encomendas[pide].id = pide;
  encomendas[pide].head = 0;
  encomendas[pide].peso = 0;
  encomendas[pide].nprodutos = 0;
  printf("Nova encomenda %d.\n", pide);
  pide++;
}

void adicionaProdutoEncomenda(char args[])
{
  int ide;
  int idp;
  int qnt;
  itemEncomenda *temp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  if (ide > (pide - 1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp > (pid - 1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (produtos[idp].stock < qnt)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if ((encomendas[ide].peso + (qnt * produtos[idp].peso)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  encomendas[ide].peso += qnt * produtos[idp].peso;
  temp = encomendas[ide].head;
  if (encomendas[ide].head == 0)
  {
    encomendas[ide].head = malloc(sizeof(itemEncomenda));
    encomendas[ide].head->id = idp;
    encomendas[ide].head->qnt = qnt;
    encomendas[ide].head->next = 0;
    encomendas[ide].nprodutos++;
  }
  else
  {
    while (temp->next != 0)
    {
      if (temp->id == idp)
      {
        temp->qnt += qnt;
        return;
      }
      else
      {
        
      }

      temp = temp->next;
    }

    temp->next = malloc(sizeof(itemEncomenda));
    temp->next->id = idp;
    temp->next->qnt = qnt;
    temp->next->next = 0;
    encomendas[ide].nprodutos++;
  }

  produtos[idp].stock -= qnt;
  return;
}

void removeProduto(char args[])
{
  int idp;
  int qnt;
  idp = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  if (idp > (pid - 1))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (produtos[idp].stock < qnt)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qnt, idp);
    return;
  }
  else
  {
    
  }

  produtos[idp].stock -= qnt;
  return;
}

void removeEncomenda(char args[])
{
  int ide;
  int idp;
  itemEncomenda *temp;
  itemEncomenda *prev;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > (pide - 1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp > (pid - 1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  temp = encomendas[ide].head;
  prev = encomendas[ide].head;
  if (encomendas[ide].head->id == idp)
  {
    encomendas[ide].head = encomendas[ide].head->next;
    encomendas[ide].peso -= temp->qnt * produtos[idp].peso;
    produtos[idp].stock += temp->qnt;
    free(temp);
    encomendas[ide].nprodutos--;
    return;
  }
  else
  {
    
  }

  while (temp != 0)
  {
    if (temp->id == idp)
    {
      prev->next = temp->next;
      encomendas[ide].peso -= temp->qnt * produtos[idp].peso;
      produtos[idp].stock += temp->qnt;
      free(temp);
      encomendas[ide].nprodutos--;
      return;
    }
    else
    {
      
    }

    prev = temp;
    temp = temp->next;
  }

  printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
  return;
}

void calculaCusto(char args[])
{
  int ide;
  int custo;
  int id;
  int qnt;
  itemEncomenda *temp;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > (pide - 1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  temp = encomendas[ide].head;
  while (temp != 0)
  {
    id = temp->id;
    qnt = temp->qnt;
    custo += produtos[id].preco * qnt;
    temp = temp->next;
  }

  printf("Custo da encomenda %d %d.\n", ide, custo);
  return;
}

void alteraPreco(char args[])
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp > (pid - 1))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  produtos[idp].preco = preco;
  return;
}

void listaProduto(char args[])
{
  int ide;
  int idp;
  itemEncomenda *temp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > (pide - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  temp = encomendas[ide].head;
  while (temp != 0)
  {
    if (temp->id == idp)
    {
      printf("%s %d\n", produtos[idp].descricao, temp->qnt);
      return;
    }
    else
    {
      
    }

    temp = temp->next;
  }

  printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
  return;
}

void maiorProduto(char args[])
{
  int idp;
  int i;
  int ideRef;
  int qntRef;
  itemEncomenda *temp;
  qntRef = 0;
  ideRef = -1;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp > (pid - 1))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < (pid - 1); i++)
  {
    temp = encomendas[i].head;
    while (temp != 0)
    {
      if (temp->id == idp)
      {
        if (qntRef < temp->qnt)
        {
          qntRef = temp->qnt;
          ideRef = i;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  if (ideRef == (-1))
  {
    return;
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", idp, ideRef, qntRef);
  return;
}

void sortProdutos()
{
  int i;
  int j;
  Produto Sorted[10000];
  Produto temp;
  for (i = 0; i < pid; i++)
  {
    strcpy(Sorted[i].descricao, produtos[i].descricao);
    Sorted[i].id = produtos[i].id;
    Sorted[i].peso = produtos[i].peso;
    Sorted[i].preco = produtos[i].preco;
    Sorted[i].stock = produtos[i].stock;
  }

  for (i = 0; i < pid; i++)
  {
    for (j = 0; j < i; j++)
    {
      if (Sorted[j].preco > Sorted[j + 1].preco)
      {
        temp = Sorted[j];
        Sorted[j] = Sorted[j + 1];
        Sorted[j + 1] = temp;
      }
      else
      {
        
      }

    }

  }

  printf("Produtos\n");
  for (i = 0; i < pid; i++)
  {
    printf("* %s %d %d\n", Sorted[i].descricao, Sorted[i].preco, Sorted[i].stock);
  }

  return;
}

void sortEncomenda(char args[])
{
  int ide;
  int i;
  int n;
  int j;
  itemEncomenda *temp;
  itemEncomenda swap;
  itemEncomenda Sorted[10000];
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > (pide - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  n = 0;
  temp = encomendas[ide].head;
  while (temp != 0)
  {
    Sorted[n].id = temp->id;
    Sorted[n].qnt = temp->qnt;
    temp = temp->next;
    n++;
  }

  for (i = 0; i < n; i++)
  {
    for (j = 0; j < i; j++)
    {
      if (strcmp(produtos[Sorted[j].id].descricao, produtos[Sorted[j + 1].id].descricao) > 0)
      {
        swap.id = Sorted[j].id;
        swap.qnt = Sorted[j].qnt;
        Sorted[j].id = Sorted[j + 1].id;
        Sorted[j].qnt = Sorted[j + 1].qnt;
        Sorted[j + 1].id = swap.id;
        Sorted[j + 1].qnt = swap.qnt;
      }
      else
      {
        
      }

    }

  }

  printf("Encomenda %d\n", ide);
  for (i = 0; i < encomendas[ide].nprodutos; i++)
  {
    printf("* %s %d %d\n", produtos[Sorted[i].id].descricao, produtos[Sorted[i].id].preco, Sorted[i].qnt);
  }

  return;
}

int main()
{
  char cmd[1000];
  char letra;
  char args[1000 - 2];
  while (1)
  {
    fgets(cmd, 1000, stdin);
    letra = new_sym_var(sizeof(char) * 8);
    for (int args_index = 0; args_index < (1000 - 2); args_index++)
    {
      args[args_index] = new_sym_var(sizeof(char) * 8);
    }

    args[(1000 - 2) - 1] = '\0';
    switch (letra)
    {
      case 'a':
        adicionaProduto(args);
        break;

      case 'q':
        adicionaStock(args);
        break;

      case 'N':
        adicionaEncomenda();
        break;

      case 'A':
        adicionaProdutoEncomenda(args);
        break;

      case 'r':
        removeProduto(args);
        break;

      case 'R':
        removeEncomenda(args);
        break;

      case 'C':
        calculaCusto(args);
        break;

      case 'p':
        alteraPreco(args);
        break;

      case 'E':
        listaProduto(args);
        break;

      case 'm':
        maiorProduto(args);
        break;

      case 'l':
        sortProdutos();
        break;

      case 'L':
        sortEncomenda(args);
        break;

      case 'x':
        return 0;
        break;

    }

  }

}

