#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "constants.h"
#include "logisticae.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


int obtainIdNumber(Logistics *l, int i)
{
  int Inumber;
  if (i == 0)
  {
    Inumber = l->nextIdp++;
  }
  else
  {
    if (i == 1)
    {
      Inumber = l->nextIde++;
    }
    else
    {
      fprintf(outputFile, "Wrong Initialisation of newInumber\n");
    }

  }

  return Inumber;
}

int getProdPos(Logistics *l, int id)
{
  int i;
  if (id >= l->nextIdp)
  {
    return -1;
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    if (getProdID(l->prods[i]) == id)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void separate(char *string, int num, int *tab)
{
  char *first;
  char *second;
  char *third;
  int i = 0;
  int firstLen = 0;
  int secondLen = 0;
  int thirdLen = 0;
  int spacing = 0;
  while (((string[i] == ':') || ((string[i] >= '0') && (string[i] <= '9'))) && (string[i] != '\0'))
  {
    if (string[i] == ':')
    {
      spacing++;
    }
    else
    {
      if (spacing == 0)
      {
        firstLen++;
      }
      else
      {
        if (spacing == 1)
        {
          secondLen++;
        }
        else
        {
          thirdLen++;
        }

      }

    }

    i++;
  }

  first = malloc((firstLen + 1) * (sizeof(char)));
  second = malloc((secondLen + 1) * (sizeof(char)));
  third = malloc((thirdLen + 1) * (sizeof(char)));
  if (((!first) || (!second)) || (!third))
  {
    perror("allocation failed in separate");
    exit(1);
  }
  else
  {
    
  }

  strncpy(first, string, firstLen);
  first[firstLen] = '\0';
  tab[0] = atoi(first);
  if ((secondLen != 0) && (num > 1))
  {
    strncpy(second, (string + firstLen) + 1, secondLen);
    second[secondLen] = '\0';
    tab[1] = atoi(second);
  }
  else
  {
    
  }

  if ((thirdLen != 0) && (num == 3))
  {
    strncpy(third, ((string + firstLen) + secondLen) + 2, thirdLen);
    third[thirdLen] = '\0';
    tab[2] = atoi(third);
  }
  else
  {
    
  }

  free(first);
  free(second);
  free(third);
}

void mergeProds(Logistics *l, int left, int middle, int right)
{
  int i;
  int j;
  int k;
  int price1;
  int price2;
  Logistics *aux = createLog();
  for (i = middle + 1; i > left; i--)
  {
    aux->prods[i - 1] = l->prods[i - 1];
  }

  for (j = middle; j < right; j++)
  {
    aux->prods[(right + middle) - j] = l->prods[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    price1 = getProdPrice(aux->prods[j]);
    price2 = getProdPrice(aux->prods[i]);
    if ((price1 < price2) || ((price1 == price2) && (getProdID(aux->prods[j]) < getProdID(aux->prods[i]))))
    {
      l->prods[k] = aux->prods[j--];
    }
    else
    {
      l->prods[k] = aux->prods[i++];
    }

  }

  freeLogistics(aux);
}

void mergeSortProds(Logistics *l, int left, int right)
{
  int middle = (left + right) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergeSortProds(l, left, middle);
  mergeSortProds(l, middle + 1, right);
  mergeProds(l, left, middle, right);
}

Logistics *createLog()
{
  Logistics *new = malloc(sizeof(Logistics));
  new->prods = malloc(10000 * (sizeof(Produto)));
  new->enco = malloc(500 * (sizeof(Encomenda)));
  if ((!new->prods) || (!new->enco))
  {
    perror("Error Initialising logistics");
    exit(1);
  }
  else
  {
    
  }

  new->nextIde = 0;
  new->nextIdp = 0;
  return new;
}

void addProd(Logistics *l, char *string)
{
  char *name;
  char *rest;
  int nameLen = 0;
  int tab[3];
  int id;
  int restLen = 0;
  id = obtainIdNumber(l, 0);
  if (id < 10000)
  {
    while (string[nameLen] != ':')
    {
      nameLen++;
    }

    restLen = strlen(string) - nameLen;
    name = malloc((nameLen + 1) * (sizeof(char)));
    rest = malloc((restLen + 1) * (sizeof(char)));
    if (((!name) || (!rest)) || (nameLen > 63))
    {
      perror("malloc didnt work addProd");
      exit(1);
    }
    else
    {
      
    }

    name = strncpy(name, string, nameLen);
    rest = strncpy(rest, (string + nameLen) + 1, restLen);
    name[nameLen] = '\0';
    rest[restLen] = '\0';
    separate(rest, 3, tab);
    l->prods[id] = createProd(id, name, tab[0], tab[1], tab[2]);
    free(name);
    free(rest);
    fprintf(outputFile, "Novo produto %d.\n", id);
  }
  else
  {
    
  }

}

void addProdStock(Logistics *l, char *string)
{
  int tab[2];
  int pos;
  separate(string, 2, tab);
  pos = getProdPos(l, tab[0]);
  if (pos == (-1))
  {
    fprintf(outputFile, "Impossivel adicionar produto %d ao stock. Produto inexistente.\n", tab[0]);
  }
  else
  {
    l->prods[pos] = addStock(l->prods[pos], tab[1]);
  }

}

void removeProdStock(Logistics *l, char *string)
{
  int tab[2];
  int pos;
  separate(string, 2, tab);
  pos = getProdPos(l, tab[0]);
  if (pos == (-1))
  {
    fprintf(outputFile, "Impossivel remover stock do produto %d. Produto inexistente.\n", tab[0]);
  }
  else
  {
    if (getProdStock(l->prods[pos]) < tab[1])
    {
      fprintf(outputFile, "Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", tab[1], tab[0]);
    }
    else
    {
      l->prods[pos] = removeStock(l->prods[pos], tab[1]);
    }

  }

}

void addEncomenda(Logistics *l)
{
  int id;
  id = obtainIdNumber(l, 1);
  if (id < 500)
  {
    l->enco[id] = createEncomenda(id);
    fprintf(outputFile, "Nova encomenda %d.\n", id);
  }
  else
  {
    
  }

}

void addProdInEnc(Logistics *l, char *string)
{
  int tab[3];
  int pos;
  Produto newP;
  Produto oldP;
  separate(string, 3, tab);
  pos = getProdPos(l, tab[1]);
  if (tab[0] >= l->nextIde)
  {
    fprintf(outputFile, "Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", tab[1], tab[0]);
  }
  else
  {
    if (pos == (-1))
    {
      fprintf(outputFile, "Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", tab[1], tab[0]);
    }
    else
    {
      if (getProdStock(l->prods[pos]) < tab[2])
      {
        fprintf(outputFile, "Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", tab[1], tab[0]);
      }
      else
      {
        if ((getEncWeight(l->enco[tab[0]]) + (getProdWeight(l->prods[pos]) * tab[2])) > 200)
        {
          fprintf(outputFile, "Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de %d.\n", tab[1], tab[0], 200);
        }
        else
        {
          oldP = l->prods[pos];
          newP = createProd(getProdID(oldP), oldP.name, getProdPrice(oldP), getProdWeight(oldP), tab[2]);
          l->enco[tab[0]] = addEncProd(l->enco[tab[0]], newP);
          l->prods[pos] = removeStock(oldP, tab[2]);
        }

      }

    }

  }

}

void changeProdPrice(Logistics *l, char *string)
{
  int tab[2];
  int pos;
  int i;
  separate(string, 2, tab);
  pos = getProdPos(l, tab[0]);
  if (pos == (-1))
  {
    fprintf(outputFile, "Impossivel alterar preco do produto %d. Produto inexistente.\n", tab[0]);
  }
  else
  {
    l->prods[pos] = changePrice(l->prods[pos], tab[1]);
    for (i = 0; i < l->nextIde; i++)
    {
      l->enco[i] = changeProdPriceInEnc(l->enco[i], tab[0], tab[1]);
    }

  }

}

void removeProdInEnc(Logistics *l, char *string)
{
  int tab[2];
  int pos;
  int stock;
  separate(string, 2, tab);
  pos = getProdPos(l, tab[1]);
  if (tab[0] >= l->nextIde)
  {
    fprintf(outputFile, "Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", tab[1], tab[0]);
  }
  else
  {
    if (pos == (-1))
    {
      fprintf(outputFile, "Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", tab[1], tab[0]);
    }
    else
    {
      stock = getProdStockInEnc(l->enco[tab[0]], getProdID(l->prods[pos]));
      l->prods[pos] = addStock(l->prods[pos], stock);
      l->enco[tab[0]] = removeEncProd(l->enco[tab[0]], getProdID(l->prods[pos]));
    }

  }

}

void getPriceForEnc(Logistics *l, char *string)
{
  int tab[1];
  int price;
  separate(string, 1, tab);
  if (tab[0] >= l->nextIde)
  {
    fprintf(outputFile, "Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", tab[0]);
  }
  else
  {
    price = getEncPrice(l->enco[tab[0]]);
    fprintf(outputFile, "Custo da encomenda %d %d.\n", tab[0], price);
  }

}

void mostFrequentProd(Logistics *l, char *string)
{
  int tab[1];
  int pos;
  int mPos = 0;
  int i;
  separate(string, 1, tab);
  pos = getProdPos(l, tab[0]);
  if (pos == (-1))
  {
    fprintf(outputFile, "Impossivel listar maximo do produto %d. Produto inexistente.\n", tab[0]);
  }
  else
  {
    for (i = 0; i < l->nextIde; i++)
    {
      if (getProdStockInEnc(l->enco[i], tab[0]) > getProdStockInEnc(l->enco[mPos], tab[0]))
      {
        mPos = i;
      }
      else
      {
        
      }

    }

    if ((l->nextIde > 0) && (getProdStockInEnc(l->enco[mPos], tab[0]) > 0))
    {
      fprintf(outputFile, "Maximo produto %d %d %d.\n", tab[0], mPos, getProdStockInEnc(l->enco[mPos], tab[0]));
    }
    else
    {
      
    }

  }

}

void printProdInEnc(Logistics *l, char *string)
{
  int tab[2];
  int pos;
  separate(string, 2, tab);
  pos = getProdPos(l, tab[1]);
  if (tab[0] >= l->nextIde)
  {
    fprintf(outputFile, "Impossivel listar encomenda %d. Encomenda inexistente.\n", tab[0]);
  }
  else
  {
    if (pos == (-1))
    {
      fprintf(outputFile, "Impossivel listar produto %d. Produto inexistente.\n", tab[1]);
    }
    else
    {
      fprintf(outputFile, "%s %d.\n", getProdName(l->prods[pos]), getProdStockInEnc(l->enco[tab[0]], tab[1]));
    }

  }

}

void printOrdProd(Logistics *l)
{
  int i;
  fprintf(outputFile, "Produtos\n");
  mergeSortProds(l, 0, l->nextIdp - 1);
  for (i = 0; i < l->nextIdp; i++)
  {
    fprintf(outputFile, "* ");
    printProd(l->prods[i]);
  }

}

void printEncProds(Logistics *l, char *string)
{
  int tab[1];
  separate(string, 1, tab);
  if (tab[0] >= l->nextIde)
  {
    fprintf(outputFile, "Impossivel listar encomenda %d. Encomenda inexistente.\n", tab[0]);
  }
  else
  {
    fprintf(outputFile, "Encomenda %d\n", tab[0]);
    listProd(l->enco[tab[0]]);
  }

}

void freeLogistics(Logistics *l)
{
  int i;
  for (i = 0; i < l->nextIdp; i++)
  {
    free_prod(l->prods[i]);
  }

  for (i = 0; i < l->nextIde; i++)
  {
    free_enco(l->enco[i]);
  }

  free(l->prods);
  free(l->enco);
  free(l);
}

