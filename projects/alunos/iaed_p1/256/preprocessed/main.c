/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>


int PRODUCTID = -1;
int NUMBEROFPRODUCTS = 0;
int ORDERID = -1;
int NUMBEROFORDERS = 0;
typedef struct 
{
  int id;
  int price;
  int weight;
  int quant;
  char desc[64];
} Product;
Product products[10000];
typedef struct 
{
  int id;
  int weight;
  int numOfProds;
  Product products[10000];
} Order;
Order orders[500];
void readLine(char input[])
{
  int c;
  int i = 0;
  getchar();
  while ((c = getchar()) != '\n')
    input[i++] = c;

  input[i] = '\0';
}

void stringCut(char input[], char *str[], int n_args, char sep[])
{
  int i = 0;
  str[i] = strtok(input, sep);
  for (i = 1; i < n_args; i++)
    str[i] = strtok(0, sep);

}

Product getProduct(int idp)
{
  return products[idp];
}

int partition(Product v[], int l, int r)
{
  int i = l - 1;
  int j = r;
  int pivot = v[r].price;
  while (i < j)
  {
    while (v[++i].price < pivot)
      ;

    while ((pivot < v[--j].price) && (j != l))
      ;

    if (i < j)
    {
      Product C = v[i];
      v[i] = v[j];
      v[j] = C;
    }
    else
    {
      
    }

    ;
  }

  {
    Product C = v[i];
    v[i] = v[r];
    v[r] = C;
  }
  ;
  return i;
}

void quicksort(Product v[], int l, int r)
{
  if (r > l)
  {
    int i = partition(v, l, r);
    quicksort(v, l, i - 1);
    quicksort(v, i + 1, r);
  }
  else
  {
    
  }

}

bool productInOrder(int idp, int ide)
{
  int i;
  for (i = 0; i < orders[ide].numOfProds; i++)
    if (orders[ide].products[i].id == idp)
  {
    return true;
  }
  else
  {
    
  }


  return false;
}

Product createProduct(char *str[])
{
  Product p;
  PRODUCTID++;
  p.id = PRODUCTID;
  strcpy(p.desc, str[0]);
  p.price = atoi(str[1]);
  p.weight = atoi(str[2]);
  p.quant = atoi(str[3]);
  NUMBEROFPRODUCTS++;
  return p;
}

void addProduct(Product p)
{
  if (p.id < 10000)
  {
    products[p.id] = p;
  }
  else
  {
    
  }

  printf("Novo produto %d.\n", p.id);
}

void addStock(char *str[])
{
  int idp = atoi(str[0]);
  int quant = atoi(str[1]);
  if (idp <= PRODUCTID)
  {
    products[idp].quant += quant;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void newOrder()
{
  Order o;
  ORDERID++;
  if (ORDERID < 500)
  {
    o.id = ORDERID;
    o.weight = 0;
    o.numOfProds = 0;
    orders[ORDERID] = o;
    NUMBEROFORDERS++;
    printf("Nova encomenda %d.\n", o.id);
  }
  else
  {
    
  }

}

void addProductToOrder(char *str[])
{
  int ide = atoi(str[0]);
  int idp = atoi(str[1]);
  int qtd = atoi(str[2]);
  int i;
  Product p = getProduct(idp);
  if (ide > ORDERID)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp > PRODUCTID)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (qtd > p.quant)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((orders[ide].weight + (qtd * p.weight)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          if (!productInOrder(idp, ide))
          {
            strcpy(orders[ide].products[orders[ide].numOfProds].desc, p.desc);
            orders[ide].products[orders[ide].numOfProds].id = p.id;
            orders[ide].products[orders[ide].numOfProds].price = p.price;
            orders[ide].products[orders[ide].numOfProds].weight = p.weight;
            orders[ide].products[orders[ide].numOfProds].quant = qtd;
            products[p.id].quant -= qtd;
            orders[ide].weight += qtd * p.weight;
            orders[ide].numOfProds++;
          }
          else
          {
            for (i = 0; i < orders[ide].numOfProds; i++)
            {
              if (orders[ide].products[i].id == idp)
              {
                orders[ide].products[i].quant += qtd;
                products[p.id].quant -= qtd;
                orders[ide].weight += qtd * p.weight;
              }
              else
              {
                
              }

            }

          }

        }

      }

    }

  }

}

void removeStock(char *str[])
{
  int idp = atoi(str[0]);
  int qtd = atoi(str[1]);
  if (idp > PRODUCTID)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (products[idp].quant < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      products[idp].quant -= qtd;
    }

  }

}

void removeFromOrder(char *str[])
{
  int ide = atoi(str[0]);
  int idp = atoi(str[1]);
  int i;
  int flag = 0;
  if (ide > ORDERID)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp > PRODUCTID)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (productInOrder(idp, ide))
      {
        for (i = 0; i < orders[ide].numOfProds; ++i)
        {
          if ((orders[ide].products[i].id == idp) || (flag == 1))
          {
            if (flag == 0)
            {
              orders[ide].weight -= products[idp].weight * orders[ide].products[i].quant;
              products[idp].quant += orders[ide].products[i].quant;
            }
            else
            {
              
            }

            orders[ide].products[i] = orders[ide].products[i + 1];
            flag = 1;
          }
          else
          {
            
          }

        }

        orders[ide].numOfProds--;
      }
      else
      {
        
      }

    }

  }

}

void getCost(char input[])
{
  int ide = atoi(input);
  int i;
  int cost = 0;
  if (ide > ORDERID)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < orders[ide].numOfProds; ++i)
      if ((orders[ide].products[i].quant > 0) && (orders[ide].products[i].price > 0))
    {
      cost += orders[ide].products[i].price * orders[ide].products[i].quant;
    }
    else
    {
      
    }


    printf("Custo da encomenda %d %d.\n", ide, cost);
  }

}

void changePrice(char *str[])
{
  int idp = atoi(str[0]);
  int price = atoi(str[1]);
  int i;
  int j;
  if (idp > PRODUCTID)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    products[idp].price = price;
    for (i = 0; i < NUMBEROFORDERS; i++)
      for (j = 0; j < orders[i].numOfProds; j++)
      if (orders[i].products[j].id == idp)
    {
      orders[i].products[j].price = price;
    }
    else
    {
      
    }



  }

}

void listProductInOrder(char *str[])
{
  int ide = atoi(str[0]);
  int idp = atoi(str[1]);
  int i;
  Product p = products[idp];
  if (ide > ORDERID)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp > PRODUCTID)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      if (!productInOrder(idp, ide))
      {
        printf("%s 0.\n", p.desc);
      }
      else
      {
        for (i = 0; i < orders[ide].numOfProds; i++)
          if (orders[ide].products[i].id == idp)
        {
          printf("%s %d.\n", p.desc, orders[ide].products[i].quant);
          break;
        }
        else
        {
          
        }


      }

    }

  }

}

void orderWithMostProduct(char *str[])
{
  int idp = atoi(str[0]);
  int ide;
  int i;
  int j;
  int mostQuant = 0;
  if (products[idp].id != idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; i < NUMBEROFORDERS; i++)
      for (j = 0; j < orders[i].numOfProds; j++)
      if ((orders[i].products[j].id == idp) && (orders[i].products[j].quant > mostQuant))
    {
      ide = i, mostQuant = orders[i].products[j].quant;
    }
    else
    {
      
    }



    if (mostQuant > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide, mostQuant);
    }
    else
    {
      
    }

  }

}

void listPerPrice()
{
  int i;
  int k = 0;
  int j;
  Product arr_temp[10000];
  for (i = 0; i < NUMBEROFPRODUCTS; i++)
    arr_temp[k++] = products[i];

  quicksort(arr_temp, 0, k - 1);
  for (i = 0; i < NUMBEROFPRODUCTS; i++)
  {
    for (j = i + 1; j < NUMBEROFPRODUCTS; j++)
      if ((arr_temp[j].price == arr_temp[i].price) && (arr_temp[j].id < arr_temp[i].id))
    {
      Product C = arr_temp[j];
      arr_temp[j] = arr_temp[i];
      arr_temp[i] = C;
    }
    else
    {
      
    }


    ;
  }

  printf("Produtos\n");
  for (i = 0; i < k; i++)
    printf("* %s %d %d\n", arr_temp[i].desc, arr_temp[i].price, arr_temp[i].quant);

}

void listAlphabetically(char input[])
{
  int ide = atoi(input);
  int i;
  int j;
  int numOfProds;
  Product array_temp[10000];
  if (ide > ORDERID)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    numOfProds = orders[ide].numOfProds;
    for (i = 0; i < numOfProds; ++i)
      array_temp[i] = orders[ide].products[i];

    for (i = 0; i < numOfProds; ++i)
      for (j = 0; j < numOfProds; ++j)
      if (strcmp(array_temp[j].desc, array_temp[i].desc) > 0)
    {
      Product C = array_temp[j];
      array_temp[j] = array_temp[i];
      array_temp[i] = C;
    }
    else
    {
      
    }



    ;
    printf("Encomenda %d\n", ide);
    for (i = 0; i < numOfProds; i++)
      printf("* %s %d %d\n", array_temp[i].desc, array_temp[i].price, array_temp[i].quant);

  }

}

int main()
{
  char c;
  char input[112];
  char *str[112];
  char sep[2] = ":";
  while (1)
  {
    c = getchar();
    switch (c)
    {
      case 'a':
        readLine(input);
        stringCut(input, str, 4, sep);
        addProduct(createProduct(str));
        break;

      case 'q':
        readLine(input);
        stringCut(input, str, 2, sep);
        addStock(str);
        break;

      case 'N':
        newOrder();
        break;

      case 'A':
        readLine(input);
        stringCut(input, str, 3, sep);
        addProductToOrder(str);
        break;

      case 'r':
        readLine(input);
        stringCut(input, str, 2, sep);
        removeStock(str);
        break;

      case 'R':
        readLine(input);
        stringCut(input, str, 2, sep);
        removeFromOrder(str);
        break;

      case 'C':
        readLine(input);
        getCost(input);
        break;

      case 'p':
        readLine(input);
        stringCut(input, str, 2, sep);
        changePrice(str);
        break;

      case 'E':
        readLine(input);
        stringCut(input, str, 2, sep);
        listProductInOrder(str);
        break;

      case 'm':
        readLine(input);
        stringCut(input, str, 1, sep);
        orderWithMostProduct(str);
        break;

      case 'l':
        listPerPrice();
        break;

      case 'L':
        readLine(input);
        listAlphabetically(input);
        break;

      case 'x':
        exit(0);

      default:
        break;

    }

  }

  return 0;
}

