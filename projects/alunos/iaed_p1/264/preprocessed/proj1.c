/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct 
{
  int id;
  int price;
  int weight;
  int stock;
  char description[64];
} product;
typedef struct 
{
  int product_quantities[10000];
  int pid_in_order[10000];
  int weight;
  int products_in;
} order;
product products[10000];
int products_counter = 0;
order orders[500];
int orders_counter = 0;
void new_product()
{
  product p;
  for (int p_index = 0; p_index < 10; p_index++)
  {
    p.description[p_index] = new_sym_var(sizeof(char) * 8);
  }

  p.description[10 - 1] = '\0';
  p.price = new_sym_var(sizeof(int) * 8);
  p.weight = new_sym_var(sizeof(int) * 8);
  p.stock = new_sym_var(sizeof(int) * 8);
  p.id = products_counter;
  products[products_counter] = p;
  products_counter++;
  printf("Novo produto %d.\n", products_counter - 1);
}

void increase_stock()
{
  int pid;
  int qty;
  pid = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (pid >= products_counter)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", pid);
  }
  else
  {
    products[pid].stock += qty;
  }

}

void new_order()
{
  orders[orders_counter].weight = 0;
  orders[orders_counter].products_in = 0;
  orders_counter++;
  printf("Nova encomenda %d.\n", orders_counter - 1);
}

void add_product_to_order()
{
  int pid;
  int oid;
  int qty;
  oid = new_sym_var(sizeof(int) * 8);
  pid = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (oid >= orders_counter)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", pid, oid);
  }
  else
  {
    if (pid >= products_counter)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", pid, oid);
    }
    else
    {
      if (products[pid].stock < qty)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", pid, oid);
      }
      else
      {
        if ((orders[oid].weight + (products[pid].weight * qty)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", pid, oid);
        }
        else
        {
          if (orders[oid].product_quantities[pid])
          {
            orders[oid].product_quantities[pid] += qty;
            products[pid].stock -= qty;
          }
          else
          {
            orders[oid].product_quantities[pid] = qty;
            orders[oid].pid_in_order[orders[oid].products_in] = pid;
            orders[oid].products_in++;
            products[pid].stock -= qty;
          }

          orders[oid].weight += products[pid].weight * qty;
        }

      }

    }

  }

}

void decrease_stock()
{
  int pid;
  int qty;
  pid = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (pid >= products_counter)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", pid);
  }
  else
  {
    if ((products[pid].stock - qty) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qty, pid);
    }
    else
    {
      products[pid].stock -= qty;
    }

  }

}

void remove_product_from_order()
{
  int pid;
  int oid;
  int i;
  int found = 0;
  oid = new_sym_var(sizeof(int) * 8);
  pid = new_sym_var(sizeof(int) * 8);
  if (oid >= orders_counter)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", pid, oid);
  }
  else
  {
    if (pid >= products_counter)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", pid, oid);
    }
    else
    {
      for (i = 0; i < orders[oid].products_in; i++)
      {
        if (orders[oid].pid_in_order[i] == pid)
        {
          orders[oid].pid_in_order[i] = orders[oid].pid_in_order[orders[oid].products_in - 1];
          found = 1;
        }
        else
        {
          
        }

      }

      if (found)
      {
        orders[oid].weight -= products[pid].weight * orders[oid].product_quantities[pid];
        products[pid].stock += orders[oid].product_quantities[pid];
        orders[oid].product_quantities[pid] = 0;
        orders[oid].products_in--;
      }
      else
      {
        
      }

    }

  }

}

void calculate_cost()
{
  int oid;
  int pid;
  int qty;
  int cost = 0;
  int i;
  oid = new_sym_var(sizeof(int) * 8);
  if (oid >= orders_counter)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", oid);
  }
  else
  {
    for (i = 0; i < orders[oid].products_in; i++)
    {
      pid = orders[oid].pid_in_order[i];
      qty = orders[oid].product_quantities[pid];
      cost += qty * products[pid].price;
    }

    printf("Custo da encomenda %d %d.\n", oid, cost);
  }

}

void change_price()
{
  int pid;
  int new_price;
  pid = new_sym_var(sizeof(int) * 8);
  new_price = new_sym_var(sizeof(int) * 8);
  if (pid >= products_counter)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", pid);
  }
  else
  {
    products[pid].price = new_price;
  }

}

void order_product_details()
{
  int oid;
  int pid;
  oid = new_sym_var(sizeof(int) * 8);
  pid = new_sym_var(sizeof(int) * 8);
  if (oid >= orders_counter)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", oid);
  }
  else
  {
    if (pid >= products_counter)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", pid);
    }
    else
    {
      printf("%s %d.\n", products[pid].description, orders[oid].product_quantities[pid]);
    }

  }

}

void order_product_ocurrence()
{
  int pid;
  int k;
  int max = 0;
  int order = -1;
  pid = new_sym_var(sizeof(int) * 8);
  if (pid >= products_counter)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", pid);
  }
  else
  {
    for (k = 0; k < orders_counter; k++)
      if (orders[k].product_quantities[pid] > max)
    {
      max = orders[k].product_quantities[pid];
      order = k;
    }
    else
    {
      
    }


    if ((order != (-1)) && max)
    {
      printf("Maximo produto %d %d %d.\n", pid, order, max);
    }
    else
    {
      
    }

  }

}

int compare_price(product a, product b)
{
  int price = a.price - b.price;
  if (price != 0)
  {
    return price;
  }
  else
  {
    
  }

  return a.id - b.id;
}

int compare_descriptions(product a, product b)
{
  int description = strcmp(a.description, b.description);
  if (description != 0)
  {
    return description;
  }
  else
  {
    
  }

  return b.id - a.id;
}

void swap_products(product *a, product *b)
{
  product temp = *a;
  *a = *b;
  *b = temp;
}

int divide_by_price(product prod[], int low, int high, int split)
{
  product price;
  int i = low - 1;
  int j;
  swap_products(&prod[split], &prod[high]);
  price = prod[high];
  for (j = low; j <= (high - 1); j++)
  {
    if (compare_price(prod[j], price) < 0)
    {
      i++;
      swap_products(&prod[i], &prod[j]);
    }
    else
    {
      
    }

  }

  swap_products(&prod[i + 1], &prod[high]);
  return i + 1;
}

int divide_by_description(product prod[], int low, int high, int split)
{
  product description;
  int i = low - 1;
  int j;
  swap_products(&prod[split], &prod[high]);
  description = prod[high];
  for (j = low; j <= (high - 1); j++)
  {
    if (compare_descriptions(prod[j], description) < 0)
    {
      i++;
      swap_products(&prod[i], &prod[j]);
    }
    else
    {
      
    }

  }

  swap_products(&prod[i + 1], &prod[high]);
  return i + 1;
}

void quicksort(product prod[], int low, int high, char type[])
{
  int d;
  if (low < high)
  {
    if (!strcmp(type, "price"))
    {
      d = divide_by_price(prod, low, high, (low + high) / 2);
    }
    else
    {
      
    }

    if (!strcmp(type, "description"))
    {
      d = divide_by_description(prod, low, high, (low + high) / 2);
    }
    else
    {
      
    }

    quicksort(prod, low, d - 1, type);
    quicksort(prod, d + 1, high, type);
  }
  else
  {
    
  }

}

void crescent_price_sort()
{
  int i;
  product prod[10000];
  for (i = 0; i < products_counter; i++)
    prod[i] = products[i];

  quicksort(prod, 0, products_counter - 1, "price");
  printf("Produtos\n");
  for (i = 0; i < products_counter; i++)
    printf("* %s %d %d\n", prod[i].description, prod[i].price, prod[i].stock);

}

void alphabetical_sort()
{
  product prod[200];
  int oid;
  int i;
  oid = new_sym_var(sizeof(int) * 8);
  if (oid >= orders_counter)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", oid);
  }
  else
  {
    for (i = 0; i < orders[oid].products_in; i++)
    {
      prod[i] = products[orders[oid].pid_in_order[i]];
      prod[i].stock = orders[oid].product_quantities[orders[oid].pid_in_order[i]];
    }

    quicksort(prod, 0, orders[oid].products_in - 1, "description");
    printf("Encomenda %d\n", oid);
    for (i = 0; i < orders[oid].products_in; i++)
      printf("* %s %d %d\n", prod[i].description, prod[i].price, prod[i].stock);

  }

}

int main()
{
  char c;
  while (1)
  {
    c = getchar();
    if (c == 'x')
    {
      break;
    }
    else
    {
      
    }

    switch (c)
    {
      case 'a':
        new_product();
        break;

      case 'q':
        increase_stock();
        break;

      case 'N':
        new_order();
        break;

      case 'A':
        add_product_to_order();
        break;

      case 'r':
        decrease_stock();
        break;

      case 'R':
        remove_product_from_order();
        break;

      case 'C':
        calculate_cost();
        break;

      case 'p':
        change_price();
        break;

      case 'E':
        order_product_details();
        break;

      case 'm':
        order_product_ocurrence();
        break;

      case 'l':
        crescent_price_sort();
        break;

      case 'L':
        alphabetical_sort();
        break;

      default:
        break;

    }

  }

  return 0;
}

