#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


int quantity;
int compare;
int id;
int counter_prod = 0;
int counter_order = 0;
void create_product();
void add_stock();
void create_order();
void product_to_order();
void remove_stock();
void remove_from_order();
void total_price();
void price_change();
void quantity_of_product();
void product_occurs_more();
void display_low_to_high();
void display_alphabetic_order();
void price_low_to_high();
void sort_by_name();
struct Products
{
  char name[64];
  int price;
  int weight;
  int qtd;
  int idp;
};
struct Orders
{
  int ide;
  int list[10000];
};
struct Products produto[10000];
struct Products copy_products[10000];
struct Orders order[500];
int main()
{
  char command;
  int i;
  int j;
  command = getchar();
  for (i = 0; i < 500; i++)
  {
    for (j = 0; j < 10000; j++)
    {
      order[i].list[j] = 0;
    }

  }

  while (command != 'x')
  {
    switch (command)
    {
      case 'a':
        create_product();
        break;

      case 'q':
        add_stock();
        break;

      case 'N':
        create_order();
        break;

      case 'A':
        product_to_order();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_from_order();
        break;

      case 'C':
        total_price();
        break;

      case 'p':
        price_change();
        break;

      case 'E':
        quantity_of_product();
        break;

      case 'm':
        product_occurs_more();
        break;

      case 'l':
        display_low_to_high();
        break;

      case 'L':
        display_alphabetic_order();
        break;

    }

    command = getchar();
  }

  return 0;
}

void create_product()
{
  for (int produto_index = 0; produto_index < 10; produto_index++)
  {
    produto[counter_prod].name[produto_index] = new_sym_var(sizeof(char) * 8);
  }

  produto[counter_prod].name[10 - 1] = '\0';
  produto[counter_prod].price = new_sym_var(sizeof(int) * 8);
  produto[counter_prod].weight = new_sym_var(sizeof(int) * 8);
  produto[counter_prod].qtd = new_sym_var(sizeof(int) * 8);
  produto[counter_prod].idp = counter_prod;
  printf("Novo produto %d.\n", produto[counter_prod].idp);
  counter_prod += 1;
}

void add_stock()
{
  compare = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (compare > (counter_prod - 1))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", compare);
  }
  else
  {
    produto[compare].qtd += quantity;
  }

}

void create_order()
{
  printf("Nova encomenda %d.\n", counter_order);
  order[counter_order].ide = counter_order;
  counter_order += 1;
}

void product_to_order()
{
  int i;
  int sum;
  compare = new_sym_var(sizeof(int) * 8);
  id = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  sum = 0;
  for (i = 0; i < counter_prod; i++)
  {
    sum += produto[i].weight * order[compare].list[i];
  }

  if (compare > (counter_order - 1))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id, compare);
  }
  else
  {
    if (id > (counter_prod - 1))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id, compare);
    }
    else
    {
      if (quantity > produto[id].qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id, compare);
      }
      else
      {
        if ((sum + (produto[id].weight * quantity)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id, compare);
        }
        else
        {
          order[compare].list[id] += quantity;
          produto[id].qtd -= quantity;
        }

      }

    }

  }

}

void remove_stock()
{
  id = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (id > (counter_prod - 1))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    if (quantity > produto[id].qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantity, id);
    }
    else
    {
      produto[id].qtd -= quantity;
    }

  }

}

void remove_from_order()
{
  compare = new_sym_var(sizeof(int) * 8);
  id = new_sym_var(sizeof(int) * 8);
  if (compare > (counter_order - 1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id, compare);
  }
  else
  {
    if (id > (counter_prod - 1))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id, compare);
    }
    else
    {
      produto[id].qtd += order[compare].list[id];
      order[compare].list[id] = 0;
    }

  }

}

void total_price()
{
  int i;
  int total;
  compare = new_sym_var(sizeof(int) * 8);
  if (compare > (counter_order - 1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", compare);
  }
  else
  {
    total = 0;
    for (i = 0; i < counter_prod; i++)
    {
      total += order[compare].list[i] * produto[i].price;
    }

    printf("Custo da encomenda %d %d.\n", compare, total);
  }

}

void price_change()
{
  int change_price;
  id = new_sym_var(sizeof(int) * 8);
  change_price = new_sym_var(sizeof(int) * 8);
  if (id > (counter_prod - 1))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    produto[id].price = change_price;
  }

}

void quantity_of_product()
{
  compare = new_sym_var(sizeof(int) * 8);
  id = new_sym_var(sizeof(int) * 8);
  if (compare > (counter_order - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", compare);
  }
  else
  {
    if (id > (counter_prod - 1))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", id);
    }
    else
    {
      printf("%s %d.\n", produto[id].name, order[compare].list[id]);
    }

  }

}

void product_occurs_more()
{
  int i;
  int max_number;
  int max_prod;
  id = new_sym_var(sizeof(int) * 8);
  if (id > (counter_prod - 1))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    if (counter_order != 0)
    {
      max_number = 0;
      for (i = 0; i < counter_order; i++)
      {
        max_number += order[i].list[id];
      }

      if (max_number != 0)
      {
        max_number = order[0].list[id];
        max_prod = 0;
        for (i = 0; i < counter_order; i++)
        {
          if (order[i].list[id] > max_number)
          {
            max_number = order[i].list[id];
            max_prod = i;
          }
          else
          {
            
          }

        }

        printf("Maximo produto %d %d %d.\n", id, max_prod, max_number);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

}

void display_low_to_high()
{
  int i;
  int m;
  memcpy(copy_products, produto, (sizeof(struct Products)) * 10000);
  m = 0;
  for (i = 0; i < 10000; i++)
  {
    if (produto[i].price > m)
    {
      m = produto[i].price;
    }
    else
    {
      
    }

  }

  price_low_to_high(copy_products, 0, counter_prod - 1, m);
  printf("Produtos\n");
  for (i = 0; i < counter_prod; i++)
  {
    printf("* %s %d %d\n", copy_products[i].name, copy_products[i].price, copy_products[i].qtd);
  }

}

void display_alphabetic_order()
{
  int i;
  int j;
  compare = new_sym_var(sizeof(int) * 8);
  if (compare > (counter_order - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", compare);
  }
  else
  {
    j = 0;
    for (i = 0; i < counter_prod; i++)
    {
      if (order[compare].list[i] != 0)
      {
        copy_products[j] = produto[i];
        j++;
      }
      else
      {
        
      }

    }

    sort_by_name(copy_products, 0, j - 1);
    printf("Encomenda %d\n", compare);
    for (i = 0; i < j; i++)
    {
      printf("* %s %d %d\n", copy_products[i].name, copy_products[i].price, order[compare].list[copy_products[i].idp]);
    }

  }

}

void price_low_to_high(struct Products a[], int l, int r, int m)
{
  int i;
  int j;
  int count[32767];
  struct Products aux[10000 + 1];
  for (j = 0; j <= m; j++)
  {
    count[j] = 0;
  }

  for (i = l; i <= r; i++)
  {
    count[a[i].price + 1]++;
  }

  for (j = 1; j <= m; j++)
  {
    count[j] += count[j - 1];
  }

  for (i = l; i <= r; i++)
  {
    aux[count[a[i].price]++] = a[i];
  }

  for (i = l; i <= r; i++)
  {
    a[i] = aux[i - l];
  }

}

void merge(struct Products a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  struct Products aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = a[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if (strcmp(aux[j].name, aux[i].name) < 0)
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void sort_by_name(struct Products a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  sort_by_name(a, l, m);
  sort_by_name(a, m + 1, r);
  merge(a, l, m, r);
}

