#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct product
{
  int id;
  char desc[64];
  int price;
  int weight;
  int stock;
} Product;
typedef struct order
{
  int products[500];
  int quantProducts[500];
  int weight;
  int numProducts;
  int productsSorted;
} Orders;
Product productsList[10000];
Orders ordersList[500];
int nProducts = 0;
int nOrders = 0;
int priceSorted = 0;
int getProductsListPosition(int id);
int getOrdersListPosition(int ide, int idp);
void ordersMerge(int ide, int l, int m, int r);
void ordersMergeSort(int ide, int l, int r);
void productsMerge(int l, int m, int r);
void productsMergeSort(int l, int r);
void fa(char c[]);
void fq(char c[]);
void fN();
void fA(char c[]);
void fr(char c[]);
void fR(char c[]);
void fC(char c[]);
void fp(char c[]);
void fE(char c[]);
void fm(char c[]);
void fl();
void fL(char c[]);
int main()
{
  int c;
  char buffer[200];
  while ((c = getchar()) != EOF)
  {
    getchar();
    switch (c)
    {
      case 'a':
        fgets(buffer, 200, stdin);
        fa(buffer);
        break;

      case 'q':
        fgets(buffer, 200, stdin);
        fq(buffer);
        break;

      case 'N':
        fN();
        break;

      case 'A':
        fgets(buffer, 200, stdin);
        fA(buffer);
        break;

      case 'r':
        fgets(buffer, 200, stdin);
        fr(buffer);
        break;

      case 'R':
        fgets(buffer, 200, stdin);
        fR(buffer);
        break;

      case 'C':
        fgets(buffer, 200, stdin);
        fC(buffer);
        break;

      case 'p':
        fgets(buffer, 200, stdin);
        fp(buffer);
        break;

      case 'E':
        fgets(buffer, 200, stdin);
        fE(buffer);
        break;

      case 'm':
        fgets(buffer, 200, stdin);
        fm(buffer);
        break;

      case 'l':
        fl();
        break;

      case 'L':
        fgets(buffer, 200, stdin);
        fL(buffer);
        break;

      case 'x':
        return 0;

    }

  }

  return 0;
}

int getProductsListPosition(int id)
{
  int i;
  for (i = 0; i < nProducts; i++)
  {
    if (productsList[i].id == id)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int getOrdersListPosition(int ide, int idp)
{
  int i;
  for (i = 0; i < ordersList[ide].numProducts; i++)
  {
    if (ordersList[ide].products[i] == idp)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void ordersMerge(int ide, int l, int m, int r)
{
  int *auxIDs;
  int *auxQuants;
  int i;
  int j;
  int k;
  int indexI;
  int indexJ;
  auxIDs = malloc((sizeof(int)) * ordersList[ide].numProducts);
  auxQuants = malloc((sizeof(int)) * ordersList[ide].numProducts);
  for (i = m + 1; i > l; i--)
  {
    auxIDs[i - 1] = ordersList[ide].products[i - 1];
    auxQuants[i - 1] = ordersList[ide].quantProducts[i - 1];
  }

  for (j = m; j < r; j++)
  {
    auxIDs[(r + m) - j] = ordersList[ide].products[j + 1];
    auxQuants[(r + m) - j] = ordersList[ide].quantProducts[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    indexI = getProductsListPosition(auxIDs[i]);
    indexJ = getProductsListPosition(auxIDs[j]);
    if (strcmp(productsList[indexJ].desc, productsList[indexI].desc) < 0)
    {
      ordersList[ide].products[k] = auxIDs[j];
      ordersList[ide].quantProducts[k] = auxQuants[j--];
    }
    else
    {
      ordersList[ide].products[k] = auxIDs[i];
      ordersList[ide].quantProducts[k] = auxQuants[i++];
    }

  }

  free(auxIDs);
  free(auxQuants);
}

void ordersMergeSort(int ide, int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  ordersMergeSort(ide, l, m);
  ordersMergeSort(ide, m + 1, r);
  ordersMerge(ide, l, m, r);
}

void productsMerge(int l, int m, int r)
{
  Product *aux;
  int i;
  int j;
  int k;
  aux = malloc((sizeof(Product)) * nProducts);
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = productsList[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = productsList[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if (aux[j].price < aux[i].price)
    {
      productsList[k] = aux[j--];
    }
    else
    {
      if (aux[j].price == aux[i].price)
      {
        if (aux[j].id < aux[i].id)
        {
          productsList[k] = aux[j--];
        }
        else
        {
          productsList[k] = aux[i++];
        }

      }
      else
      {
        productsList[k] = aux[i++];
      }

    }

  }

  free(aux);
}

void productsMergeSort(int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  productsMergeSort(l, m);
  productsMergeSort(m + 1, r);
  productsMerge(l, m, r);
}

void fa(char c[])
{
  char *token;
  token = strtok(c, ":");
  strcpy(productsList[nProducts].desc, token);
  token = strtok(0, ":");
  productsList[nProducts].price = atoi(token);
  token = strtok(0, ":");
  productsList[nProducts].weight = atoi(token);
  token = strtok(0, "\n");
  productsList[nProducts].stock = atoi(token);
  productsList[nProducts].id = nProducts;
  printf("Novo produto %d.\n", nProducts);
  nProducts++;
  priceSorted = 0;
}

void fq(char c[])
{
  char *token;
  int idp;
  int qnt;
  int index;
  token = strtok(c, ":");
  idp = atoi(token);
  token = strtok(0, "\n");
  qnt = atoi(token);
  if (idp < nProducts)
  {
    index = getProductsListPosition(idp);
    productsList[index].stock += qnt;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void fN()
{
  printf("Nova encomenda %d.\n", nOrders);
  nOrders++;
}

void fA(char c[])
{
  char *token;
  int ide;
  int idp;
  int qtd;
  int indexP;
  int indexO;
  token = strtok(c, ":");
  ide = atoi(token);
  token = strtok(0, ":");
  idp = atoi(token);
  token = strtok(0, "\n");
  qtd = atoi(token);
  indexP = getProductsListPosition(idp);
  if (ide < nOrders)
  {
    if (idp < nProducts)
    {
      if (qtd > productsList[indexP].stock)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((ordersList[ide].weight + (qtd * productsList[indexP].weight)) <= 200)
        {
          ordersList[ide].weight += qtd * productsList[indexP].weight;
          productsList[indexP].stock -= qtd;
          indexO = getOrdersListPosition(ide, idp);
          if (indexO == (-1))
          {
            ordersList[ide].products[ordersList[ide].numProducts] = idp;
            ordersList[ide].quantProducts[ordersList[ide].numProducts] = qtd;
            ordersList[ide].numProducts++;
          }
          else
          {
            ordersList[ide].quantProducts[indexO] += qtd;
          }

          ordersList[ide].productsSorted = 0;
        }
        else
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }

      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void fr(char c[])
{
  char *token;
  int idp;
  int qtd;
  int index;
  token = strtok(c, ":");
  idp = atoi(token);
  token = strtok(0, "\n");
  qtd = atoi(token);
  if (idp < nProducts)
  {
    index = getProductsListPosition(idp);
    if (qtd > productsList[index].stock)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      productsList[index].stock -= qtd;
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }

}

void fR(char c[])
{
  char *token;
  int ide;
  int idp;
  int indexO;
  int indexP;
  token = strtok(c, ":");
  ide = atoi(token);
  token = strtok(0, "\n");
  idp = atoi(token);
  if (ide < nOrders)
  {
    if (idp < nProducts)
    {
      indexO = getOrdersListPosition(ide, idp);
      indexP = getProductsListPosition(idp);
      if (indexO != (-1))
      {
        productsList[indexP].stock += ordersList[ide].quantProducts[indexO];
        ordersList[ide].weight -= productsList[indexP].weight * ordersList[ide].quantProducts[indexO];
        ordersList[ide].numProducts--;
        ordersList[ide].products[indexO] = ordersList[ide].products[ordersList[ide].numProducts];
        ordersList[ide].quantProducts[indexO] = ordersList[ide].quantProducts[ordersList[ide].numProducts];
      }
      else
      {
        
      }

      ordersList[ide].productsSorted = 0;
    }
    else
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void fC(char c[])
{
  char *token;
  int ide;
  int total = 0;
  int i;
  int index;
  token = strtok(c, "\n");
  ide = atoi(token);
  if (ide < nOrders)
  {
    for (i = 0; i < ordersList[ide].numProducts; i++)
    {
      index = getProductsListPosition(ordersList[ide].products[i]);
      total += productsList[index].price * ordersList[ide].quantProducts[i];
    }

    printf("Custo da encomenda %d %d.\n", ide, total);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void fp(char c[])
{
  char *token;
  int idp;
  int newPrice;
  int index;
  token = strtok(c, ":");
  idp = atoi(token);
  token = strtok(0, "\n");
  newPrice = atoi(token);
  if (idp < nProducts)
  {
    index = getProductsListPosition(idp);
    productsList[index].price = newPrice;
    priceSorted = 0;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

void fE(char c[])
{
  char *token;
  int ide;
  int idp;
  int indexO;
  int indexP;
  token = strtok(c, ":");
  ide = atoi(token);
  token = strtok(0, "\n");
  idp = atoi(token);
  if (ide < nOrders)
  {
    if (idp < nProducts)
    {
      indexO = getOrdersListPosition(ide, idp);
      indexP = getProductsListPosition(idp);
      printf("%s %d.\n", productsList[indexP].desc, ordersList[ide].quantProducts[indexO]);
    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void fm(char c[])
{
  char *token;
  int idp;
  int max = 0;
  int ide;
  int productIndex;
  int i;
  int index;
  token = strtok(c, "\n");
  idp = atoi(token);
  if (idp < nProducts)
  {
    for (i = 0; i < nOrders; i++)
    {
      index = getOrdersListPosition(i, idp);
      if (ordersList[i].quantProducts[index] > max)
      {
        max = ordersList[i].quantProducts[index];
        ide = i;
        productIndex = index;
      }
      else
      {
        
      }

    }

    if (max != 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide, ordersList[ide].quantProducts[productIndex]);
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }

}

void fl()
{
  int i;
  if (priceSorted == 0)
  {
    productsMergeSort(0, nProducts - 1);
    priceSorted = 1;
  }
  else
  {
    
  }

  printf("Produtos\n");
  for (i = 0; i < nProducts; i++)
  {
    printf("* %s %d %d\n", productsList[i].desc, productsList[i].price, productsList[i].stock);
  }

}

void fL(char c[])
{
  char *token;
  int ide;
  int j;
  int indexJ;
  token = strtok(c, "\n");
  ide = atoi(token);
  if (ide < nOrders)
  {
    if (ordersList[ide].productsSorted == 0)
    {
      ordersMergeSort(ide, 0, ordersList[ide].numProducts - 1);
      ordersList[ide].productsSorted = 1;
    }
    else
    {
      
    }

    printf("Encomenda %d\n", ide);
    for (j = 0; j < ordersList[ide].numProducts; j++)
    {
      indexJ = getProductsListPosition(ordersList[ide].products[j]);
      printf("* %s %d %d\n", productsList[indexJ].desc, productsList[indexJ].price, ordersList[ide].quantProducts[j]);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

