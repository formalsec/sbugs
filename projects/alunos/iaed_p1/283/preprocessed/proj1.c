/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <stdio.h>
#include <string.h>


typedef struct 
{
  int idp;
  char description[64];
  int price;
  int quantity;
  int weight;
} product;
typedef struct 
{
  product produtos[10000];
  int ide;
  int peso;
  int pesomax;
} encomenda;
int maxidp;
int maxide;
product produtos[10000];
encomenda encomendas[500];
void exch(product a[], int i, int j)
{
  product aux = a[i];
  a[i] = a[j];
  a[j] = aux;
}

int less(product a, product v)
{
  if (a.price == v.price)
  {
    if (a.idp < v.idp)
    {
      return 1;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  if (a.price < v.price)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

int partition_preco(product a[], int l, int r)
{
  int i = l - 1;
  int j = r;
  product v = a[r];
  while (i < j)
  {
    while (less(a[++i], v))
      ;

    while (less(v, a[--j]))
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      exch(a, i, j);
    }
    else
    {
      
    }

  }

  exch(a, i, r);
  return i;
}

void quicksort_preco(product a[], int l, int r)
{
  int i = 0;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition_preco(a, l, r);
  quicksort_preco(a, l, i - 1);
  quicksort_preco(a, i + 1, r);
}

void exch_nome(product a[], int i, int j)
{
  product aux = a[i];
  a[i] = a[j];
  a[j] = aux;
}

int less_descricao(product a, product v)
{
  int result;
  result = strcmp(a.description, v.description);
  if (result < 0)
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

int partition_nome(product a[], int l, int r)
{
  int i = l;
  int j = r;
  product v = a[r];
  while (i < j)
  {
    while (less_descricao(a[++i], v))
      ;

    while (less_descricao(v, a[--j]))
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      exch_nome(a, i, j);
    }
    else
    {
      
    }

  }

  exch_nome(a, i, r);
  return i;
}

void quicksort_nome(product a[], int l, int r)
{
  int i = 0;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition_nome(a, l, r);
  quicksort_nome(a, l, i - 1);
  quicksort_nome(a, i + 1, r);
}

int criaproduto()
{
  char espaco = '\0';
  espaco = new_sym_var(sizeof(char) * 8);
  for (int produtos_index = 0; produtos_index < 10; produtos_index++)
  {
    produtos[maxidp].description[produtos_index] = new_sym_var(sizeof(char) * 8);
  }

  produtos[maxidp].description[10 - 1] = '\0';
  produtos[maxidp].price = new_sym_var(sizeof(int) * 8);
  produtos[maxidp].weight = new_sym_var(sizeof(int) * 8);
  produtos[maxidp].quantity = new_sym_var(sizeof(int) * 8);
  produtos[maxidp].idp = maxidp;
  printf("Novo produto %d.\n", maxidp);
  return ++maxidp;
}

void novostock()
{
  int arg2;
  int arg3;
  arg2 = new_sym_var(sizeof(int) * 8);
  arg3 = new_sym_var(sizeof(int) * 8);
  if (arg2 >= maxidp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", arg2);
  }
  else
  {
    produtos[arg2].quantity += arg3;
  }

  return;
}

int criaencomenda()
{
  encomendas[maxide].ide = maxide;
  printf("Nova encomenda %d.\n", maxide);
  return ++maxide;
}

void adicionaproduto()
{
  int arg1;
  int arg2;
  int arg3;
  int quantidade;
  int peso;
  int pesoencomenda;
  int peso_t;
  arg1 = new_sym_var(sizeof(int) * 8);
  arg2 = new_sym_var(sizeof(int) * 8);
  arg3 = new_sym_var(sizeof(int) * 8);
  if (arg1 >= maxide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", arg2, arg1);
  }
  else
  {
    if (arg2 >= maxidp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", arg2, arg1);
    }
    else
    {
      if (produtos[arg2].quantity < arg3)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", arg2, arg1);
      }
      else
      {
        if (encomendas[arg1].produtos[arg2].quantity != 0)
        {
          peso = produtos[arg2].weight;
          quantidade = arg3;
          peso_t = peso * quantidade;
          pesoencomenda = peso_t + encomendas[arg1].pesomax;
          if (pesoencomenda >= 201)
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", arg2, encomendas[arg1].ide);
          }
          else
          {
            encomendas[arg1].pesomax += peso_t;
            encomendas[arg1].produtos[arg2].quantity += arg3;
            produtos[arg2].quantity -= arg3;
            strcpy(encomendas[arg1].produtos[arg2].description, produtos[arg2].description);
          }

        }
        else
        {
          peso = produtos[arg2].weight;
          quantidade = arg3;
          peso_t = peso * quantidade;
          pesoencomenda = peso_t + encomendas[arg1].pesomax;
          if (pesoencomenda >= 201)
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", arg2, encomendas[arg1].ide);
          }
          else
          {
            encomendas[arg1].pesomax += peso_t;
            encomendas[arg1].produtos[arg2].quantity = arg3;
            produtos[arg2].quantity -= arg3;
            strcpy(encomendas[arg1].produtos[arg2].description, produtos[arg2].description);
          }

        }

      }

    }

  }

  return;
}

void removestock()
{
  int arg2;
  int arg3;
  int atual;
  arg2 = new_sym_var(sizeof(int) * 8);
  arg3 = new_sym_var(sizeof(int) * 8);
  if (arg2 >= maxidp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", arg2);
  }
  else
  {
    atual = produtos[arg2].quantity;
    produtos[arg2].quantity -= arg3;
    if (produtos[arg2].quantity < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", arg3, arg2);
      produtos[arg2].quantity = atual;
    }
    else
    {
      
    }

  }

  return;
}

void removeproduto()
{
  int arg1;
  int arg2;
  int c;
  int peso;
  int pesototal = 0;
  arg1 = new_sym_var(sizeof(int) * 8);
  arg2 = new_sym_var(sizeof(int) * 8);
  if (arg1 >= maxide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", arg2, arg1);
  }
  else
  {
    if (arg2 >= maxidp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", arg2, arg1);
    }
    else
    {
      c = encomendas[arg1].produtos[arg2].quantity;
      produtos[arg2].quantity += c;
      encomendas[arg1].produtos[arg2].quantity = 0;
      peso = produtos[arg2].weight;
      pesototal = peso * c;
      encomendas[arg1].pesomax -= pesototal;
    }

  }

  return;
}

int calculapreco()
{
  int arg1;
  int x;
  int preco;
  int quantidade;
  int precototal;
  int contador = 0;
  arg1 = new_sym_var(sizeof(int) * 8);
  if (arg1 >= maxide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", arg1);
  }
  else
  {
    for (x = 0; encomendas[arg1].produtos[x].description < encomendas[arg1].produtos[maxidp].description; x++)
    {
      quantidade = encomendas[arg1].produtos[x].quantity;
      preco = produtos[x].price;
      precototal = quantidade * preco;
      contador += precototal;
    }

    printf("Custo da encomenda %d %d.\n", arg1, contador);
  }

  return 0;
}

void alterapreco()
{
  int arg2;
  int arg3;
  arg2 = new_sym_var(sizeof(int) * 8);
  arg3 = new_sym_var(sizeof(int) * 8);
  if (arg2 >= maxidp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", arg2);
  }
  else
  {
    produtos[arg2].price = arg3;
  }

  return;
}

void lista()
{
  int arg1;
  int arg2;
  int quantidade = 0;
  arg1 = new_sym_var(sizeof(int) * 8);
  arg2 = new_sym_var(sizeof(int) * 8);
  if (arg1 >= maxide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", arg1);
  }
  else
  {
    if (arg2 >= maxidp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", arg2);
    }
    else
    {
      quantidade += encomendas[arg1].produtos[arg2].quantity;
      printf("%s %d.\n", produtos[arg2].description, quantidade);
    }

  }

  return;
}

int maximo()
{
  int contador = 0;
  int encomendaide;
  int quantidade;
  int arg1;
  int x;
  int c = 0;
  arg1 = new_sym_var(sizeof(int) * 8);
  if (arg1 >= maxidp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", arg1);
  }
  else
  {
    for (x = 0; x < maxidp; x++)
    {
      c += encomendas[x].produtos[arg1].quantity;
    }

    if (c != 0)
    {
      for (x = 0; x <= maxide; x++)
      {
        if (encomendas[x].produtos[arg1].quantity != 0)
        {
          quantidade = encomendas[x].produtos[arg1].quantity;
          if (quantidade == contador)
          {
            if (encomendas[x].ide < encomendaide)
            {
              contador = encomendas[x].produtos[arg1].quantity;
              encomendaide = encomendas[x].ide;
            }
            else
            {
              
            }

          }
          else
          {
            
          }

          if (quantidade > contador)
          {
            contador = encomendas[x].produtos[arg1].quantity;
            encomendaide = encomendas[x].ide;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

      printf("Maximo produto %d %d %d.\n", arg1, encomendaide, contador);
    }
    else
    {
      
    }

  }

  return 0;
}

int listaproduto()
{
  int x = 0;
  int y = 0;
  product vetor[10000];
  for (x = 0; x < maxidp; x++)
  {
    vetor[x].price = produtos[x].price;
    vetor[x].idp = produtos[x].idp;
    vetor[x].weight = produtos[x].weight;
    vetor[x].quantity = produtos[x].quantity;
    strcpy(vetor[x].description, produtos[x].description);
  }

  quicksort_preco(vetor, y, maxidp - 1);
  printf("Produtos\n");
  for (x = 0; x < maxidp; x++)
  {
    printf("* %s %d %d\n", vetor[x].description, vetor[x].price, vetor[x].quantity);
  }

  return 0;
}

int listaalfabetica()
{
  int x = 0;
  int arg1;
  int len = 0;
  int id;
  product vetor[10000] = {0};
  int tamanho = 0;
  arg1 = new_sym_var(sizeof(int) * 8);
  if (arg1 >= maxide)
  {
    return printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", arg1);
  }
  else
  {
    for (x = 0; x < maxidp; x++)
    {
      if (encomendas[arg1].produtos[x].quantity != 0)
      {
        id = produtos[x].idp;
        len += 1;
      }
      else
      {
        
      }

    }

    if (len == 1)
    {
      printf("Encomenda %d\n", arg1);
      printf("* %s %d %d\n", encomendas[arg1].produtos[id].description, produtos[id].price, encomendas[arg1].produtos[id].quantity);
    }
    else
    {
      printf("Encomenda %d\n", arg1);
      for (x = 0; x < maxidp; x++)
      {
        if (encomendas[arg1].produtos[x].quantity != 0)
        {
          vetor[x].price = encomendas[arg1].produtos[x].price;
          vetor[x].idp = encomendas[arg1].produtos[x].idp;
          vetor[x].quantity = encomendas[arg1].produtos[x].quantity;
          strcpy(vetor[x].description, encomendas[arg1].produtos[x].description);
          tamanho++;
        }
        else
        {
          
        }

      }

      quicksort_nome(vetor, 0, len);
      for (x = 0; x < len; x++)
        printf("* %s %d %d\n", vetor[x].description, vetor[x].price, vetor[x].quantity);

    }

  }

  return 0;
}

int main()
{
  char frase = '\0';
  while (1)
  {
    frase = new_sym_var(sizeof(char) * 8);
    switch (frase)
    {
      case 'a':
        criaproduto();
        break;

      case 'q':
        novostock();
        break;

      case 'N':
        criaencomenda();
        break;

      case 'A':
        adicionaproduto();
        break;

      case 'r':
        removestock();
        break;

      case 'R':
        removeproduto();
        break;

      case 'C':
        calculapreco();
        break;

      case 'p':
        alterapreco();
        break;

      case 'E':
        lista();
        break;

      case 'm':
        maximo();
        break;

      case 'l':
        listaproduto();
        break;

      case 'L':
        listaalfabetica();
        break;

      case 'x':
        return 0;
        break;

    }

  }

}

