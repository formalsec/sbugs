#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct produto
{
  int identificador;
  char descricao[100];
  int preco;
  int peso;
  int quantidade;
} produto;
typedef struct encomenda
{
  int identificadorpro;
  int identificador;
  int quantidade;
} encomenda;
produto PRODUTO[10000];
encomenda ENCOMENDA[500][200];
void _a_(int i);
void _q_(int k);
void _N_(int n);
int _A_(int k);
int _r_(int k);
int _R_();
int _C_();
int _p_(int k);
int _E_(int k);
int _m_(int n);
int _l_(int k);
int _L_(int n);
int calcula_peso_encomenda(int ide);
int calcula_produtos_encomenda(int ide);
int verifica_idp_na_encomenda(int idp, int ide);
void get_input(char info[5][100]);
void quicksort_l(produto a[], int l, int r);
int less_l(produto a, produto v);
int partition_l(produto a[], int l, int r);
void exch_l(produto a[], int i, int j);
void quicksort_L(encomenda a[], int l, int r);
int less_L(encomenda a, encomenda v);
int partition_L(encomenda a[], int l, int r);
void exch_L(encomenda a[], int i, int j);
int main()
{
  int i = 0;
  int j = 0;
  int k = -1;
  int n = -1;
  char first = '\0';
  for (i = 0; i < 500; i++)
  {
    for (j = 0; j < 200; j++)
    {
      ENCOMENDA[i][j].identificador = -1;
      ENCOMENDA[i][j].identificadorpro = -1;
      ENCOMENDA[i][j].quantidade = 0;
    }

  }

  while (first != 'x')
  {
    first = new_sym_var(sizeof(char) * 8);
    switch (first)
    {
      case 'a':
        k++;
        _a_(k);
        break;

      case 'q':
        _q_(k);
        break;

      case 'N':
        n++;
        _N_(n);
        break;

      case 'A':
        _A_(k);
        break;

      case 'r':
        _r_(k);
        break;

      case 'R':
        _R_();
        break;

      case 'C':
        _C_();
        break;

      case 'p':
        _p_(k);
        break;

      case 'E':
        _E_(k);
        break;

      case 'm':
        _m_(n);
        break;

      case 'l':
        _l_(k);
        break;

      case 'L':
        _L_(n);
        break;

    }

  }

  return 0;
}

void get_input(char info[5][100])
{
  char array[400];
  char space;
  int i = 0;
  const char str[100] = ":\n";
  char *token;
  space = new_sym_var(sizeof(char) * 8);
  fgets(array, 400, stdin);
  token = strtok(array, str);
  strcpy(info[i], token);
  while (token != 0)
  {
    token = strtok(0, str);
    if (token != 0)
    {
      i++;
      strcpy(info[i], token);
    }
    else
    {
      break;
    }

  }

}

void _a_(int i)
{
  char info[5][100];
  char descrip[100];
  int price;
  int weight;
  int qtd;
  get_input(info);
  strcpy(descrip, info[0]);
  price = atoi(info[1]);
  weight = atoi(info[2]);
  qtd = atoi(info[3]);
  strcpy(PRODUTO[i].descricao, info[0]);
  PRODUTO[i].identificador = i;
  PRODUTO[i].preco = price;
  PRODUTO[i].peso = weight;
  PRODUTO[i].quantidade = qtd;
  printf("Novo produto %d.\n", PRODUTO[i].identificador);
}

void _q_(int k)
{
  char info[5][100];
  int idp = 0;
  int qtd = 0;
  int i;
  int j = 0;
  get_input(info);
  idp = atoi(info[0]);
  qtd = atoi(info[1]);
  if (k == (-1))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    if (idp == PRODUTO[i].identificador)
    {
      j = 1;
      break;
    }
    else
    {
      j = 0;
    }

  }

  if (j == 1)
  {
    PRODUTO[idp].quantidade += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void _N_(int n)
{
  int i = 0;
  for (i = 0; i < 200; i++)
    ENCOMENDA[n][i].identificador = n;

  printf("Nova encomenda %d.\n", n);
}

int _A_(int n)
{
  char info[5][100];
  int ide = 0;
  int idp = 0;
  int qtd = 0;
  int newpeso = 0;
  int i = 0;
  int j = 0;
  int l = 0;
  get_input(info);
  ide = atoi(info[0]);
  idp = atoi(info[1]);
  qtd = atoi(info[2]);
  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificador == ide)
    {
      j = 1;
      break;
    }
    else
    {
      j = 0;
    }

  }

  if (j == 0)
  {
    return printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    if (PRODUTO[i].identificador == idp)
    {
      l = 1;
      break;
    }
    else
    {
      l = 0;
    }

  }

  if ((l == 0) || (n == (-1)))
  {
    return printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
  }
  else
  {
    
  }

  if (PRODUTO[idp].quantidade < qtd)
  {
    return printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
  }
  else
  {
    
  }

  newpeso = calcula_peso_encomenda(ide) + (qtd * PRODUTO[idp].peso);
  if (calcula_produtos_encomenda(ide) == 0)
  {
    newpeso = qtd * PRODUTO[idp].peso;
  }
  else
  {
    
  }

  if (newpeso > 200)
  {
    return printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
  }
  else
  {
    
  }

  if (verifica_idp_na_encomenda(idp, ide) == 0)
  {
    for (i = 0; i < 200; i++)
    {
      if (ENCOMENDA[ide][i].identificadorpro == (-1))
      {
        PRODUTO[idp].quantidade = PRODUTO[idp].quantidade - qtd;
        ENCOMENDA[ide][i].identificadorpro = idp;
        ENCOMENDA[ide][i].identificador = ide;
        return ENCOMENDA[ide][i].quantidade = ENCOMENDA[ide][i].quantidade + qtd;
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  if (verifica_idp_na_encomenda(idp, ide) == 1)
  {
    for (i = 0; i < 200; i++)
    {
      if (ENCOMENDA[ide][i].identificadorpro == idp)
      {
        PRODUTO[idp].quantidade = PRODUTO[idp].quantidade - qtd;
        ENCOMENDA[ide][i].identificadorpro = idp;
        ENCOMENDA[ide][i].identificador = ide;
        ENCOMENDA[ide][i].quantidade = ENCOMENDA[ide][i].quantidade + qtd;
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  return 0;
}

int _r_(int k)
{
  char info[5][100];
  int i = 0;
  int l = 0;
  int idp = 0;
  int qtd = 0;
  get_input(info);
  idp = atoi(info[0]);
  qtd = atoi(info[1]);
  if (k == (-1))
  {
    return printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    if (PRODUTO[i].identificador == idp)
    {
      l = 1;
      break;
    }
    else
    {
      l = 0;
    }

  }

  if (l == 0)
  {
    return printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  if ((PRODUTO[idp].quantidade - qtd) < 0)
  {
    return printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
  }
  else
  {
    
  }

  PRODUTO[idp].quantidade = PRODUTO[idp].quantidade - qtd;
  return 0;
}

int _R_()
{
  char info[5][100];
  int ide = 0;
  int idp = 0;
  int i = 0;
  int j = 0;
  int l = 0;
  get_input(info);
  ide = atoi(info[0]);
  idp = atoi(info[1]);
  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificador == ide)
    {
      j = 1;
      break;
    }
    else
    {
      j = 0;
    }

  }

  if (j == 0)
  {
    return printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    if (PRODUTO[i].identificador == idp)
    {
      l = 1;
      break;
    }
    else
    {
      l = 0;
    }

  }

  if (l == 0)
  {
    return printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
  }
  else
  {
    
  }

  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificadorpro == idp)
    {
      PRODUTO[idp].quantidade = PRODUTO[idp].quantidade + ENCOMENDA[ide][i].quantidade;
      ENCOMENDA[ide][i].quantidade = 0;
      ENCOMENDA[ide][i].identificador = -1;
      ENCOMENDA[ide][i].identificadorpro = -1;
      break;
    }
    else
    {
      
    }

  }

  return 0;
}

int _C_()
{
  char info[5][100];
  int ide = 0;
  int custo = 0;
  int i = 0;
  int j = 0;
  get_input(info);
  ide = atoi(info[0]);
  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificador == ide)
    {
      j = 1;
      break;
    }
    else
    {
      j = 0;
    }

  }

  if (j == 0)
  {
    return printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    
  }

  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificadorpro != (-1))
    {
      custo += PRODUTO[ENCOMENDA[ide][i].identificadorpro].preco * ENCOMENDA[ide][i].quantidade;
    }
    else
    {
      
    }

  }

  printf("Custo da encomenda %d %d.\n", ide, custo);
  return 0;
}

int _p_(int k)
{
  char info[5][100];
  int idp = 0;
  int preco = 0;
  int i = 0;
  int l = 0;
  get_input(info);
  idp = atoi(info[0]);
  preco = atoi(info[1]);
  if (k == (-1))
  {
    return printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    if (PRODUTO[i].identificador == idp)
    {
      l = 1;
      PRODUTO[i].preco = preco;
      break;
    }
    else
    {
      l = 0;
    }

  }

  if (l == 0)
  {
    return printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  return 0;
}

int _E_(int k)
{
  char info[5][100];
  int i = 0;
  int j = 0;
  int l = 0;
  int ide = 0;
  int idp = 0;
  char desc[100];
  int qtd = 0;
  get_input(info);
  ide = atoi(info[0]);
  idp = atoi(info[1]);
  if (k == (-1))
  {
    return printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificador == ide)
    {
      j = 1;
      break;
    }
    else
    {
      j = 0;
    }

  }

  if (j == 0)
  {
    return printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    
  }

  for (i = 0; i < 10000; i++)
  {
    if (PRODUTO[i].identificador == idp)
    {
      l = 1;
      strcpy(desc, PRODUTO[idp].descricao);
      break;
    }
    else
    {
      l = 0;
    }

  }

  if (l == 0)
  {
    return printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificadorpro == idp)
    {
      qtd = ENCOMENDA[ide][i].quantidade;
      break;
    }
    else
    {
      
    }

  }

  return printf("%s %d.\n", desc, qtd);
  return 0;
}

int _m_(int n)
{
  char info[5][100];
  int i = 0;
  int j = 0;
  int l = 0;
  int k = 0;
  int count = 0;
  int max = 0;
  int ide = 0;
  int idp = 0;
  get_input(info);
  idp = atoi(info[0]);
  for (i = 0; i < 10000; i++)
  {
    if (PRODUTO[i].identificador == idp)
    {
      l = 1;
      break;
    }
    else
    {
      l = 0;
    }

  }

  if (l == 0)
  {
    return printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  for (i = 0; i <= n; i++)
  {
    for (j = 0; j < 200; j++)
    {
      if (ENCOMENDA[i][j].identificadorpro == idp)
      {
        count = ENCOMENDA[i][j].quantidade;
        k = 1;
      }
      else
      {
        
      }

    }

    if (count > max)
    {
      max = count;
      ide = i;
    }
    else
    {
      
    }

  }

  if (k == 0)
  {
    return 0;
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", idp, ide, max);
  return 0;
}

int _l_(int k)
{
  int i = 0;
  int le = 0;
  int ri = k;
  produto guarda[10000];
  for (i = 0; i < (k + 1); i++)
  {
    guarda[i].identificador = PRODUTO[i].identificador;
    guarda[i].preco = PRODUTO[i].preco;
    guarda[i].peso = PRODUTO[i].peso;
    guarda[i].quantidade = PRODUTO[i].quantidade;
    strcpy(guarda[i].descricao, PRODUTO[i].descricao);
  }

  quicksort_l(guarda, le, ri);
  printf("Produtos\n");
  for (i = 0; i < (k + 1); i++)
    printf("* %s %d %d\n", guarda[i].descricao, guarda[i].preco, guarda[i].quantidade);

  return 0;
}

void quicksort_l(produto a[], int l, int r)
{
  int i = 0;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition_l(a, l, r);
  quicksort_l(a, l, i - 1);
  quicksort_l(a, i + 1, r);
}

int partition_l(produto a[], int l, int r)
{
  int i = l - 1;
  int j = r;
  produto v = a[r];
  while (i < j)
  {
    while (less_l(a[++i], v))
      ;

    while (less_l(v, a[--j]))
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      exch_l(a, i, j);
    }
    else
    {
      
    }

  }

  exch_l(a, i, r);
  return i;
}

int less_l(produto a, produto v)
{
  if (a.preco < v.preco)
  {
    return 1;
  }
  else
  {
    
  }

  if (a.preco > v.preco)
  {
    return 0;
  }
  else
  {
    
  }

  if (a.preco == v.preco)
  {
    if (a.identificador < v.identificador)
    {
      return 1;
    }
    else
    {
      
    }

    if (a.identificador > v.identificador)
    {
      return 0;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  return 0;
}

void exch_l(produto a[], int i, int j)
{
  produto t;
  t = a[i];
  a[i] = a[j];
  a[j] = t;
}

int _L_(int n)
{
  char info[5][100];
  int ide = 0;
  int i = 0;
  int l = 0;
  int r = 0;
  encomenda guardaenc[500][200];
  get_input(info);
  ide = atoi(info[0]);
  if ((n == (-1)) || (ide > n))
  {
    return printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    
  }

  printf("Encomenda %d\n", ide);
  if (calcula_produtos_encomenda(ide) == 0)
  {
    return 0;
  }
  else
  {
    
  }

  if (calcula_produtos_encomenda(ide) == 1)
  {
    for (i = 0; i < 200; i++)
    {
      if (ENCOMENDA[ide][i].identificadorpro != (-1))
      {
        return printf("* %s %d %d\n", PRODUTO[ENCOMENDA[ide][i].identificadorpro].descricao, PRODUTO[ENCOMENDA[ide][i].identificadorpro].preco, ENCOMENDA[ide][i].quantidade);
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificadorpro != (-1))
    {
      guardaenc[ide][i].identificadorpro = ENCOMENDA[ide][i].identificadorpro;
      guardaenc[ide][i].identificador = ENCOMENDA[ide][i].identificador;
      guardaenc[ide][i].quantidade = ENCOMENDA[ide][i].quantidade;
      r++;
    }
    else
    {
      
    }

  }

  quicksort_L(guardaenc[ide], l, r);
  for (i = r; i > (-1); i--)
  {
    if (verifica_idp_na_encomenda(guardaenc[ide][i].identificadorpro, ide) == 1)
    {
      printf("* %s %d %d\n", PRODUTO[guardaenc[ide][i].identificadorpro].descricao, PRODUTO[guardaenc[ide][i].identificadorpro].preco, guardaenc[ide][i].quantidade);
    }
    else
    {
      
    }

  }

  return 0;
}

void quicksort_L(encomenda a[], int l, int r)
{
  int i = 0;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition_L(a, l, r);
  quicksort_L(a, l, i - 1);
  quicksort_L(a, i + 1, r);
}

int partition_L(encomenda a[], int l, int r)
{
  int i = l - 1;
  int j = r;
  encomenda v = a[r];
  while (i < j)
  {
    while (less_L(a[++i], v))
      ;

    while (less_L(v, a[--j]))
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      exch_L(a, i, j);
    }
    else
    {
      
    }

  }

  exch_L(a, i, r);
  return i;
}

int less_L(encomenda a, encomenda v)
{
  char desc1[100];
  char desc2[100];
  int compr = 0;
  int i = 0;
  for (i = 0; i < 10000; i++)
  {
    if (PRODUTO[i].identificador == a.identificadorpro)
    {
      strcpy(desc1, PRODUTO[i].descricao);
    }
    else
    {
      
    }

    if (PRODUTO[i].identificador == v.identificadorpro)
    {
      strcpy(desc2, PRODUTO[i].descricao);
    }
    else
    {
      
    }

  }

  compr = strlen(desc1);
  for (i = 0; i < compr; i++)
  {
    if (desc1[i] < desc2[i])
    {
      return 0;
      break;
    }
    else
    {
      return 1;
      break;
    }

  }

  return 0;
}

void exch_L(encomenda a[], int i, int j)
{
  encomenda t;
  t = a[i];
  a[i] = a[j];
  a[j] = t;
}

int calcula_peso_encomenda(int ide)
{
  int i = 0;
  int pesototal = 0;
  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificadorpro != (-1))
    {
      pesototal += PRODUTO[ENCOMENDA[ide][i].identificadorpro].peso * ENCOMENDA[ide][i].quantidade;
    }
    else
    {
      
    }

  }

  return pesototal;
  return 0;
}

int calcula_produtos_encomenda(int ide)
{
  int i = 0;
  int cont = 0;
  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificadorpro != (-1))
    {
      cont++;
    }
    else
    {
      
    }

  }

  return cont;
  return 0;
}

int verifica_idp_na_encomenda(int idp, int ide)
{
  int i = 0;
  int yes = 0;
  for (i = 0; i < 200; i++)
  {
    if (ENCOMENDA[ide][i].identificadorpro == idp)
    {
      yes = 1;
      break;
    }
    else
    {
      yes = 0;
    }

  }

  return yes;
  return 0;
}

