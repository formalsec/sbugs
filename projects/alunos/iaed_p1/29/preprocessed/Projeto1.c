#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct product
{
  int id;
  char description[100];
  int price;
  int weight;
  int qtty;
} Product;
typedef struct order
{
  int id;
  int weight;
  int numOrders;
  Product ordered[100];
} Order;
Product products[10000];
Order orders[500];
int numP = 0;
int numO = 0;
void comando_a(char *input);
void comando_q(char *input);
void comando_r(char *input);
void comando_p(char *input);
void comando_l();
void comando_N();
void comando_A(char *input);
void comando_R(char *input);
void comando_C(char *input);
void comando_E(char *input);
void addOrder(int qtty, int orderID, int productID);
void removeOrder(int orderID, int productID);
void calculatePrice(int orderID);
void sortAlphabetic(Product *sortedArray, int max);
void mergesort(Product *sortedArray, int start, int end);
void merge(Product *array, int l, int m, int r);
void comando_a(char *input)
{
  Product newP;
  newP.id = numP;
  strcpy(newP.description, strtok(input, ":"));
  newP.price = atoi(strtok(0, ":"));
  newP.weight = atoi(strtok(0, ":"));
  newP.qtty = atoi(strtok(0, ":"));
  products[numP] = newP;
  printf("Novo produto %d.\n", numP);
}

void comando_q(char *input)
{
  int id;
  int stock;
  id = atoi(strtok(input, ":"));
  stock = atoi(strtok(0, ""));
  if ((id < 0) || (id >= numP))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  }
  else
  {
    products[id].qtty += stock;
  }

}

void comando_r(char *input)
{
  int id;
  int stock;
  id = atoi(strtok(input, ":"));
  stock = atoi(strtok(0, ""));
  if ((id < 0) || (id >= numP))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    if (stock > products[id].qtty)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", stock, id);
    }
    else
    {
      products[id].qtty -= stock;
    }

  }

}

void comando_p(char *input)
{
  int id;
  int newPrice;
  id = atoi(strtok(input, ":"));
  newPrice = atoi(strtok(0, ""));
  if ((id < 0) || (id >= numP))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    products[id].price = newPrice;
  }

}

void comando_l()
{
  int i;
  Product sortedArray[10000];
  for (i = 0; i < numP; i++)
  {
    sortedArray[i] = products[i];
  }

  mergesort(sortedArray, 0, numP - 1);
  printf("Produtos\n");
  for (i = 0; i < numP; i++)
  {
    printf("* %s %d %d\n", sortedArray[i].description, sortedArray[i].price, sortedArray[i].qtty);
  }

}

void comando_N()
{
  Order newOrder;
  newOrder.id = numO;
  newOrder.weight = 0;
  newOrder.numOrders = 0;
  orders[numO] = newOrder;
  printf("Nova encomenda %d.\n", newOrder.id);
}

void comando_A(char *input)
{
  int productID;
  int orderID;
  int qtty;
  orderID = atoi(strtok(input, ":"));
  productID = atoi(strtok(0, ":"));
  qtty = atoi(strtok(0, ""));
  if ((orderID < 0) || (orderID >= numO))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", productID, orderID);
    return;
  }
  else
  {
    if ((productID < 0) || (productID >= numP))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", productID, orderID);
      return;
    }
    else
    {
      if (products[productID].qtty < qtty)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", productID, orderID);
        return;
      }
      else
      {
        if ((orders[orderID].weight + (qtty * products[productID].weight)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", productID, orderID);
          return;
        }
        else
        {
          addOrder(qtty, orderID, productID);
          return;
        }

      }

    }

  }

}

void comando_R(char *input)
{
  int productID;
  int orderID;
  orderID = atoi(strtok(input, ":"));
  productID = atoi(strtok(0, ":"));
  if ((orderID < 0) || (orderID >= numO))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", productID, orderID);
    return;
  }
  else
  {
    if ((productID < 0) || (productID >= numP))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", productID, orderID);
      return;
    }
    else
    {
      removeOrder(orderID, productID);
    }

  }

}

void comando_C(char *input)
{
  int orderID;
  orderID = atoi(input);
  if ((orderID < 0) || (orderID >= numO))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", orderID);
    return;
  }
  else
  {
    calculatePrice(orderID);
  }

}

void comando_E(char *input)
{
  int productID;
  int orderID;
  int i;
  orderID = atoi(strtok(input, ":"));
  productID = atoi(strtok(0, ":"));
  if ((orderID < 0) || (orderID >= numO))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", orderID);
    return;
  }
  else
  {
    if ((productID < 0) || (productID >= numP))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", productID);
      return;
    }
    else
    {
      for (i = 0; i < orders[orderID].numOrders; i++)
      {
        if (orders[orderID].ordered[i].id == productID)
        {
          printf("%s %d.\n", products[productID].description, orders[orderID].ordered[i].qtty);
          return;
        }
        else
        {
          
        }

      }

      printf("%s %d.\n", products[productID].description, 0);
    }

  }

}

void comando_m(char *input)
{
  int productID;
  int i;
  int j;
  int orderID;
  int max;
  productID = atoi(input);
  if ((productID < 0) || (productID >= numP))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", productID);
    return;
  }
  else
  {
    
  }

  if (numO == 0)
  {
    return;
  }
  else
  {
    
  }

  max = 0;
  orderID = 0;
  for (i = 0; i < numO; i++)
  {
    for (j = 0; j < orders[i].numOrders; j++)
    {
      if ((orders[i].ordered[j].id == productID) && (orders[i].ordered[j].qtty > max))
      {
        max = orders[i].ordered[j].qtty;
        orderID = i;
      }
      else
      {
        
      }

    }

  }

  if (max == 0)
  {
    return;
  }
  else
  {
    printf("Maximo produto %d %d %d.\n", productID, orderID, max);
  }

}

void comando_L(char *input)
{
  int orderID;
  int i;
  int j;
  int productID;
  Product sortedArray[10000];
  orderID = atoi(input);
  if ((orderID < 0) || (orderID >= numO))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", orderID);
    return;
  }
  else
  {
    
  }

  j = 0;
  for (i = 0; i < orders[orderID].numOrders; i++)
  {
    if (orders[orderID].ordered[i].qtty != 0)
    {
      sortedArray[j] = orders[orderID].ordered[i];
      j++;
    }
    else
    {
      
    }

  }

  sortAlphabetic(sortedArray, j);
  printf("Encomenda %d\n", orderID);
  for (i = 0; i < j; i++)
  {
    productID = sortedArray[i].id;
    printf("* %s %d %d\n", products[productID].description, products[productID].price, sortedArray[i].qtty);
  }

}

void sortAlphabetic(Product *sortedArray, int max)
{
  int i;
  int j;
  Product swap;
  for (i = 0; i < max; i++)
  {
    for (j = 0; j < max; j++)
    {
      if (strcmp(sortedArray[j].description, sortedArray[i].description) > 0)
      {
        swap = sortedArray[i];
        sortedArray[i] = sortedArray[j];
        sortedArray[j] = swap;
      }
      else
      {
        
      }

    }

  }

}

void calculatePrice(int orderID)
{
  int i;
  int sum;
  int price;
  int qtty;
  sum = 0;
  price = 0;
  qtty = 0;
  for (i = 0; i < orders[orderID].numOrders; i++)
  {
    price = products[orders[orderID].ordered[i].id].price;
    qtty = orders[orderID].ordered[i].qtty;
    sum += qtty * price;
  }

  printf("Custo da encomenda %d %d.\n", orderID, sum);
}

void addOrder(int qtty, int orderID, int productID)
{
  int i;
  int peso;
  Product newProduct;
  for (i = 0; i < orders[orderID].numOrders; i++)
  {
    if (orders[orderID].ordered[i].id == products[productID].id)
    {
      peso = products[productID].weight;
      orders[orderID].ordered[i].qtty += qtty;
      orders[orderID].weight += qtty * peso;
      products[productID].qtty -= qtty;
      return;
    }
    else
    {
      
    }

  }

  i = orders[orderID].numOrders;
  orders[orderID].numOrders++;
  newProduct.id = products[productID].id;
  newProduct.qtty = qtty;
  strcpy(newProduct.description, products[productID].description);
  orders[orderID].ordered[i] = newProduct;
  orders[orderID].weight += qtty * products[productID].weight;
  products[productID].qtty -= qtty;
  return;
}

void removeOrder(int orderID, int productID)
{
  int i;
  for (i = 0; i < orders[orderID].numOrders; i++)
  {
    if (orders[orderID].ordered[i].id == productID)
    {
      products[productID].qtty += orders[orderID].ordered[i].qtty;
      orders[orderID].weight -= orders[orderID].ordered[i].qtty * products[productID].weight;
      orders[orderID].ordered[i].qtty = 0;
      return;
    }
    else
    {
      
    }

  }

}

void merge(Product *array, int l, int m, int r)
{
  int i;
  int j;
  int k;
  Product aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = array[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = array[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if (aux[j].price < aux[i].price)
    {
      array[k] = aux[j--];
    }
    else
    {
      if ((aux[j].id < aux[i].id) && (aux[j].price == aux[i].price))
      {
        array[k] = aux[j--];
      }
      else
      {
        array[k] = aux[i++];
      }

    }

  }

}

void mergesort(Product *sortedArray, int start, int end)
{
  int m;
  if (start < end)
  {
    m = (start + end) / 2;
    mergesort(sortedArray, start, m);
    mergesort(sortedArray, m + 1, end);
    merge(sortedArray, start, m, end);
  }
  else
  {
    
  }

}

int main()
{
  char control;
  char input[100];
  int end;
  end = 0;
  while (end == 0)
  {
    control = new_sym_var(sizeof(char) * 8);
    switch (control)
    {
      case 'a':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_a(input);
        numP++;
        break;

      case 'q':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_q(input);
        break;

      case 'r':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_r(input);
        break;

      case 'p':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_p(input);
        break;

      case 'l':
        comando_l();
        break;

      case 'N':
        comando_N();
        numO++;
        break;

      case 'A':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_A(input);
        break;

      case 'R':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_R(input);
        break;

      case 'C':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_C(input);
        break;

      case 'E':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_E(input);
        break;

      case 'm':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_m(input);
        break;

      case 'L':
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_L(input);
        break;

      case 'x':
        end = 1;
        break;

    }

  }

  return 0;
}

