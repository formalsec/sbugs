#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct 
{
  char used;
  char description[64];
  int price;
  int weight;
  int amount;
} product_struct;
typedef struct 
{
  char used;
  int product_id[10000];
  int amount[10000];
} orders_struct;
int input1(char v[]);
int input2();
void inicialize(orders_struct v[], product_struct v1[]);
void mergesort(int v[][2], int l, int r);
void mergesort_string(char v[][64], int id[], int l, int r);
product_struct products[10000];
orders_struct orders[500];
int main()
{
  char c[100];
  inicialize(orders, products);
  do
  {
    fgets(c, 100, stdin);
    switch (c[0])
    {
      case 'a':
      {
        char d[64];
        char *s;
        int new_id;
        int len;
        int l;
        for (new_id = 0; products[new_id].used != (-1); new_id++)
          continue;

        strtok(c, " ");
        s = strtok(strtok(0, " "), ":");
        if (s == 0)
        {
          break;
        }
        else
        {
          
        }

        products[new_id].price = input2();
        products[new_id].weight = input2();
        products[new_id].amount = input2();
        products[new_id].used = 1;
        len = strlen(s) + 1;
        for (l = 0; (l != len) && (l < 64); l++)
          d[l] = s[l];

        strcpy(products[new_id].description, d);
        printf("Novo produto %d.\n", new_id);
        break;
      }

      case 'q':
      {
        int id = input1(c);
        int a = input2();
        if (products[id].used == (-1))
        {
          printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
        }
        else
        {
          products[id].amount += a;
        }

        break;
      }

      case 'N':
      {
        int new_order;
        for (new_order = 0; orders[new_order].used != (-1); new_order++)
          continue;

        orders[new_order].used = 1;
        printf("Nova encomenda %d.\n", new_order);
        break;
      }

      case 'A':
      {
        int i;
        int w = 0;
        int encom = input1(c);
        int prod = input2();
        int q = input2();
        for (i = 0; orders[encom].product_id[i] != (-1); i++)
          w += products[orders[encom].product_id[i]].weight * orders[encom].amount[i];

        if (orders[encom].used == (-1))
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", prod, encom);
          break;
        }
        else
        {
          if (products[prod].used == (-1))
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", prod, encom);
            break;
          }
          else
          {
            if (q > products[prod].amount)
            {
              printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", prod, encom);
              break;
            }
            else
            {
              if ((w + (products[prod].weight * q)) > 200)
              {
                printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de %d.\n", prod, encom, 200);
                break;
              }
              else
              {
                
              }

            }

          }

        }

        for (i = 0; (orders[encom].product_id[i] != (-1)) || (i == 0); i++)
        {
          if (orders[encom].product_id[i] == (-1))
          {
            orders[encom].product_id[i] = prod;
            orders[encom].amount[i] = q;
            products[prod].amount -= q;
            break;
          }
          else
          {
            if (orders[encom].product_id[i] == prod)
            {
              orders[encom].amount[i] += q;
              products[prod].amount -= q;
              break;
            }
            else
            {
              if (orders[encom].product_id[i + 1] == (-1))
              {
                orders[encom].product_id[i + 1] = prod;
                orders[encom].amount[i + 1] = q;
                products[prod].amount -= q;
                break;
              }
              else
              {
                
              }

            }

          }

        }

        break;
      }

      case 'r':
      {
        int prod = input1(c);
        int a = input2();
        if (products[prod].used == 1)
        {
          if (products[prod].amount >= a)
          {
            products[prod].amount -= a;
          }
          else
          {
            printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", a, prod);
          }

        }
        else
        {
          printf("Impossivel remover stock do produto %d. Produto inexistente.\n", prod);
        }

        break;
      }

      case 'R':
      {
        int i;
        int last;
        int l;
        int encom = input1(c);
        int prod = input2();
        if (orders[encom].used == 1)
        {
          if (products[prod].used == 1)
          {
            for (i = 0; i != 10000; i++)
              if (orders[encom].product_id[i] == prod)
            {
              for (l = i; orders[encom].product_id[l] != (-1); l++)
                last = l;

              products[prod].amount += orders[encom].amount[i];
              orders[encom].product_id[i] = orders[encom].product_id[last];
              orders[encom].amount[i] = orders[encom].amount[last];
              orders[encom].product_id[last] = -1;
              orders[encom].amount[last] = 0;
              break;
            }
            else
            {
              
            }


          }
          else
          {
            printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", prod, encom);
          }

        }
        else
        {
          printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", prod, encom);
        }

        break;
      }

      case 'C':
      {
        int i;
        int encom = input1(c);
        int pr = 0;
        if (orders[encom].used == (-1))
        {
          printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", encom);
          break;
        }
        else
        {
          
        }

        for (i = 0; orders[encom].product_id[i] != (-1); i++)
          pr += orders[encom].amount[i] * products[orders[encom].product_id[i]].price;

        printf("Custo da encomenda %d %d.\n", encom, pr);
        break;
      }

      case 'p':
      {
        int prod = input1(c);
        int pr = input2();
        if (products[prod].used == (-1))
        {
          printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", prod);
          break;
        }
        else
        {
          products[prod].price = pr;
        }

        break;
      }

      case 'E':
      {
        int i;
        int encom = input1(c);
        int prod = input2();
        if (products[prod].used == (-1))
        {
          printf("Impossivel listar produto %d. Produto inexistente.\n", prod);
          break;
        }
        else
        {
          
        }

        if (orders[encom].used == (-1))
        {
          printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", encom);
          break;
        }
        else
        {
          
        }

        for (i = 0; i != 10000; i++)
        {
          if (orders[encom].product_id[i] == (-1))
          {
            printf("%s 0.\n", products[prod].description);
            break;
          }
          else
          {
            if (orders[encom].product_id[i] == prod)
            {
              printf("%s %d.\n", products[prod].description, orders[encom].amount[i]);
              break;
            }
            else
            {
              
            }

          }

        }

        break;
      }

      case 'm':
      {
        int o;
        int i;
        int prod = input1(c);
        int larger_amount = -1;
        int q = 0;
        if (products[prod].used == (-1))
        {
          printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", prod);
          break;
        }
        else
        {
          
        }

        for (o = 0; o != 500; o++)
          for (i = 0; i != 10000; i++)
        {
          if (orders[o].product_id[i] == prod)
          {
            if (orders[o].amount[i] > q)
            {
              larger_amount = o;
              q = orders[o].amount[i];
            }
            else
            {
              
            }

            break;
          }
          else
          {
            if (orders[o].product_id[i] == (-1))
            {
              break;
            }
            else
            {
              
            }

          }

        }


        if (larger_amount != (-1))
        {
          printf("Maximo produto %d %d %d.\n", prod, larger_amount, q);
        }
        else
        {
          
        }

        break;
      }

      case 'l':
      {
        int i;
        int sorted[10000][2];
        for (i = 0; products[i].used != (-1); i++)
        {
          if (products[i].used == 1)
          {
            sorted[i][0] = products[i].price;
            sorted[i][1] = i;
          }
          else
          {
            break;
          }

        }

        mergesort(sorted, 0, i - 1);
        printf("Produtos\n");
        for (i = 0; products[i].used != (-1); i++)
          printf("* %s %d %d\n", products[sorted[i][1]].description, sorted[i][0], products[sorted[i][1]].amount);

        break;
      }

      case 'L':
      {
        int i;
        int j;
        int sorted_id[10000];
        int encom = input1(c);
        char sorted_description[10000][64];
        if (orders[encom].used == (-1))
        {
          printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", encom);
          break;
        }
        else
        {
          
        }

        for (i = 0; orders[encom].product_id[i] != (-1); i++)
        {
          if (orders[encom].product_id[i] != (-1))
          {
            strcpy(sorted_description[i], products[orders[encom].product_id[i]].description);
            sorted_id[i] = orders[encom].product_id[i];
          }
          else
          {
            break;
          }

        }

        mergesort_string(sorted_description, sorted_id, 0, i - 1);
        printf("Encomenda %d\n", encom);
        for (i = 0; orders[encom].product_id[i] != (-1); i++)
        {
          for (j = 0; j != 10000; j++)
            if (orders[encom].product_id[j] == sorted_id[i])
          {
            printf("* %s %d %d\n", sorted_description[i], products[sorted_id[i]].price, orders[encom].amount[j]);
            break;
          }
          else
          {
            
          }


        }

        break;
      }

    }

  }
  while (c[0] != 'x');
  return 0;
}

void inicialize(orders_struct v[], product_struct v1[])
{
  int j;
  int i;
  for (j = 0; j < 500; j++)
  {
    v[j].used = -1;
    for (i = 0; i < 10000; i++)
      v[j].product_id[i] = -1;

  }

  for (j = 0; j < 10000; j++)
    v1[j].used = -1;

}

int input1(char v[])
{
  char *s;
  strtok(v, " ");
  s = strtok(strtok(0, " "), ":");
  return atoi(s);
}

int input2()
{
  char *s;
  s = strtok(0, ":");
  return atoi(s);
}

void merge(int v[][2], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int aux[10000][2];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1][0] = v[i - 1][0];
    aux[i - 1][1] = v[i - 1][1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j][0] = v[j + 1][0];
    aux[(r + m) - j][1] = v[j + 1][1];
  }

  for (k = l; k <= r; k++)
  {
    if (aux[j][0] < aux[i][0])
    {
      v[k][0] = aux[j][0];
      v[k][1] = aux[j--][1];
    }
    else
    {
      if (aux[j][0] > aux[i][0])
      {
        v[k][0] = aux[i][0];
        v[k][1] = aux[i++][1];
      }
      else
      {
        if (aux[j][0] == aux[i][0])
        {
          if (aux[j][1] > aux[i][1])
          {
            v[k][0] = aux[i][0];
            v[k][1] = aux[i++][1];
          }
          else
          {
            v[k][0] = aux[j][0];
            v[k][1] = aux[j--][1];
          }

        }
        else
        {
          
        }

      }

    }

  }

}

void mergesort(int v[][2], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort(v, l, m);
  mergesort(v, m + 1, r);
  merge(v, l, m, r);
}

void merge_string(char v[][64], int id[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int aux1[10000];
  char aux[10000][64];
  for (i = m + 1; i > l; i--)
  {
    strcpy(aux[i - 1], v[i - 1]);
    aux1[i - 1] = id[i - 1];
  }

  for (j = m; j < r; j++)
  {
    strcpy(aux[(r + m) - j], v[j + 1]);
    aux1[(r + m) - j] = id[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if (strcmp(aux[j], aux[i]) < 0)
    {
      strcpy(v[k], aux[j]);
      id[k] = aux1[j--];
    }
    else
    {
      strcpy(v[k], aux[i]);
      id[k] = aux1[i++];
    }

  }

}

void mergesort_string(char v[][64], int id[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_string(v, id, l, m);
  mergesort_string(v, id, m + 1, r);
  merge_string(v, id, l, m, r);
}

