#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct produto
{
  char descricao[64];
  int preco;
  int peso;
  int stock;
  int idp;
} produto;
typedef struct encomenda
{
  int ide;
  int peso;
  produto info_produtos[10000];
} encomenda;
produto catalogo_produtos[10000];
encomenda catalogo_encomendas[500];
int proximo_produto = 0;
int run = 1;
int proxima_encomenda = 0;
char input[1024];
void adiciona_produto()
{
  char auxiliar[4][64];
  int i = 0;
  int j;
  char *corta;
  corta = strtok(input, " ");
  while (corta != 0)
  {
    corta = strtok(0, ":");
    if (corta == 0)
    {
      break;
    }
    else
    {
      
    }

    strcpy(auxiliar[i], corta);
    i++;
  }

  for (j = 0; j < 10000; j++)
  {
    if (catalogo_produtos[j].idp == (-1))
    {
      strcpy(catalogo_produtos[j].descricao, auxiliar[0]);
      catalogo_produtos[j].preco = atoi(auxiliar[1]);
      catalogo_produtos[j].peso = atoi(auxiliar[2]);
      catalogo_produtos[j].stock = atoi(auxiliar[3]);
      catalogo_produtos[j].idp = j;
      break;
    }
    else
    {
      
    }

  }

  printf("Novo produto %d.\n", proximo_produto);
}

void adiciona_stock()
{
  char auxiliar[2][64];
  int id;
  int stock;
  int i = 0;
  char *corta;
  corta = strtok(input, " ");
  while (corta != 0)
  {
    corta = strtok(0, ":");
    if (corta == 0)
    {
      break;
    }
    else
    {
      
    }

    strcpy(auxiliar[i], corta);
    i++;
  }

  id = atoi(auxiliar[0]);
  stock = atoi(auxiliar[1]);
  if (proximo_produto > id)
  {
    catalogo_produtos[id].stock += stock;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  }

}

void cria_encomenda()
{
  int i;
  for (i = 0; i < 500; i++)
  {
    if (catalogo_encomendas[i].ide == (-1))
    {
      catalogo_encomendas[i].ide = i;
      break;
    }
    else
    {
      
    }

  }

  printf("Nova encomenda %d.\n", catalogo_encomendas[i].ide);
}

void adiciona_produto_encomenda()
{
  char auxiliar[3][64];
  int id_encomenda;
  int id_produto;
  int quantidade;
  int i = 0;
  int j;
  char *corta;
  corta = strtok(input, " ");
  while (corta != 0)
  {
    corta = strtok(0, ":");
    if (corta == 0)
    {
      break;
    }
    else
    {
      
    }

    strcpy(auxiliar[i], corta);
    i++;
  }

  id_encomenda = atoi(auxiliar[0]);
  id_produto = atoi(auxiliar[1]);
  quantidade = atoi(auxiliar[2]);
  if (id_encomenda >= proxima_encomenda)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id_produto, id_encomenda);
  }
  else
  {
    if (id_produto >= proximo_produto)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id_produto, id_encomenda);
    }
    else
    {
      if ((catalogo_produtos[id_produto].stock - quantidade) < 0)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_produto, id_encomenda);
      }
      else
      {
        if ((catalogo_encomendas[id_encomenda].peso + (quantidade * catalogo_produtos[id_produto].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_produto, id_encomenda);
        }
        else
        {
          for (j = 0; j < 200; j++)
          {
            if (catalogo_encomendas[id_encomenda].info_produtos[j].idp == (-1))
            {
              catalogo_encomendas[id_encomenda].info_produtos[j].stock = quantidade;
              catalogo_produtos[id_produto].stock -= quantidade;
              catalogo_encomendas[id_encomenda].peso += quantidade * catalogo_produtos[id_produto].peso;
              catalogo_encomendas[id_encomenda].info_produtos[j].idp = id_produto;
              break;
            }
            else
            {
              if (catalogo_encomendas[id_encomenda].info_produtos[j].idp == id_produto)
              {
                catalogo_encomendas[id_encomenda].info_produtos[j].stock += quantidade;
                catalogo_produtos[id_produto].stock -= quantidade;
                catalogo_encomendas[id_encomenda].peso += quantidade * catalogo_produtos[id_produto].peso;
                break;
              }
              else
              {
                
              }

            }

          }

        }

      }

    }

  }

}

void remove_stock()
{
  char auxiliar[2][64];
  int id;
  int stock;
  int i = 0;
  char *corta;
  corta = strtok(input, " ");
  while (corta != 0)
  {
    corta = strtok(0, ":");
    if (corta == 0)
    {
      break;
    }
    else
    {
      
    }

    strcpy(auxiliar[i], corta);
    i++;
  }

  id = atoi(auxiliar[0]);
  stock = atoi(auxiliar[1]);
  if (proximo_produto > id)
  {
    if (catalogo_produtos[id].stock >= stock)
    {
      catalogo_produtos[id].stock -= stock;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", stock, id);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id);
  }

}

void remove_produto_encomenda()
{
  char auxiliar[2][64];
  int i = 0;
  int id_encomenda;
  int id_produto;
  int j;
  int contador = 0;
  char *corta;
  corta = strtok(input, " ");
  while (corta != 0)
  {
    corta = strtok(0, ":");
    if (corta == 0)
    {
      break;
    }
    else
    {
      
    }

    strcpy(auxiliar[i], corta);
    i++;
  }

  id_encomenda = atoi(auxiliar[0]);
  id_produto = atoi(auxiliar[1]);
  if (catalogo_encomendas[id_encomenda].ide == (-1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id_produto, id_encomenda);
  }
  else
  {
    if (catalogo_produtos[id_produto].idp == (-1))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_produto, id_encomenda);
    }
    else
    {
      for (j = 0; j < 200; j++)
      {
        if (catalogo_encomendas[id_encomenda].info_produtos[j].idp == id_produto)
        {
          catalogo_encomendas[id_encomenda].peso -= catalogo_encomendas[id_encomenda].info_produtos[j].stock * catalogo_produtos[id_produto].peso;
          catalogo_produtos[id_produto].stock += catalogo_encomendas[id_encomenda].info_produtos[j].stock;
          catalogo_encomendas[id_encomenda].info_produtos[j].stock = 0;
        }
        else
        {
          if (contador == 200)
          {
            printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_produto, id_encomenda);
          }
          else
          {
            contador++;
          }

        }

      }

    }

  }

}

void custo_encomenda()
{
  char auxiliar[1][64];
  int i = 0;
  int j;
  int custo = 0;
  char *corta;
  getchar();
  while (corta != 0)
  {
    corta = strtok(0, " ");
    if (corta == 0)
    {
      break;
    }
    else
    {
      
    }

    strcpy(auxiliar[i], corta);
    i++;
  }

  if (catalogo_encomendas[atoi(auxiliar[0])].ide == (-1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", atoi(auxiliar[0]));
  }
  else
  {
    for (j = 0; j < 200; j++)
      custo += catalogo_encomendas[atoi(auxiliar[0])].info_produtos[j].stock * catalogo_produtos[j].preco;

    printf("Custo da encomenda %d %d.", atoi(auxiliar[0]), custo);
  }

}

void altera_preco()
{
  char auxiliar[2][64];
  int id;
  int novo_preco;
  int i = 0;
  char *corta;
  while (corta != 0)
  {
    corta = strtok(0, ":");
    if (corta == 0)
    {
      break;
    }
    else
    {
      
    }

    strcpy(auxiliar[i], corta);
    i++;
  }

  id = atoi(auxiliar[0]);
  novo_preco = atoi(auxiliar[1]);
  if (proximo_produto > id)
  {
    catalogo_produtos[id].preco = novo_preco;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id);
  }

}

void descricao_produto_encomenda()
{
}

void id_encomenda()
{
}

void lista_crescente()
{
}

void lista_alfabetica()
{
}

int main()
{
  int i;
  int j;
  for (i = 0; i < 500; i++)
  {
    for (j = 0; j < 200; j++)
    {
      catalogo_encomendas[i].info_produtos[j].idp = -1;
      catalogo_encomendas[i].ide = -1;
    }

  }

  for (i = 0; i < 10000; i++)
  {
    catalogo_produtos[i].idp = -1;
  }

  while (run)
  {
    fgets(input, 1024, stdin);
    switch (input[0])
    {
      case 'a':
        adiciona_produto();
        proximo_produto++;
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        cria_encomenda();
        proxima_encomenda++;
        break;

      case 'A':
        adiciona_produto_encomenda();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_produto_encomenda();
        break;

      case 'C':
        custo_encomenda();
        break;

      case 'p':
        altera_preco();
        break;

      case 'E':
        descricao_produto_encomenda();
        break;

      case 'm':
        id_encomenda();
        break;

      case 'l':
        lista_crescente();
        break;

      case 'L':
        lista_alfabetica();
        break;

      case 'x':
        run = 0;
        break;

    }

  }

  return 0;
}

