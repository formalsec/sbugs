/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


struct Product
{
  int productIdentifier;
  char productDescription[64];
  int productPrice;
  int productWeight;
  int productStock;
} product;
struct Order
{
  struct Product prodt[100];
  int orderWeight;
} order;
char *Separate(char received[100], char new[10][64])
{
  char *thing;
  int i = 0;
  thing = strtok(received, ":");
  while (thing != 0)
  {
    strcpy(new[i], thing);
    thing = strtok(0, ":");
    i++;
  }

  return (char *) new;
}

int WeightOrder(struct Order warehouse[500], char received[100])
{
  int i;
  int Weight;
  int totalWeight = 0;
  int orID;
  char new[10][64];
  Separate(received, new);
  orID = atoi(new[0]);
  for (i = 0; i < 100; i++)
  {
    Weight = warehouse[orID].prodt[i].productWeight * warehouse[orID].prodt[i].productStock;
    totalWeight += Weight;
  }

  return totalWeight;
}

int Switch(struct Product p1, struct Product p2)
{
  struct Product t = p1;
  p1 = p2;
  p2 = t;
  return 0;
}

int Smaller(struct Product p1, struct Product p2)
{
  if (p1.productPrice == p2.productPrice)
  {
    return p1.productIdentifier < p2.productIdentifier;
  }
  else
  {
    return p1.productPrice < p2.productPrice;
  }

  return 0;
}

int PriceSort(struct Product new[10000], int l, int r)
{
  struct Product x = new[r];
  int i = l - 1;
  int j = r;
  while (i < j)
  {
    while (Smaller(new[++i], x))
      ;

    while (Smaller(x, new[--j]))
    {
      if (l == j)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      Switch(new[i], new[r]);
    }
    else
    {
      
    }

  }

  Switch(new[i], new[r]);
  return i;
}

void Sort(struct Product new[10000], int l, int r)
{
  int i = 0;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = PriceSort(new, l, r);
  PriceSort(new, l, i - 1);
  PriceSort(new, i + 1, r);
}

int AddProduct(struct Product shelf[10000], int pidentifier, char received[100])
{
  char new[10][64];
  Separate(received, new);
  shelf[pidentifier].productIdentifier = pidentifier;
  strcpy(shelf[pidentifier].productDescription, new[0]);
  shelf[pidentifier].productPrice = atoi(new[1]);
  shelf[pidentifier].productWeight = atoi(new[2]);
  shelf[pidentifier].productStock = atoi(new[3]);
  printf("Novo produto %d.\n", pidentifier);
  return ++pidentifier;
}

void AddStock(struct Product shelf[10000], int pidentifier, char received[100])
{
  char new[10][64];
  int pID;
  int sAUX;
  Separate(received, new);
  pID = atoi(new[0]);
  sAUX = atoi(new[1]);
  if (pID >= pidentifier)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", pID);
  }
  else
  {
    
  }

  shelf[pID].productStock += sAUX;
}

int NewOrder(int oridentifier)
{
  printf("Nova encomenda %d.\n", oridentifier);
  return ++oridentifier;
}

void OrderAddProd(struct Product shelf[10000], struct Order warehouse[500], char received[100], int pidentifier, int oridentifier)
{
  int totalWeight;
  int orID;
  int pID;
  int sAUX;
  char new[10][64];
  Separate(received, new);
  orID = atoi(new[0]);
  pID = atoi(new[1]);
  sAUX = atoi(new[2]);
  if (orID >= oridentifier)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", pID, orID);
    return;
  }
  else
  {
    
  }

  if (pID >= pidentifier)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", pID, orID);
    return;
  }
  else
  {
    
  }

  if (sAUX > shelf[pID].productStock)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", pID, orID);
    return;
  }
  else
  {
    
  }

  warehouse[orID].orderWeight = WeightOrder(warehouse, received);
  totalWeight = warehouse[orID].orderWeight + (shelf[pID].productWeight * sAUX);
  if (totalWeight > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", pID, orID);
    return;
  }
  else
  {
    
  }

  if (warehouse[orID].prodt[pID].productStock != 0)
  {
    warehouse[orID].prodt[pID].productStock += sAUX;
    warehouse[orID].orderWeight = totalWeight;
    shelf[pID].productStock -= sAUX;
    return;
  }
  else
  {
    warehouse[orID].prodt[pID].productIdentifier = pID;
    strcpy(warehouse[orID].prodt[pID].productDescription, shelf[pID].productDescription);
    warehouse[orID].prodt[pID].productPrice = shelf[pID].productPrice;
    warehouse[orID].prodt[pID].productWeight = shelf[pID].productWeight;
    warehouse[orID].prodt[pID].productStock = sAUX;
    warehouse[orID].orderWeight = totalWeight;
    shelf[pID].productStock -= sAUX;
  }

}

void RemoveStock(struct Product shelf[10000], int pidentifier, char received[100])
{
  char new[10][64];
  int pID;
  int sAUX;
  Separate(received, new);
  pID = atoi(new[0]);
  sAUX = atoi(new[1]);
  if (pID >= pidentifier)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", pID);
    return;
  }
  else
  {
    
  }

  if ((shelf[pID].productStock - sAUX) < 0)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", sAUX, pID);
    return;
  }
  else
  {
    
  }

  shelf[pID].productStock -= sAUX;
}

void RemoveProduct(struct Order warehouse[500], struct Product shelf[10000], int oridentifier, int pidentifier, char received[100])
{
  char new[10][64];
  int pID;
  int orID;
  Separate(received, new);
  orID = atoi(new[0]);
  pID = atoi(new[1]);
  if (orID >= oridentifier)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", pID, orID);
    return;
  }
  else
  {
    
  }

  if (pID >= pidentifier)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", pID, orID);
    return;
  }
  else
  {
    
  }

  warehouse[orID].orderWeight -= warehouse[orID].prodt[pID].productStock * warehouse[orID].prodt[pID].productWeight;
  shelf[pID].productStock += warehouse[orID].prodt[pID].productStock;
  warehouse[orID].prodt[pID].productStock = 0;
}

void OrderPrice(struct Order warehouse[500], int oridentifier, char received[100])
{
  int orID;
  int e = 0;
  int totalPrice = 0;
  orID = atoi(received);
  if (orID >= oridentifier)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", orID);
    return;
  }
  else
  {
    
  }

  while (e < 100)
  {
    totalPrice += warehouse[orID].prodt[e].productStock * warehouse[orID].prodt[e].productPrice;
    e++;
  }

  printf("Custo da encomenda %d %d.\n", orID, totalPrice);
}

void ChangePrice(struct Product shelf[10000], struct Order warehouse[500], int oridentifier, int pidentifier, char received[100])
{
  char new[10][64];
  int pID;
  int prAUX;
  int i = 0;
  Separate(received, new);
  pID = atoi(new[0]);
  prAUX = atoi(new[1]);
  if (pID >= pidentifier)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", pID);
    return;
  }
  else
  {
    
  }

  while (i < oridentifier)
  {
    if (strcmp(warehouse[i].prodt[pID].productDescription, shelf[pID].productDescription) == 0)
    {
      warehouse[i].prodt[pID].productPrice = prAUX;
    }
    else
    {
      
    }

    i++;
  }

  shelf[pID].productPrice = prAUX;
}

void ListDescStock(struct Order warehouse[500], struct Product shelf[10000], int oridentifier, int pidentifier, char received[100])
{
  char new[10][64];
  int i;
  int orID;
  int pID;
  int stock = 0;
  Separate(received, new);
  orID = atoi(new[0]);
  pID = atoi(new[1]);
  if (orID >= oridentifier)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", orID);
    return;
  }
  else
  {
    
  }

  if (pID >= pidentifier)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", pID);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < 100; i++)
  {
    if (warehouse[orID].prodt[i].productIdentifier == pID)
    {
      stock = warehouse[orID].prodt[i].productStock;
      break;
    }
    else
    {
      
    }

  }

  printf("%s %d.\n", shelf[pID].productDescription, stock);
}

void ListBiggest(struct Order warehouse[500], int oridentifier, int pidentifier, char received[100])
{
  int pID;
  int orID = 0;
  int i;
  int e;
  int stock = 0;
  int biggest = 0;
  pID = atoi(received);
  if (pID >= pidentifier)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", pID);
    return;
  }
  else
  {
    for (i = 0; i < oridentifier; i++)
    {
      for (e = 0; e < 100; e++)
      {
        if (warehouse[i].prodt[e].productIdentifier == pID)
        {
          stock = warehouse[i].prodt[e].productStock;
          if (stock == biggest)
          {
            if (orID > i)
            {
              orID = i;
            }
            else
            {
              
            }

          }
          else
          {
            
          }

          if (stock > biggest)
          {
            biggest = warehouse[i].prodt[e].productStock;
            orID = i;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    if (biggest != 0)
    {
      printf("Maximo produto %d %d %d.\n", pID, orID, biggest);
      return;
    }
    else
    {
      
    }

  }

}

void PriceList(struct Product shelf[10000], int pidentifier)
{
  int i;
  struct Product new[10000];
  printf("Produtos\n");
  for (i = 0; i <= (pidentifier + 1); i++)
  {
    strcpy(new[i].productDescription, shelf[i].productDescription);
    new[i].productPrice = shelf[i].productPrice;
    new[i].productWeight = shelf[i].productWeight;
    new[i].productStock = shelf[i].productStock;
  }

  PriceSort(new, 0, 10000 + 1);
  for (i = 0; i < pidentifier; i++)
  {
    printf("* %s %d %d\n", new[i].productDescription, new[i].productPrice, new[i].productStock);
  }

  return;
}

int main()
{
  struct Product shelf[10000];
  struct Order warehouse[500];
  int run = 1;
  int pidentifier;
  int oridentifier;
  char c;
  char received[100];
  while (run == 1)
  {
    switch (c = getchar())
    {
      case 'a':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        pidentifier = AddProduct(shelf, pidentifier, received);
        break;

      case 'q':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        AddStock(shelf, pidentifier, received);
        break;

      case 'N':
        oridentifier = NewOrder(oridentifier);
        break;

      case 'A':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        OrderAddProd(shelf, warehouse, received, pidentifier, oridentifier);
        break;

      case 'r':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        RemoveStock(shelf, pidentifier, received);
        break;

      case 'R':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        RemoveProduct(warehouse, shelf, oridentifier, pidentifier, received);
        break;

      case 'C':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        OrderPrice(warehouse, oridentifier, received);
        break;

      case 'p':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        ChangePrice(shelf, warehouse, oridentifier, pidentifier, received);
        break;

      case 'E':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        ListDescStock(warehouse, shelf, oridentifier, pidentifier, received);
        break;

      case 'm':
        for (int received_index = 0; received_index < 10; received_index++)
      {
        received[received_index] = new_sym_var(sizeof(char) * 8);
      }

        received[10 - 1] = '\0';
        ListBiggest(warehouse, oridentifier, pidentifier, received);
        break;

      case 'l':
        PriceList(shelf, pidentifier);
        break;

      case 'L':
        exit(1);
        break;

      case 'x':
        return 0;
        break;

    }

  }

  return 0;
}

