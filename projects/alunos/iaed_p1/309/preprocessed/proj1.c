/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  int idp;
  char desc[64];
  int preco;
  int peso;
  int quantidade;
} produto;
produto stock[10000];
int prox_idp;
typedef struct produto_na_encomenda
{
  int idp;
  char desc[64];
  int quantidade;
} produto_na_encomenda;
typedef struct encomenda
{
  produto_na_encomenda registo_prod[200];
  int peso;
} encomenda;
encomenda registo_encom[500];
int prox_ide;
void adiciona_produto();
void adiciona_stock();
void cria_nova_encomenda();
void adiciona_produto_a_encomenda();
void remove_stock();
void remove_produto_encomenda();
void calcula_custo();
void altera_preco_produto();
void lista_descr_qtd_prod();
void lista_encomenda_maior_qtd_prod();
void lista_produtos_stock();
void lista_produtos_encomenda();
void mergesort(produto aux[], produto a[], int left, int right);
void merge(produto aux[], produto a[], int left, int m, int right);
void quicksort(produto a[], int left, int right);
int partition(produto a[], int left, int right);
int less_desc(produto a, produto b);
int main()
{
  while (1)
  {
    char cmd;
    cmd = getchar();
    switch (cmd)
    {
      case 'a':
        adiciona_produto();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        cria_nova_encomenda();
        break;

      case 'A':
        adiciona_produto_a_encomenda();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_produto_encomenda();
        break;

      case 'C':
        calcula_custo();
        break;

      case 'p':
        altera_preco_produto();
        break;

      case 'E':
        lista_descr_qtd_prod();
        break;

      case 'm':
        lista_encomenda_maior_qtd_prod();
        break;

      case 'l':
        lista_produtos_stock();
        break;

      case 'L':
        lista_produtos_encomenda();
        break;

      case 'x':
        return 0;

      default:
        printf("Comando desconhecido\n");

    }

    getchar();
  }

  return -1;
}

void adiciona_produto()
{
  stock[prox_idp].idp = prox_idp;
  for (int stock_index = 0; stock_index < 10; stock_index++)
  {
    stock[prox_idp].desc[stock_index] = new_sym_var(sizeof(char) * 8);
  }

  stock[prox_idp].desc[10 - 1] = '\0';
  stock[prox_idp].preco = new_sym_var(sizeof(int) * 8);
  stock[prox_idp].peso = new_sym_var(sizeof(int) * 8);
  stock[prox_idp].quantidade = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", prox_idp);
  prox_idp++;
}

void adiciona_stock()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= prox_idp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    stock[idp].quantidade += qtd;
  }

}

void cria_nova_encomenda()
{
  printf("Nova encomenda %d.\n", prox_ide);
  prox_ide++;
}

void adiciona_produto_a_encomenda()
{
  int ide;
  int idp;
  int qtd;
  int pos_prod = 0;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= prox_ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= prox_idp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (stock[idp].quantidade < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((registo_encom[ide].peso + (qtd * stock[idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          while (((pos_prod < 200) && (registo_encom[ide].registo_prod[pos_prod].desc[0] != '\0')) && (registo_encom[ide].registo_prod[pos_prod].idp != idp))
          {
            pos_prod++;
          }

          if ((registo_encom[ide].registo_prod[pos_prod].idp != idp) || (registo_encom[ide].registo_prod[pos_prod].desc[0] == '\0'))
          {
            registo_encom[ide].registo_prod[pos_prod].idp = idp;
            strcpy(registo_encom[ide].registo_prod[pos_prod].desc, stock[idp].desc);
          }
          else
          {
            
          }

          stock[idp].quantidade -= qtd;
          registo_encom[ide].registo_prod[pos_prod].quantidade += qtd;
          registo_encom[ide].peso += qtd * stock[idp].peso;
        }

      }

    }

  }

}

void remove_stock()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= prox_idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (stock[idp].quantidade < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      stock[idp].quantidade -= qtd;
    }

  }

}

void remove_produto_encomenda()
{
  int ide;
  int idp;
  int pos_prod = 0;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= prox_ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= prox_idp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      while ((pos_prod < 200) && (registo_encom[ide].registo_prod[pos_prod].idp != idp))
      {
        pos_prod++;
      }

      if (pos_prod == 200)
      {
        return;
      }
      else
      {
        
      }

      stock[idp].quantidade += registo_encom[ide].registo_prod[pos_prod].quantidade;
      registo_encom[ide].peso -= stock[idp].peso * registo_encom[ide].registo_prod[pos_prod].quantidade;
      while ((pos_prod < (200 - 1)) && (registo_encom[ide].registo_prod[pos_prod].desc[0] != '\0'))
      {
        registo_encom[ide].registo_prod[pos_prod] = registo_encom[ide].registo_prod[pos_prod + 1];
        pos_prod++;
      }

      registo_encom[ide].registo_prod[pos_prod].idp = 0;
      registo_encom[ide].registo_prod[pos_prod].desc[0] = '\0';
      registo_encom[ide].registo_prod[pos_prod].quantidade = 0;
    }

  }

}

void calcula_custo()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= prox_ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    int pos_prod;
    int custo = 0;
    for (pos_prod = 0; (pos_prod < 200) && (registo_encom[ide].registo_prod[pos_prod].desc[0] != '\0'); pos_prod++)
    {
      custo += stock[registo_encom[ide].registo_prod[pos_prod].idp].preco * registo_encom[ide].registo_prod[pos_prod].quantidade;
    }

    printf("Custo da encomenda %d %d.\n", ide, custo);
  }

}

void altera_preco_produto()
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= prox_idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    stock[idp].preco = preco;
  }

}

void lista_descr_qtd_prod()
{
  int ide;
  int idp;
  int pos_prod = 0;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= prox_ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= prox_idp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      while (((pos_prod < 200) && (registo_encom[ide].registo_prod[pos_prod].desc[0] != '\0')) && (registo_encom[ide].registo_prod[pos_prod].idp != idp))
      {
        pos_prod++;
      }

      qtd = ((pos_prod == 200) || (registo_encom[ide].registo_prod[pos_prod].idp != idp)) ? (0) : (registo_encom[ide].registo_prod[pos_prod].quantidade);
      printf("%s %d.\n", stock[idp].desc, qtd);
    }

  }

}

void lista_encomenda_maior_qtd_prod()
{
  int idp;
  int contador_prod = 0;
  int pos_encom;
  int pos_prod;
  int ide;
  int max_na_encom = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= prox_idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (prox_ide == 0)
    {
      return;
    }
    else
    {
      for (pos_encom = 0; pos_encom < prox_ide; pos_encom++)
      {
        for (pos_prod = 0; (pos_prod < 200) && (registo_encom[pos_encom].registo_prod[pos_prod].desc[0] != '\0'); pos_prod++)
        {
          if (registo_encom[pos_encom].registo_prod[pos_prod].idp == idp)
          {
            contador_prod = registo_encom[pos_encom].registo_prod[pos_prod].quantidade;
          }
          else
          {
            
          }

        }

        if (contador_prod > max_na_encom)
        {
          ide = pos_encom;
          max_na_encom = contador_prod;
        }
        else
        {
          
        }

        contador_prod = 0;
      }

      if (max_na_encom == 0)
      {
        return;
      }
      else
      {
        printf("Maximo produto %d %d %d.\n", idp, ide, max_na_encom);
      }

    }

  }

}

void lista_produtos_stock()
{
  int i;
  produto temp[10000];
  produto aux[10000];
  for (i = 0; i < prox_idp; i++)
  {
    temp[i].idp = stock[i].idp;
    temp[i].preco = stock[i].preco;
  }

  mergesort(aux, temp, 0, prox_idp - 1);
  printf("Produtos\n");
  for (i = 0; i < prox_idp; i++)
  {
    printf("* %s %d %d\n", stock[temp[i].idp].desc, temp[i].preco, stock[temp[i].idp].quantidade);
  }

}

void mergesort(produto aux[], produto a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(aux, a, left, m);
  mergesort(aux, a, m + 1, right);
  merge(aux, a, left, m, right);
}

void merge(produto aux[], produto a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if ((aux[j].preco < aux[i].preco) || (i > m))
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void lista_produtos_encomenda()
{
  int ide;
  produto temp[200];
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= prox_ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    int i;
    int num_prod_encom = 0;
    for (i = 0; registo_encom[ide].registo_prod[i].desc[0] != '\0'; i++)
    {
      temp[i].idp = registo_encom[ide].registo_prod[i].idp;
      strcpy(temp[i].desc, registo_encom[ide].registo_prod[i].desc);
      temp[i].quantidade = registo_encom[ide].registo_prod[i].quantidade;
      num_prod_encom++;
    }

    quicksort(temp, 0, num_prod_encom - 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; registo_encom[ide].registo_prod[i].desc[0] != '\0'; i++)
    {
      printf("* %s %d %d\n", temp[i].desc, stock[temp[i].idp].preco, temp[i].quantidade);
    }

  }

}

void quicksort(produto a[], int left, int right)
{
  int i;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  i = partition(a, left, right);
  quicksort(a, left, i - 1);
  quicksort(a, i + 1, right);
}

int partition(produto a[], int left, int right)
{
  int i = left - 1;
  int j = right;
  produto pivot = a[right];
  while (i < j)
  {
    while (less_desc(a[++i], pivot))
      ;

    while (less_desc(pivot, a[--j]))
    {
      if (j == left)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      {
        produto t = a[i];
        a[i] = a[j];
        a[j] = t;
      }
      ;
    }
    else
    {
      
    }

  }

  {
    produto t = a[i];
    a[i] = a[right];
    a[right] = t;
  }
  ;
  return i;
}

int less_desc(produto a, produto b)
{
  return (strcmp(a.desc, b.desc) < 0) ? (1) : (0);
}

