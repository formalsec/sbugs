/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


struct Prodt
{
  int id;
  char descr[64];
  int preco;
  int peso;
  int qtd;
} prodt;
struct Encomenda
{
  struct Prodt produto[200];
  int n_unidades;
  int idp;
} encomenda;
struct Prodt produtos[10000];
struct Encomenda encomendas[500];
int a(char descr[64], int preco, int peso, int qtd, int idp)
{
  struct Prodt prod;
  strcpy(prod.descr, descr);
  prod.id = idp;
  prod.preco = preco;
  prod.peso = peso;
  prod.qtd = qtd;
  produtos[idp] = prod;
  printf("Novo produto %i.\n", idp);
  return ++idp;
}

void q(int idp, int new_idp, int qtd)
{
  if (new_idp >= idp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", new_idp);
  }
  else
  {
    produtos[new_idp].qtd += qtd;
  }

}

int N(int ide)
{
  struct Encomenda enc;
  enc.n_unidades = 0;
  enc.idp = 0;
  encomendas[ide] = enc;
  printf("Nova encomenda %i.\n", ide);
  return ++ide;
}

void A(int idp, int new_idp, int ide, int new_ide, int qtd)
{
  int new_peso = 0;
  int prodNotFound = 1;
  if (new_ide >= ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", new_idp, new_ide);
  }
  else
  {
    if (new_idp >= idp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", new_idp, new_ide);
    }
    else
    {
      if (produtos[new_idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", new_idp, new_ide);
      }
      else
      {
        if ((encomendas[new_ide].n_unidades + (qtd * produtos[new_idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", new_idp, new_ide);
        }
        else
        {
          int i;
          struct Prodt prod = produtos[new_idp];
          int prod_idp = encomendas[new_ide].idp;
          new_peso = qtd * produtos[new_idp].peso;
          encomendas[new_ide].n_unidades += new_peso;
          produtos[new_idp].qtd -= qtd;
          for (i = 0; i < prod_idp; i++)
          {
            struct Prodt new_prod = encomendas[new_ide].produto[i];
            if (new_prod.id == prod.id)
            {
              encomendas[new_ide].produto[i].qtd += qtd;
              prodNotFound = 0;
              break;
            }
            else
            {
              
            }

          }

          if (prodNotFound)
          {
            encomendas[new_ide].produto[prod_idp] = produtos[new_idp];
            encomendas[new_ide].produto[prod_idp].qtd = qtd;
            encomendas[new_ide].idp++;
          }
          else
          {
            
          }

        }

      }

    }

  }

}

void r(int idp, int new_idp, int qtd)
{
  if (new_idp >= idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", new_idp);
    return;
  }
  else
  {
    
  }

  if (produtos[new_idp].qtd < qtd)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, new_idp);
    return;
  }
  else
  {
    
  }

  produtos[new_idp].qtd -= qtd;
}

void R(int ide, int idp, int new_ide, int new_idp)
{
  if (new_ide >= ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", new_idp, new_ide);
  }
  else
  {
    if (new_idp >= idp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", new_idp, new_ide);
    }
    else
    {
      int i;
      int rem_unidades;
      int prod_idp = encomendas[new_ide].idp;
      int prodNotFound = 1;
      struct Prodt prod = produtos[new_idp];
      for (i = 0; i < prod_idp; i++)
      {
        struct Prodt new_prod = encomendas[new_ide].produto[i];
        if (new_prod.id == prod.id)
        {
          rem_unidades = encomendas[new_ide].produto[i].qtd * encomendas[new_ide].produto[i].peso;
          encomendas[new_ide].n_unidades -= rem_unidades;
          produtos[new_idp].qtd += encomendas[new_ide].produto[i].qtd;
          prodNotFound = 0;
          break;
        }
        else
        {
          
        }

      }

      if (!prodNotFound)
      {
        for (; i < prod_idp; i++)
          encomendas[new_ide].produto[i] = encomendas[new_ide].produto[i + 1];

        encomendas[new_ide].idp--;
      }
      else
      {
        
      }

    }

  }

}

void C(int ide, int new_ide)
{
  int i;
  int preco = 0;
  struct Encomenda enc = encomendas[new_ide];
  if (new_ide >= ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", new_ide);
  }
  else
  {
    for (i = 0; i < enc.idp; i++)
      preco += enc.produto[i].preco * enc.produto[i].qtd;

    printf("Custo da encomenda %i %i.\n", new_ide, preco);
  }

}

void p(int idp, int ide, int preco, int new_idp)
{
  int i;
  int j;
  if (new_idp >= idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", new_idp);
  }
  else
  {
    produtos[new_idp].preco = preco;
    for (i = 0; i < ide; i++)
    {
      for (j = 0; j < encomendas[i].idp; j++)
      {
        if (encomendas[i].produto[j].id == produtos[new_idp].id)
        {
          encomendas[i].produto[j].preco = preco;
        }
        else
        {
          
        }

      }

    }

  }

}

void E(int new_idp, int new_ide, int idp, int ide)
{
  int i;
  int prod_idp;
  int qtd = 0;
  if (new_ide >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", new_ide);
  }
  else
  {
    if (new_idp >= idp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", new_idp);
    }
    else
    {
      prod_idp = encomendas[new_ide].idp;
      for (i = 0; i < prod_idp; i++)
      {
        if (encomendas[new_ide].produto[i].id == produtos[new_idp].id)
        {
          qtd = encomendas[new_ide].produto[i].qtd;
          break;
        }
        else
        {
          
        }

      }

      printf("%s %d.\n", produtos[new_idp].descr, qtd);
    }

  }

}

void m(int new_idp, int idp, int ide)
{
  int i;
  int j;
  int max = 0;
  int enc = 0;
  if (new_idp >= idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", new_idp);
  }
  else
  {
    for (i = 0; i < ide; i++)
    {
      for (j = 0; j < encomendas[i].idp; j++)
      {
        if (encomendas[i].produto[j].id == produtos[new_idp].id)
        {
          if (encomendas[i].produto[j].qtd > max)
          {
            max = encomendas[i].produto[j].qtd;
            enc = i;
          }
          else
          {
            
          }

          break;
        }
        else
        {
          
        }

      }

    }

    if (max)
    {
      printf("Maximo produto %d %d %d.\n", new_idp, enc, max);
    }
    else
    {
      
    }

  }

}

void k2(struct Prodt prod[], int l_Lim, int m, int r_Lim)
{
  int i;
  int j;
  int k;
  struct Prodt aux[10000];
  for (i = m + 1; i > l_Lim; i--)
    aux[i - 1] = prod[i - 1];

  for (j = m; j < r_Lim; j++)
    aux[(r_Lim + m) - j] = prod[j + 1];

  for (k = l_Lim; k <= r_Lim; k++)
  {
    if (aux[j].preco < aux[i].preco)
    {
      prod[k] = aux[j--];
    }
    else
    {
      if (aux[j].preco == aux[i].preco)
      {
        if (aux[j].id > aux[i].id)
        {
          prod[k] = aux[i++];
        }
        else
        {
          prod[k] = aux[j--];
        }

      }
      else
      {
        prod[k] = aux[i++];
      }

    }

  }

}

void k1(struct Prodt prod[], int l_Lim, int r_Lim)
{
  int m;
  m = (r_Lim + l_Lim) / 2;
  if (r_Lim <= l_Lim)
  {
    return;
  }
  else
  {
    
  }

  k1(prod, l_Lim, m);
  k1(prod, m + 1, r_Lim);
  k2(prod, l_Lim, m, r_Lim);
}

void l(int l_Lim, int r_Lim)
{
  int i;
  struct Prodt prod[10000];
  for (i = l_Lim; i <= r_Lim; i++)
    prod[i] = produtos[i];

  k1(prod, l_Lim, r_Lim);
  printf("Produtos\n");
  for (i = l_Lim; i <= r_Lim; i++)
    printf("* %s %d %d\n", prod[i].descr, prod[i].preco, prod[i].qtd);

}

void k3(struct Prodt output[], int pos, int idp)
{
  int i;
  int cnt[127 + 1] = {0};
  struct Prodt new_output[200];
  for (i = 0; i < idp; i++)
  {
    if (((int) strlen(output[i].descr)) > pos)
    {
      cnt[(int) output[i].descr[pos]]++;
    }
    else
    {
      cnt[0]++;
    }

  }

  for (i = 1; i <= 127; i++)
    cnt[i] += cnt[i - 1];

  for (i = idp - 1; i >= 0; i--)
  {
    if (((int) strlen(output[i].descr)) > pos)
    {
      new_output[cnt[(int) output[i].descr[pos]] - 1] = output[i];
      cnt[(int) output[i].descr[pos]]--;
    }
    else
    {
      new_output[cnt[0] - 1] = output[i];
      cnt[0]--;
    }

  }

  for (i = 0; i < idp; i++)
  {
    output[i] = new_output[i];
  }

}

void L(int new_ide, int ide)
{
  int i;
  int max = 0;
  struct Prodt output[200];
  struct Encomenda enc = encomendas[new_ide];
  int idp = enc.idp;
  if (new_ide >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", new_ide);
  }
  else
  {
    for (i = 0; i < idp; i++)
    {
      output[i] = enc.produto[i];
      if (((int) strlen(output[i].descr)) > max)
      {
        max = strlen(output[i].descr);
      }
      else
      {
        
      }

    }

    for (i = max - 1; i >= 0; i--)
      k3(output, i, idp);

    printf("Encomenda %d\n", new_ide);
    for (i = 0; i < idp; i++)
      printf("* %s %d %d\n", output[i].descr, output[i].preco, output[i].qtd);

  }

}

int main()
{
  char comando;
  char descr[64];
  int preco;
  int peso;
  int qtd;
  int idp = 0;
  int new_idp;
  int ide = 0;
  int new_ide;
  while (1)
  {
    comando = new_sym_var(sizeof(char) * 8);
    switch (comando)
    {
      case 'a':
        for (int descr_index = 0; descr_index < 10; descr_index++)
      {
        descr[descr_index] = new_sym_var(sizeof(char) * 8);
      }

        descr[10 - 1] = '\0';
        preco = new_sym_var(sizeof(int) * 8);
        peso = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        idp = a(descr, preco, peso, qtd, idp);
        break;

      case 'q':
        new_idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        q(idp, new_idp, qtd);
        break;

      case 'N':
        ide = N(ide);
        break;

      case 'A':
        new_ide = new_sym_var(sizeof(int) * 8);
        new_idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        A(idp, new_idp, ide, new_ide, qtd);
        break;

      case 'r':
        new_idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        r(idp, new_idp, qtd);
        break;

      case 'R':
        new_ide = new_sym_var(sizeof(int) * 8);
        new_idp = new_sym_var(sizeof(int) * 8);
        R(ide, idp, new_ide, new_idp);
        break;

      case 'C':
        new_ide = new_sym_var(sizeof(int) * 8);
        C(ide, new_ide);
        break;

      case 'p':
        new_idp = new_sym_var(sizeof(int) * 8);
        preco = new_sym_var(sizeof(int) * 8);
        p(idp, ide, preco, new_idp);
        break;

      case 'E':
        new_ide = new_sym_var(sizeof(int) * 8);
        new_idp = new_sym_var(sizeof(int) * 8);
        E(new_idp, new_ide, idp, ide);
        break;

      case 'm':
        new_idp = new_sym_var(sizeof(int) * 8);
        m(new_idp, idp, ide);
        break;

      case 'l':
        l(0, idp - 1);
        break;

      case 'L':
        new_ide = new_sym_var(sizeof(int) * 8);
        L(new_ide, ide);
        break;

      case 'x':
        return 0;
        break;

    }

  }

  return 0;
}

