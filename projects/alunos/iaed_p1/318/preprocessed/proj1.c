/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct 
{
  char description[63];
  int identifier_product;
  int price;
  int weight;
  int stock;
} product;
typedef struct 
{
  int lista_quantities[10000];
  int list_of_idps[200];
  int identifier_order;
  int total_weight;
  int num_of_products;
} order;
product sistema[10000];
int idp_counter = 0;
order list_of_orders[500];
int ide_counter = 0;
int calculates_or_changes_order_weight(char option[], int ide, int idp, int quantity, char sign)
{
  int weight_atual = 0;
  if (sign == '+')
  {
    weight_atual = list_of_orders[ide].total_weight + (sistema[idp].weight * quantity);
  }
  else
  {
    weight_atual = list_of_orders[ide].total_weight - (sistema[idp].weight * quantity);
  }

  if (strncmp(option, "change", 6) == 0)
  {
    list_of_orders[ide].total_weight = weight_atual;
    return 0;
  }
  else
  {
    return weight_atual;
  }

}

void remove_idp_from_list_of_idps(int idp, int ide)
{
  int i;
  int ii;
  for (i = 0; i < list_of_orders[ide].num_of_products; i++)
  {
    if (list_of_orders[ide].list_of_idps[i] == idp)
    {
      for (ii = i; ii < list_of_orders[ide].num_of_products; ii++)
      {
        list_of_orders[ide].list_of_idps[ii] = list_of_orders[ide].list_of_idps[ii + 1];
      }

      break;
    }
    else
    {
      
    }

  }

}

int compare(char option[], int list_to_ordenate[], int a, int b)
{
  if (strncmp(option, "price", 5) == 0)
  {
    return sistema[list_to_ordenate[a]].price - sistema[list_to_ordenate[b]].price;
  }
  else
  {
    
  }

  if (strncmp(option, "identifier", 10) == 0)
  {
    return list_to_ordenate[a] - list_to_ordenate[b];
  }
  else
  {
    return strcmp(sistema[list_to_ordenate[a]].description, sistema[list_to_ordenate[b]].description);
  }

}

void exch(int list_to_ordenate[], int a, int b)
{
  int x = list_to_ordenate[a];
  list_to_ordenate[a] = list_to_ordenate[b];
  list_to_ordenate[b] = x;
}

int partition(char option[], int list_to_ordenate[], int l, int r)
{
  int i = l - 1;
  int j = r;
  while (i < j)
  {
    while (compare(option, list_to_ordenate, ++i, r) < 0)
      ;

    while (compare(option, list_to_ordenate, r, --j) < 0)
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      exch(list_to_ordenate, i, j);
    }
    else
    {
      
    }

  }

  exch(list_to_ordenate, i, r);
  return i;
}

void quicksort_by_price_or_idp_or_alpha(char option[], int list_to_ordenate[], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition(option, list_to_ordenate, l, r);
  quicksort_by_price_or_idp_or_alpha(option, list_to_ordenate, l, i - 1);
  quicksort_by_price_or_idp_or_alpha(option, list_to_ordenate, i + 1, r);
}

void ordenate_idps(int list_to_ordenate[])
{
  int left = 0;
  int right = 1;
  int save_r;
  int flag = 0;
  while (left < (idp_counter - 1))
  {
    if (sistema[list_to_ordenate[left]].price == sistema[list_to_ordenate[right]].price)
    {
      while (sistema[list_to_ordenate[left]].price == sistema[list_to_ordenate[right]].price)
      {
        if (right < idp_counter)
        {
          right++;
        }
        else
        {
          break;
        }

      }

      save_r = right;
      quicksort_by_price_or_idp_or_alpha("identifier", list_to_ordenate, left, right - 1);
      flag++;
    }
    else
    {
      
    }

    if (flag == 0)
    {
      left++;
      right++;
    }
    else
    {
      
    }

    if (flag != 0)
    {
      left = save_r;
      right = save_r + 1;
      flag = 0;
    }
    else
    {
      
    }

  }

}

void new_product_in_system(char description[], int price, int weight, int stock)
{
  product new_p;
  new_p.identifier_product = idp_counter;
  strcpy(new_p.description, description);
  new_p.price = price;
  new_p.weight = weight;
  new_p.stock = stock;
  sistema[idp_counter] = new_p;
  printf("Novo produto %d.\n", idp_counter);
  idp_counter++;
}

void add_stock_product(int idp, int quantity)
{
  if (idp < idp_counter)
  {
    sistema[idp].stock += quantity;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void remove_stock_product(int idp, int quantity)
{
  if (idp < idp_counter)
  {
    if (sistema[idp].stock >= quantity)
    {
      sistema[idp].stock -= quantity;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantity, idp);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }

}

void change_product_price(int idp, int new_price)
{
  if (idp < idp_counter)
  {
    sistema[idp].price = new_price;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

void print_system_by_price()
{
  int i;
  int idp_to_print;
  int list_to_ordenate[10000];
  for (i = 0; i < idp_counter; i++)
  {
    list_to_ordenate[i] = i;
  }

  quicksort_by_price_or_idp_or_alpha("price", list_to_ordenate, 0, idp_counter - 1);
  ordenate_idps(list_to_ordenate);
  printf("Produtos\n");
  for (i = 0; i < idp_counter; i++)
  {
    idp_to_print = list_to_ordenate[i];
    printf("* %s %d %d\n", sistema[idp_to_print].description, sistema[idp_to_print].price, sistema[idp_to_print].stock);
  }

}

void new_order()
{
  int i;
  order new_order;
  new_order.identifier_order = ide_counter;
  new_order.total_weight = 0;
  new_order.num_of_products = 0;
  for (i = 0; i < 10000; i++)
  {
    new_order.lista_quantities[i] = 0;
  }

  list_of_orders[ide_counter] = new_order;
  printf("Nova encomenda %d.\n", ide_counter);
  ide_counter++;
}

void add_product_to_order(int ide, int idp, int quantity)
{
  if (ide < ide_counter)
  {
    if (idp < idp_counter)
    {
      if (sistema[idp].stock >= quantity)
      {
        if (calculates_or_changes_order_weight("calculate", ide, idp, quantity, '+') <= 200)
        {
          if (list_of_orders[ide].lista_quantities[idp] == 0)
          {
            list_of_orders[ide].list_of_idps[list_of_orders[ide].num_of_products] = idp;
            list_of_orders[ide].num_of_products++;
          }
          else
          {
            
          }

          list_of_orders[ide].lista_quantities[idp] += quantity;
          calculates_or_changes_order_weight("change", ide, idp, quantity, '+');
          remove_stock_product(idp, quantity);
        }
        else
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }

      }
      else
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void remove_product_from_order(int ide, int idp)
{
  if (ide < ide_counter)
  {
    if (idp < idp_counter)
    {
      if (list_of_orders[ide].lista_quantities[idp] > 0)
      {
        add_stock_product(idp, list_of_orders[ide].lista_quantities[idp]);
        calculates_or_changes_order_weight("change", ide, idp, list_of_orders[ide].lista_quantities[idp], '-');
        list_of_orders[ide].lista_quantities[idp] = 0;
        remove_idp_from_list_of_idps(idp, ide);
        list_of_orders[ide].num_of_products--;
      }
      else
      {
        
      }

    }
    else
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void cost_of_order(int ide)
{
  int i;
  int cost = 0;
  int idp;
  if (ide < ide_counter)
  {
    for (i = 0; i < list_of_orders[ide].num_of_products; i++)
    {
      idp = list_of_orders[ide].list_of_idps[i];
      cost += sistema[idp].price * list_of_orders[ide].lista_quantities[idp];
    }

    printf("Custo da encomenda %d %d.\n", ide, cost);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void quantity_of_product_in_order(int ide, int idp)
{
  if (ide < ide_counter)
  {
    if (idp < idp_counter)
    {
      printf("%s %d.\n", sistema[idp].description, list_of_orders[ide].lista_quantities[idp]);
    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void order_w_more_qnt_product(int idp)
{
  int i;
  int ide_w_more_qnt = 0;
  int max_quantity = 0;
  if (idp < idp_counter)
  {
    for (i = 0; i < ide_counter; i++)
    {
      if (list_of_orders[i].lista_quantities[idp] > max_quantity)
      {
        max_quantity = list_of_orders[i].lista_quantities[idp];
        ide_w_more_qnt = i;
      }
      else
      {
        
      }

    }

    if (max_quantity != 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide_w_more_qnt, max_quantity);
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }

}

void print_order_by_alpha(int ide)
{
  int i;
  int idp_to_print;
  int list_to_ordenate[200];
  if (ide < ide_counter)
  {
    for (i = 0; i < list_of_orders[ide].num_of_products; i++)
    {
      list_to_ordenate[i] = list_of_orders[ide].list_of_idps[i];
    }

    quicksort_by_price_or_idp_or_alpha("description", list_to_ordenate, 0, list_of_orders[ide].num_of_products - 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < list_of_orders[ide].num_of_products; i++)
    {
      idp_to_print = list_to_ordenate[i];
      printf("* %s %d %d\n", sistema[idp_to_print].description, sistema[idp_to_print].price, list_of_orders[ide].lista_quantities[idp_to_print]);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

int main()
{
  char input[5000];
  int ide;
  int idp;
  int price;
  int weight;
  int stock;
  int quantity;
  int new_price;
  char description[63];
  while (1)
  {
    fgets(input, 5000, stdin);
    switch (input[0])
    {
      case 'a':
        for (int description_index = 0; description_index < 10; description_index++)
      {
        description[description_index] = new_sym_var(sizeof(char) * 8);
      }

        description[10 - 1] = '\0';
        price = new_sym_var(sizeof(int) * 8);
        weight = new_sym_var(sizeof(int) * 8);
        stock = new_sym_var(sizeof(int) * 8);
        new_product_in_system(description, price, weight, stock);
        break;

      case 'q':
        idp = new_sym_var(sizeof(int) * 8);
        quantity = new_sym_var(sizeof(int) * 8);
        add_stock_product(idp, quantity);
        break;

      case 'N':
        new_order();
        break;

      case 'A':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        quantity = new_sym_var(sizeof(int) * 8);
        add_product_to_order(ide, idp, quantity);
        break;

      case 'r':
        idp = new_sym_var(sizeof(int) * 8);
        quantity = new_sym_var(sizeof(int) * 8);
        remove_stock_product(idp, quantity);
        break;

      case 'R':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        remove_product_from_order(ide, idp);
        break;

      case 'C':
        ide = new_sym_var(sizeof(int) * 8);
        cost_of_order(ide);
        break;

      case 'p':
        idp = new_sym_var(sizeof(int) * 8);
        new_price = new_sym_var(sizeof(int) * 8);
        change_product_price(idp, new_price);
        break;

      case 'E':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        quantity_of_product_in_order(ide, idp);
        break;

      case 'm':
        idp = new_sym_var(sizeof(int) * 8);
        order_w_more_qnt_product(idp);
        break;

      case 'l':
        print_system_by_price();
        break;

      case 'L':
        ide = new_sym_var(sizeof(int) * 8);
        print_order_by_alpha(ide);
        break;

      case 'x':
        return 0;

    }

  }

  return 0;
}

