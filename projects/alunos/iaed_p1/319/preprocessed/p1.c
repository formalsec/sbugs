/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int id;
  char description[63];
  int price;
  int weight;
  int stock;
} Product;
typedef struct 
{
  int product_id_in_order;
  int amount_of_product_in_order;
} Composition;
typedef struct 
{
  int id;
  Composition order_composition_list[200];
} Order;
void start_products_list(Product products_list[10000], int dim, int num);
void start_orders_list(Order orders_list[500], int dim, int num);
int weight(Product products_list[10000], Composition order_composition_list[200]);
int find_product_in_order(Composition order_composition_list[200], int product_id);
int find_free_spot(Composition order_composition_list[200]);
int find_free_spot_products_list(Product products_list[10000]);
int no_product(Product products_list[10000], int product_id);
int no_order(Order orders_list[500], int order_id);
void merge_sort(Product products_list[10000], int left, int right);
void merge(Product products_list[10000], int left, int mid, int right);
void merge_sort_2(Product products_list[10000], Composition order_composition_list[200], int left, int right);
void merge_2(Product products_list[10000], Composition order_composition_list[200], int left, int mid, int right);
void add_product(Product products_list[10000]);
void add_stock(Product products_list[10000]);
void add_order(Order orders_list[500]);
void add_product_to_order(Product products_list[10000], Order orders_list[500]);
void remove_stock(Product products_list[10000]);
void remove_product_in_order(Product products_list[10000], Order orders_list[500]);
void order_cost(Product products_list[10000], Order orders_list[500]);
void change_price(Product products_list[10000]);
void list_product_in_order(Product products_list[10000], Order orders_list[500]);
void list_order_id_with_max_product(Product products_list[10000], Order orders_list[500]);
void sort_by_price(Product products_list[10000], int left, int right);
void sort_alphabetically(Product products_list[10000], Order orders_list[500]);
int main()
{
  Product products_list[10000];
  Order orders_list[500];
  char cmd;
  start_products_list(products_list, 10000, -1);
  start_orders_list(orders_list, 500, -1);
  while ((cmd = getchar()) != 'x')
  {
    switch (cmd)
    {
      case 'a':
        add_product(products_list);
        break;

      case 'q':
        add_stock(products_list);
        break;

      case 'N':
        add_order(orders_list);
        break;

      case 'A':
        add_product_to_order(products_list, orders_list);
        break;

      case 'r':
        remove_stock(products_list);
        break;

      case 'R':
        remove_product_in_order(products_list, orders_list);
        break;

      case 'C':
        order_cost(products_list, orders_list);
        break;

      case 'p':
        change_price(products_list);
        break;

      case 'E':
        list_product_in_order(products_list, orders_list);
        break;

      case 'm':
        list_order_id_with_max_product(products_list, orders_list);
        break;

      case 'l':
        sort_by_price(products_list, 0, find_free_spot_products_list(products_list));
        break;

      case 'L':
        sort_alphabetically(products_list, orders_list);
        break;

      default:
        break;

    }

  }

  return 0;
}

void start_products_list(Product products_list[10000], int dim, int num)
{
  int i;
  for (i = 0; i < dim; i++)
  {
    products_list[i].id = num;
  }

}

void start_orders_list(Order orders_list[10000], int dim, int num)
{
  int i;
  int j;
  for (i = 0; i < dim; i++)
  {
    orders_list[i].id = num;
    for (j = 0; j < 200; j++)
    {
      orders_list[i].order_composition_list[j].product_id_in_order = num;
    }

  }

}

int weight(Product products_list[10000], Composition order_composition_list[200])
{
  int i;
  int product_id_aux;
  int weight = 0;
  for (i = 0; i < 200; i++)
  {
    product_id_aux = order_composition_list[i].product_id_in_order;
    if (product_id_aux != (-1))
    {
      weight += order_composition_list[i].amount_of_product_in_order * products_list[product_id_aux].weight;
    }
    else
    {
      
    }

  }

  return weight;
}

int find_product_in_order(Composition order_composition_list[200], int product_id)
{
  int i;
  for (i = 0; i < 200; i++)
  {
    if (order_composition_list[i].product_id_in_order == product_id)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int find_free_spot(Composition order_composition_list[200])
{
  int i;
  for (i = 0; i < 200; i++)
  {
    if (order_composition_list[i].product_id_in_order == (-1))
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int find_free_spot_products_list(Product products_list[10000])
{
  int i;
  for (i = 0; i < 10000; i++)
  {
    if (products_list[i].id == (-1))
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int no_product(Product products_list[10000], int product_id)
{
  return (products_list[product_id].id == (-1)) ? (1) : (0);
}

int no_order(Order orders_list[500], int order_id)
{
  return (orders_list[order_id].id == (-1)) ? (1) : (0);
}

void add_product(Product products_list[10000])
{
  static int product_id = 0;
  char desc[63];
  int price;
  int weight;
  int stock;
  for (int desc_index = 0; desc_index < 10; desc_index++)
  {
    desc[desc_index] = new_sym_var(sizeof(char) * 8);
  }

  desc[10 - 1] = '\0';
  price = new_sym_var(sizeof(int) * 8);
  weight = new_sym_var(sizeof(int) * 8);
  stock = new_sym_var(sizeof(int) * 8);
  if ((((((product_id < 10000) && (strcmp(desc, "") != 0)) && (strlen(desc) <= 63)) && (price >= 0)) && (weight >= 0)) && (stock >= 0))
  {
    products_list[product_id].id = product_id;
    strcpy(products_list[product_id].description, desc);
    products_list[product_id].price = price;
    products_list[product_id].weight = weight;
    products_list[product_id].stock = stock;
    printf("Novo produto %d.\n", product_id++);
  }
  else
  {
    
  }

}

void add_stock(Product products_list[10000])
{
  int product_id;
  int stock;
  product_id = new_sym_var(sizeof(int) * 8);
  stock = new_sym_var(sizeof(int) * 8);
  if (no_product(products_list, product_id))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", product_id);
  }
  else
  {
    products_list[product_id].stock += stock;
  }

}

void add_order(Order orders_list[500])
{
  static int order_id = 0;
  if (order_id < 500)
  {
    orders_list[order_id].id = order_id;
    printf("Nova encomenda %d.\n", order_id++);
  }
  else
  {
    
  }

}

void add_product_to_order(Product products_list[10000], Order orders_list[500])
{
  int product_id;
  int order_id;
  int amount;
  int index;
  order_id = new_sym_var(sizeof(int) * 8);
  product_id = new_sym_var(sizeof(int) * 8);
  amount = new_sym_var(sizeof(int) * 8);
  if (no_order(orders_list, order_id))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", product_id, order_id);
  }
  else
  {
    if (no_product(products_list, product_id))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", product_id, order_id);
    }
    else
    {
      if (products_list[product_id].stock < amount)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", product_id, order_id);
      }
      else
      {
        if ((weight(products_list, orders_list[order_id].order_composition_list) + (amount * products_list[product_id].weight)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", product_id, order_id);
        }
        else
        {
          if ((index = find_product_in_order(orders_list[order_id].order_composition_list, product_id)) != (-1))
          {
            orders_list[order_id].order_composition_list[index].amount_of_product_in_order += amount;
            products_list[product_id].stock -= amount;
          }
          else
          {
            if ((index = find_free_spot(orders_list[order_id].order_composition_list)) != (-1))
            {
              orders_list[order_id].order_composition_list[index].product_id_in_order = product_id;
              orders_list[order_id].order_composition_list[index].amount_of_product_in_order = amount;
              products_list[product_id].stock -= amount;
            }
            else
            {
              
            }

          }

        }

      }

    }

  }

}

void remove_stock(Product products_list[10000])
{
  int product_id;
  int amount;
  product_id = new_sym_var(sizeof(int) * 8);
  amount = new_sym_var(sizeof(int) * 8);
  if (no_product(products_list, product_id))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", product_id);
  }
  else
  {
    if (products_list[product_id].stock < amount)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", amount, product_id);
    }
    else
    {
      products_list[product_id].stock -= amount;
    }

  }

}

void remove_product_in_order(Product products_list[10000], Order orders_list[500])
{
  int order_id;
  int product_id;
  int index;
  int index_aux;
  order_id = new_sym_var(sizeof(int) * 8);
  product_id = new_sym_var(sizeof(int) * 8);
  if (no_order(orders_list, order_id))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", product_id, order_id);
  }
  else
  {
    if (no_product(products_list, product_id))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", product_id, order_id);
    }
    else
    {
      if ((index = find_product_in_order(orders_list[order_id].order_composition_list, product_id)) != (-1))
      {
        products_list[product_id].stock += orders_list[order_id].order_composition_list[index].amount_of_product_in_order;
        index_aux = find_free_spot(orders_list[order_id].order_composition_list);
        orders_list[order_id].order_composition_list[index].product_id_in_order = orders_list[order_id].order_composition_list[index_aux - 1].product_id_in_order;
        orders_list[order_id].order_composition_list[index].amount_of_product_in_order = orders_list[order_id].order_composition_list[index_aux - 1].amount_of_product_in_order;
        orders_list[order_id].order_composition_list[index_aux - 1].product_id_in_order = -1;
      }
      else
      {
        
      }

    }

  }

}

void order_cost(Product products_list[10000], Order orders_list[500])
{
  int order_id;
  int i;
  int aux;
  int stock;
  int product_id;
  int price;
  int cost = 0;
  order_id = new_sym_var(sizeof(int) * 8);
  if (no_order(orders_list, order_id))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", order_id);
  }
  else
  {
    aux = find_free_spot(orders_list[order_id].order_composition_list);
    for (i = 0; i < aux; i++)
    {
      product_id = orders_list[order_id].order_composition_list[i].product_id_in_order;
      if (product_id != (-1))
      {
        price = products_list[product_id].price;
        stock = orders_list[order_id].order_composition_list[i].amount_of_product_in_order;
        cost += price * stock;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d %d.\n", order_id, cost);
  }

}

void change_price(Product products_list[10000])
{
  int product_id;
  int price;
  product_id = new_sym_var(sizeof(int) * 8);
  price = new_sym_var(sizeof(int) * 8);
  if (no_product(products_list, product_id))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", product_id);
  }
  else
  {
    products_list[product_id].price = price;
  }

}

void list_product_in_order(Product products_list[10000], Order orders_list[500])
{
  int order_id;
  int product_id;
  int amount;
  char desc[63];
  order_id = new_sym_var(sizeof(int) * 8);
  product_id = new_sym_var(sizeof(int) * 8);
  if (no_order(orders_list, order_id))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order_id);
  }
  else
  {
    if (no_product(products_list, product_id))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", product_id);
    }
    else
    {
      strcpy(desc, products_list[product_id].description);
      if (find_product_in_order(orders_list[order_id].order_composition_list, product_id) == (-1))
      {
        printf("%s %d.\n", desc, 0);
      }
      else
      {
        amount = orders_list[order_id].order_composition_list[find_product_in_order(orders_list[order_id].order_composition_list, product_id)].amount_of_product_in_order;
        printf("%s %d.\n", desc, amount);
      }

    }

  }

}

void list_order_id_with_max_product(Product products_list[10000], Order orders_list[500])
{
  int product_id;
  int i;
  int j;
  int max_stock;
  int max_order_id = -1;
  int first = 1;
  Composition temp;
  product_id = new_sym_var(sizeof(int) * 8);
  if (no_product(products_list, product_id))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", product_id);
  }
  else
  {
    for (i = 0; i < 500; i++)
    {
      if (orders_list[i].id != (-1))
      {
        for (j = 0; j < 200; j++)
        {
          temp = orders_list[i].order_composition_list[j];
          if ((temp.product_id_in_order != (-1)) && (temp.product_id_in_order == product_id))
          {
            if (first == 1)
            {
              max_stock = temp.amount_of_product_in_order;
              max_order_id = i;
              first = 0;
            }
            else
            {
              if (temp.amount_of_product_in_order > max_stock)
              {
                max_stock = temp.amount_of_product_in_order;
                max_order_id = i;
              }
              else
              {
                
              }

            }

          }
          else
          {
            
          }

        }

      }
      else
      {
        
      }

    }

    if (max_order_id != (-1))
    {
      printf("Maximo produto %d %d %d.\n", product_id, max_order_id, max_stock);
    }
    else
    {
      
    }

  }

}

void sort_by_price(Product products_list[10000], int left, int right)
{
  int i;
  Product product;
  Product products_list_aux[10000];
  for (i = left; i < right; i++)
  {
    products_list_aux[i] = products_list[i];
  }

  merge_sort(products_list_aux, left, right - 1);
  printf("Produtos\n");
  for (i = left; i < right; i++)
  {
    product = products_list_aux[i];
    printf("* %s %d %d\n", product.description, product.price, product.stock);
  }

}

void merge_sort(Product products_list[10000], int left, int right)
{
  int mid = (left + right) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    merge_sort(products_list, left, mid);
    merge_sort(products_list, mid + 1, right);
    merge(products_list, left, mid, right);
  }

}

void merge(Product products_list[10000], int left, int mid, int right)
{
  int i;
  int j;
  int k;
  Product products_list_aux[10000];
  for (i = mid + 1; i > left; i--)
  {
    products_list_aux[i - 1] = products_list[i - 1];
  }

  for (j = mid; j < right; j++)
  {
    products_list_aux[(right + mid) - j] = products_list[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if (products_list_aux[j].price < products_list_aux[i].price)
    {
      products_list[k] = products_list_aux[j--];
    }
    else
    {
      if ((products_list_aux[j].price == products_list_aux[i].price) && (products_list_aux[j].id < products_list_aux[i].id))
      {
        products_list[k] = products_list_aux[j--];
      }
      else
      {
        if ((products_list_aux[j].price == products_list_aux[i].price) && (products_list_aux[j].id > products_list_aux[i].id))
        {
          products_list[k] = products_list_aux[i++];
        }
        else
        {
          products_list[k] = products_list_aux[i++];
        }

      }

    }

  }

}

void sort_alphabetically(Product products_list[10000], Order orders_list[500])
{
  int order_id;
  int i;
  int left = 0;
  int right;
  Composition order_composition_list_aux[200];
  Composition aux;
  order_id = new_sym_var(sizeof(int) * 8);
  if (no_order(orders_list, order_id))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order_id);
  }
  else
  {
    right = find_free_spot(orders_list[order_id].order_composition_list);
    for (i = left; i < right; i++)
    {
      order_composition_list_aux[i] = orders_list[order_id].order_composition_list[i];
    }

    merge_sort_2(products_list, order_composition_list_aux, left, right - 1);
    printf("Encomenda %d\n", order_id);
    for (i = left; i < right; i++)
    {
      aux = order_composition_list_aux[i];
      printf("* %s %d %d\n", products_list[aux.product_id_in_order].description, products_list[aux.product_id_in_order].price, aux.amount_of_product_in_order);
    }

  }

}

void merge_sort_2(Product products_list[10000], Composition order_composition_list[200], int left, int right)
{
  int mid = (left + right) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    merge_sort_2(products_list, order_composition_list, left, mid);
    merge_sort_2(products_list, order_composition_list, mid + 1, right);
    merge_2(products_list, order_composition_list, left, mid, right);
  }

}

void merge_2(Product products_list[10000], Composition order_composition_list[200], int left, int mid, int right)
{
  int i;
  int j;
  int k;
  int product_id_1;
  int product_id_2;
  Composition order_composition_list_aux[200];
  for (i = mid + 1; i > left; i--)
  {
    order_composition_list_aux[i - 1] = order_composition_list[i - 1];
  }

  for (j = mid; j < right; j++)
  {
    order_composition_list_aux[(right + mid) - j] = order_composition_list[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    product_id_1 = order_composition_list_aux[j].product_id_in_order;
    product_id_2 = order_composition_list_aux[i].product_id_in_order;
    if (strcmp(products_list[product_id_1].description, products_list[product_id_2].description) < 0)
    {
      order_composition_list[k] = order_composition_list_aux[j--];
    }
    else
    {
      order_composition_list[k] = order_composition_list_aux[i++];
    }

  }

}

