/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct Produto
{
  int idp;
  char descricao[64];
  int preco;
  int peso;
  int qtd;
} Produto;
Produto sistema[10000];
Produto vetor[10000];
typedef struct Encomenda
{
  int ide;
  int peso_encomenda;
  int custo_encomenda;
  int tabela[10000];
} Encomenda;
Encomenda conjunto[500];
int comando_a(Produto sistema[]);
int comando_q(Produto sistema[]);
int comando_N(Encomenda conjunto[]);
int comando_A(Encomenda conjunto[], Produto sistema[]);
int comando_r(Produto sistema[]);
int comando_R(Encomenda conjunto[]);
int comando_C(Encomenda conjunto[], Produto sistema[]);
int comando_p(Produto sistema[]);
int comando_E(Encomenda conjunto[], Produto sistema[]);
int comando_m(Produto sistema[], Encomenda conjunto[]);
int comando_l(Produto sistema[], Produto vetor[]);
int comando_L(Encomenda conjunto[], Produto sistema[], Produto vetor[]);
void mergesort1l(Produto vetor[], int left, int right);
void merge1l(Produto vetor[], int left, int m, int right);
void mergesort2L(Produto vetor[], int left, int right);
void merge2L(Produto vetor[], int left, int m, int right);
int num_produtos = 0;
int num_encomendas = 0;
int main()
{
  char caracter;
  conjunto[0].ide = -1;
  sistema[0].idp = -1;
  caracter = getchar();
  while (caracter != 'x')
  {
    switch (caracter)
    {
      case 'a':
        comando_a(sistema);
        num_produtos++;
        break;

      case 'q':
        comando_q(sistema);
        break;

      case 'N':
        comando_N(conjunto);
        num_encomendas++;
        break;

      case 'A':
        comando_A(conjunto, sistema);
        break;

      case 'R':
        comando_R(conjunto);
        break;

      case 'r':
        comando_r(sistema);
        break;

      case 'C':
        comando_C(conjunto, sistema);
        break;

      case 'p':
        comando_p(sistema);
        break;

      case 'E':
        comando_E(conjunto, sistema);
        break;

      case 'm':
        comando_m(sistema, conjunto);
        break;

      case 'l':
        comando_l(sistema, vetor);
        break;

      case 'L':
        comando_L(conjunto, sistema, vetor);
        break;

    }

    caracter = getchar();
  }

  return 0;
}

int comando_a(Produto sistema[])
{
  static int i = 0;
  if (i < 10000)
  {
    for (int sistema_index = 0; sistema_index < 10; sistema_index++)
    {
      sistema[i].descricao[sistema_index] = new_sym_var(sizeof(char) * 8);
    }

    sistema[i].descricao[10 - 1] = '\0';
    sistema[i].preco = new_sym_var(sizeof(int) * 8);
    sistema[i].peso = new_sym_var(sizeof(int) * 8);
    sistema[i].qtd = new_sym_var(sizeof(int) * 8);
    printf("Novo produto %d.\r\n", i);
    sistema[i].idp = i;
  }
  else
  {
    
  }

  return i++;
}

int comando_q(Produto sistema[])
{
  int produto;
  int quantidade_adicionada;
  int identificador;
  identificador = new_sym_var(sizeof(int) * 8);
  quantidade_adicionada = new_sym_var(sizeof(int) * 8);
  if ((identificador == 0) && (sistema[0].idp == (-1)))
  {
    printf("Impossivel adicionar produto 0 ao stock. Produto inexistente.\r\n");
    return 0;
  }
  else
  {
    
  }

  for (produto = 0; produto <= 10000; produto++)
  {
    if (sistema[produto].idp == identificador)
    {
      sistema[produto].qtd = sistema[produto].qtd + quantidade_adicionada;
      return 0;
    }
    else
    {
      
    }

  }

  printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\r\n", identificador);
  return 0;
}

int comando_N(Encomenda conjunto[])
{
  static int j = 0;
  if (j < 500)
  {
    printf("Nova encomenda %d.\r\n", j);
    conjunto[j].ide = j;
  }
  else
  {
    
  }

  return j++;
}

int comando_A(Encomenda conjunto[], Produto sistema[])
{
  int enc;
  int prod;
  int ide_dado;
  int idp_dado;
  int qtd_dada;
  ide_dado = new_sym_var(sizeof(int) * 8);
  idp_dado = new_sym_var(sizeof(int) * 8);
  qtd_dada = new_sym_var(sizeof(int) * 8);
  if ((conjunto[0].ide == (-1)) && (ide_dado == 0))
  {
    printf("Impossivel adicionar produto %d a encomenda 0. Encomenda inexistente.\r\n", idp_dado);
    return 0;
  }
  else
  {
    
  }

  if ((idp_dado == 0) && (sistema[0].idp == (-1)))
  {
    printf("Impossivel adicionar produto 0 a encomenda %d. Produto inexistente.\r\n", ide_dado);
    return 0;
  }
  else
  {
    
  }

  for (enc = 0; enc <= 500; enc++)
  {
    if (ide_dado == conjunto[enc].ide)
    {
      break;
    }
    else
    {
      if (enc == 500)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\r\n", idp_dado, ide_dado);
        return 0;
      }
      else
      {
        
      }

    }

  }

  for (prod = 0; prod <= 10000; prod++)
  {
    if (idp_dado == sistema[prod].idp)
    {
      break;
    }
    else
    {
      if (prod == 10000)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\r\n", idp_dado, ide_dado);
        return 0;
      }
      else
      {
        
      }

    }

  }

  if (qtd_dada <= sistema[idp_dado].qtd)
  {
    conjunto[ide_dado].tabela[idp_dado] = conjunto[ide_dado].tabela[idp_dado] + qtd_dada;
    sistema[idp_dado].qtd = sistema[idp_dado].qtd - qtd_dada;
    conjunto[ide_dado].peso_encomenda = conjunto[ide_dado].peso_encomenda + (sistema[idp_dado].peso * qtd_dada);
    if (conjunto[ide_dado].peso_encomenda > 200)
    {
      sistema[idp_dado].qtd = sistema[idp_dado].qtd + qtd_dada;
      conjunto[ide_dado].tabela[idp_dado] = conjunto[ide_dado].tabela[idp_dado] - qtd_dada;
      conjunto[ide_dado].peso_encomenda = conjunto[ide_dado].peso_encomenda - (sistema[idp_dado].peso * qtd_dada);
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\r\n", idp_dado, ide_dado);
      return 0;
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\r\n", idp_dado, ide_dado);
    return 0;
  }

  return 0;
}

int comando_r(Produto sistema[])
{
  int j = 0;
  int quantidade_retirada;
  int identificador;
  identificador = new_sym_var(sizeof(int) * 8);
  quantidade_retirada = new_sym_var(sizeof(int) * 8);
  if ((identificador == 0) && (sistema[0].idp == (-1)))
  {
    printf("Impossivel remover stock do produto 0. Produto inexistente.\r\n");
    return 0;
  }
  else
  {
    
  }

  for (j = 0; j <= 10000; j++)
  {
    if (sistema[j].idp == identificador)
    {
      sistema[j].qtd = sistema[j].qtd - quantidade_retirada;
      if (sistema[j].qtd < 0)
      {
        sistema[j].qtd = sistema[j].qtd + quantidade_retirada;
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\r\n", quantidade_retirada, identificador);
        return 0;
      }
      else
      {
        
      }

      return 0;
    }
    else
    {
      
    }

  }

  printf("Impossivel remover stock do produto %d. Produto inexistente.\r\n", identificador);
  return 0;
}

int comando_R(Encomenda conjunto[])
{
  int ide_dado;
  int idp_dado;
  int prod;
  int i;
  ide_dado = new_sym_var(sizeof(int) * 8);
  idp_dado = new_sym_var(sizeof(int) * 8);
  if ((conjunto[0].ide == (-1)) && (ide_dado == 0))
  {
    printf("Impossivel remover produto %d a encomenda 0. Encomenda inexistente.\r\n", idp_dado);
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i <= 500; i++)
  {
    if (ide_dado == conjunto[i].ide)
    {
      break;
    }
    else
    {
      if (i == 500)
      {
        printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\r\n", idp_dado, ide_dado);
        return 0;
      }
      else
      {
        
      }

    }

  }

  for (prod = 0; prod <= 10000; prod++)
  {
    if (idp_dado == sistema[prod].idp)
    {
      break;
    }
    else
    {
      if (prod == 10000)
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\r\n", idp_dado, ide_dado);
        return 0;
      }
      else
      {
        
      }

    }

  }

  sistema[idp_dado].qtd = sistema[idp_dado].qtd + conjunto[ide_dado].tabela[idp_dado];
  conjunto[ide_dado].peso_encomenda = conjunto[ide_dado].peso_encomenda - (sistema[idp_dado].peso * conjunto[ide_dado].tabela[idp_dado]);
  conjunto[ide_dado].tabela[idp_dado] = 0;
  return 0;
}

int comando_C(Encomenda conjunto[], Produto sistema[])
{
  int ide_dado;
  int i;
  int j;
  int custo = 0;
  ide_dado = new_sym_var(sizeof(int) * 8);
  if ((conjunto[0].ide == (-1)) && (ide_dado == 0))
  {
    printf("Impossivel calcular custo da encomenda 0. Encomenda inexistente.\r\n");
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i <= 500; i++)
  {
    if (ide_dado == conjunto[i].ide)
    {
      break;
    }
    else
    {
      if (i == 500)
      {
        printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\r\n", ide_dado);
        return 0;
      }
      else
      {
        
      }

    }

  }

  for (j = 0; j < 10000; j++)
  {
    if (conjunto[ide_dado].tabela[j] != 0)
    {
      custo = custo + (sistema[j].preco * conjunto[ide_dado].tabela[j]);
    }
    else
    {
      
    }

  }

  printf("Custo da encomenda %d %d.\r\n", ide_dado, custo);
  return 0;
}

int comando_p(Produto sistema[])
{
  int i;
  int idp_dado;
  int preco_novo;
  idp_dado = new_sym_var(sizeof(int) * 8);
  preco_novo = new_sym_var(sizeof(int) * 8);
  for (i = 0; i <= 10000; i++)
  {
    if (sistema[i].idp == idp_dado)
    {
      sistema[i].preco = 0;
      sistema[i].preco = sistema[i].preco + preco_novo;
      return 0;
    }
    else
    {
      
    }

  }

  printf("Impossivel alterar preco do produto %d. Produto inexistente.\r\n", idp_dado);
  return 0;
}

int comando_E(Encomenda conjunto[], Produto sistema[])
{
  int i;
  int j;
  int ide_dado;
  int idp_dado;
  ide_dado = new_sym_var(sizeof(int) * 8);
  idp_dado = new_sym_var(sizeof(int) * 8);
  if ((conjunto[0].ide == (-1)) && (ide_dado == 0))
  {
    printf("Impossivel listar encomenda 0. Encomenda inexistente.\r\n");
    return 0;
  }
  else
  {
    
  }

  if ((idp_dado == 0) && (sistema[0].idp == (-1)))
  {
    printf("Impossivel listar produto 0. Produto inexistente.\r\n");
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i <= 500; i++)
  {
    if (ide_dado == conjunto[i].ide)
    {
      break;
    }
    else
    {
      if (i == 500)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\r\n", ide_dado);
        return 0;
      }
      else
      {
        
      }

    }

  }

  for (j = 0; j <= 10000; j++)
  {
    if (idp_dado == sistema[j].idp)
    {
      break;
    }
    else
    {
      if (j == 10000)
      {
        printf("Impossivel listar produto %d. Produto inexistente.\r\n", idp_dado);
        return 0;
      }
      else
      {
        
      }

    }

  }

  printf("%s %d.\r\n", sistema[idp_dado].descricao, conjunto[ide_dado].tabela[idp_dado]);
  return 0;
}

int comando_m(Produto sistema[], Encomenda conjunto[])
{
  int encomenda;
  int j;
  int idp_dado;
  int qtd = 0;
  int ide = 0;
  idp_dado = new_sym_var(sizeof(int) * 8);
  if ((idp_dado == 0) && (sistema[0].idp == (-1)))
  {
    printf("Impossivel listar maximo do produto 0. Produto inexistente.\r\n");
    return 0;
  }
  else
  {
    
  }

  for (j = 0; j <= 10000; j++)
  {
    if (idp_dado == sistema[j].idp)
    {
      break;
    }
    else
    {
      if (j == 10000)
      {
        printf("Impossivel listar maximo do produto %d. Produto inexistente.\r\n", idp_dado);
        return 0;
      }
      else
      {
        
      }

    }

  }

  if (conjunto[0].ide == (-1))
  {
    return 0;
  }
  else
  {
    
  }

  for (encomenda = 0; encomenda < 500; encomenda++)
  {
    if (conjunto[encomenda].tabela[idp_dado] > qtd)
    {
      qtd = conjunto[encomenda].tabela[idp_dado];
      ide = encomenda;
    }
    else
    {
      if (encomenda == (500 - 1))
      {
        break;
      }
      else
      {
        
      }

    }

  }

  if (qtd == 0)
  {
    return 0;
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\r\n", idp_dado, ide, qtd);
  return 0;
}

int comando_l(Produto sistema[], Produto vetor[])
{
  int left = 0;
  int right = num_produtos;
  int i;
  for (i = 0; i < num_produtos; i++)
  {
    vetor[i] = sistema[i];
  }

  mergesort1l(vetor, left, right - 1);
  printf("Produtos\r\n");
  for (i = left; i < right; i++)
  {
    if (vetor[i].preco != 0)
    {
      printf("* %s %d %d\r\n", vetor[i].descricao, vetor[i].preco, vetor[i].qtd);
    }
    else
    {
      
    }

  }

  return 0;
}

int comando_L(Encomenda conjunto[], Produto sistema[], Produto vetor[])
{
  int left = 0;
  int right = num_produtos;
  int i;
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  for (i = 0; i < num_produtos; i++)
  {
    vetor[i] = sistema[i];
  }

  for (i = 0; i <= num_encomendas; i++)
  {
    if (conjunto[i].ide == ide)
    {
      mergesort2L(vetor, left, right - 1);
      printf("Encomenda %d\r\n", ide);
      for (i = 0; i < num_produtos; i++)
      {
        if (conjunto[ide].tabela[vetor[i].idp] != 0)
        {
          printf("* %s %d %d\r\n", vetor[i].descricao, vetor[i].preco, conjunto[ide].tabela[vetor[i].idp]);
        }
        else
        {
          
        }

      }

      return 0;
    }
    else
    {
      if (i == num_encomendas)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\r\n", ide);
      }
      else
      {
        
      }

    }

  }

  return 0;
}

void mergesort1l(Produto vetor[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort1l(vetor, left, m);
  mergesort1l(vetor, m + 1, right);
  merge1l(vetor, left, m, right);
}

void merge1l(Produto vetor[], int left, int m, int right)
{
  Produto aux[10000];
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = vetor[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = vetor[j + 1];

  for (k = left; k <= right; k++)
  {
    if (aux[j].preco < aux[i].preco)
    {
      vetor[k] = aux[j--];
    }
    else
    {
      if (aux[j].preco == aux[i].preco)
      {
        if (aux[j].idp < aux[i].idp)
        {
          vetor[k] = aux[j--];
        }
        else
        {
          vetor[k] = aux[i++];
        }

      }
      else
      {
        vetor[k] = aux[i++];
      }

    }

  }

}

void mergesort2L(Produto vetor[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort2L(vetor, left, m);
  mergesort2L(vetor, m + 1, right);
  merge2L(vetor, left, m, right);
}

void merge2L(Produto vetor[], int left, int m, int right)
{
  Produto aux[10000];
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = vetor[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = vetor[j + 1];

  for (k = left; k <= right; k++)
  {
    if (strcmp(aux[j].descricao, aux[i].descricao) < 0)
    {
      vetor[k] = aux[j--];
    }
    else
    {
      vetor[k] = aux[i++];
    }

  }

}

