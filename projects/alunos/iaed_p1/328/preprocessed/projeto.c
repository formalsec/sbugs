#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>


char comando[300];
char *ptr_comando = comando + 2;
char *ptr_novo_comando = comando;
char char_aux[300];
int i = 0;
int maior;
int lista[11000][65 + 3];
int ult_valor = 0;
int aux_main[65 + 3];
int b = 0;
int var_aux = 0;
int len;
int extrai_nr()
{
  i = 0;
  while ((ptr_comando[0] != ':') && (ptr_comando[0] != '\0'))
  {
    char_aux[i] = ptr_comando[0];
    ptr_comando += 1;
    i += 1;
  }

  char_aux[i] = '\0';
  i = 0;
  return atoi(char_aux);
}

int parent(int k)
{
  return ((k + 1) / 2) - 1;
}

int left(int k)
{
  return (k * 2) + 1;
}

int right(int k)
{
  return (k * 2) + 2;
}

void fixdown()
{
  static int aux[65 + 3];
  if (left(i) > ult_valor)
  {
    return;
  }
  else
  {
    
  }

  maior = left(i);
  if (right(i) <= ult_valor)
  {
    if (lista[right(i)][0] > lista[left(i)][0])
    {
      maior = right(i);
    }
    else
    {
      
    }

    if (lista[right(i)][0] == lista[left(i)][0])
    {
      var_aux = 1;
      while (lista[right(i)][var_aux] == lista[left(i)][var_aux])
      {
        var_aux += 1;
      }

      if (lista[right(i)][var_aux] > lista[left(i)][var_aux])
      {
        maior = right(i);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }
  else
  {
    
  }

  if (lista[i][0] > lista[maior][0])
  {
    return;
  }
  else
  {
    
  }

  if (lista[i][0] == lista[maior][0])
  {
    var_aux = 1;
    while (lista[i][var_aux] == lista[maior][var_aux])
    {
      var_aux += 1;
    }

    if (lista[i][var_aux] > lista[maior][var_aux])
    {
      return;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  var_aux = 0;
  while (var_aux != (len + 1))
  {
    aux[var_aux] = lista[i][var_aux];
    lista[i][var_aux] = lista[maior][var_aux];
    lista[maior][var_aux] = aux[var_aux];
    var_aux += 1;
  }

  var_aux = 0;
  i = maior;
  fixdown();
}

void buildheap()
{
  static int aux_i;
  aux_i = ((ult_valor + 1) / 2) - 1;
  while (aux_i > 0)
  {
    i = aux_i;
    fixdown();
    aux_i = aux_i - 1;
  }

  i = 0;
  fixdown();
  return;
}

typedef struct produto
{
  char descricao[65];
  int preco;
  int peso;
  int qtd;
  int idp;
} produto;
typedef struct encomenda
{
  int produto[10001];
  int peso;
  int preco;
} encomenda;
encomenda lista_encomendas[501];
int main()
{
  int idf = 0;
  int ide = 0;
  int idf_produto;
  int stock;
  int idf_encomenda;
  produto lista_produtos[10001];
  for (int comando_index = 0; comando_index < 10; comando_index++)
  {
    comando[comando_index] = new_sym_var(sizeof(char) * 8);
  }

  comando[10 - 1] = '\0';
  while (comando[0] != 'x')
  {
    switch (comando[0])
    {
      case 'a':
      {
        i = 0;
        while ((ptr_comando[0] != ':') && (i < 64))
        {
          lista_produtos[idf].descricao[i] = ptr_comando[0];
          i += 1;
          ptr_comando += 1;
        }

        ptr_comando += 1;
        lista_produtos[idf].preco = extrai_nr();
        ptr_comando += 1;
        lista_produtos[idf].peso = extrai_nr();
        ptr_comando += 1;
        lista_produtos[idf].qtd = extrai_nr();
        printf("Novo produto %d.\n", idf);
        lista_produtos[idf].idp = idf;
        idf += 1;
        break;
      }

      case 'q':
      {
        idf_produto = extrai_nr();
        if (idf_produto >= idf)
        {
          printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idf_produto);
          break;
        }
        else
        {
          
        }

        ptr_comando += 1;
        lista_produtos[idf_produto].qtd += extrai_nr();
        break;
      }

      case 'N':
      {
        lista_encomendas[ide].peso = 0;
        printf("Nova encomenda %d.\n", ide);
        ide += 1;
        break;
      }

      case 'A':
      {
        idf_encomenda = extrai_nr();
        ptr_comando += 1;
        idf_produto = extrai_nr();
        ptr_comando += 1;
        stock = extrai_nr();
        if (idf_encomenda >= ide)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idf_produto, idf_encomenda);
          break;
        }
        else
        {
          
        }

        if (idf_produto >= idf)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idf_produto, idf_encomenda);
          break;
        }
        else
        {
          
        }

        if (stock > lista_produtos[idf_produto].qtd)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idf_produto, idf_encomenda);
          break;
        }
        else
        {
          
        }

        i = (stock * lista_produtos[idf_produto].peso) + lista_encomendas[idf_encomenda].peso;
        if (i > 200)
        {
          i = 0;
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idf_produto, idf_encomenda);
          break;
        }
        else
        {
          
        }

        lista_produtos[idf_produto].qtd += (-1) * stock;
        lista_encomendas[idf_encomenda].peso = i;
        lista_encomendas[idf_encomenda].produto[idf_produto] += stock;
        i = 0;
        break;
      }

      case 'd':
      {
        idf_produto = extrai_nr();
        printf("%s\n%d\n%d\n%d\n", lista_produtos[idf_produto].descricao, lista_produtos[idf_produto].peso, lista_produtos[idf_produto].preco, lista_produtos[idf_produto].qtd);
        break;
      }

      case 'D':
      {
        idf_encomenda = extrai_nr();
        i = 0;
        while (i < idf)
        {
          printf("%d-%d\n", i, lista_encomendas[idf_encomenda].produto[i]);
          i += 1;
        }

        i = 0;
        break;
      }

      case 'r':
      {
        idf_produto = extrai_nr();
        if (idf_produto >= idf)
        {
          printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idf_produto);
          break;
        }
        else
        {
          
        }

        ptr_comando += 1;
        i = extrai_nr();
        if (lista_produtos[idf_produto].qtd < i)
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", i, idf_produto);
          break;
        }
        else
        {
          
        }

        lista_produtos[idf_produto].qtd += (-1) * i;
        break;
      }

      case 'R':
      {
        idf_encomenda = extrai_nr();
        ptr_comando += 1;
        idf_produto = extrai_nr();
        if (idf_encomenda >= ide)
        {
          printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idf_produto, idf_encomenda);
          break;
        }
        else
        {
          
        }

        if (idf_produto >= idf)
        {
          printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idf_produto, idf_encomenda);
          break;
        }
        else
        {
          
        }

        lista_encomendas[idf_encomenda].peso -= lista_encomendas[idf_encomenda].produto[idf_produto] * lista_produtos[idf_produto].peso;
        lista_produtos[idf_produto].qtd += lista_encomendas[idf_encomenda].produto[idf_produto];
        lista_encomendas[idf_encomenda].produto[idf_produto] = 0;
        break;
      }

      case 'C':
      {
        idf_encomenda = extrai_nr();
        if (idf_encomenda >= ide)
        {
          printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", idf_encomenda);
          break;
        }
        else
        {
          
        }

        i = 0;
        lista_encomendas[idf_encomenda].preco = 0;
        while (i < idf)
        {
          lista_encomendas[idf_encomenda].preco += lista_encomendas[idf_encomenda].produto[i] * lista_produtos[i].preco;
          i = i + 1;
        }

        printf("Custo da encomenda %d %d.\n", idf_encomenda, lista_encomendas[idf_encomenda].preco);
        break;
      }

      case 'p':
      {
        idf_produto = extrai_nr();
        if (idf_produto >= idf)
        {
          printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idf_produto);
          break;
        }
        else
        {
          
        }

        ptr_comando += 1;
        i = extrai_nr();
        lista_produtos[idf_produto].preco = i;
        break;
      }

      case 'E':
      {
        idf_encomenda = extrai_nr();
        ptr_comando += 1;
        idf_produto = extrai_nr();
        if (idf_encomenda >= ide)
        {
          printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idf_encomenda);
          break;
        }
        else
        {
          
        }

        if (idf_produto >= idf)
        {
          printf("Impossivel listar produto %d. Produto inexistente.\n", idf_produto);
          break;
        }
        else
        {
          
        }

        printf("%s %d.\n", lista_produtos[idf_produto].descricao, lista_encomendas[idf_encomenda].produto[idf_produto]);
        break;
      }

      case 'm':
      {
        idf_produto = extrai_nr();
        if (idf_produto >= idf)
        {
          printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idf_produto);
          break;
        }
        else
        {
          
        }

        i = 0;
        idf_encomenda = 0;
        while (ide > i)
        {
          if (lista_encomendas[idf_encomenda].produto[idf_produto] < lista_encomendas[i].produto[idf_produto])
          {
            idf_encomenda = i;
          }
          else
          {
            
          }

          i = i + 1;
        }

        if (lista_encomendas[idf_encomenda].produto[idf_produto] == 0)
        {
          break;
        }
        else
        {
          
        }

        printf("Maximo produto %d %d %d.\n", idf_produto, idf_encomenda, lista_encomendas[idf_encomenda].produto[idf_produto]);
        break;
      }

      case 'l':
      {
        i = 0;
        len = 2;
        if (idf == 0)
        {
          printf("Produtos\n");
          break;
        }
        else
        {
          
        }

        while (i < idf)
        {
          lista[i][0] = lista_produtos[i].preco;
          lista[i][1] = lista_produtos[i].idp;
          i += 1;
        }

        ult_valor = i - 1;
        b = ult_valor;
        buildheap();
        while (ult_valor != 0)
        {
          aux_main[0] = lista[ult_valor][0];
          aux_main[1] = lista[ult_valor][1];
          lista[ult_valor][0] = lista[0][0];
          lista[ult_valor][1] = lista[0][1];
          lista[0][0] = aux_main[0];
          lista[0][1] = aux_main[1];
          ult_valor -= 1;
          i = 0;
          fixdown();
        }

        i = 0;
        printf("Produtos\n");
        while (i <= b)
        {
          ult_valor = lista[i][1];
          printf("* %s %d %d\n", lista_produtos[ult_valor].descricao, lista_produtos[ult_valor].preco, lista_produtos[ult_valor].qtd);
          i = i + 1;
        }

        break;
      }

      case 'L':
      {
        static int indice_counter;
        len = 65 + 2;
        i = 0;
        idf_encomenda = extrai_nr();
        i = 0;
        if (idf_encomenda >= ide)
        {
          printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idf_encomenda);
          break;
        }
        else
        {
          
        }

        if (idf == 0)
        {
          printf("Encomenda %d\n", idf_encomenda);
          break;
        }
        else
        {
          
        }

        indice_counter = 0;
        while (i < idf)
        {
          var_aux = 0;
          if (lista_encomendas[idf_encomenda].produto[i] == 0)
          {
            i = i + 1;
            continue;
          }
          else
          {
            
          }

          while (lista_produtos[i].descricao[var_aux] != '\0')
          {
            lista[indice_counter][var_aux] = lista_produtos[i].descricao[var_aux];
            if (lista[indice_counter][var_aux] > 96)
            {
              lista[indice_counter][var_aux] -= 32;
            }
            else
            {
              
            }

            var_aux += 1;
          }

          lista[indice_counter][var_aux] = 255;
          lista[indice_counter][len] = i;
          i = i + 1;
          indice_counter += 1;
        }

        if (indice_counter == 1)
        {
          printf("Encomenda %d\n", idf_encomenda);
          printf("* %s %d %d\n", lista_produtos[lista[0][len]].descricao, lista_produtos[lista[0][len]].preco, lista_encomendas[idf_encomenda].produto[lista[0][len]]);
          break;
        }
        else
        {
          
        }

        if (indice_counter == 0)
        {
          printf("Encomenda %d\n", idf_encomenda);
          break;
        }
        else
        {
          
        }

        ult_valor = indice_counter - 1;
        b = ult_valor;
        buildheap();
        i = 0;
        while (ult_valor != 0)
        {
          var_aux = 0;
          while (var_aux != (len + 1))
          {
            aux_main[var_aux] = lista[ult_valor][var_aux];
            lista[ult_valor][var_aux] = lista[0][var_aux];
            lista[0][var_aux] = aux_main[var_aux];
            var_aux += 1;
          }

          ult_valor -= 1;
          i = 0;
          fixdown();
        }

        i = 0;
        ult_valor = 10500;
        printf("Encomenda %d\n", idf_encomenda);
        while (i <= b)
        {
          if (ult_valor == lista[i][len])
          {
            i += 1;
            continue;
          }
          else
          {
            
          }

          ult_valor = lista[i][len];
          if (lista_encomendas[idf_encomenda].produto[ult_valor] == 0)
          {
            i += 1;
            continue;
          }
          else
          {
            
          }

          printf("* %s %d %d\n", lista_produtos[ult_valor].descricao, lista_produtos[ult_valor].preco, lista_encomendas[idf_encomenda].produto[ult_valor]);
          i = i + 1;
        }

        break;
      }

    }

    for (int comando_index = 0; comando_index < 10; comando_index++)
    {
      comando[comando_index] = new_sym_var(sizeof(char) * 8);
    }

    comando[10 - 1] = '\0';
    ptr_comando = ptr_novo_comando + 2;
  }

  return 0;
}

