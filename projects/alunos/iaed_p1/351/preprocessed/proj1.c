#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


struct produto
{
  char descricao[64];
  int preco;
  int peso;
  int qtd;
  int id;
};
struct encomenda
{
  int id[200];
  int quantidades[200];
  int id_atual;
};
struct produto a2[10000];
struct produto produtos[10000];
struct encomenda encomendas[500];
void novo_produto(int id)
{
  char d[64];
  int preco;
  int peso;
  int qtd;
  for (int d_index = 0; d_index < 10; d_index++)
  {
    d[d_index] = new_sym_var(sizeof(char) * 8);
  }

  d[10 - 1] = '\0';
  preco = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  strcpy(produtos[id].descricao, d);
  produtos[id].preco = preco;
  produtos[id].peso = peso;
  produtos[id].qtd = qtd;
  produtos[id].id = id;
  printf("Novo produto %d.\n", id);
}

void adc_stock(int id_atual)
{
  int id;
  int qtd;
  id = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (id_atual >= id)
  {
    produtos[id].qtd += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  }

}

void cria_encomenda(int id)
{
  encomendas[id].id_atual = -1;
  printf("Nova encomenda %d.\n", id);
}

void adc_prod_encomenda(int id_atual_p, int id_atual_e)
{
  int i;
  int ide;
  int idp;
  int qtd;
  int peso = 0;
  int existe = -1;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide > id_atual_e)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (idp > id_atual_p)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      if (qtd > produtos[idp].qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        return;
      }
      else
      {
        
      }

    }

  }

  for (i = 0; i < (encomendas[ide].id_atual + 1); i++)
  {
    peso += produtos[encomendas[ide].id[i]].peso * encomendas[ide].quantidades[i];
    if (idp == encomendas[ide].id[i])
    {
      existe = i;
    }
    else
    {
      
    }

  }

  peso += produtos[idp].peso * qtd;
  if (peso > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
  }
  else
  {
    if (existe != (-1))
    {
      produtos[idp].qtd -= qtd;
      encomendas[ide].quantidades[existe] += qtd;
    }
    else
    {
      produtos[idp].qtd -= qtd;
      encomendas[ide].id_atual++;
      encomendas[ide].id[encomendas[ide].id_atual] = idp;
      encomendas[ide].quantidades[encomendas[ide].id_atual] = qtd;
    }

  }

}

void remove_stock(int id_atual)
{
  int id;
  int qtd;
  id = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (id_atual < id)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id);
  }
  else
  {
    if (produtos[id].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, id);
    }
    else
    {
      produtos[id].qtd -= qtd;
    }

  }

}

void remove_produto(int id_atual_e, int id_atual_p)
{
  int i;
  int ide;
  int idp;
  int estado = 0;
  int k;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > id_atual_e)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp > id_atual_p)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      for (i = 0; i < (encomendas[ide].id_atual + 1); i++)
      {
        if (encomendas[ide].id[i] == idp)
        {
          estado = 1;
          k = i;
        }
        else
        {
          
        }

      }

      if (estado == 1)
      {
        produtos[idp].qtd += encomendas[ide].quantidades[k];
        for (i = k; i < encomendas[ide].id_atual; i++)
        {
          encomendas[ide].id[i] = encomendas[ide].id[i + 1];
          encomendas[ide].quantidades[i] = encomendas[ide].quantidades[i + 1];
        }

        encomendas[ide].id_atual--;
      }
      else
      {
        
      }

    }

  }

}

void custo_encomenda(int id_atual_e)
{
  int ide;
  int i;
  int preco = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > id_atual_e)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < (encomendas[ide].id_atual + 1); i++)
    {
      preco += produtos[encomendas[ide].id[i]].preco * encomendas[ide].quantidades[i];
    }

    printf("Custo da encomenda %d %d.\n", ide, preco);
  }

}

void altera_preco(int id_atual_p)
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp > id_atual_p)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].preco = preco;
  }

}

void prod_na_enc(int id_atual_e, int id_atual_p)
{
  int ide;
  int idp;
  int i;
  int tracker = -1;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide > id_atual_e)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp > id_atual_p)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      for (i = 0; i < (encomendas[ide].id_atual + 1); i++)
      {
        if (idp == encomendas[ide].id[i])
        {
          tracker = i;
        }
        else
        {
          
        }

      }

      printf("%s %d.\n", produtos[idp].descricao, encomendas[ide].quantidades[tracker]);
    }

  }

}

void max_ocorrencia_produto(int id_atual_p, int id_atual_e)
{
  int idp;
  int max = -1;
  int idemax;
  int i;
  int j;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp > id_atual_p)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; i < (id_atual_e + 1); i++)
    {
      for (j = 0; j < (encomendas[i].id_atual + 1); j++)
      {
        if ((encomendas[i].id[j] == idp) && (encomendas[i].quantidades[j] > max))
        {
          max = encomendas[i].quantidades[j];
          idemax = i;
        }
        else
        {
          
        }

      }

    }

    if (max != (-1))
    {
      printf("Maximo produto %d %d %d.\n", idp, idemax, max);
    }
    else
    {
      
    }

  }

}

void merge_preco(struct produto a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
    a2[i - 1] = a[i - 1];

  for (j = m; j < r; j++)
    a2[(r + m) - j] = a[j + 1];

  for (k = l; k <= r; k++)
    if (a2[j].preco < a2[i].preco)
  {
    a[k] = a2[j--];
  }
  else
  {
    if ((a2[j].preco == a2[i].preco) && (a2[j].id < a2[i].id))
    {
      a[k] = a2[j--];
    }
    else
    {
      a[k] = a2[i++];
    }

  }


}

void mergesort_preco(struct produto prod[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_preco(prod, l, m);
  mergesort_preco(prod, m + 1, r);
  merge_preco(prod, l, m, r);
}

void lista_todos(int id_atual_p)
{
  int i;
  struct produto p[10000];
  for (i = 0; i < (id_atual_p + 1); i++)
  {
    p[i] = produtos[i];
  }

  mergesort_preco(p, 0, id_atual_p);
  printf("Produtos\n");
  for (i = 0; i < (id_atual_p + 1); i++)
  {
    printf("* %s %d %d\n", p[i].descricao, p[i].preco, p[i].qtd);
  }

}

void lista_encomenda(int id_atual_e)
{
  int ide;
  int i;
  int j;
  struct produto aux;
  struct produto p[200];
  ide = new_sym_var(sizeof(int) * 8);
  if (ide > id_atual_e)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < (encomendas[ide].id_atual + 1); i++)
    {
      p[i] = produtos[encomendas[ide].id[i]];
      p[i].qtd = encomendas[ide].quantidades[i];
    }

    for (i = 0; i < encomendas[ide].id_atual; i++)
    {
      for (j = 0; j < (encomendas[ide].id_atual - i); j++)
      {
        if (strcmp(p[j].descricao, p[j + 1].descricao) > 0)
        {
          aux = p[j];
          p[j] = p[j + 1];
          p[j + 1] = aux;
        }
        else
        {
          
        }

      }

    }

    printf("Encomenda %d\n", ide);
    for (i = 0; i < (encomendas[ide].id_atual + 1); i++)
    {
      printf("* %s %d %d\n", p[i].descricao, p[i].preco, p[i].qtd);
    }

  }

}

int main()
{
  char c;
  int id_p = -1;
  int id_e = -1;
  while (c != 'x')
  {
    c = getchar();
    switch (c)
    {
      case 'a':
        id_p++;
        novo_produto(id_p);
        break;

      case 'q':
        adc_stock(id_p);
        break;

      case 'N':
        id_e++;
        cria_encomenda(id_e);
        break;

      case 'A':
        adc_prod_encomenda(id_p, id_e);
        break;

      case 'r':
        remove_stock(id_p);
        break;

      case 'R':
        remove_produto(id_e, id_p);
        break;

      case 'C':
        custo_encomenda(id_e);
        break;

      case 'p':
        altera_preco(id_p);
        break;

      case 'E':
        prod_na_enc(id_e, id_p);
        break;

      case 'm':
        max_ocorrencia_produto(id_p, id_e);
        break;

      case 'l':
        lista_todos(id_p);
        break;

      case 'L':
        lista_encomenda(id_e);
        break;

    }

  }

  return 0;
}

