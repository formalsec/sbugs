/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


int var[3];
char descricao[63];
char v1[1];
int contadorp = 0;
int contadorenc = 0;
void le_input()
{
  int i;
  int c;
  int o = 0;
  if (v1[0] == 'a')
  {
    for (i = 0; i < 80; i++)
    {
      c = getchar();
      if ((c == '\n') || (c == EOF))
      {
        break;
      }
      else
      {
        if (c == ':')
        {
          break;
        }
        else
        {
          if (c != ' ')
          {
            descricao[i - 1] = c;
            descricao[i] = '\0';
          }
          else
          {
            
          }

        }

      }

    }

  }
  else
  {
    
  }

  var[0] = 0;
  var[1] = 0;
  var[2] = 0;
  for (i = 0; i < 63; i++)
  {
    c = getchar();
    if ((c == '\n') || (c == EOF))
    {
      break;
    }
    else
    {
      if (c == ':')
      {
        o += 1;
      }
      else
      {
        if (c != ' ')
        {
          var[o] = ((var[o] * 10) + c) - '0';
        }
        else
        {
          
        }

      }

    }

  }

}

typedef struct produtos
{
  int peso;
  int qtd;
  int idp;
  int preco;
  char descr[63];
} prod;
prod stock[10000];
typedef struct encomenda
{
  int peso;
  int ide;
  int qtd[10000];
  int idp;
  char prod[10000];
} encomenda;
encomenda encomendas[500];
int compara_s(char a[], char b[])
{
  int r;
  for (r = 0; r < 63; r++)
  {
    if (a[r] > b[r])
    {
      return 1;
    }
    else
    {
      if (a[r] < b[r])
      {
        return 0;
      }
      else
      {
        
      }

    }

  }

  return 0;
}

void merge_l(int a[], int l, int m, int r)
{
  int aux[10000];
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < r; j++)
    aux[(r + m) - j] = a[j + 1];

  for (k = l; k <= r; k++)
    if ((stock[aux[j]].preco < stock[aux[i]].preco) || ((stock[aux[j]].preco == stock[aux[i]].preco) && (aux[j] < aux[i])))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

void mergesort_l(int a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_l(a, l, m);
  mergesort_l(a, m + 1, r);
  merge_l(a, l, m, r);
}

void merge_L(int a[], int l, int m, int r)
{
  int aux[10000];
  int i;
  int j;
  int k;
  for (i = m + 1; i > l; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < r; j++)
    aux[(r + m) - j] = a[j + 1];

  for (k = l; k <= r; k++)
    if (compara_s(stock[aux[i]].descr, stock[aux[j]].descr))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

void mergesort_L(int a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_L(a, l, m);
  mergesort_L(a, m + 1, r);
  merge_L(a, l, m, r);
}

void func_a()
{
  int i;
  stock[contadorp].idp = contadorp;
  for (i = 0; i < 63; i++)
  {
    if ((descricao[i] == '\n') || (descricao[i] == EOF))
    {
      break;
    }
    else
    {
      stock[contadorp].descr[i] = descricao[i];
      stock[contadorp].descr[i + 1] = '\0';
    }

  }

  stock[contadorp].preco = var[0];
  stock[contadorp].peso = var[1];
  stock[contadorp].qtd = var[2];
  printf("Novo produto %d.\n", stock[contadorp].idp);
  contadorp += 1;
}

void func_q()
{
  if (var[0] < contadorp)
  {
    stock[var[0]].qtd += var[1];
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", var[0]);
  }

}

void func_N()
{
  int o;
  encomendas[contadorenc].idp = 0;
  encomendas[contadorenc].ide = contadorenc;
  for (o = 0; o < 10000; o++)
  {
    encomendas[contadorenc].qtd[o] = 0;
  }

  encomendas[contadorenc].peso = 0;
  printf("Nova encomenda %d.\n", encomendas[contadorenc].ide);
  contadorenc += 1;
}

void func_A()
{
  if (var[0] >= contadorenc)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", var[1], var[0]);
  }
  else
  {
    if (var[1] >= contadorp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", var[1], var[0]);
    }
    else
    {
      if (stock[var[1]].qtd < var[2])
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", var[1], var[0]);
      }
      else
      {
        if ((encomendas[var[0]].peso + (var[2] * stock[var[1]].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", var[1], var[0]);
        }
        else
        {
          encomendas[var[0]].idp += 1;
          encomendas[var[0]].qtd[var[1]] += var[2];
          encomendas[var[0]].peso = encomendas[var[0]].peso + (var[2] * stock[var[1]].peso);
          stock[var[1]].qtd -= var[2];
        }

      }

    }

  }

}

void func_r()
{
  if (var[0] >= contadorp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", var[0]);
  }
  else
  {
    if (stock[var[0]].qtd < var[1])
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", var[1], var[0]);
    }
    else
    {
      stock[var[0]].qtd -= var[1];
    }

  }

}

void func_R()
{
  int n;
  if (var[0] >= contadorenc)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", var[1], var[0]);
  }
  else
  {
    if (var[1] >= contadorp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", var[1], var[0]);
    }
    else
    {
      n = encomendas[var[0]].qtd[var[1]];
      encomendas[var[0]].qtd[var[1]] = 0;
      stock[var[1]].qtd += n;
      encomendas[var[0]].peso -= n * stock[var[1]].peso;
    }

  }

}

void func_C()
{
  int i;
  int custo = 0;
  if (var[0] >= contadorenc)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", var[0]);
  }
  else
  {
    for (i = 0; i < 10000; i++)
    {
      custo += encomendas[var[0]].qtd[i] * stock[i].preco;
    }

    printf("Custo da encomenda %d %d.\n", var[0], custo);
  }

}

void func_p()
{
  if (var[0] >= contadorp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", var[0]);
  }
  else
  {
    stock[var[0]].preco = var[1];
  }

}

void func_E()
{
  if (var[0] >= contadorenc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", var[0]);
  }
  else
  {
    if (var[1] >= contadorp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", var[1]);
    }
    else
    {
      printf("%s %d.\n", stock[var[1]].descr, encomendas[var[0]].qtd[var[1]]);
    }

  }

}

void func_m()
{
  int i;
  int maximo = 0;
  int idatual;
  int estado = 0;
  for (i = 0; i < contadorenc; i++)
  {
    if (encomendas[i].qtd[var[0]] > 0)
    {
      estado = 1;
      break;
    }
    else
    {
      
    }

  }

  if (var[0] >= contadorp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", var[0]);
  }
  else
  {
    if ((contadorenc < 1) || (estado == 0))
    {
    }
    else
    {
      for (i = 0; i < contadorenc; i++)
      {
        if (encomendas[i].qtd[var[0]] > maximo)
        {
          maximo = encomendas[i].qtd[var[0]];
          idatual = i;
        }
        else
        {
          
        }

      }

      printf("Maximo produto %d %d %d.\n", var[0], idatual, maximo);
    }

  }

}

void func_l()
{
  int z;
  int o;
  int l_precos[10000];
  for (o = 0; o < contadorp; o++)
  {
    l_precos[o] = o;
  }

  mergesort_l(l_precos, 0, contadorp - 1);
  printf("Produtos\n");
  for (z = 0; z < contadorp; z++)
  {
    printf("* %s %d %d\n", stock[l_precos[z]].descr, stock[l_precos[z]].preco, stock[l_precos[z]].qtd);
  }

}

void func_L()
{
  int enc_d[200];
  int i;
  int u;
  int o = 0;
  if (var[0] >= contadorenc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", var[0]);
  }
  else
  {
    for (u = 0; u < 10000; u++)
    {
      if (encomendas[var[0]].qtd[u] > 0)
      {
        enc_d[o] = stock[u].idp;
        o += 1;
        if ((o - 1) == encomendas[var[0]].idp)
        {
          break;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    mergesort_L(enc_d, 0, o - 1);
    printf("Encomenda %d\n", var[0]);
    for (i = 0; i < o; i++)
    {
      printf("* %s %d %d\n", stock[enc_d[i]].descr, stock[enc_d[i]].preco, encomendas[var[0]].qtd[enc_d[i]]);
    }

  }

}

void que_func()
{
  switch (v1[0])
  {
    case 'a':
      func_a();
      break;

    case 'q':
      func_q();
      break;

    case 'N':
      func_N();
      break;

    case 'A':
      func_A();
      break;

    case 'r':
      func_r();
      break;

    case 'R':
      func_R();
      break;

    case 'C':
      func_C();
      break;

    case 'p':
      func_p();
      break;

    case 'E':
      func_E();
      break;

    case 'm':
      func_m();
      break;

    case 'l':
      func_l();
      break;

    case 'L':
      func_L();
      break;

  }

}

int main()
{
  v1[0] = getchar();
  while (v1[0] != 'x')
  {
    le_input();
    que_func();
    v1[0] = getchar();
  }

  return 0;
}

