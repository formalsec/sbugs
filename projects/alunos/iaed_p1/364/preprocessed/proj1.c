#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


void add_prod(int idp);
void add_stock(int idp);
void new_enc(int ide);
void add_prod_enc(int idp, int ide);
void remove_stock(int idp);
void remove_prod_enc(int idp, int ide);
void preco_enc(int ide);
void change_preco(int idp);
void desc_qtd_enc(int ide, int idp);
void enc_max_prod(int idp);
void ordem_preco();
void ordem_alfabetica_enc();
char descricao[64];
int preco;
int peso;
int quantidade;
typedef struct produto
{
  int idp;
  int preco;
  int peso;
  int qtd;
  char desc[64];
} prod;
typedef struct encomenda
{
  int nr_prod_enc;
  int nr_enc;
  int peso_enc;
  int qtd_enc[200];
  prod prod_enc[200];
} enc;
void quicksort(prod copia[], int first, int last, int FLAG);
int partition(prod copia[], int first, int last);
void selectionsort(prod copia[], int first, int last);
int peso_total_enc(enc a);
prod total_prod[10000];
enc total_enc[500];
int idp = 0;
int ide = 0;
int main()
{
  char comando;
  while ((comando = getchar()) != 'x')
  {
    switch (comando)
    {
      case 'a':
        add_prod(idp++);
        break;

      case 'q':
        add_stock(idp);
        break;

      case 'N':
        new_enc(ide++);
        break;

      case 'A':
        add_prod_enc(idp, ide);
        break;

      case 'r':
        remove_stock(idp);
        break;

      case 'R':
        remove_prod_enc(idp, ide);
        break;

      case 'C':
        preco_enc(ide);
        break;

      case 'p':
        change_preco(idp);
        break;

      case 'E':
        desc_qtd_enc(ide, idp);
        break;

      case 'm':
        enc_max_prod(ide);
        break;

      case 'l':
        ordem_preco();
        break;

      case 'L':
        ordem_alfabetica_enc();
        break;

      default:
        break;

    }

  }

  return 0;
}

void add_prod(int idp)
{
  prod n;
  for (int n_index = 0; n_index < 10; n_index++)
  {
    n.desc[n_index] = new_sym_var(sizeof(char) * 8);
  }

  n.desc[10 - 1] = '\0';
  n.preco = new_sym_var(sizeof(int) * 8);
  n.peso = new_sym_var(sizeof(int) * 8);
  n.qtd = new_sym_var(sizeof(int) * 8);
  n.idp = idp;
  idp++;
  total_prod[n.idp] = n;
  printf("Novo produto %d.\n", n.idp);
}

void add_stock(int idp)
{
  prod n;
  n.idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (n.idp >= idp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", n.idp);
  }
  else
  {
    total_prod[n.idp].qtd += quantidade;
  }

}

void new_enc(int ide)
{
  enc n;
  n.nr_enc = ide;
  total_enc[ide] = n;
  printf("Nova encomenda %d.\n", n.nr_enc);
}

int peso_total_enc(enc a)
{
  int i;
  for (i = 0; i < a.nr_prod_enc; i++)
    a.peso_enc += a.prod_enc[i].qtd * a.prod_enc[i].peso;

  return a.peso_enc;
}

void add_prod_enc(int idp, int ide)
{
  enc a;
  prod p;
  int i;
  int DENTRO = 0;
  a.nr_enc = new_sym_var(sizeof(int) * 8);
  p.idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (a.nr_enc >= ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", p.idp, a.nr_enc);
  }
  else
  {
    if (p.idp >= idp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", p.idp, a.nr_enc);
    }
    else
    {
      if (total_prod[p.idp].qtd < quantidade)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", p.idp, a.nr_enc);
      }
      else
      {
        if ((peso_total_enc(total_enc[a.nr_enc]) + (quantidade * total_prod[p.idp].peso)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", p.idp, a.nr_enc);
        }
        else
        {
          for (i = 0; i < total_enc[a.nr_enc].nr_prod_enc; i++)
          {
            if (total_enc[a.nr_enc].prod_enc[i].idp == p.idp)
            {
              DENTRO = 1;
              total_enc[a.nr_enc].prod_enc[i].qtd += quantidade;
              total_prod[p.idp].qtd -= quantidade;
              break;
            }
            else
            {
              
            }

          }

          if (DENTRO == 0)
          {
            total_enc[a.nr_enc].prod_enc[i] = total_prod[p.idp];
            total_enc[a.nr_enc].prod_enc[i].qtd = quantidade;
            total_enc[a.nr_enc].nr_prod_enc++;
            total_prod[p.idp].qtd -= quantidade;
          }
          else
          {
            
          }

        }

      }

    }

  }

}

void remove_stock(int idp)
{
  prod n;
  n.idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (n.idp >= idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", n.idp);
  }
  else
  {
    if (total_prod[n.idp].qtd < quantidade)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantidade, n.idp);
    }
    else
    {
      total_prod[n.idp].qtd -= quantidade;
    }

  }

}

void remove_prod_enc(int idp, int ide)
{
  prod n;
  enc a;
  int i;
  a.nr_enc = new_sym_var(sizeof(int) * 8);
  n.idp = new_sym_var(sizeof(int) * 8);
  if (a.nr_enc >= ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", n.idp, a.nr_enc);
  }
  else
  {
    if (n.idp >= idp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", n.idp, a.nr_enc);
    }
    else
    {
      for (i = 0; i < total_enc[a.nr_enc].nr_prod_enc; i++)
      {
        if (total_enc[a.nr_enc].prod_enc[i].idp == n.idp)
        {
          total_prod[n.idp].qtd += total_enc[a.nr_enc].prod_enc[i].qtd;
          total_enc[a.nr_enc].prod_enc[i].qtd = 0;
        }
        else
        {
          
        }

      }

    }

  }

}

void preco_enc(int ide)
{
  enc a;
  int total = 0;
  int i;
  a.nr_enc = new_sym_var(sizeof(int) * 8);
  if (a.nr_enc >= ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", a.nr_enc);
  }
  else
  {
    for (i = 0; i < total_enc[a.nr_enc].nr_prod_enc; i++)
    {
      total += total_enc[a.nr_enc].prod_enc[i].preco * total_enc[a.nr_enc].prod_enc[i].qtd;
    }

    printf("Custo da encomenda %d %d.\n", a.nr_enc, total);
  }

}

void change_preco(int idp)
{
  prod n;
  int i;
  int j;
  n.idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (n.idp >= idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", n.idp);
  }
  else
  {
    total_prod[n.idp].preco = preco;
    for (i = 0; i < ide; i++)
    {
      for (j = 0; j < total_enc[i].nr_prod_enc; j++)
      {
        if (total_enc[i].prod_enc[j].idp == n.idp)
        {
          total_enc[i].prod_enc[j].preco = preco;
        }
        else
        {
          
        }

      }

    }

  }

}

void desc_qtd_enc(int ide, int idp)
{
  prod n;
  enc a;
  int i;
  int DEFINE = 0;
  a.nr_enc = new_sym_var(sizeof(int) * 8);
  n.idp = new_sym_var(sizeof(int) * 8);
  if (a.nr_enc >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", a.nr_enc);
  }
  else
  {
    if (n.idp >= idp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", n.idp);
    }
    else
    {
      for (i = 0; i < total_enc[a.nr_enc].nr_prod_enc; i++)
      {
        if (total_enc[a.nr_enc].prod_enc[i].idp == n.idp)
        {
          DEFINE = 1;
          printf("%s %d.\n", total_enc[a.nr_enc].prod_enc[i].desc, total_enc[a.nr_enc].prod_enc[i].qtd);
        }
        else
        {
          
        }

      }

      if (DEFINE == 0)
      {
        printf("%s %d.\n", total_prod[n.idp].desc, 0);
      }
      else
      {
        
      }

    }

  }

}

void enc_max_prod(int ide)
{
  prod n;
  int maior = 0;
  int guarda;
  int i;
  int j;
  n.idp = new_sym_var(sizeof(int) * 8);
  if (n.idp >= idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", n.idp);
  }
  else
  {
    for (i = 0; i < ide; i++)
    {
      for (j = 0; j < total_enc[i].nr_prod_enc; j++)
      {
        if (total_enc[i].prod_enc[j].idp == n.idp)
        {
          if (total_enc[i].prod_enc[j].qtd > maior)
          {
            maior = total_enc[i].prod_enc[j].qtd;
            guarda = i;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    if (maior > 0)
    {
      printf("Maximo produto %d %d %d.\n", n.idp, guarda, maior);
    }
    else
    {
      
    }

  }

}

void ordem_preco()
{
  int i;
  int j;
  prod copia[10000];
  for (j = 0; j < idp; j++)
  {
    copia[j] = total_prod[j];
  }

  quicksort(copia, 0, idp - 1, 1);
  printf("Produtos\n");
  for (i = 0; i < idp; i++)
  {
    printf("* %s %d %d\n", copia[i].desc, copia[i].preco, copia[i].qtd);
  }

}

void ordem_alfabetica_enc()
{
  enc a;
  prod copia[10000];
  int j;
  int i;
  a.nr_enc = new_sym_var(sizeof(int) * 8);
  if (a.nr_enc >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", a.nr_enc);
  }
  else
  {
    for (j = 0; j < total_enc[a.nr_enc].nr_prod_enc; j++)
    {
      copia[j] = total_enc[a.nr_enc].prod_enc[j];
    }

    selectionsort(copia, 0, total_enc[a.nr_enc].nr_prod_enc - 1);
    printf("Encomenda %d\n", a.nr_enc);
    for (i = 0; i < total_enc[a.nr_enc].nr_prod_enc; i++)
    {
      if (copia[i].qtd != 0)
      {
        printf("* %s %d %d\n", copia[i].desc, copia[i].preco, copia[i].qtd);
      }
      else
      {
        
      }

    }

  }

}

void quicksort(prod copia[], int first, int last, int FLAG)
{
  int i;
  if (FLAG == 1)
  {
    if (last <= first)
    {
      return;
    }
    else
    {
      
    }

    i = partition(copia, first, last);
    quicksort(copia, first, i - 1, 1);
    quicksort(copia, i + 1, last, 1);
  }
  else
  {
    
  }

}

int partition(prod copia[], int first, int last)
{
  prod pivot = copia[last];
  int i = first - 1;
  int j = first;
  for (; j <= (last - 1); j++)
  {
    if (copia[j].preco < pivot.preco)
    {
      i++;
      {
        prod t = copia[i];
        copia[i] = copia[j];
        copia[j] = t;
      }
      ;
    }
    else
    {
      if (copia[j].preco == pivot.preco)
      {
        if (copia[j].idp < pivot.idp)
        {
          i++;
          {
            prod t = copia[i];
            copia[i] = copia[j];
            copia[j] = t;
          }
          ;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  {
    prod t = copia[i + 1];
    copia[i + 1] = copia[last];
    copia[last] = t;
  }
  ;
  return i + 1;
}

void selectionsort(prod copia[], int first, int last)
{
  int i;
  int j;
  for (i = first; i < last; i++)
  {
    prod aux;
    int min = i;
    for (j = i + 1; j <= last; j++)
      if (strcmp(copia[j].desc, copia[min].desc) < 0)
    {
      min = j;
    }
    else
    {
      
    }


    aux = copia[i];
    copia[i] = copia[min];
    copia[min] = aux;
  }

}

