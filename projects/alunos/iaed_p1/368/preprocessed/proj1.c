#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


struct produto
{
  char desc[64];
  int preco;
  int peso;
  int qtd;
};
struct encomenda
{
  int idp[200];
  int qtd[200];
  int dim;
};
struct produto p[10000];
struct encomenda e[500];
int num_p = 0;
int num_e = 0;
int existe_produto(int idp)
{
  return idp < num_p;
}

int existe_encomenda(int ide)
{
  return ide < num_e;
}

int pos_produto(int ide, int idp)
{
  int res = -1;
  int i;
  for (i = 0; i < e[ide].dim; i++)
    if (e[ide].idp[i] == idp)
  {
    res = i;
  }
  else
  {
    
  }


  return res;
}

int peso_encomenda(int ide)
{
  int peso = 0;
  int idp;
  int i;
  for (i = 0; i < e[ide].dim; i++)
  {
    idp = e[ide].idp[i];
    peso += e[ide].qtd[i] * p[idp].peso;
  }

  return peso;
}

void remove_p_de_e(int ide, int i)
{
  int j = e[ide].dim - 1;
  e[ide].idp[i] = e[ide].idp[j];
  e[ide].qtd[i] = e[ide].qtd[j];
  e[ide].dim--;
  return;
}

int menor_preco(int id1, int id2)
{
  return p[id1].preco < p[id2].preco;
}

int cmp_desc(int ide, int i, int j)
{
  int id1 = e[ide].idp[i];
  int id2 = e[ide].idp[j];
  return strcmp(p[id1].desc, p[id2].desc) < 0;
}

int qtd_em_encomenda(int ide, int idp)
{
  int i;
  i = pos_produto(ide, idp);
  if (i == (-1))
  {
    return 0;
  }
  else
  {
    return e[ide].qtd[i];
  }

}

void comando_k()
{
  int idp;
  printf("Produtos\n");
  for (idp = 0; idp < num_p; idp++)
  {
    printf("* %s %d %d\n", p[idp].desc, p[idp].preco, p[idp].qtd);
  }

  return;
}

void comando_a()
{
  for (int p_index = 0; p_index < 10; p_index++)
  {
    p[num_p].desc[p_index] = new_sym_var(sizeof(char) * 8);
  }

  p[num_p].desc[10 - 1] = '\0';
  p[num_p].preco = new_sym_var(sizeof(int) * 8);
  p[num_p].peso = new_sym_var(sizeof(int) * 8);
  p[num_p].qtd = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", num_p);
  num_p++;
  return;
}

void comando_q()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (!existe_produto(idp))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  p[idp].qtd += qtd;
  return;
}

void comando_K()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  printf("Encomenda %d\n", ide);
  for (i = 0; i < e[ide].dim; i++)
  {
    idp = e[ide].idp[i];
    printf("* %s %d %d\n", p[idp].desc, p[idp].preco, e[ide].qtd[i]);
  }

  return;
}

void comando_N()
{
  e[num_e].dim = 0;
  printf("Nova encomenda %d.\n", num_e);
  num_e++;
  return;
}

void comando_A()
{
  int ide;
  int idp;
  int qtd;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (!existe_encomenda(ide))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (!existe_produto(idp))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (qtd > p[idp].qtd)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if ((peso_encomenda(ide) + (qtd * p[idp].peso)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de %d.\n", idp, ide, 200);
    return;
  }
  else
  {
    
  }

  i = pos_produto(ide, idp);
  if (i == (-1))
  {
    i = e[ide].dim;
    e[ide].idp[i] = idp;
    e[ide].qtd[i] = 0;
    e[ide].dim++;
  }
  else
  {
    
  }

  p[idp].qtd -= qtd;
  e[ide].qtd[i] += qtd;
  return;
}

void comando_r()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (!existe_produto(idp))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (qtd > p[idp].qtd)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    return;
  }
  else
  {
    
  }

  p[idp].qtd -= qtd;
  return;
}

void comando_R()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (!existe_encomenda(ide))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (!existe_produto(idp))
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  i = pos_produto(ide, idp);
  if (i != (-1))
  {
    p[idp].qtd += e[ide].qtd[i];
    remove_p_de_e(ide, i);
  }
  else
  {
    
  }

  return;
}

void comando_C()
{
  int ide;
  int idp;
  int i;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (!existe_encomenda(ide))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < e[ide].dim; i++)
  {
    idp = e[ide].idp[i];
    total += e[ide].qtd[i] * p[idp].preco;
  }

  printf("Custo da encomenda %d %d.\n", ide, total);
  return;
}

void comando_p()
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (!existe_produto(idp))
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  p[idp].preco = preco;
  return;
}

void comando_E()
{
  int ide;
  int idp;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (!existe_encomenda(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  if (!existe_produto(idp))
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  qtd = qtd_em_encomenda(ide, idp);
  printf("%s %d.\n", p[idp].desc, qtd);
  return;
}

void comando_m()
{
  int ide;
  int idp;
  int qtd;
  int max = 0;
  int max_qtd = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (!existe_produto(idp))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (ide = 0; ide < num_e; ide++)
  {
    qtd = qtd_em_encomenda(ide, idp);
    if (qtd > max_qtd)
    {
      max_qtd = qtd;
      max = ide;
    }
    else
    {
      
    }

  }

  if (max_qtd > 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, max, max_qtd);
  }
  else
  {
    
  }

  return;
}

void comando_l()
{
  int ordem[10000];
  int idp;
  int i;
  int j;
  int v;
  for (i = 0; i < num_p; i++)
    ordem[i] = i;

  for (i = 1; i < num_p; i++)
  {
    v = ordem[i];
    j = i - 1;
    while ((j >= 0) && menor_preco(v, ordem[j]))
    {
      ordem[j + 1] = ordem[j];
      j--;
    }

    ordem[j + 1] = v;
  }

  printf("Produtos\n");
  for (i = 0; i < num_p; i++)
  {
    idp = ordem[i];
    printf("* %s %d %d\n", p[idp].desc, p[idp].preco, p[idp].qtd);
  }

  return;
}

void comando_L()
{
  int ordem[200];
  int ide;
  int idp;
  int i;
  int j;
  int v;
  ide = new_sym_var(sizeof(int) * 8);
  if (!existe_encomenda(ide))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < e[ide].dim; i++)
    ordem[i] = i;

  for (i = 1; i < e[ide].dim; i++)
  {
    v = ordem[i];
    j = i - 1;
    while ((j >= 0) && cmp_desc(ide, v, ordem[j]))
    {
      ordem[j + 1] = ordem[j];
      j--;
    }

    ordem[j + 1] = v;
  }

  printf("Encomenda %d\n", ide);
  for (j = 0; j < e[ide].dim; j++)
  {
    i = ordem[j];
    idp = e[ide].idp[i];
    printf("* %s %d %d\n", p[idp].desc, p[idp].preco, e[ide].qtd[i]);
  }

  return;
}

int main()
{
  char comando;
  while ((comando = getchar()) != 'x')
  {
    switch (comando)
    {
      case 'k':
        comando_k();
        break;

      case 'a':
        comando_a();
        break;

      case 'q':
        comando_q();
        break;

      case 'K':
        comando_K();
        break;

      case 'N':
        comando_N();
        break;

      case 'A':
        comando_A();
        break;

      case 'r':
        comando_r();
        break;

      case 'R':
        comando_R();
        break;

      case 'C':
        comando_C();
        break;

      case 'p':
        comando_p();
        break;

      case 'E':
        comando_E();
        break;

      case 'm':
        comando_m();
        break;

      case 'l':
        comando_l();
        break;

      case 'L':
        comando_L();
        break;

    }

  }

  return 0;
}

