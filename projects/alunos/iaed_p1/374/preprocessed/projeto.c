#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


int qtd;
int prec;
int idpX;
int ideX;
int idp = 0;
int ide = 0;
char chr;
typedef struct produtos
{
  int preco;
  int peso;
  int stock;
  char desc[63];
} produtos;
produtos prods[10000];
typedef struct encomendas
{
  int qnt;
} encomendas;
encomendas encs[500][10000];
int pesos[500];
void func_a()
{
  for (int prods_index = 0; prods_index < 10; prods_index++)
  {
    prods[idp].desc[prods_index] = new_sym_var(sizeof(char) * 8);
  }

  prods[idp].desc[10 - 1] = '\0';
  prods[idp].preco = new_sym_var(sizeof(int) * 8);
  prods[idp].peso = new_sym_var(sizeof(int) * 8);
  prods[idp].stock = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", idp++);
}

void func_q()
{
  idpX = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idpX >= idp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idpX);
  }
  else
  {
    prods[idpX].stock = prods[idpX].stock + qtd;
  }

}

void func_N()
{
  for (idpX = 0; idpX < 10000; idpX++)
  {
    encs[ide][idpX].qnt = 0;
  }

  pesos[ide] = 0;
  printf("Nova encomenda %d.\n", ide++);
}

void func_A()
{
  ideX = new_sym_var(sizeof(int) * 8);
  idpX = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ideX >= ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idpX, ideX);
  }
  else
  {
    if (idpX >= idp)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idpX, ideX);
    }
    else
    {
      if (qtd > prods[idpX].stock)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idpX, ideX);
      }
      else
      {
        if (200 < (pesos[ideX] + (prods[idpX].peso * qtd)))
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idpX, ideX);
        }
        else
        {
          encs[ideX][idpX].qnt = encs[ideX][idpX].qnt + qtd;
          pesos[ideX] += qtd * prods[idpX].peso;
          prods[idpX].stock = prods[idpX].stock - qtd;
        }

      }

    }

  }

}

void func_r()
{
  idpX = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idpX >= idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idpX);
  }
  else
  {
    if (prods[idpX].stock < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idpX);
    }
    else
    {
      prods[idpX].stock = prods[idpX].stock - qtd;
    }

  }

}

void func_R()
{
  ideX = new_sym_var(sizeof(int) * 8);
  idpX = new_sym_var(sizeof(int) * 8);
  if (ideX >= ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idpX, ideX);
  }
  else
  {
    if (idpX >= idp)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idpX, ideX);
    }
    else
    {
      prods[idpX].stock += encs[ideX][idpX].qnt;
      pesos[ideX] -= encs[ideX][idpX].qnt * prods[idpX].peso;
      encs[ideX][idpX].qnt = 0;
    }

  }

}

void func_C()
{
  int prodX;
  int precoATM = 0;
  ideX = new_sym_var(sizeof(int) * 8);
  if (ideX >= ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ideX);
  }
  else
  {
    for (prodX = 0; prodX < 10000; prodX++)
    {
      precoATM = precoATM + (encs[ideX][prodX].qnt * prods[prodX].preco);
    }

    printf("Custo da encomenda %d %d.\n", ideX, precoATM);
  }

}

void func_p()
{
  idpX = new_sym_var(sizeof(int) * 8);
  prec = new_sym_var(sizeof(int) * 8);
  if (idpX >= idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idpX);
  }
  else
  {
    prods[idpX].preco = prec;
  }

}

void func_E()
{
  ideX = new_sym_var(sizeof(int) * 8);
  idpX = new_sym_var(sizeof(int) * 8);
  if (ideX >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ideX);
  }
  else
  {
    if (idpX >= idp)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idpX);
    }
    else
    {
      printf("%s %d.\n", prods[idpX].desc, encs[ideX][idpX].qnt);
    }

  }

}

void func_m()
{
  int ideC;
  int MAX = 0;
  int ideM;
  idpX = new_sym_var(sizeof(int) * 8);
  if (idpX >= idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idpX);
  }
  else
  {
    if (ide != 0)
    {
      for (ideC = 0; ideC < ide; ideC++)
      {
        if (encs[ideC][idpX].qnt > MAX)
        {
          MAX = encs[ideC][idpX].qnt;
          ideM = ideC;
        }
        else
        {
          
        }

      }

      if (MAX != 0)
      {
        printf("Maximo produto %d %d %d.\n", idpX, ideM, encs[ideM][idpX].qnt);
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

}

int less_l(int y, int z)
{
  if (prods[y].preco < prods[z].preco)
  {
    return 1;
  }
  else
  {
    if (prods[y].preco == prods[z].preco)
    {
      if (y < z)
      {
        return 1;
      }
      else
      {
        return 0;
      }

    }
    else
    {
      return 0;
    }

  }

}

void merge_l(int a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = a[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if (less_l(aux[j], aux[i]))
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void mergesort_l(int a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_l(a, l, m);
  mergesort_l(a, m + 1, r);
  merge_l(a, l, m, r);
}

void func_l()
{
  int listaP[10000];
  int idprod;
  int k;
  for (idpX = 0; idpX < idp; idpX++)
  {
    listaP[idpX] = idpX;
  }

  mergesort_l(listaP, 0, idp - 1);
  printf("Produtos\n");
  for (k = 0; k < idp; k++)
  {
    idprod = listaP[k];
    printf("* %s %d %d\n", prods[idprod].desc, prods[idprod].preco, prods[idprod].stock);
  }

}

int less_L(char y[], char z[])
{
  int k;
  for (k = 0; k < 63; k++)
  {
    if (y[k] > z[k])
    {
      return 1;
    }
    else
    {
      if (y[k] < z[k])
      {
        return 0;
      }
      else
      {
        
      }

    }

  }

  return 0;
}

void merge_L(int a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = a[j + 1];
  }

  for (k = l; k <= r; k++)
  {
    if (less_L(prods[aux[i]].desc, prods[aux[j]].desc))
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void mergesort_L(int a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_L(a, l, m);
  mergesort_L(a, m + 1, r);
  merge_L(a, l, m, r);
}

void func_L()
{
  int listaP[10000];
  int idprod;
  int k = 0;
  int c = 0;
  ideX = new_sym_var(sizeof(int) * 8);
  if (ideX >= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ideX);
  }
  else
  {
    for (idprod = 0; idprod < 10000; idprod++)
    {
      if (encs[ideX][idprod].qnt != 0)
      {
        listaP[k++] = idprod;
      }
      else
      {
        
      }

    }

    mergesort_L(listaP, 0, k - 1);
    printf("Encomenda %d\n", ideX);
    for (idprod = 0; idprod < k; idprod++)
    {
      c = listaP[idprod];
      if (encs[ideX][c].qnt != 0)
      {
        printf("* %s %d %d\n", prods[c].desc, prods[c].preco, encs[ideX][c].qnt);
      }
      else
      {
        
      }

    }

  }

}

void lista_comandos()
{
  char c;
  c = chr;
  switch (c)
  {
    case 'a':
      func_a();
      break;

    case 'q':
      func_q();
      break;

    case 'N':
      func_N();
      break;

    case 'A':
      func_A();
      break;

    case 'r':
      func_r();
      break;

    case 'R':
      func_R();
      break;

    case 'C':
      func_C();
      break;

    case 'p':
      func_p();
      break;

    case 'E':
      func_E();
      break;

    case 'm':
      func_m();
      break;

    case 'l':
      func_l();
      break;

    case 'L':
      func_L();
      break;

  }

}

int main()
{
  char c;
  char x;
  chr = getchar();
  c = chr;
  x = 'x';
  while (c != x)
  {
    c = chr;
    lista_comandos();
    chr = getchar();
  }

  return 0;
}

