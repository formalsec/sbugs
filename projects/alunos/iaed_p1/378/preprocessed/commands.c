/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "proj1.h"


unsigned int orderWeight(order o, item *items)
{
  unsigned int weight = 0;
  unsigned int i;
  for (i = 0; i < o.itemCount; i++)
    weight += items[o.items[i].id].weight * o.items[i].qty;

  return weight;
}

unsigned int orderCost(order o, item *items)
{
  unsigned int cost = 0;
  unsigned int i;
  for (i = 0; i < o.itemCount; i++)
    cost += items[o.items[i].id].price * o.items[i].qty;

  return cost;
}

void newItem(char *cmd, logistics *l)
{
  int i = 0;
  unsigned int id = l->itemCount;
  while (cmd[i] && (cmd[i] != ':'))
  {
    l->items[id].desc[i] = cmd[i];
    i++;
  }

  l->items[id].desc[i] = '\0';
  l->items[id].id = id;
  l->items[id].price = new_sym_var(sizeof(unsigned int) * 8);
  l->items[id].weight = new_sym_var(sizeof(unsigned int) * 8);
  l->items[id].qty = new_sym_var(sizeof(unsigned int) * 8);
  printf("Novo produto %d.\n", id);
  l->itemCount++;
}

void addQty(char *cmd, logistics *l)
{
  unsigned int idp;
  unsigned int qty;
  idp = new_sym_var(sizeof(unsigned int) * 8);
  qty = new_sym_var(sizeof(unsigned int) * 8);
  if (idp >= l->itemCount)
  {
    printf("Impossivel adicionar produto %u ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  l->items[idp].qty += qty;
}

void newOrder(logistics *l)
{
  l->orders[l->orderCount].itemCount = 0;
  printf("Nova encomenda %u.\n", l->orderCount);
  l->orderCount++;
}

void addItem(char *cmd, logistics *l)
{
  unsigned int ide;
  unsigned int idp;
  unsigned int qty;
  unsigned int i;
  unsigned int found = 0;
  ide = new_sym_var(sizeof(unsigned int) * 8);
  idp = new_sym_var(sizeof(unsigned int) * 8);
  qty = new_sym_var(sizeof(unsigned int) * 8);
  if (ide >= l->orderCount)
  {
    printf("Impossivel adicionar produto %u a encomenda %u. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp >= l->itemCount)
  {
    printf("Impossivel adicionar produto %u a encomenda %u. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (qty > l->items[idp].qty)
  {
    printf("Impossivel adicionar produto %u a encomenda %u. Quantidade em stock insuficiente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if ((orderWeight(l->orders[ide], l->items) + (qty * l->items[idp].weight)) > 200)
  {
    printf("Impossivel adicionar produto %u a encomenda %u. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  l->items[idp].qty -= qty;
  for (i = 0; i < l->orders[ide].itemCount; i++)
  {
    if (l->orders[ide].items[i].id == idp)
    {
      found = 1;
      l->orders[ide].items[i].qty += qty;
      break;
    }
    else
    {
      
    }

  }

  if (!found)
  {
    l->orders[ide].items[l->orders[ide].itemCount].qty = qty;
    l->orders[ide].items[l->orders[ide].itemCount].id = idp;
    l->orders[ide].itemCount++;
  }
  else
  {
    
  }

}

void removeQty(char *cmd, logistics *l)
{
  unsigned int idp;
  unsigned int qty;
  idp = new_sym_var(sizeof(unsigned int) * 8);
  qty = new_sym_var(sizeof(unsigned int) * 8);
  if (idp >= l->itemCount)
  {
    printf("Impossivel remover stock do produto %u. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (qty > l->items[idp].qty)
  {
    printf("Impossivel remover %u unidades do produto %u do stock. Quantidade insuficiente.\n", qty, idp);
    return;
  }
  else
  {
    
  }

  l->items[idp].qty -= qty;
}

void removeItem(char *cmd, logistics *l)
{
  unsigned int ide;
  unsigned int idp;
  unsigned int i;
  unsigned int j;
  unsigned int found = 0;
  ide = new_sym_var(sizeof(unsigned int) * 8);
  idp = new_sym_var(sizeof(unsigned int) * 8);
  if (ide >= l->orderCount)
  {
    printf("Impossivel remover produto %u a encomenda %u. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp >= l->itemCount)
  {
    printf("Impossivel remover produto %u a encomenda %u. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < l->orders[ide].itemCount; i++)
  {
    if (l->orders[ide].items[i].id == idp)
    {
      found = 1;
      break;
    }
    else
    {
      
    }

  }

  if (!found)
  {
    return;
  }
  else
  {
    
  }

  l->items[idp].qty += l->orders[ide].items[i].qty;
  for (j = i + 1; j < l->orders[ide].itemCount; j++)
  {
    l->orders[ide].items[j - 1].id = l->orders[ide].items[j].id;
    l->orders[ide].items[j - 1].qty = l->orders[ide].items[j].qty;
  }

  l->orders[ide].itemCount--;
}

void getCost(char *cmd, logistics *l)
{
  unsigned int ide;
  ide = new_sym_var(sizeof(unsigned int) * 8);
  if (ide >= l->orderCount)
  {
    printf("Impossivel calcular custo da encomenda %u. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  printf("Custo da encomenda %u %u.\n", ide, orderCost(l->orders[ide], l->items));
}

void changePrice(char *cmd, logistics *l)
{
  unsigned int idp;
  unsigned int price;
  idp = new_sym_var(sizeof(unsigned int) * 8);
  price = new_sym_var(sizeof(unsigned int) * 8);
  if (idp >= l->itemCount)
  {
    printf("Impossivel alterar preco do produto %u. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  l->items[idp].price = price;
}

void getDesc(char *cmd, logistics *l)
{
  unsigned int ide;
  unsigned int idp;
  unsigned int i;
  ide = new_sym_var(sizeof(unsigned int) * 8);
  idp = new_sym_var(sizeof(unsigned int) * 8);
  if (ide >= l->orderCount)
  {
    printf("Impossivel listar encomenda %u. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  if (idp >= l->itemCount)
  {
    printf("Impossivel listar produto %u. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < l->orders[ide].itemCount; i++)
  {
    if (l->orders[ide].items[i].id == idp)
    {
      printf("%s %u.\n", l->items[idp].desc, l->orders[ide].items[i].qty);
      return;
    }
    else
    {
      
    }

  }

  printf("%s 0.\n", l->items[idp].desc);
}

void getMost(char *cmd, logistics *l)
{
  unsigned int idp;
  unsigned int i;
  unsigned int j;
  unsigned int most = 0;
  unsigned int mostAt;
  order o;
  idp = new_sym_var(sizeof(unsigned int) * 8);
  if (idp >= l->itemCount)
  {
    printf("Impossivel listar maximo do produto %u. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < l->orderCount; i++)
  {
    o = l->orders[i];
    for (j = 0; j < o.itemCount; j++)
    {
      if ((o.items[j].id == idp) && (o.items[j].qty > most))
      {
        mostAt = i;
        most = o.items[j].qty;
        break;
      }
      else
      {
        
      }

    }

  }

  if (most)
  {
    printf("Maximo produto %u %u %u.\n", idp, mostAt, most);
  }
  else
  {
    
  }

}

int partitionItems(item *it, int lo, int hi)
{
  item pivot = it[hi];
  item swap;
  int i = lo - 1;
  int j;
  for (j = lo; j <= (hi - 1); j++)
  {
    if (it[j].price < pivot.price)
    {
      i++;
      swap = it[j];
      it[j] = it[i];
      it[i] = swap;
    }
    else
    {
      
    }

  }

  swap = it[hi];
  it[hi] = it[i + 1];
  it[i + 1] = swap;
  return i + 1;
}

void sortItems(item *it, int lo, int hi)
{
  int pi;
  if (lo < hi)
  {
    pi = partitionItems(it, lo, hi);
    sortItems(it, lo, pi - 1);
    sortItems(it, pi + 1, hi);
  }
  else
  {
    
  }

}

int sortItems2(item *it, int max)
{
  int i;
  int s = 0;
  item swap;
  for (i = 0; i < (max - 1); i++)
  {
    if (it[i].price != it[i + 1].price)
    {
      continue;
    }
    else
    {
      
    }

    if (it[i].id > it[i + 1].id)
    {
      swap = it[i];
      it[i] = it[i + 1];
      it[i + 1] = swap;
      s = 1;
    }
    else
    {
      
    }

  }

  return s;
}

void listItems(logistics *l)
{
  unsigned int i;
  item sorted[10000];
  memcpy(sorted, l->items, (sizeof(item)) * l->itemCount);
  sortItems(sorted, 0, l->itemCount - 1);
  while (sortItems2(sorted, l->itemCount))
    ;

  printf("Produtos\n");
  for (i = 0; i < l->itemCount; i++)
  {
    printf("* %s %u %u\n", sorted[i].desc, sorted[i].price, sorted[i].qty);
  }

}

int partitionOrder(orderItem *it, int lo, int hi, item *li)
{
  int i = lo - 1;
  int j;
  orderItem pivot = it[hi];
  orderItem swap;
  item a;
  item b = li[pivot.id];
  ;
  for (j = lo; j <= (hi - 1); j++)
  {
    a = li[it[j].id];
    if (strcmp(a.desc, b.desc) < 1)
    {
      i++;
      swap = it[j];
      it[j] = it[i];
      it[i] = swap;
    }
    else
    {
      
    }

  }

  swap = it[hi];
  it[hi] = it[i + 1];
  it[i + 1] = swap;
  return i + 1;
}

void sortOrder(orderItem *it, int lo, int hi, item *li)
{
  int pi;
  if (lo < hi)
  {
    pi = partitionOrder(it, lo, hi, li);
    sortOrder(it, lo, pi - 1, li);
    sortOrder(it, pi + 1, hi, li);
  }
  else
  {
    
  }

}

void listOrder(char *cmd, logistics *l)
{
  unsigned int ide;
  unsigned int i;
  orderItem sorted[200];
  ide = new_sym_var(sizeof(unsigned int) * 8);
  if (ide >= l->orderCount)
  {
    printf("Impossivel listar encomenda %u. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  memcpy(sorted, l->orders[ide].items, (sizeof(orderItem)) * l->orders[ide].itemCount);
  sortOrder(sorted, 0, l->orders[ide].itemCount - 1, l->items);
  printf("Encomenda %u\n", ide);
  for (i = 0; i < l->orders[ide].itemCount; i++)
    printf("* %s %u %u\n", l->items[sorted[i].id].desc, l->items[sorted[i].id].price, sorted[i].qty);

}

