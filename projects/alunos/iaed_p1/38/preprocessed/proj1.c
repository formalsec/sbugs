#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct 
{
  char description[64];
  int price;
  int weight;
  int stock;
  int id_product;
} product;
typedef struct 
{
  int weight;
  int n_order;
  int n_product;
  product _product_[200];
} order;
char input[6][64] = {{0}};
int get_input(char string[]);
int idp_product = 0;
int ide_order = 0;
product products[10000] = {0};
product aux;
order orders[500] = {0};
order other_aux;
product a;
product b;
int get_input(char string[]);
product new_product();
void add_product();
int error_product_inex1();
void add_stock();
void new_order();
int add_product_to_order();
int remov_stock();
int remov_product();
void calc_c(int ide);
void change_price();
void desc_stock_product();
void ide_product_more_often(int idp);
void list_products();
void insertion();
int main()
{
  int i = 0;
  int j = 0;
  int ide = 0;
  int idp = 0;
  char string[100];
  char comando;
  while ((comando = getchar()) != 'x')
  {
    switch (comando)
    {
      case 'a':
        getchar();
        for (int string_index = 0; string_index < 10; string_index++)
      {
        string[string_index] = new_sym_var(sizeof(char) * 8);
      }

        string[10 - 1] = '\0';
        get_input(string);
        new_product();
        add_product();
        for (i = 0; i < 64; i++)
      {
        for (j = 0; j < 6; j++)
        {
          input[j][i] = 0;
        }

      }

        break;

      case 'q':
        getchar();
        for (int string_index = 0; string_index < 10; string_index++)
      {
        string[string_index] = new_sym_var(sizeof(char) * 8);
      }

        string[10 - 1] = '\0';
        get_input(string);
        add_stock(input);
        for (i = 0; i < 64; i++)
      {
        for (j = 0; j < 6; j++)
        {
          input[j][i] = 0;
        }

      }

        break;

      case 'N':
        new_order();
        break;

      case 'A':
        getchar();
        for (int string_index = 0; string_index < 10; string_index++)
      {
        string[string_index] = new_sym_var(sizeof(char) * 8);
      }

        string[10 - 1] = '\0';
        get_input(string);
        add_product_to_order(input);
        for (i = 0; i < 64; i++)
      {
        for (j = 0; j < 6; j++)
        {
          input[j][i] = 0;
        }

      }

        break;

      case 'r':
        getchar();
        for (int string_index = 0; string_index < 10; string_index++)
      {
        string[string_index] = new_sym_var(sizeof(char) * 8);
      }

        string[10 - 1] = '\0';
        get_input(string);
        remov_stock(input);
        for (i = 0; i < 64; i++)
      {
        for (j = 0; j < 6; j++)
        {
          input[j][i] = 0;
        }

      }

        break;

      case 'R':
        getchar();
        for (int string_index = 0; string_index < 10; string_index++)
      {
        string[string_index] = new_sym_var(sizeof(char) * 8);
      }

        string[10 - 1] = '\0';
        get_input(string);
        remov_product(input);
        for (i = 0; i < 64; i++)
      {
        for (j = 0; j < 6; j++)
        {
          input[j][i] = 0;
        }

      }

        break;

      case 'C':
        getchar();
        ide = new_sym_var(sizeof(int) * 8);
        calc_c(ide);
        break;

      case 'p':
        getchar();
        for (int string_index = 0; string_index < 10; string_index++)
      {
        string[string_index] = new_sym_var(sizeof(char) * 8);
      }

        string[10 - 1] = '\0';
        get_input(string);
        change_price(input);
        for (i = 0; i < 64; i++)
      {
        for (j = 0; j < 6; j++)
        {
          input[j][i] = 0;
        }

      }

        break;

      case 'E':
        getchar();
        for (int string_index = 0; string_index < 10; string_index++)
      {
        string[string_index] = new_sym_var(sizeof(char) * 8);
      }

        string[10 - 1] = '\0';
        get_input(string);
        desc_stock_product(input);
        for (i = 0; i < 64; i++)
      {
        for (j = 0; j < 6; j++)
        {
          input[j][i] = 0;
        }

      }

        break;

      case 'm':
        getchar();
        idp = new_sym_var(sizeof(int) * 8);
        ide_product_more_often(idp);
        break;

      case 'l':
        getchar();
        insertion();
        list_products();
        break;

    }

  }

  return 0;
}

int get_input(char string[])
{
  int i = 0;
  char *val;
  val = strtok(string, ":");
  while (val != 0)
  {
    strcpy(input[i], val);
    i++;
    val = strtok(0, ":");
  }

  return 0;
}

product new_product()
{
  strcpy(aux.description, input[0]);
  aux.price = atoi(input[1]);
  aux.weight = atoi(input[2]);
  aux.stock = atoi(input[3]);
  return aux;
}

void add_product()
{
  products[idp_product] = aux;
  aux.id_product = idp_product;
  idp_product++;
  printf("Novo produto %d.\n", aux.id_product);
}

void add_stock()
{
  int idp = 0;
  int stock = 0;
  idp = atoi(input[0]);
  stock = atoi(input[1]);
  if (idp >= idp_product)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    products[idp].stock += stock;
  }

}

void new_order()
{
  orders[ide_order] = other_aux;
  other_aux.n_order = ide_order;
  ide_order++;
  printf("Nova encomenda %d.\n", other_aux.n_order);
}

int add_product_to_order()
{
  int ide = 0;
  int idp = 0;
  int stock = 0;
  int i = 0;
  ide = atoi(input[0]);
  idp = atoi(input[1]);
  stock = atoi(input[2]);
  if (ide >= ide_order)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return 0;
  }
  else
  {
    
  }

  if (idp >= idp_product)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return 0;
  }
  else
  {
    
  }

  if (products[idp].stock >= stock)
  {
    if (((products[idp].weight * stock) + orders[ide].weight) <= 200)
    {
      for (i = 0; i < orders[ide].n_product; i++)
      {
        if (orders[ide]._product_[i].id_product == idp)
        {
          strcpy(orders[ide]._product_[i].description, products[idp].description);
          orders[ide]._product_[i].price = products[idp].price;
          orders[ide]._product_[i].weight += products[idp].weight * stock;
          orders[ide]._product_[i].stock += stock;
          products[idp].stock -= stock;
          break;
        }
        else
        {
          
        }

      }

      if (i == orders[ide].n_product)
      {
        strcpy(orders[ide]._product_[orders[ide].n_product].description, products[idp].description);
        orders[ide]._product_[orders[ide].n_product].price = products[idp].price;
        orders[ide]._product_[orders[ide].n_product].weight = products[idp].weight * stock;
        orders[ide]._product_[orders[ide].n_product].stock = stock;
        orders[ide]._product_[orders[ide].n_product].id_product = idp;
        products[idp].stock -= stock;
        orders[ide].n_product++;
      }
      else
      {
        
      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    }

    return 0;
  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
  }

  return 0;
}

int remov_stock()
{
  int stock = 0;
  int idp = 0;
  idp = atoi(input[0]);
  stock = atoi(input[1]);
  if (idp >= idp_product)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return 0;
  }
  else
  {
    
  }

  if ((products[idp].stock - stock) < 0)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", stock, idp);
    return 0;
  }
  else
  {
    products[idp].stock -= stock;
  }

  return 0;
}

int remov_product()
{
  int ide = 0;
  int idp = 0;
  int i = 0;
  int vazio_int = {0};
  char vazio_char[] = {0};
  ide = atoi(input[0]);
  idp = atoi(input[1]);
  if (ide >= ide_order)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return 0;
  }
  else
  {
    
  }

  if (idp >= idp_product)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < orders[ide].n_product; i++)
  {
    if (orders[ide]._product_[i].id_product == idp)
    {
      strcpy(orders[ide]._product_[i].description, vazio_char);
      orders[ide]._product_[i].price = vazio_int;
      orders[ide]._product_[i].weight = vazio_int;
      orders[ide]._product_[i].stock = vazio_int;
      orders[ide]._product_[i].id_product = vazio_int;
      orders[ide].n_product--;
      orders[ide]._product_[i] = orders[ide]._product_[i - 1];
      break;
    }
    else
    {
      
    }

    return 0;
  }

  return 0;
}

void calc_c(int ide)
{
  int custo = 0;
  int i = 0;
  if (ide >= ide_order)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i <= orders[ide].n_product; i++)
    {
      custo += orders[ide]._product_[i].stock * orders[ide]._product_[i].price;
    }

    printf("Custo da encomenda %d %d.\n", ide, custo);
  }

}

void change_price()
{
  int idp = 0;
  int price = 0;
  idp = atoi(input[0]);
  price = atoi(input[1]);
  if (idp >= idp_product)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    products[idp].price = price;
  }

}

void desc_stock_product()
{
  int ide = 0;
  int idp = 0;
  ide = atoi(input[0]);
  idp = atoi(input[1]);
  if (ide >= ide_order)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    
  }

  if (idp >= idp_product)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    printf("<%s> <%d>", orders[ide]._product_[idp].description, orders[ide]._product_[idp].stock);
  }

}

void ide_product_more_often(int idp)
{
  int i = 0;
  int max = -1;
  int max_quant = 0;
  int j = 0;
  if (idp >= idp_product)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < ide_order; i++)
  {
    for (j = 0; j < orders[i].n_product; j++)
    {
      if (orders[i]._product_[j].id_product == idp)
      {
        if (orders[i]._product_[j].stock > max_quant)
        {
          max_quant = orders[i]._product_[j].stock;
          max = i;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      if ((orders[i]._product_[j].id_product != idp) || (i < 0))
      {
        break;
      }
      else
      {
        
      }

    }

  }

  if (max == (-1))
  {
    return;
  }
  else
  {
    printf("Maximo produto %d %d %d.\n", idp, max, max_quant);
  }

}

void insertion()
{
  int j = 0;
  int i = 0;
  product v;
  for (i = 0; i < idp_product; i++)
  {
    v = products[i];
    j = i - 1;
    while ((j >= 0) && (products[j].price > v.price))
    {
      products[j + 1] = products[j];
      j--;
    }

    products[j + 1] = v;
  }

}

void list_products()
{
  int i = 0;
  printf("Produtos\n");
  for (i = 0; i < idp_product; i++)
  {
    printf("* %s %d %d\n", products[i].description, products[i].price, products[i].stock);
  }

}

