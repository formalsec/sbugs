/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct produto
{
  char descricao[63];
  int preco;
  int peso;
  int stock;
} produto;
typedef struct encomenda
{
  int quantidade[10000];
  int peso_tot;
} encomenda;
produto armazem[10000];
encomenda lis_encom[500];
int id = 0;
int id_e = 0;
int adicionar_prod()
{
  for (int armazem_index = 0; armazem_index < 10; armazem_index++)
  {
    armazem[id].descricao[armazem_index] = new_sym_var(sizeof(char) * 8);
  }

  armazem[id].descricao[10 - 1] = '\0';
  armazem[id].preco = new_sym_var(sizeof(int) * 8);
  armazem[id].peso = new_sym_var(sizeof(int) * 8);
  armazem[id].stock = new_sym_var(sizeof(int) * 8);
  return printf("Novo produto %d.\n", id++);
}

void adicionar_stock()
{
  int idq;
  int qtd;
  idq = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idq >= id)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idq);
  }
  else
  {
    armazem[idq].stock += qtd;
  }

}

int nova_enc()
{
  int idp;
  for (idp = 0; idp < 10000; idp++)
    lis_encom[id_e].quantidade[idp] = 0;

  lis_encom[id_e].peso_tot = 0;
  return printf("Nova encomenda %d.\n", id_e++);
}

void ad_pro_enc()
{
  int ide;
  int idp;
  int qnt;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  if (ide < id_e)
  {
    if (idp < id)
    {
      if (qnt <= armazem[idp].stock)
      {
        if ((lis_encom[ide].peso_tot + (qnt * armazem[idp].peso)) <= 200)
        {
          armazem[idp].stock -= qnt;
          lis_encom[ide].quantidade[idp] += qnt;
          lis_encom[ide].peso_tot += qnt * armazem[idp].peso;
        }
        else
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }

      }
      else
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void remove_stock()
{
  int idp;
  int qnt;
  idp = new_sym_var(sizeof(int) * 8);
  qnt = new_sym_var(sizeof(int) * 8);
  if (idp < id)
  {
    if (armazem[idp].stock >= qnt)
    {
      armazem[idp].stock -= qnt;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qnt, idp);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }

}

void remove_pro_ecom()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide < id_e)
  {
    if (idp < id)
    {
      lis_encom[ide].peso_tot -= lis_encom[ide].quantidade[idp] * armazem[idp].peso;
      armazem[idp].stock += lis_encom[ide].quantidade[idp];
      lis_encom[ide].quantidade[idp] = 0;
    }
    else
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void custo_encom()
{
  int ide;
  int idp;
  int custo = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide < id_e)
  {
    for (idp = 0; idp < 10000; idp++)
    {
      if (lis_encom[ide].quantidade[idp] > 0)
      {
        custo += lis_encom[ide].quantidade[idp] * armazem[idp].preco;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d %d.\n", ide, custo);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void alterar_preco()
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp < id)
  {
    armazem[idp].preco = preco;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

void descricao_quantidade()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide < id_e)
  {
    if (idp < id)
    {
      printf("%s %d.\n", armazem[idp].descricao, lis_encom[ide].quantidade[idp]);
    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void max_produto()
{
  int idp;
  int ide;
  int encom;
  int max = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp < id)
  {
    for (ide = 0; ide < id_e; ide++)
    {
      if (lis_encom[ide].quantidade[idp] > max)
      {
        max = lis_encom[ide].quantidade[idp];
        encom = ide;
      }
      else
      {
        
      }

    }

    if (max != 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, encom, max);
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }

}

int menor_preco(int X, int Y)
{
  int booleano = 0;
  if ((armazem[X].preco < armazem[Y].preco) || ((armazem[X].preco == armazem[Y].preco) && (X < Y)))
  {
    booleano = 1;
  }
  else
  {
    
  }

  return booleano;
}

int menor_desc(int X, int Y)
{
  int i;
  int booleano = -1;
  for (i = 0; (((i < 63) && (armazem[X].descricao[i] != '\n')) && (armazem[Y].descricao[i] != '\n')) && (booleano == (-1)); i++)
  {
    if (armazem[X].descricao[i] > armazem[Y].descricao[i])
    {
      booleano = 0;
    }
    else
    {
      if (armazem[X].descricao[i] < armazem[Y].descricao[i])
      {
        booleano = 1;
      }
      else
      {
        
      }

    }

  }

  return booleano;
}

void merge(int array[], int ini, int meio, int ult, int type)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = meio + 1; i > ini; i--)
    aux[i - 1] = array[i - 1];

  for (j = meio; j < ult; j++)
    aux[(ult + meio) - j] = array[j + 1];

  for (k = ini; k <= ult; k++)
  {
    if (type == 0)
    {
      if (menor_preco(aux[j], aux[i]))
      {
        array[k] = aux[j--];
      }
      else
      {
        array[k] = aux[i++];
      }

    }
    else
    {
      if (menor_desc(aux[j], aux[i]))
      {
        array[k] = aux[j--];
      }
      else
      {
        array[k] = aux[i++];
      }

    }

  }

}

void mergesort(int array[], int ini, int ult, int type)
{
  int meio = (ult + ini) / 2;
  if (ult <= ini)
  {
    return;
  }
  else
  {
    
  }

  mergesort(array, ini, meio, type);
  mergesort(array, meio + 1, ult, type);
  merge(array, ini, meio, ult, type);
}

void ordenar_preco()
{
  int ids[10000];
  int p;
  for (p = 0; p < id; p++)
    ids[p] = p;

  mergesort(ids, 0, id - 1, 0);
  printf("Produtos\n");
  for (p = 0; p < id; p++)
    printf("* %s %d %d\n", armazem[ids[p]].descricao, armazem[ids[p]].preco, armazem[ids[p]].stock);

}

void ordenar_desc()
{
  int ids[10000];
  int p;
  int ide;
  int i = 0;
  int tamanho = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide < id_e)
  {
    for (p = 0; p < id; p++)
    {
      if (lis_encom[ide].quantidade[p] > 0)
      {
        ids[i++] = p;
        tamanho++;
      }
      else
      {
        
      }

    }

    mergesort(ids, 0, tamanho - 1, 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < tamanho; i++)
      printf("* %s %d %d\n", armazem[ids[i]].descricao, armazem[ids[i]].preco, lis_encom[ide].quantidade[ids[i]]);

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void lis_comandos(char comando)
{
  switch (comando)
  {
    case 'a':
      adicionar_prod();
      break;

    case 'q':
      adicionar_stock();
      break;

    case 'N':
      nova_enc();
      break;

    case 'A':
      ad_pro_enc();
      break;

    case 'r':
      remove_stock();
      break;

    case 'R':
      remove_pro_ecom();
      break;

    case 'C':
      custo_encom();
      break;

    case 'p':
      alterar_preco();
      break;

    case 'E':
      descricao_quantidade();
      break;

    case 'm':
      max_produto();
      break;

    case 'l':
      ordenar_preco();
      break;

    case 'L':
      ordenar_desc();
      break;

  }

}

int main()
{
  char c;
  char comando;
  while (((c = getchar()) != 'x') && (c != EOF))
  {
    comando = c;
    lis_comandos(comando);
  }

  return 0;
}

