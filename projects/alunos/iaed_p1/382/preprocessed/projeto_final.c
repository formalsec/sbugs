#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int identificador;
  char descricao[64];
  int preco;
  int peso;
  int quantidade;
  int criado;
} produto;
typedef struct 
{
  int num_produtos;
  int criada;
  int peso_encomenda;
  produto produtos[200];
} encomenda;
produto stock[10000];
encomenda encomendas[500];
int idp = 0;
int num_encomendas = 0;
int num_produtos_encomenda = 0;
void novo_produto();
void adiciona_produto_stock();
void nova_encomenda();
void adiciona_produto_encomenda();
void add_produto_encomenda(int quantidade, int ide, int idp);
void guarda_novo_produto_encomenda(int idp, int ide, int quantidade);
void remove_stock_produto();
void remove_produto_encomenda();
void calcula_custo_encomenda();
void altera_preco_produto();
void mostra_produto_encomenda();
void produto_quantidade_max();
void lista_stock();
void guarda_produtos_em_stock(produto stock_produtos[10000]);
void mergesort_produtos(produto stock_produtos[10000], int l, int r);
void merge(produto stock_produtos[10000], int l, int m, int r);
void compara_e_junta_ordenado(produto stock_produtos[10000], produto v_aux[10000], int j, int l, int r, int i);
void mostra_produtos_em_stock(produto stock_produtos[10000]);
void lista_produtos_encomenda();
void guarda_produtos_encomenda(produto produtos_encomenda[200], int ide);
void quicksort_encomenda(produto produtos_encomenda[200], int l, int r);
int partition_encomendas(produto produtos_encomenda[200], int l, int r);
void mostra_produtos_encomenda(produto produtos_encomenda[200], int ide);
int existe_produto_encomenda(int ide, int idp);
int main()
{
  char c;
  while ((c = getchar()) != 'x')
  {
    switch (c)
    {
      case 'a':
        novo_produto();
        break;

      case 'q':
        adiciona_produto_stock();
        break;

      case 'N':
        nova_encomenda();
        break;

      case 'A':
        adiciona_produto_encomenda();
        break;

      case 'r':
        remove_stock_produto();
        break;

      case 'R':
        remove_produto_encomenda();
        break;

      case 'C':
        calcula_custo_encomenda();
        break;

      case 'p':
        altera_preco_produto();
        break;

      case 'E':
        mostra_produto_encomenda();
        break;

      case 'm':
        produto_quantidade_max();
        break;

      case 'l':
        lista_stock();
        break;

      case 'L':
        lista_produtos_encomenda();
        break;

    }

  }

  return 0;
}

void novo_produto()
{
  stock[idp].identificador = idp;
  stock[idp].criado = 1;
  for (int stock_index = 0; stock_index < 10; stock_index++)
  {
    stock[idp].descricao[stock_index] = new_sym_var(sizeof(char) * 8);
  }

  stock[idp].descricao[10 - 1] = '\0';
  stock[idp].preco = new_sym_var(sizeof(int) * 8);
  stock[idp].peso = new_sym_var(sizeof(int) * 8);
  stock[idp].quantidade = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", idp);
  idp = idp + 1;
}

void adiciona_produto_stock()
{
  int idp;
  int quantidade;
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (stock[idp].criado != 0)
  {
    stock[idp].quantidade += quantidade;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void nova_encomenda()
{
  encomendas[num_encomendas].criada = 1;
  printf("Nova encomenda %d.\n", num_encomendas);
  num_encomendas += 1;
}

void adiciona_produto_encomenda()
{
  int ide;
  int idp;
  int quantidade;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (encomendas[ide].criada == 0)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (stock[idp].criado == 0)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (stock[idp].quantidade < quantidade)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if ((encomendas[ide].peso_encomenda + (stock[idp].peso * quantidade)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          add_produto_encomenda(quantidade, ide, idp);
        }

      }

    }

  }

}

void add_produto_encomenda(int quantidade, int ide, int idp)
{
  if (existe_produto_encomenda(ide, idp) == (-1))
  {
    guarda_novo_produto_encomenda(ide, idp, quantidade);
    encomendas[ide].num_produtos += 1;
  }
  else
  {
    encomendas[ide].produtos[existe_produto_encomenda(ide, idp)].quantidade += quantidade;
  }

  encomendas[ide].peso_encomenda += stock[idp].peso * quantidade;
  stock[idp].quantidade -= quantidade;
}

void guarda_novo_produto_encomenda(int ide, int idp, int quantidade)
{
  int idp_e = encomendas[ide].num_produtos;
  encomendas[ide].produtos[idp_e].identificador = idp;
  encomendas[ide].produtos[idp_e].criado = 1;
  encomendas[ide].produtos[idp_e].preco = stock[idp].preco;
  encomendas[ide].produtos[idp_e].peso = stock[idp].peso;
  strcpy(encomendas[ide].produtos[idp_e].descricao, stock[idp].descricao);
  encomendas[ide].produtos[idp_e].quantidade += quantidade;
}

void remove_stock_produto()
{
  int idp;
  int quantidade;
  idp = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (stock[idp].criado == 0)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (stock[idp].quantidade < quantidade)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantidade, idp);
    }
    else
    {
      stock[idp].quantidade -= quantidade;
    }

  }

}

void remove_produto_encomenda()
{
  int ide;
  int idp;
  int i_prod_enc;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (encomendas[ide].criada == 0)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (stock[idp].criado == 0)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if ((i_prod_enc = existe_produto_encomenda(ide, idp)) != (-1))
      {
        stock[idp].quantidade += encomendas[ide].produtos[i_prod_enc].quantidade;
        encomendas[ide].peso_encomenda -= encomendas[ide].produtos[i_prod_enc].quantidade * stock[idp].peso;
        encomendas[ide].produtos[i_prod_enc].quantidade = 0;
      }
      else
      {
        
      }

    }

  }

}

void calcula_custo_encomenda()
{
  int custo_total = 0;
  int idp;
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (encomendas[ide].criada != 0)
  {
    for (idp = 0; idp < encomendas[ide].num_produtos; idp++)
    {
      if (encomendas[ide].produtos[idp].criado != 0)
      {
        custo_total += encomendas[ide].produtos[idp].quantidade * encomendas[ide].produtos[idp].preco;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d %d.\n", ide, custo_total);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void altera_preco_produto()
{
  int idp;
  int novo_preco;
  int i_enc;
  int i_prod;
  idp = new_sym_var(sizeof(int) * 8);
  novo_preco = new_sym_var(sizeof(int) * 8);
  if (stock[idp].criado != 0)
  {
    stock[idp].preco = novo_preco;
    for (i_enc = 0; i_enc < num_encomendas; i_enc++)
    {
      if ((i_prod = existe_produto_encomenda(i_enc, idp)) != (-1))
      {
        encomendas[i_enc].produtos[i_prod].preco = novo_preco;
      }
      else
      {
        
      }

    }

  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

void mostra_produto_encomenda()
{
  int ide;
  int idp;
  int i_prod;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (encomendas[ide].criada == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (stock[idp].criado == 0)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      if ((i_prod = existe_produto_encomenda(ide, idp)) != (-1))
      {
        printf("%s %d.\n", encomendas[ide].produtos[i_prod].descricao, encomendas[ide].produtos[i_prod].quantidade);
      }
      else
      {
        printf("%s 0.\n", stock[idp].descricao);
      }

    }

  }

}

void produto_quantidade_max()
{
  int idp;
  int i_enc;
  int i_prod;
  int quantidade_max = 0;
  int ide_max = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (stock[idp].criado != 0)
  {
    for (i_enc = 0; i_enc < num_encomendas; i_enc++)
    {
      if ((i_prod = existe_produto_encomenda(i_enc, idp)) != (-1))
      {
        if (encomendas[i_enc].produtos[i_prod].quantidade > quantidade_max)
        {
          quantidade_max = encomendas[i_enc].produtos[i_prod].quantidade;
          ide_max = i_enc;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (quantidade_max != 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide_max, quantidade_max);
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }

}

void lista_stock()
{
  produto stock_produtos[10000];
  guarda_produtos_em_stock(stock_produtos);
  mergesort_produtos(stock_produtos, 0, idp - 1);
  mostra_produtos_em_stock(stock_produtos);
}

void guarda_produtos_em_stock(produto stock_produtos[10000])
{
  int i_prod;
  for (i_prod = 0; i_prod < idp; i_prod++)
    stock_produtos[i_prod] = stock[i_prod];

}

void mergesort_produtos(produto stock_produtos[10000], int l, int r)
{
  int m = (l + r) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort_produtos(stock_produtos, l, m);
  mergesort_produtos(stock_produtos, m + 1, r);
  merge(stock_produtos, l, m, r);
}

void merge(produto stock_produtos[10000], int l, int m, int r)
{
  int i;
  int j;
  produto v_aux[10000];
  for (i = m + 1; i > l; i--)
    v_aux[i - 1] = stock_produtos[i - 1];

  for (j = m; j < r; j++)
    v_aux[(r + m) - j] = stock_produtos[j + 1];

  compara_e_junta_ordenado(stock_produtos, v_aux, j, l, r, i);
}

void compara_e_junta_ordenado(produto stock_produtos[10000], produto v_aux[10000], int j, int l, int r, int i)
{
  int k;
  for (k = l; k <= r; k++)
  {
    if (v_aux[j].preco < v_aux[i].preco)
    {
      stock_produtos[k] = v_aux[j--];
    }
    else
    {
      if (v_aux[j].preco == v_aux[i].preco)
      {
        if (v_aux[j].identificador < v_aux[i].identificador)
        {
          stock_produtos[k] = v_aux[j--];
        }
        else
        {
          stock_produtos[k] = v_aux[i++];
        }

      }
      else
      {
        stock_produtos[k] = v_aux[i++];
      }

    }

  }

}

void mostra_produtos_em_stock(produto stock_produtos[10000])
{
  int i_prod;
  printf("Produtos\n");
  for (i_prod = 0; i_prod < idp; i_prod++)
    printf("* %s %d %d\n", stock_produtos[i_prod].descricao, stock_produtos[i_prod].preco, stock_produtos[i_prod].quantidade);

}

void lista_produtos_encomenda()
{
  int ide;
  produto produtos_encomenda[200];
  ide = new_sym_var(sizeof(int) * 8);
  if (encomendas[ide].criada != 0)
  {
    guarda_produtos_encomenda(produtos_encomenda, ide);
    quicksort_encomenda(produtos_encomenda, 0, num_produtos_encomenda - 1);
    mostra_produtos_encomenda(produtos_encomenda, ide);
  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void guarda_produtos_encomenda(produto produtos_encomenda[200], int ide)
{
  int idp;
  int idp_e = 0;
  for (idp = 0; idp < encomendas[ide].num_produtos; idp++)
  {
    if ((encomendas[ide].produtos[idp].criado != 0) && (encomendas[ide].produtos[idp].quantidade > 0))
    {
      produtos_encomenda[idp_e++] = encomendas[ide].produtos[idp];
    }
    else
    {
      
    }

  }

  num_produtos_encomenda = idp_e;
}

void quicksort_encomenda(produto produtos_encomenda[200], int l, int r)
{
  int i;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  i = partition_encomendas(produtos_encomenda, l, r);
  quicksort_encomenda(produtos_encomenda, l, i - 1);
  quicksort_encomenda(produtos_encomenda, i + 1, r);
}

int partition_encomendas(produto produtos_encomenda[200], int l, int r)
{
  int i = l - 1;
  int j = r;
  produto pivot = produtos_encomenda[r];
  while (i < j)
  {
    while (strcmp(pivot.descricao, produtos_encomenda[++i].descricao) > 0)
      ;

    while (strcmp(produtos_encomenda[--j].descricao, pivot.descricao) > 0)
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      produto t = produtos_encomenda[i];
      produtos_encomenda[i] = produtos_encomenda[j];
      produtos_encomenda[j] = t;
    }
    else
    {
      
    }

    ;
  }

  {
    produto t = produtos_encomenda[i];
    produtos_encomenda[i] = produtos_encomenda[r];
    produtos_encomenda[r] = t;
  }
  ;
  return i;
}

void mostra_produtos_encomenda(produto produtos_encomenda[200], int ide)
{
  int idp;
  printf("Encomenda %d\n", ide);
  for (idp = 0; idp < num_produtos_encomenda; idp++)
    printf("* %s %d %d\n", produtos_encomenda[idp].descricao, produtos_encomenda[idp].preco, produtos_encomenda[idp].quantidade);

}

int existe_produto_encomenda(int ide, int idp)
{
  int i_prod;
  if (encomendas[ide].num_produtos > 0)
  {
    for (i_prod = 0; i_prod < encomendas[ide].num_produtos; i_prod++)
    {
      if (encomendas[ide].produtos[i_prod].identificador == idp)
      {
        return i_prod;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  return -1;
}

