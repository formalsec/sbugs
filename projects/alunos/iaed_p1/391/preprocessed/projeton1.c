#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>


typedef struct 
{
  int identifier;
  int price;
  int weight;
  int amount;
  char description[63];
} product;
typedef struct 
{
  int p_id;
  int quantity;
} products_in_delivery;
typedef struct 
{
  int identifier;
  int weight;
  int product_count;
  products_in_delivery list_products[200];
} delivery;
product stock[10000];
delivery list_deliverys[500];
int idp = 0;
int ide = 0;
void addproduct_stock(char description[], int price, int weight, int amount)
{
  product prod;
  if (idp < 10000)
  {
    strcpy(prod.description, description);
    prod.price = price;
    prod.weight = weight;
    prod.amount = amount;
    prod.identifier = idp;
    stock[idp] = prod;
    printf("Novo produto %d.\n", idp);
    idp++;
  }
  else
  {
    
  }

}

void add_product_amount(int identifier, int amount)
{
  if (identifier < idp)
  {
    stock[identifier].amount += amount;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", identifier);
  }

}

void new_delivery()
{
  delivery new_d;
  new_d.identifier = ide;
  new_d.weight = 0;
  new_d.product_count = 0;
  list_deliverys[ide] = new_d;
  printf("Nova encomenda %d.\n", ide);
  ide++;
}

void add_product_to_delivery(int id_delivery, int id_product, int amount)
{
  int item;
  int new_weight;
  int flag = 0;
  if (id_delivery < ide)
  {
    if (id_product < idp)
    {
      if (amount <= stock[id_product].amount)
      {
        new_weight = list_deliverys[id_delivery].weight + (stock[id_product].weight * amount);
        if (new_weight <= 200)
        {
          for (item = 0; item < list_deliverys[id_delivery].product_count; item++)
          {
            if (list_deliverys[id_delivery].list_products[item].p_id == id_product)
            {
              list_deliverys[id_delivery].list_products[item].quantity += amount;
              list_deliverys[id_delivery].weight = new_weight;
              stock[id_product].amount -= amount;
              flag++;
            }
            else
            {
              
            }

          }

          if (flag == 0)
          {
            products_in_delivery new_product;
            new_product.p_id = stock[id_product].identifier;
            new_product.quantity = amount;
            list_deliverys[id_delivery].list_products[list_deliverys[id_delivery].product_count] = new_product;
            list_deliverys[id_delivery].product_count++;
            stock[id_product].amount -= amount;
            list_deliverys[id_delivery].weight = new_weight;
          }
          else
          {
            
          }

        }
        else
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_product, id_delivery);
        }

      }
      else
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_product, id_delivery);
      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id_product, id_delivery);
    }

  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id_product, id_delivery);
  }

}

void remove_product_stock(int identifier, int amount)
{
  if (identifier < idp)
  {
    if (amount <= stock[identifier].amount)
    {
      stock[identifier].amount -= amount;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", amount, identifier);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", identifier);
  }

}

void TESTE_encomenda(int id_delivery)
{
  int i = 0;
  for (i = 0; i < list_deliverys[id_delivery].product_count; i++)
    printf("%d", list_deliverys[id_delivery].list_products[i].p_id);

}

void remove_prod_delivery(int id_delivery, int id_product)
{
  int position;
  int i;
  int ii;
  if (id_delivery < ide)
  {
    if (id_product < idp)
    {
      for (i = 0; i < list_deliverys[id_delivery].product_count; i++)
      {
        if (list_deliverys[id_delivery].list_products[i].p_id == id_product)
        {
          position = i;
          stock[id_product].amount += list_deliverys[id_delivery].list_products[i].quantity;
          list_deliverys[id_delivery].weight -= stock[id_product].weight * list_deliverys[id_delivery].list_products[i].quantity;
          list_deliverys[id_delivery].list_products[i].quantity = 0;
          for (ii = position; ii < (list_deliverys[id_delivery].product_count - 1); ii++)
            list_deliverys[id_delivery].list_products[ii] = list_deliverys[id_delivery].list_products[ii + 1];

          list_deliverys[id_delivery].product_count--;
        }
        else
        {
          
        }

      }

    }
    else
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_product, id_delivery);
    }

  }
  else
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id_product, id_delivery);
  }

}

void delivery_cost(int id_delivery)
{
  int total_price = 0;
  int i = 0;
  if (id_delivery < ide)
  {
    total_price = 0;
    for (i = 0; i < list_deliverys[id_delivery].product_count; i++)
    {
      total_price += stock[list_deliverys[id_delivery].list_products[i].p_id].price * list_deliverys[id_delivery].list_products[i].quantity;
    }

    printf("Custo da encomenda %d %d.\n", id_delivery, total_price);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", id_delivery);
  }

}

void change_product_price(int id_product, int new_price)
{
  if (id_product < idp)
  {
    stock[id_product].price = new_price;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id_product);
  }

}

void print_product(int id_delivery, int id_product)
{
  int i;
  int flag = 0;
  if (id_delivery < ide)
  {
    if (id_product < idp)
    {
      for (i = 0; i < list_deliverys[id_delivery].product_count; i++)
      {
        if (id_product == list_deliverys[id_delivery].list_products[i].p_id)
        {
          printf("%s %d.\n", stock[id_product].description, list_deliverys[id_delivery].list_products[i].quantity);
          flag++;
        }
        else
        {
          
        }

      }

      if (flag == 0)
      {
        printf("%s 0.\n", stock[id_product].description);
      }
      else
      {
        
      }

    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", id_product);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_delivery);
  }

}

void largest_order_by_product(int id_product)
{
  int iddelivery_maxprod = 0;
  int max_amount = 0;
  int i = 0;
  int ii = 0;
  int flag = 0;
  if (id_product < idp)
  {
    for (i = 0; i < ide; i++)
    {
      for (ii = 0; ii < list_deliverys[i].product_count; ii++)
      {
        if (list_deliverys[i].list_products[ii].p_id == id_product)
        {
          if (flag == 0)
          {
            flag++;
          }
          else
          {
            
          }

          if (list_deliverys[i].list_products[ii].quantity > max_amount)
          {
            max_amount = list_deliverys[i].list_products[ii].quantity;
            iddelivery_maxprod = i;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    if (flag != 0)
    {
      printf("Maximo produto %d %d %d.\n", id_product, iddelivery_maxprod, max_amount);
    }
    else
    {
      return;
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id_product);
  }

}

void initialize_stock_price_index(int stock_price_index[])
{
  int i;
  for (i = 0; i < idp; i++)
    stock_price_index[i] = i;

}

int quicksort_partition_price(int stock_pri[], int l, int r)
{
  int pivot = r;
  int left = l - 1;
  int right = r;
  int save_num;
  while (left < right)
  {
    while (stock[stock_pri[++left]].price < stock[stock_pri[pivot]].price)
      ;

    while ((left != right) && (stock[stock_pri[--right]].price > stock[stock_pri[pivot]].price))
      ;

    if (left < right)
    {
      save_num = stock_pri[left];
      stock_pri[left] = stock_pri[right];
      stock_pri[right] = save_num;
    }
    else
    {
      
    }

  }

  save_num = stock_pri[left];
  stock_pri[left] = stock_pri[pivot];
  stock_pri[pivot] = save_num;
  return left;
}

void quicksort_price(int stock_p[], int left, int right)
{
  int i;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  i = quicksort_partition_price(stock_p, left, right);
  quicksort_price(stock_p, left, i - 1);
  quicksort_price(stock_p, i + 1, right);
}

int quicksort_partition_idp(int stock_pri[], int l, int r)
{
  int pivot = r;
  int left = l - 1;
  int right = r;
  int save_num;
  while (left < right)
  {
    while (stock[stock_pri[++left]].identifier < stock[stock_pri[pivot]].identifier)
      ;

    while ((left != right) && (stock[stock_pri[--right]].identifier > stock[stock_pri[pivot]].identifier))
      ;

    if (left < right)
    {
      save_num = stock_pri[left];
      stock_pri[left] = stock_pri[right];
      stock_pri[right] = save_num;
    }
    else
    {
      
    }

  }

  save_num = stock_pri[left];
  stock_pri[left] = stock_pri[pivot];
  stock_pri[pivot] = save_num;
  return left;
}

void quicksort_idp(int stock_p[], int left, int right)
{
  int i;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  i = quicksort_partition_idp(stock_p, left, right);
  quicksort_idp(stock_p, left, i - 1);
  quicksort_idp(stock_p, i + 1, right);
}

void print_stock_product_by_price()
{
  int stock_price_index[10000];
  int i;
  int l;
  int i1 = 0;
  int r = 0;
  int flag;
  int left = 0;
  int right = idp - 1;
  initialize_stock_price_index(stock_price_index);
  quicksort_price(stock_price_index, left, right);
  while (i1 < (idp - 1))
  {
    flag = 0;
    if (stock[stock_price_index[i1]].price == stock[stock_price_index[i1 + 1]].price)
    {
      flag++;
      r = i1;
      l = i1;
      while ((r < (idp - 1)) && (stock[stock_price_index[r]].price == stock[stock_price_index[r + 1]].price))
        r++;

      quicksort_idp(stock_price_index, l, r);
    }
    else
    {
      
    }

    if (flag == 0)
    {
      i1++;
    }
    else
    {
      i1 = r;
    }

  }

  printf("Produtos\n");
  for (i = 0; i < idp; i++)
    printf("* %s %d %d\n", stock[stock_price_index[i]].description, stock[stock_price_index[i]].price, stock[stock_price_index[i]].amount);

}

void initialize_delivery_products_index(int delivery_products_index[], int id_delivery)
{
  int i;
  for (i = 0; i < list_deliverys[id_delivery].product_count; i++)
  {
    delivery_products_index[i] = list_deliverys[id_delivery].list_products[i].p_id;
  }

}

int quicksort_partition_alphabetical(int delivery_products_index[], int l, int r)
{
  int pivot = r;
  int left = l - 1;
  int right = r;
  int save_num;
  while (left < right)
  {
    while (strcmp(stock[delivery_products_index[++left]].description, stock[delivery_products_index[pivot]].description) < 0)
      ;

    while ((left != right) && (strcmp(stock[delivery_products_index[--right]].description, stock[delivery_products_index[pivot]].description) > 0))
      ;

    if ((left < right) && (strcmp(stock[delivery_products_index[left]].description, stock[delivery_products_index[right]].description) > 0))
    {
      save_num = delivery_products_index[left];
      delivery_products_index[left] = delivery_products_index[right];
      delivery_products_index[right] = save_num;
    }
    else
    {
      
    }

  }

  save_num = delivery_products_index[left];
  delivery_products_index[left] = delivery_products_index[pivot];
  delivery_products_index[pivot] = save_num;
  return left;
}

void quicksort_alphabetical(int stock_p[], int left, int right)
{
  int i;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  i = quicksort_partition_alphabetical(stock_p, left, right);
  quicksort_alphabetical(stock_p, left, i - 1);
  quicksort_alphabetical(stock_p, i + 1, right);
}

void print_delivery_products_alphabetically(int id_delivery)
{
  int delivery_products_index[200];
  int i = 0;
  int delivery_products_quantities[200];
  int left = 0;
  int right = list_deliverys[id_delivery].product_count - 1;
  int x;
  int w;
  if (id_delivery < ide)
  {
    initialize_delivery_products_index(delivery_products_index, id_delivery);
    quicksort_alphabetical(delivery_products_index, left, right);
    printf("Encomenda %d\n", id_delivery);
    if (list_deliverys[id_delivery].product_count > 0)
    {
      for (x = 0; x < list_deliverys[id_delivery].product_count; x++)
      {
        for (w = 0; w < list_deliverys[id_delivery].product_count; w++)
        {
          if (list_deliverys[id_delivery].list_products[w].p_id == delivery_products_index[x])
          {
            delivery_products_quantities[x] = list_deliverys[id_delivery].list_products[w].quantity;
          }
          else
          {
            
          }

        }

      }

      for (i = 0; i < list_deliverys[id_delivery].product_count; i++)
        printf("* %s %d %d\n", stock[delivery_products_index[i]].description, stock[delivery_products_index[i]].price, delivery_products_quantities[i]);

    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_delivery);
  }

}

bool parse_command(char input[])
{
  int identifier = 0;
  int price = 0;
  int weight = 0;
  int amount = 0;
  int id_delivery = 0;
  int id_product = 0;
  int new_price = 0;
  char description[63];
  char command[1];
  char parameters[255];
  for (int command_index = 0; command_index < 1; command_index++)
  {
    command[command_index] = new_sym_var(sizeof(char) * 8);
  }

  command[1 - 1] = '\0';
  for (int parameters_index = 0; parameters_index < 10; parameters_index++)
  {
    parameters[parameters_index] = new_sym_var(sizeof(char) * 8);
  }

  parameters[10 - 1] = '\0';
  switch (command[0])
  {
    case 'a':
    {
      for (int description_index = 0; description_index < 10; description_index++)
      {
        description[description_index] = new_sym_var(sizeof(char) * 8);
      }

      description[10 - 1] = '\0';
      price = new_sym_var(sizeof(int) * 8);
      weight = new_sym_var(sizeof(int) * 8);
      amount = new_sym_var(sizeof(int) * 8);
      addproduct_stock(description, price, weight, amount);
      break;
    }

    case 'q':
      identifier = new_sym_var(sizeof(int) * 8);
      amount = new_sym_var(sizeof(int) * 8);
      add_product_amount(identifier, amount);
      break;

    case 'N':
      new_delivery();
      break;

    case 'A':
      id_delivery = new_sym_var(sizeof(int) * 8);
      id_product = new_sym_var(sizeof(int) * 8);
      amount = new_sym_var(sizeof(int) * 8);
      add_product_to_delivery(id_delivery, id_product, amount);
      break;

    case 'r':
      identifier = new_sym_var(sizeof(int) * 8);
      amount = new_sym_var(sizeof(int) * 8);
      remove_product_stock(identifier, amount);
      break;

    case 'R':
      id_delivery = new_sym_var(sizeof(int) * 8);
      id_product = new_sym_var(sizeof(int) * 8);
      remove_prod_delivery(id_delivery, id_product);
      break;

    case 'C':
      id_delivery = new_sym_var(sizeof(int) * 8);
      delivery_cost(id_delivery);
      break;

    case 'p':
      id_product = new_sym_var(sizeof(int) * 8);
      new_price = new_sym_var(sizeof(int) * 8);
      change_product_price(id_product, new_price);
      break;

    case 'E':
    {
      id_delivery = new_sym_var(sizeof(int) * 8);
      id_product = new_sym_var(sizeof(int) * 8);
      print_product(id_delivery, id_product);
      break;
    }

    case 'm':
    {
      id_product = new_sym_var(sizeof(int) * 8);
      largest_order_by_product(id_product);
      break;
    }

    case 'l':
      print_stock_product_by_price();
      break;

    case 'L':
      id_delivery = new_sym_var(sizeof(int) * 8);
      print_delivery_products_alphabetically(id_delivery);
      break;

    case 'x':
      return false;

  }

  return true;
}

void read_and_parse_commands()
{
  char input[4000];
  do
  {
    fgets(input, 4000, stdin);
  }
  while (parse_command(input));
}

int main()
{
  read_and_parse_commands();
  return 0;
}

