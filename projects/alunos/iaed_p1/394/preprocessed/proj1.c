#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct product
{
  int id;
  int price;
  int weight;
  int stock;
  char desc[63];
} Product;
typedef struct order
{
  int id;
  int cost;
  int weight;
  int orderProdId;
  int orderProd[200][2];
} Order;
Product products[10000];
Order orders[500];
int productsId;
int ordersId;
void addProduct();
void addStock();
void removeStock();
void newOrder();
void addProductToOrder();
void removeProductFromOrder();
void orderCost();
void changePrice();
void listOrderDescQtd();
void listMostOrderId();
void listProductsByPrice();
void listOrderByDesc();
void init();
void updateValuesAddProductToOrder(int, int, int, int, int);
void quickSortByPrice(Product products[], int, int);
int quickSortPartitionByPrice(Product products[], int, int);
void quickSortByDesc(int prod[][2], int, int);
int quickSortPartitionByDesc(int prod[][2], int, int);
void swapProd(Product prod[], int, int);
void swapProdDesc(int prod[][2], int, int);
int main()
{
  int progRun = 1;
  char command;
  init();
  while (progRun)
  {
    switch (command = getchar())
    {
      case 'a':
        getchar();
        addProduct();
        break;

      case 'q':
        addStock();
        break;

      case 'r':
        removeStock();
        break;

      case 'N':
        newOrder();
        break;

      case 'A':
        addProductToOrder();
        break;

      case 'R':
        removeProductFromOrder();
        break;

      case 'C':
        orderCost();
        break;

      case 'p':
        changePrice();
        break;

      case 'E':
        listOrderDescQtd();
        break;

      case 'm':
        listMostOrderId();
        break;

      case 'l':
        listProductsByPrice();
        break;

      case 'L':
        listOrderByDesc();
        break;

      case 'x':
        progRun = 0;
        break;

    }

    getchar();
  }

  return 0;
}

void addProduct()
{
  for (int products_index = 0; products_index < 10; products_index++)
  {
    products[productsId].desc[products_index] = new_sym_var(sizeof(char) * 8);
  }

  products[productsId].desc[10 - 1] = '\0';
  products[productsId].price = new_sym_var(sizeof(int) * 8);
  products[productsId].weight = new_sym_var(sizeof(int) * 8);
  products[productsId].stock = new_sym_var(sizeof(int) * 8);
  products[productsId].id = productsId;
  printf("Novo produto %d.\n", productsId);
  productsId++;
}

void addStock()
{
  int idp;
  int stock;
  idp = new_sym_var(sizeof(int) * 8);
  stock = new_sym_var(sizeof(int) * 8);
  if (products[idp].id != (-1))
  {
    products[idp].stock += stock;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void removeStock()
{
  int idp;
  int stock;
  idp = new_sym_var(sizeof(int) * 8);
  stock = new_sym_var(sizeof(int) * 8);
  if (products[idp].id != (-1))
  {
    if ((products[idp].stock - stock) >= 0)
    {
      products[idp].stock -= stock;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", stock, idp);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }

}

void newOrder()
{
  orders[ordersId].id = ordersId;
  printf("Nova encomenda %d.\n", ordersId);
  ordersId++;
}

void addProductToOrder()
{
  int ide;
  int idp;
  int qty;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (orders[ide].id != (-1))
  {
    if (products[idp].id != (-1))
    {
      if ((products[idp].stock - qty) >= 0)
      {
        if ((orders[ide].weight + (qty * products[idp].weight)) <= 200)
        {
          for (i = 0; i < orders[ide].orderProdId; i++)
          {
            if (orders[ide].orderProd[i][0] == idp)
            {
              updateValuesAddProductToOrder(ide, idp, i, qty, 1);
              return;
            }
            else
            {
              
            }

          }

          if (orders[ide].orderProdId == 200)
          {
            for (i = 0; i < orders[ide].orderProdId; i++)
            {
              if (orders[ide].orderProd[i][1] == 0)
              {
                updateValuesAddProductToOrder(ide, idp, i, qty, 0);
                return;
              }
              else
              {
                
              }

            }

          }
          else
          {
            updateValuesAddProductToOrder(ide, idp, orders[ide].orderProdId, qty, 0);
            orders[ide].orderProdId++;
          }

        }
        else
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }

      }
      else
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void removeProductFromOrder()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (orders[ide].id != (-1))
  {
    if (products[idp].id != (-1))
    {
      for (i = 0; i < orders[ide].orderProdId; i++)
      {
        if (orders[ide].orderProd[i][0] == idp)
        {
          orders[ide].cost -= orders[ide].orderProd[i][1] * products[orders[ide].orderProd[i][0]].price;
          orders[ide].weight -= orders[ide].orderProd[i][1] * products[orders[ide].orderProd[i][0]].weight;
          products[idp].stock += orders[ide].orderProd[i][1];
          orders[ide].orderProd[i][1] = 0;
        }
        else
        {
          
        }

      }

    }
    else
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }

  }
  else
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }

}

void orderCost()
{
  int ide;
  ide = new_sym_var(sizeof(int) * 8);
  if (orders[ide].id != (-1))
  {
    printf("Custo da encomenda %d %d.\n", ide, orders[ide].cost);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void changePrice()
{
  int idp;
  int price;
  int i;
  int j;
  int prevPrice = 0;
  idp = new_sym_var(sizeof(int) * 8);
  price = new_sym_var(sizeof(int) * 8);
  if (products[idp].id != (-1))
  {
    prevPrice = products[idp].price;
    products[idp].price = price;
    for (i = 0; i < ordersId; i++)
    {
      for (j = 0; j < orders[i].orderProdId; j++)
      {
        if (orders[i].orderProd[j][0] == idp)
        {
          orders[i].cost += (price - prevPrice) * orders[i].orderProd[j][1];
          break;
        }
        else
        {
          
        }

      }

    }

  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }

}

void listOrderDescQtd()
{
  int ide;
  int idp;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (orders[ide].id != (-1))
  {
    if (products[idp].id != (-1))
    {
      for (i = 0; i < orders[ide].orderProdId; i++)
      {
        if (orders[ide].orderProd[i][0] == idp)
        {
          printf("%s %d.\n", products[orders[ide].orderProd[i][0]].desc, orders[ide].orderProd[i][1]);
          return;
        }
        else
        {
          
        }

      }

      printf("%s 0.\n", products[idp].desc);
    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void listMostOrderId()
{
  int idp;
  int i;
  int j;
  int maxId = 0;
  int maxProdId = 0;
  int tempQty = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (products[idp].id != (-1))
  {
    if (ordersId == 0)
    {
      return;
    }
    else
    {
      
    }

    for (i = 0; i < ordersId; i++)
    {
      for (j = 0; j < orders[i].orderProdId; j++)
      {
        if ((orders[i].orderProd[j][0] == idp) && (tempQty < orders[i].orderProd[j][1]))
        {
          tempQty = orders[i].orderProd[j][1];
          maxId = i;
          maxProdId = j;
          break;
        }
        else
        {
          
        }

      }

    }

    if (tempQty > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, maxId, orders[maxId].orderProd[maxProdId][1]);
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }

}

void listProductsByPrice()
{
  int i;
  Product tempProducts[10000];
  for (i = 0; i < productsId; i++)
  {
    tempProducts[i] = products[i];
  }

  quickSortByPrice(tempProducts, 0, productsId - 1);
  printf("Produtos\n");
  for (i = 0; i < productsId; i++)
  {
    printf("* %s %d %d\n", tempProducts[i].desc, tempProducts[i].price, tempProducts[i].stock);
  }

}

void listOrderByDesc()
{
  int i;
  int ide;
  int tempOrderProd[200][2];
  ide = new_sym_var(sizeof(int) * 8);
  if (orders[ide].id != (-1))
  {
    for (i = 0; i < orders[ide].orderProdId; i++)
    {
      tempOrderProd[i][0] = orders[ide].orderProd[i][0];
      tempOrderProd[i][1] = orders[ide].orderProd[i][1];
    }

    quickSortByDesc(tempOrderProd, 0, orders[ide].orderProdId - 1);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < orders[ide].orderProdId; i++)
    {
      if (tempOrderProd[i][1] != 0)
      {
        printf("* %s %d %d\n", products[tempOrderProd[i][0]].desc, products[tempOrderProd[i][0]].price, tempOrderProd[i][1]);
      }
      else
      {
        
      }

    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }

}

void init()
{
  int i;
  for (i = 0; i < 10000; i++)
  {
    products[i].id = -1;
  }

  for (i = 0; i < 500; i++)
  {
    orders[i].id = -1;
  }

}

void updateValuesAddProductToOrder(int tempIde, int tempIdp, int prodIndex, int tempQtd, int exists)
{
  if (!exists)
  {
    orders[tempIde].orderProd[prodIndex][0] = products[tempIdp].id;
  }
  else
  {
    
  }

  orders[tempIde].orderProd[prodIndex][1] += tempQtd;
  products[tempIdp].stock -= tempQtd;
  orders[tempIde].weight += tempQtd * products[tempIdp].weight;
  orders[tempIde].cost += tempQtd * products[tempIdp].price;
}

void quickSortByPrice(Product prod[], int l, int h)
{
  int i;
  if (h <= l)
  {
    return;
  }
  else
  {
    
  }

  i = quickSortPartitionByPrice(prod, l, h);
  quickSortByPrice(prod, l, i - 1);
  quickSortByPrice(prod, i + 1, h);
}

int quickSortPartitionByPrice(Product prod[], int l, int h)
{
  int i;
  int j;
  i = l - 1;
  j = h;
  while (i < j)
  {
    while ((prod[++i].price < prod[h].price) || ((prod[i].price == prod[h].price) && (prod[i].id < prod[h].id)))
      ;

    while ((prod[--j].price > prod[h].price) || ((prod[j].price == prod[h].price) && (prod[j].id > prod[h].id)))
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      swapProd(prod, i, j);
    }
    else
    {
      
    }

  }

  swapProd(prod, i, h);
  return i;
}

void quickSortByDesc(int prod[][2], int l, int h)
{
  int i;
  if (h <= l)
  {
    return;
  }
  else
  {
    
  }

  i = quickSortPartitionByDesc(prod, l, h);
  quickSortByDesc(prod, l, i - 1);
  quickSortByDesc(prod, i + 1, h);
}

int quickSortPartitionByDesc(int prod[][2], int l, int h)
{
  int i;
  int j;
  i = l - 1;
  j = h;
  while (i < j)
  {
    while (strcmp(products[prod[++i][0]].desc, products[prod[h][0]].desc) < 0)
      ;

    while (strcmp(products[prod[--j][0]].desc, products[prod[h][0]].desc) > 0)
    {
      if (j == l)
      {
        break;
      }
      else
      {
        
      }

    }

    if (i < j)
    {
      swapProdDesc(prod, i, j);
    }
    else
    {
      
    }

  }

  swapProdDesc(prod, i, h);
  return i;
}

void swapProd(Product prod[], int i, int j)
{
  Product temp;
  temp = prod[i];
  prod[i] = prod[j];
  prod[j] = temp;
}

void swapProdDesc(int prod[][2], int i, int j)
{
  int temp;
  temp = prod[i][0];
  prod[i][0] = prod[j][0];
  prod[j][0] = temp;
  temp = prod[i][1];
  prod[i][1] = prod[j][1];
  prod[j][1] = temp;
}

