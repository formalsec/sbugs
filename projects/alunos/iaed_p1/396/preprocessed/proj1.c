/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


struct produtos
{
  int idp;
  char des[63];
  int preco;
  int peso;
  int qtd;
};
struct encomendas
{
  int ide;
  int peso;
  int cpe;
  int preco;
  struct produtos listagem[200];
};
int i;
int cide = 0;
int cidp = 0;
struct encomendas encomenda[500];
struct produtos produto[10000];
struct produtos auxproduto[10000];
struct produtos aux[10000];
struct encomendas aux2[500];
void mergep(struct produtos a[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = a[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = a[j + 1];

  for (k = left; k <= right; k++)
    if ((aux[j].preco < aux[i].preco) || (i > m))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

void mergesortp(struct produtos a[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesortp(a, left, m);
  mergesortp(a, m + 1, right);
  mergep(a, left, m, right);
}

void merges(struct encomendas a[], int id, int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux2[id].listagem[i - 1] = a[id].listagem[i - 1];

  for (j = m; j < right; j++)
    aux2[id].listagem[(right + m) - j] = a[id].listagem[j + 1];

  for (k = left; k <= right; k++)
    if ((strcmp(aux2[id].listagem[j].des, aux2[id].listagem[i].des) < 0) || (i > m))
  {
    a[id].listagem[k] = aux2[id].listagem[j--];
  }
  else
  {
    a[id].listagem[k] = aux2[id].listagem[i++];
  }


}

void mergesorts(struct encomendas a[], int id, int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesorts(a, id, left, m);
  mergesorts(a, id, m + 1, right);
  merges(a, id, left, m, right);
}

void criaProduto()
{
  for (int produto_index = 0; produto_index < 10; produto_index++)
  {
    produto[cidp].des[produto_index] = new_sym_var(sizeof(char) * 8);
  }

  produto[cidp].des[10 - 1] = '\0';
  produto[cidp].preco = new_sym_var(sizeof(int) * 8);
  produto[cidp].peso = new_sym_var(sizeof(int) * 8);
  produto[cidp].qtd = new_sym_var(sizeof(int) * 8);
  produto[cidp].idp = cidp;
  printf("Novo produto %d.\n", produto[cidp].idp);
  cidp++;
}

void adiconaQuantidade()
{
  int idpt;
  int addqtd;
  idpt = new_sym_var(sizeof(int) * 8);
  addqtd = new_sym_var(sizeof(int) * 8);
  if (idpt < cidp)
  {
    produto[idpt].qtd += addqtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idpt);
  }

}

void criaEncomenda()
{
  encomenda[cide].ide = 0;
  encomenda[cide].peso = 0;
  encomenda[cide].cpe = 0;
  encomenda[cide].preco = 0;
  printf("Nova encomenda %d.\n", cide);
  cide++;
}

void adicionaProdutoEncomenda()
{
  int j;
  int idet;
  int idpt;
  int qtdt;
  int modo = 0;
  idet = new_sym_var(sizeof(int) * 8);
  idpt = new_sym_var(sizeof(int) * 8);
  qtdt = new_sym_var(sizeof(int) * 8);
  if (idet < cide)
  {
    if (idpt < cidp)
    {
      if ((produto[idpt].qtd - qtdt) >= 0)
      {
        for (j = 0; j < encomenda[idet].cpe; j++)
        {
          if (encomenda[idet].listagem[j].idp == idpt)
          {
            if ((encomenda[idet].peso + (qtdt * encomenda[idet].listagem[j].peso)) > 200)
            {
              modo = 1;
              printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idpt, idet);
              break;
            }
            else
            {
              encomenda[idet].listagem[j].qtd += qtdt;
              produto[idpt].qtd -= qtdt;
              encomenda[idet].peso += qtdt * produto[idpt].peso;
              modo = 1;
              break;
            }

          }
          else
          {
            
          }

        }

        if (modo == 0)
        {
          if ((encomenda[idet].peso + (qtdt * produto[idpt].peso)) > 200)
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idpt, idet);
          }
          else
          {
            encomenda[idet].listagem[encomenda[idet].cpe] = produto[idpt];
            encomenda[idet].listagem[encomenda[idet].cpe].qtd = qtdt;
            encomenda[idet].peso += qtdt * produto[idpt].peso;
            encomenda[idet].cpe++;
            produto[idpt].qtd -= qtdt;
          }

        }
        else
        {
          
        }

      }
      else
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idpt, idet);
      }

    }
    else
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idpt, idet);
    }

  }
  else
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idpt, idet);
  }

}

void removeQuantidade()
{
  int idpt;
  int rqtd;
  idpt = new_sym_var(sizeof(int) * 8);
  rqtd = new_sym_var(sizeof(int) * 8);
  if (idpt < cidp)
  {
    if ((produto[idpt].qtd - rqtd) >= 0)
    {
      produto[idpt].qtd -= rqtd;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", rqtd, idpt);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idpt);
  }

}

void removeProdutoEncomenda()
{
  int modo = 0;
  int j;
  int idet;
  int idpt;
  idet = new_sym_var(sizeof(int) * 8);
  idpt = new_sym_var(sizeof(int) * 8);
  if (idet < cide)
  {
    if (idpt < cidp)
    {
      for (j = 0; j < encomenda[idet].cpe; j++)
      {
        if ((modo == 0) && (encomenda[idet].listagem[j].idp == idpt))
        {
          produto[idpt].qtd += encomenda[idet].listagem[j].qtd;
          encomenda[idet].peso -= encomenda[idet].listagem[j].qtd * encomenda[idet].listagem[j].peso;
          modo = 1;
        }
        else
        {
          if (modo == 1)
          {
            encomenda[idet].listagem[j - 1] = encomenda[idet].listagem[j];
          }
          else
          {
            
          }

        }

        if ((modo == 1) && (encomenda[idet].cpe == (j + 1)))
        {
          encomenda[idet].cpe--;
        }
        else
        {
          
        }

      }

    }
    else
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idpt, idet);
    }

  }
  else
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idpt, idet);
  }

}

void listaProdutoPreco()
{
  int j;
  for (j = 0; j < cidp; j++)
    auxproduto[j] = produto[j];

  mergesortp(auxproduto, 0, cidp - 1);
  printf("Produtos\n");
  for (j = 0; j < cidp; j++)
    printf("* %s %d %d\n", auxproduto[j].des, auxproduto[j].preco, auxproduto[j].qtd);

}

void listaDescricaoQuantidade()
{
  int j;
  int idet;
  int idpt;
  int modo = 0;
  idet = new_sym_var(sizeof(int) * 8);
  idpt = new_sym_var(sizeof(int) * 8);
  if (idet < cide)
  {
    if (idpt < cidp)
    {
      for (j = 0; j < encomenda[idet].cpe; j++)
      {
        if (encomenda[idet].listagem[j].idp == idpt)
        {
          printf("%s %d.\n", encomenda[idet].listagem[j].des, encomenda[idet].listagem[j].qtd);
          modo = 1;
          break;
        }
        else
        {
          
        }

      }

      if (modo == 0)
      {
        printf("%s 0.\n", produto[idpt].des);
      }
      else
      {
        
      }

    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idpt);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idet);
  }

}

void alteraPreco()
{
  int precot;
  int idpt;
  idpt = new_sym_var(sizeof(int) * 8);
  precot = new_sym_var(sizeof(int) * 8);
  if (idpt < cidp)
  {
    produto[idpt].preco = precot;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idpt);
  }

}

void encomendaMaiorQuantidade()
{
  int j;
  int k;
  int idpt;
  int idep;
  int max;
  int modo = 0;
  idpt = new_sym_var(sizeof(int) * 8);
  if (idpt < cidp)
  {
    for (j = 0; j < cide; j++)
    {
      for (k = 0; k < encomenda[j].cpe; k++)
      {
        if ((encomenda[j].listagem[k].idp == idpt) && (modo == 0))
        {
          max = encomenda[j].listagem[k].qtd;
          idep = j;
          modo = 1;
          break;
        }
        else
        {
          if (((encomenda[j].listagem[k].idp == idpt) && (modo == 1)) && (encomenda[j].listagem[k].qtd > max))
          {
            max = encomenda[j].listagem[k].qtd;
            idep = j;
            break;
          }
          else
          {
            
          }

        }

      }

    }

    if (modo == 1)
    {
      printf("Maximo produto %d %d %d.\n", idpt, idep, max);
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idpt);
  }

}

void ordenaEncomendaDescricao()
{
  int j;
  int idet;
  idet = new_sym_var(sizeof(int) * 8);
  mergesorts(encomenda, idet, 0, encomenda[idet].cpe - 1);
  if (idet < cide)
  {
    printf("Encomenda %d\n", idet);
    for (j = 0; j < encomenda[idet].cpe; j++)
      printf("* %s %d %d\n", encomenda[idet].listagem[j].des, produto[encomenda[idet].listagem[j].idp].preco, encomenda[idet].listagem[j].qtd);

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idet);
  }

}

void calculaPreco()
{
  int j;
  int idet;
  idet = new_sym_var(sizeof(int) * 8);
  if (idet < cide)
  {
    encomenda[idet].preco = 0;
    for (j = 0; j < encomenda[idet].cpe; j++)
      encomenda[idet].preco += encomenda[idet].listagem[j].qtd * produto[encomenda[idet].listagem[j].idp].preco;

    printf("Custo da encomenda %d %d.\n", idet, encomenda[idet].preco);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", idet);
  }

}

int main()
{
  while (((i = getchar()) != EOF) && (i != 'x'))
  {
    switch (i)
    {
      case 'a':
        criaProduto();
        break;

      case 'q':
        adiconaQuantidade();
        break;

      case 'N':
        criaEncomenda();
        break;

      case 'A':
        adicionaProdutoEncomenda();
        break;

      case 'r':
        removeQuantidade();
        break;

      case 'R':
        removeProdutoEncomenda();
        break;

      case 'C':
        calculaPreco();
        break;

      case 'p':
        alteraPreco();
        break;

      case 'E':
        listaDescricaoQuantidade();
        break;

      case 'm':
        encomendaMaiorQuantidade();
        break;

      case 'l':
        listaProdutoPreco();
        break;

      case 'L':
        ordenaEncomendaDescricao();
        break;

    }

  }

  return 0;
}

