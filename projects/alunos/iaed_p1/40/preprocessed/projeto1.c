#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  char desc[64];
  int price;
  int weight;
  int qtd;
  int enc[500];
} System;
System sys[10000];
typedef struct 
{
  int idp;
  char desc[64];
  int price;
  int qtd;
} Listpr;
Listpr lp[10000];
Listpr aux[10000];
int npr = 0;
int nenc = 0;
void mergepriceSort(int left, int m, int right, Listpr a[])
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if (aux[j].price < aux[i].price)
    {
      a[k] = aux[j--];
    }
    else
    {
      if ((aux[j].price == aux[i].price) && (aux[j].idp < aux[i].idp))
      {
        a[k] = aux[j--];
      }
      else
      {
        a[k] = aux[i++];
      }

    }

  }

}

void mergeprice(int left, int right, Listpr a[])
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergeprice(left, m, a);
  mergeprice(m + 1, right, a);
  mergepriceSort(left, m, right, a);
}

void mergedescSort(int left, int m, int right, Listpr a[])
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = a[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = a[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if (strcmp(aux[j].desc, aux[i].desc) < 0)
    {
      a[k] = aux[j--];
    }
    else
    {
      a[k] = aux[i++];
    }

  }

}

void mergedesc(int left, int right, Listpr a[])
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergedesc(left, m, a);
  mergedesc(m + 1, right, a);
  mergedescSort(left, m, right, a);
}

void __a__()
{
  getchar();
  for (int sys_index = 0; sys_index < 10; sys_index++)
  {
    sys[npr].desc[sys_index] = new_sym_var(sizeof(char) * 8);
  }

  sys[npr].desc[10 - 1] = '\0';
  sys[npr].price = new_sym_var(sizeof(int) * 8);
  sys[npr].weight = new_sym_var(sizeof(int) * 8);
  sys[npr].qtd = new_sym_var(sizeof(int) * 8);
  if (npr >= 10000)
  {
    memset(&sys[npr], 0, sizeof(System));
  }
  else
  {
    printf("Novo produto %d.\n", npr++);
  }

}

void __q__()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp < npr)
  {
    sys[idp].qtd += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void __N__()
{
  if (nenc < 500)
  {
    printf("Nova encomenda %d.\n", nenc++);
  }
  else
  {
    
  }

}

void __A__()
{
  int ide;
  int idp;
  int qtd;
  int weighttotal = 0;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (ide >= nenc)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp >= npr)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (sys[idp].qtd < qtd)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < npr; i++)
  {
    weighttotal += sys[i].enc[ide] * sys[i].weight;
  }

  if ((weighttotal + (sys[idp].weight * qtd)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  sys[idp].qtd -= qtd;
  sys[idp].enc[ide] += qtd;
}

void __r__()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= npr)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (sys[idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      sys[idp].qtd -= qtd;
    }

  }

}

void __R__()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= nenc)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (idp >= npr)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  sys[idp].qtd += sys[idp].enc[ide];
  sys[idp].enc[ide] = 0;
}

void __C__()
{
  int ide;
  int pricetotal = 0;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= nenc)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < npr; i++)
  {
    pricetotal += sys[i].price * sys[i].enc[ide];
  }

  printf("Custo da encomenda %d %d.\n", ide, pricetotal);
}

void __p__()
{
  int idp;
  int price;
  idp = new_sym_var(sizeof(int) * 8);
  price = new_sym_var(sizeof(int) * 8);
  if (idp >= npr)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    sys[idp].price = price;
  }

}

void __E__()
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (npr <= idp)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (nenc <= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  printf("%s %d.\n", sys[idp].desc, sys[idp].enc[ide]);
}

void __m__()
{
  int i;
  int idp;
  int qtdmax = 0;
  int encmax = 0;
  int flag = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (npr <= idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < nenc; i++)
  {
    if (sys[idp].enc[i] > qtdmax)
    {
      qtdmax = sys[idp].enc[i];
      encmax = i;
      flag = 1;
    }
    else
    {
      
    }

  }

  if (flag)
  {
    printf("Maximo produto %d %d %d.\n", idp, encmax, qtdmax);
  }
  else
  {
    
  }

}

void __l__()
{
  int left = 0;
  int right = npr - 1;
  int m;
  int l;
  memset(lp, 0, (sizeof(Listpr)) * npr);
  printf("Produtos\n");
  for (l = 0; l < npr; l++)
  {
    lp[l].idp = l;
    strcpy(lp[l].desc, sys[l].desc);
    lp[l].price = sys[l].price;
    lp[l].qtd = sys[l].qtd;
  }

  mergeprice(left, right, lp);
  for (m = 0; m < npr; m++)
  {
    printf("* %s %d %d\n", lp[m].desc, lp[m].price, lp[m].qtd);
  }

}

void __L__()
{
  int ide;
  int l;
  int right;
  int left = 0;
  int m;
  int num = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (nenc <= ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  memset(lp, 0, (sizeof(Listpr)) * npr);
  printf("Encomenda %d\n", ide);
  for (l = 0; l < npr; l++)
  {
    if (sys[l].enc[ide] != 0)
    {
      strcpy(lp[num].desc, sys[l].desc);
      lp[num].price = sys[l].price;
      lp[num++].qtd = sys[l].enc[ide];
    }
    else
    {
      
    }

  }

  right = num - 1;
  mergedesc(left, right, lp);
  for (m = 0; m < num; m++)
  {
    printf("* %s %d %d\n", lp[m].desc, lp[m].price, lp[m].qtd);
  }

}

int main()
{
  char command;
  while ((command = getchar()) != 'x')
  {
    switch (command)
    {
      case 'a':
        __a__();
        break;

      case 'q':
        __q__();
        break;

      case 'N':
        __N__();
        break;

      case 'A':
        __A__();
        break;

      case 'r':
        __r__();
        break;

      case 'R':
        __R__();
        break;

      case 'C':
        __C__();
        break;

      case 'p':
        __p__();
        break;

      case 'E':
        __E__();
        break;

      case 'm':
        __m__();
        break;

      case 'l':
        __l__();
        break;

      case 'L':
        __L__();
        break;

    }

    getchar();
  }

  return 0;
}

