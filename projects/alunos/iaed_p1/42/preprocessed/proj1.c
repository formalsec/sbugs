/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  char desc[63];
  int preco;
  int peso;
  int qtd;
} Produtos;
typedef struct 
{
  int lista[200][2];
  int peso;
  int num_prods;
} Encomendas;
Produtos prod[10000];
Encomendas enc[500];
int pcount;
int ecount;
int idps_ord[10000];
void adiciona_prod();
void adiciona_stock_prod();
void cria_enc();
void adiciona_prod_enc();
void remove_stock_prod();
void remove_prod_enc();
void custo_enc();
void altera_preco();
void mostra_prod_enc();
void maior_ocorrencia();
void lista_prods();
void lista_enc();
void mostra_prod(int, int);
int obtem_preco_prod(int);
int obtem_peso_prod(int);
int obtem_qtd_prod(int);
int *obtem_prod_enc(int, int);
int obtem_idp_enc(int, int);
int obtem_qtd_prod_enc(int, int);
int obtem_num_prods_enc(int);
int obtem_peso_enc(int);
void altera_qtd_prod(int, int);
void altera_idp_enc(int, int, int);
void altera_qtd_prod_enc(int, int, int);
void altera_peso_enc(int, int, int);
void altera_num_prods_enc(int, int);
int cria_prod_enc(int, int);
int procura_prod_enc(int, int);
void limpa_prod_enc(int, int);
void copia_idps();
void ordena_idps();
int menor_preco(int, int);
void ordena_enc(int);
int menor_desc(int, int);
int verifica_ide_idp(int, int, char);
int verifica_quantidades(int, int, int, char);
int main()
{
  char cmd;
  while ((cmd = getchar()) != 'x')
  {
    switch (cmd)
    {
      case 'a':
        adiciona_prod();
        break;

      case 'q':
        adiciona_stock_prod();
        break;

      case 'N':
        cria_enc();
        break;

      case 'A':
        adiciona_prod_enc();
        break;

      case 'r':
        remove_stock_prod();
        break;

      case 'R':
        remove_prod_enc();
        break;

      case 'C':
        custo_enc();
        break;

      case 'p':
        altera_preco();
        break;

      case 'E':
        mostra_prod_enc();
        break;

      case 'm':
        maior_ocorrencia();
        break;

      case 'l':
        lista_prods();
        break;

      case 'L':
        lista_enc();
        break;

    }

  }

  return 0;
}

void adiciona_prod()
{
  for (int prod_index = 0; prod_index < 10; prod_index++)
  {
    prod[pcount].desc[prod_index] = new_sym_var(sizeof(char) * 8);
  }

  prod[pcount].desc[10 - 1] = '\0';
  prod[pcount].preco = new_sym_var(sizeof(int) * 8);
  prod[pcount].peso = new_sym_var(sizeof(int) * 8);
  prod[pcount].qtd = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", pcount);
  pcount++;
}

void adiciona_stock_prod()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (verifica_ide_idp(-1, idp, 'q') == 1)
  {
    altera_qtd_prod(idp, qtd);
  }
  else
  {
    
  }

}

void cria_enc()
{
  printf("Nova encomenda %d.\n", ecount);
  ecount++;
}

void adiciona_prod_enc()
{
  int ide;
  int idp;
  int qtd;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if ((verifica_ide_idp(ide, idp, 'A') == 1) && (verifica_quantidades(ide, idp, qtd, 'A') == 1))
  {
    i = procura_prod_enc(ide, idp);
    if (i == (-1))
    {
      i = cria_prod_enc(ide, idp);
    }
    else
    {
      
    }

    altera_qtd_prod(idp, -qtd);
    altera_qtd_prod_enc(ide, i, qtd);
    altera_peso_enc(ide, idp, qtd);
  }
  else
  {
    
  }

}

void remove_stock_prod()
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if ((verifica_ide_idp(-1, idp, 'r') == 1) && (verifica_quantidades(0, idp, qtd, 'r') == 1))
  {
    altera_qtd_prod(idp, -qtd);
  }
  else
  {
    
  }

}

void remove_prod_enc()
{
  int ide;
  int idp;
  int i;
  int i_max;
  int qtd;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (verifica_ide_idp(ide, idp, 'R') == 1)
  {
    i = procura_prod_enc(ide, idp);
    if (i == (-1))
    {
      return;
    }
    else
    {
      
    }

    qtd = obtem_qtd_prod_enc(ide, i);
    altera_qtd_prod(idp, qtd);
    altera_peso_enc(ide, idp, -qtd);
    i_max = obtem_num_prods_enc(ide) - 1;
    if (i != i_max)
    {
      obtem_prod_enc(ide, i)[0] = obtem_prod_enc(ide, i_max)[0];
      obtem_prod_enc(ide, i)[1] = obtem_prod_enc(ide, i_max)[1];
    }
    else
    {
      
    }

    ;
    limpa_prod_enc(ide, i_max);
  }
  else
  {
    
  }

}

void custo_enc()
{
  int ide;
  int i;
  int num_prods;
  long int custo = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (verifica_ide_idp(ide, -1, 'C') == 1)
  {
    num_prods = obtem_num_prods_enc(ide);
    for (i = 0; i < num_prods; i++)
      custo += obtem_preco_prod(obtem_idp_enc(ide, i)) * obtem_qtd_prod_enc(ide, i);

    printf("Custo da encomenda %d %ld.\n", ide, custo);
  }
  else
  {
    
  }

}

void altera_preco()
{
  int idp;
  int preco;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (verifica_ide_idp(-1, idp, 'p') == 1)
  {
    prod[idp].preco = preco;
  }
  else
  {
    
  }

}

void mostra_prod_enc()
{
  int ide;
  int idp;
  int i;
  int qtd = 0;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (verifica_ide_idp(ide, idp, 'E') == 0)
  {
    return;
  }
  else
  {
    
  }

  i = procura_prod_enc(ide, idp);
  if (i >= 0)
  {
    qtd = obtem_qtd_prod_enc(ide, i);
  }
  else
  {
    
  }

  printf("%s %d.\n", prod[idp].desc, qtd);
}

void maior_ocorrencia()
{
  int idp;
  int ide;
  int i;
  int ide_final;
  int qtd_max;
  int qtd;
  ide_final = -1;
  qtd_max = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (verifica_ide_idp(-1, idp, 'm') == 0)
  {
    return;
  }
  else
  {
    
  }

  for (ide = 0; ide < ecount; ide++)
    if ((i = procura_prod_enc(ide, idp)) >= 0)
  {
    if ((qtd = obtem_qtd_prod_enc(ide, i)) > qtd_max)
    {
      qtd_max = qtd;
      ide_final = ide;
    }
    else
    {
      
    }

  }
  else
  {
    
  }


  if (ide_final >= 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, ide_final, qtd_max);
  }
  else
  {
    
  }

}

void lista_prods()
{
  int i;
  printf("Produtos\n");
  if (pcount > 0)
  {
    copia_idps();
    ordena_idps();
    for (i = 0; i < pcount; i++)
      mostra_prod(idps_ord[i], obtem_qtd_prod(idps_ord[i]));

  }
  else
  {
    
  }

}

void lista_enc()
{
  int ide;
  int i;
  int num_prods;
  ide = new_sym_var(sizeof(int) * 8);
  if (verifica_ide_idp(ide, -1, 'L') == 1)
  {
    printf("Encomenda %d\n", ide);
    ordena_enc(ide);
    num_prods = obtem_num_prods_enc(ide);
    for (i = 0; i < num_prods; i++)
      mostra_prod(obtem_idp_enc(ide, i), obtem_qtd_prod_enc(ide, i));

  }
  else
  {
    
  }

}

void mostra_prod(int i, int qtd)
{
  printf("* %s %d %d\n", prod[i].desc, obtem_preco_prod(i), qtd);
}

int obtem_preco_prod(int idp)
{
  return prod[idp].preco;
}

int obtem_peso_prod(int idp)
{
  return prod[idp].peso;
}

int obtem_qtd_prod(int idp)
{
  return prod[idp].qtd;
}

int *obtem_prod_enc(int ide, int i)
{
  return enc[ide].lista[i];
}

int obtem_idp_enc(int ide, int i)
{
  return obtem_prod_enc(ide, i)[0];
}

int obtem_qtd_prod_enc(int ide, int i)
{
  return obtem_prod_enc(ide, i)[1];
}

int obtem_peso_enc(int ide)
{
  return enc[ide].peso;
}

int obtem_num_prods_enc(int ide)
{
  return enc[ide].num_prods;
}

void altera_qtd_prod(int idp, int qtd)
{
  prod[idp].qtd += qtd;
}

void altera_idp_enc(int ide, int i, int idp)
{
  enc[ide].lista[i][0] = idp;
}

void altera_qtd_prod_enc(int ide, int i, int qtd)
{
  if (qtd == 0)
  {
    enc[ide].lista[i][1] = 0;
  }
  else
  {
    enc[ide].lista[i][1] += qtd;
  }

}

void altera_peso_enc(int ide, int idp, int qtd)
{
  enc[ide].peso += obtem_peso_prod(idp) * qtd;
}

void altera_num_prods_enc(int ide, int qtd)
{
  enc[ide].num_prods += qtd;
}

int cria_prod_enc(int ide, int idp)
{
  int i = obtem_num_prods_enc(ide);
  altera_idp_enc(ide, i, idp);
  altera_num_prods_enc(ide, 1);
  return i;
}

int procura_prod_enc(int ide, int idp)
{
  int i;
  int num_prods = obtem_num_prods_enc(ide);
  for (i = 0; (obtem_idp_enc(ide, i) != idp) && (i < num_prods); i++)
    ;

  if (i == num_prods)
  {
    return -1;
  }
  else
  {
    
  }

  return i;
}

void limpa_prod_enc(int ide, int i)
{
  altera_idp_enc(ide, i, 0);
  altera_qtd_prod_enc(ide, i, 0);
  altera_num_prods_enc(ide, -1);
}

void copia_idps()
{
  static int i;
  for (; i < pcount; i++)
    idps_ord[i] = i;

}

void ordena_idps()
{
  int i;
  int j;
  int id_aux;
  int ultimo = pcount - 1;
  for (i = 1; i <= ultimo; i++)
    if (menor_preco(idps_ord[i], idps_ord[i - 1]))
  {
    id_aux = idps_ord[i];
    j = i - 1;
    do
    {
      idps_ord[j + 1] = idps_ord[j];
      j--;
    }
    while ((j >= 0) && menor_preco(id_aux, idps_ord[j]));
    idps_ord[j + 1] = id_aux;
  }
  else
  {
    
  }


}

int menor_preco(int i, int j)
{
  if (obtem_preco_prod(i) < obtem_preco_prod(j))
  {
    return 1;
  }
  else
  {
    
  }

  if (obtem_preco_prod(i) == obtem_preco_prod(j))
  {
    return i < j;
  }
  else
  {
    
  }

  return 0;
}

void ordena_enc(int ide)
{
  int i;
  int j;
  int aux[2];
  int ultimo = obtem_num_prods_enc(ide) - 1;
  for (i = 1; i <= ultimo; i++)
    if (menor_desc(obtem_idp_enc(ide, i), obtem_idp_enc(ide, i - 1)) < 0)
  {
    {
      aux[0] = obtem_prod_enc(ide, i)[0];
      aux[1] = obtem_prod_enc(ide, i)[1];
    }
    ;
    j = i - 1;
    do
    {
      {
        obtem_prod_enc(ide, j + 1)[0] = obtem_prod_enc(ide, j)[0];
        obtem_prod_enc(ide, j + 1)[1] = obtem_prod_enc(ide, j)[1];
      }
      ;
      j--;
    }
    while ((j >= 0) && (menor_desc(aux[0], obtem_idp_enc(ide, j)) < 0));
    {
      obtem_prod_enc(ide, j + 1)[0] = aux[0];
      obtem_prod_enc(ide, j + 1)[1] = aux[1];
    }
    ;
  }
  else
  {
    
  }


}

int menor_desc(int i, int j)
{
  return strcmp(prod[i].desc, prod[j].desc);
}

int verifica_quantidades(int ide, int idp, int qtd, char cmd)
{
  if (obtem_qtd_prod(idp) < qtd)
  {
    switch (cmd)
    {
      case 'A':
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        break;

      case 'r':
        printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
        break;

    }

    return 0;
  }
  else
  {
    
  }

  if ((cmd == 'A') && ((obtem_peso_enc(ide) + (qtd * obtem_peso_prod(idp))) > 200))
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    return 0;
  }
  else
  {
    
  }

  return 1;
}

int verifica_ide_idp(int ide, int idp, char cmd)
{
  if (ide >= ecount)
  {
    switch (cmd)
    {
      case 'A':
        printf("Impossivel adicionar produto %d a encomenda %d.", idp, ide);
        break;

      case 'R':
        printf("Impossivel remover produto %d a encomenda %d.", idp, ide);
        break;

      case 'C':
        printf("Impossivel calcular custo da encomenda %d.", ide);
        break;

      case 'E':

      case 'L':
        printf("Impossivel listar encomenda %d.", ide);
        break;

    }

    printf(" Encomenda inexistente.\n");
    return 0;
  }
  else
  {
    
  }

  if (idp >= pcount)
  {
    switch (cmd)
    {
      case 'q':
        printf("Impossivel adicionar produto %d ao stock.", idp);
        break;

      case 'A':
        printf("Impossivel adicionar produto %d a encomenda %d.", idp, ide);
        break;

      case 'r':
        printf("Impossivel remover stock do produto %d.", idp);
        break;

      case 'R':
        printf("Impossivel remover produto %d a encomenda %d.", idp, ide);
        break;

      case 'p':
        printf("Impossivel alterar preco do produto %d.", idp);
        break;

      case 'E':
        printf("Impossivel listar produto %d.", idp);
        break;

      case 'm':
        printf("Impossivel listar maximo do produto %d.", idp);
        break;

    }

    printf(" Produto inexistente.\n");
    return 0;
  }
  else
  {
    
  }

  return 1;
}

