/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>


typedef struct 
{
  char name[64];
  int price;
  int weight;
  int stock;
} product_t;
typedef struct 
{
  int id;
  char name[64];
  int qty;
} productOrdered_t;
typedef struct 
{
  productOrdered_t productOrdered[10000];
  int totalWeight;
  int productsNumber;
} order_t;
static product_t product[10000];
static order_t order[500];
static int productsNumber;
static int ordersNumber;
int idOrder;
void comando_a();
void comando_q();
void comando_N();
void comando_A();
void comando_r();
void comando_R();
void comando_C();
void comando_p();
void comando_E();
void comando_m();
void comando_l();
void comando_L();
void comando_x();
int find_product(int ido, int idp);
void remove_product(int ido, int idp);
int evaluate_order_price(int ido);
void quicksort(int v[], int left, int right, int cmp(int, int));
void swap(int v[], int i, int j);
int pcmp(int pa, int pb);
int pocmp(int poa, int pob);
int main()
{
  while (1)
  {
    char comando = getchar();
    switch (comando)
    {
      case 'a':
        comando_a();
        break;

      case 'q':
        comando_q();
        break;

      case 'N':
        comando_N();
        break;

      case 'A':
        comando_A();
        break;

      case 'r':
        comando_r();
        break;

      case 'R':
        comando_R();
        break;

      case 'C':
        comando_C();
        break;

      case 'p':
        comando_p();
        break;

      case 'E':
        comando_E();
        break;

      case 'm':
        comando_m();
        break;

      case 'l':
        comando_l();
        break;

      case 'L':
        comando_L();
        break;

      case 'x':
        return 0;

      default:
        assert(0);

    }

    getchar();
  }

  return 1;
}

void comando_a()
{
  if (productsNumber < 10000)
  {
    for (int product_index = 0; product_index < 10; product_index++)
    {
      product[productsNumber].name[product_index] = new_sym_var(sizeof(char) * 8);
    }

    product[productsNumber].name[10 - 1] = '\0';
    product[productsNumber].price = new_sym_var(sizeof(int) * 8);
    product[productsNumber].weight = new_sym_var(sizeof(int) * 8);
    product[productsNumber].stock = new_sym_var(sizeof(int) * 8);
    printf("Novo produto %d.\n", productsNumber);
    productsNumber++;
  }
  else
  {
    
  }

}

void comando_q()
{
  int idp;
  int qty;
  idp = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (idp < productsNumber)
  {
    product[idp].stock += qty;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void comando_N()
{
  if (ordersNumber < 500)
  {
    printf("Nova encomenda %d.\n", ordersNumber);
    order[ordersNumber].totalWeight = 0;
    order[ordersNumber].productsNumber = 0;
    ordersNumber++;
  }
  else
  {
    
  }

}

void comando_A()
{
  int ido;
  int idp;
  int qty;
  int i;
  ido = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (ido >= ordersNumber)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ido);
  }
  else
  {
    if (idp >= productsNumber)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ido);
    }
    else
    {
      if (qty > product[idp].stock)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ido);
      }
      else
      {
        if (((product[idp].weight * qty) + order[ido].totalWeight) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ido);
        }
        else
        {
          i = find_product(ido, idp);
          if (i < order[ido].productsNumber)
          {
            order[ido].productOrdered[i].qty += qty;
          }
          else
          {
            order[ido].productOrdered[i].id = idp;
            strcpy(order[ido].productOrdered[i].name, product[idp].name);
            order[ido].productOrdered[i].qty = qty;
            order[ido].productsNumber++;
          }

          order[ido].totalWeight += product[idp].weight * qty;
          product[idp].stock -= qty;
        }

      }

    }

  }

}

void comando_r()
{
  int idp;
  int qty;
  idp = new_sym_var(sizeof(int) * 8);
  qty = new_sym_var(sizeof(int) * 8);
  if (idp >= productsNumber)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (qty > product[idp].stock)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qty, idp);
    }
    else
    {
      product[idp].stock -= qty;
    }

  }

}

void comando_R()
{
  int ido;
  int idp;
  ido = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ido >= ordersNumber)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ido);
  }
  else
  {
    if (idp >= productsNumber)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ido);
    }
    else
    {
      remove_product(ido, idp);
    }

  }

}

void comando_C()
{
  int ido;
  ido = new_sym_var(sizeof(int) * 8);
  if (ido >= ordersNumber)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ido);
  }
  else
  {
    printf("Custo da encomenda %d %d.\n", ido, evaluate_order_price(ido));
  }

}

void comando_p()
{
  int idp;
  int price;
  idp = new_sym_var(sizeof(int) * 8);
  price = new_sym_var(sizeof(int) * 8);
  if (idp >= productsNumber)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    product[idp].price = price;
  }

}

void comando_E()
{
  int ido;
  int idp;
  int i;
  ido = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ido >= ordersNumber)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ido);
  }
  else
  {
    if (idp >= productsNumber)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      i = find_product(ido, idp);
      if (i < order[ido].productsNumber)
      {
        printf("%s %d.\n", order[ido].productOrdered[i].name, order[ido].productOrdered[i].qty);
      }
      else
      {
        printf("%s 0.\n", product[idp].name);
      }

    }

  }

}

void comando_m()
{
  int i;
  int idp;
  int maxProductQuantity = 0;
  int maxIDOrder = -1;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= productsNumber)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; i < ordersNumber; i++)
    {
      int j = find_product(i, idp);
      if (j < order[i].productsNumber)
      {
        if (order[i].productOrdered[j].qty > maxProductQuantity)
        {
          maxProductQuantity = order[i].productOrdered[j].qty;
          maxIDOrder = i;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }

  if (maxIDOrder != (-1))
  {
    printf("Maximo produto %d %d %d.\n", idp, maxIDOrder, maxProductQuantity);
  }
  else
  {
    
  }

}

void comando_l()
{
  int indP[10000];
  int i;
  for (i = 0; i < productsNumber; i++)
    indP[i] = i;

  quicksort(indP, 0, productsNumber - 1, pcmp);
  printf("Produtos\n");
  for (i = 0; i < productsNumber; i++)
    printf("* %s %d %d\n", product[indP[i]].name, product[indP[i]].price, product[indP[i]].stock);

}

void comando_L()
{
  idOrder = new_sym_var(sizeof(int) * 8);
  if (idOrder >= ordersNumber)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", idOrder);
  }
  else
  {
    int indPO[10000];
    int i;
    for (i = 0; i < productsNumber; i++)
      indPO[i] = i;

    quicksort(indPO, 0, order[idOrder].productsNumber - 1, pocmp);
    printf("Encomenda %d\n", idOrder);
    for (i = 0; i < order[idOrder].productsNumber; i++)
      printf("* %s %d %d\n", order[idOrder].productOrdered[indPO[i]].name, product[order[idOrder].productOrdered[indPO[i]].id].price, order[idOrder].productOrdered[indPO[i]].qty);

  }

}

int find_product(int ido, int idp)
{
  int i;
  for (i = 0; i < order[ido].productsNumber; i++)
    if (order[ido].productOrdered[i].id == idp)
  {
    break;
  }
  else
  {
    
  }


  return i;
}

void remove_product(int ido, int idp)
{
  int i = 0;
  i = find_product(ido, idp);
  if (i < order[ido].productsNumber)
  {
    order[ido].totalWeight -= product[idp].weight * order[ido].productOrdered[i].qty;
    product[idp].stock += order[ido].productOrdered[i].qty;
    order[ido].productsNumber--;
    if (i != order[ido].productsNumber)
    {
      order[ido].productOrdered[i].id = order[ido].productOrdered[order[ido].productsNumber].id;
      strcpy(order[ido].productOrdered[i].name, order[ido].productOrdered[order[ido].productsNumber].name);
      order[ido].productOrdered[i].qty = order[ido].productOrdered[order[ido].productsNumber].qty;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

}

int evaluate_order_price(int ido)
{
  int i;
  int price = 0;
  for (i = 0; i < order[ido].productsNumber; i++)
    price += product[order[ido].productOrdered[i].id].price * order[ido].productOrdered[i].qty;

  return price;
}

void quicksort(int v[], int left, int right, int cmp(int, int))
{
  int i;
  int last;
  if (left >= right)
  {
    return;
  }
  else
  {
    
  }

  swap(v, left, (left + right) / 2);
  last = left;
  for (i = left + 1; i <= right; i++)
    if (cmp(v[i], v[left]) < 0)
  {
    swap(v, ++last, i);
  }
  else
  {
    
  }


  swap(v, left, last);
  quicksort(v, left, last - 1, cmp);
  quicksort(v, last + 1, right, cmp);
}

void swap(int v[], int i, int j)
{
  int temp;
  temp = v[i];
  v[i] = v[j];
  v[j] = temp;
}

int pcmp(int pa, int pb)
{
  if (product[pa].price < product[pb].price)
  {
    return -1;
  }
  else
  {
    if (product[pa].price > product[pb].price)
    {
      return 1;
    }
    else
    {
      return pa - pb;
    }

  }

}

int pocmp(int poa, int pob)
{
  if (strcmp(order[idOrder].productOrdered[poa].name, order[idOrder].productOrdered[pob].name) < 0)
  {
    return -1;
  }
  else
  {
    if (strcmp(order[idOrder].productOrdered[poa].name, order[idOrder].productOrdered[pob].name) > 0)
    {
      return 1;
    }
    else
    {
      return 0;
    }

  }

}

