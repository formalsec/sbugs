#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


char *inputFile;
int countP = 0;
int countE = 0;
int countEprodutos[10000];
typedef struct produto
{
  int idp;
  char description[64];
  int value;
  int weight;
  int stock;
} produto;
typedef struct encomenda
{
  int ide;
  int idp[100];
  int units[100];
  char description[100][64];
  int value[100];
  int weight;
} encomenda;
produto produtos[10000];
encomenda encomendas[500];
produto aux[10000];
encomenda auxE[500];
void mergeP(int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    aux[i - 1] = produtos[i - 1];
  }

  for (j = m; j < right; j++)
  {
    aux[(right + m) - j] = produtos[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if ((aux[j].value < aux[i].value) || (i > m))
    {
      produtos[k] = aux[j--];
    }
    else
    {
      if (aux[j].value > aux[i].value)
      {
        produtos[k] = aux[i++];
      }
      else
      {
        if (aux[j].idp < aux[i].idp)
        {
          produtos[k] = aux[j--];
        }
        else
        {
          produtos[k] = aux[i++];
        }

      }

    }

  }

}

void mergeE(int loc, int left, int m, int right)
{
  int i;
  int j;
  int k;
  int y;
  for (i = m + 1; i > left; i--)
  {
    auxE[loc].idp[i - 1] = encomendas[loc].idp[i - 1];
    auxE[loc].units[i - 1] = encomendas[loc].units[i - 1];
    strcpy(auxE[loc].description[i - 1], encomendas[loc].description[i - 1]);
  }

  for (j = m; j < right; j++)
  {
    auxE[loc].idp[(right + m) - j] = encomendas[loc].idp[j + 1];
    auxE[loc].units[(right + m) - j] = encomendas[loc].units[j + 1];
    strcpy(auxE[loc].description[(right + m) - j], encomendas[loc].description[j + 1]);
  }

  for (k = left; k <= right; k++)
  {
    for (y = 0; y < 64; y++)
    {
      if ((auxE[loc].description[j][y] < auxE[loc].description[i][y]) || (i > m))
      {
        encomendas[loc].units[k] = auxE[loc].units[j];
        strcpy(encomendas[loc].description[k], encomendas[loc].description[j]);
        encomendas[loc].idp[k] = auxE[loc].idp[j--];
        break;
      }
      else
      {
        if (auxE[loc].description[j][y] > auxE[loc].description[i][y])
        {
          encomendas[loc].units[k] = auxE[loc].units[i];
          strcpy(encomendas[loc].description[k], encomendas[loc].description[i]);
          encomendas[loc].idp[k] = auxE[loc].idp[i++];
          break;
        }
        else
        {
          
        }

      }

    }

  }

}

void mergesort(int lL, int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(lL, left, m);
  mergesort(lL, m + 1, right);
  if (lL == (-1))
  {
    mergeP(left, m, right);
  }
  else
  {
    mergeE(lL, left, m, right);
  }

}

void processInput()
{
  int k;
  int variavel = 0;
  while (variavel < 10)
  {
    char token = '\0';
    char s[1];
    char text[100] = {'\0'};
    int givenID = 0;
    int auxNum = 0;
    int qtd = 0;
    int savedloc = 0;
    int locE = 0;
    int y = 0;
    int h;
    int i;
    int j;
    int lL;
    int numTokens;
    k = 0;
    numTokens = 1;
    for (int s_index = 0; s_index < 1; s_index++)
    {
      s[s_index] = new_sym_var(sizeof(char) * 8);
    }

    s[1 - 1] = '\0';
    token = s[0];
    if (((token != 'N') && (token != 'l')) && (token != 'x'))
    {
      for (int text_index = 0; text_index < 10; text_index++)
      {
        text[text_index] = new_sym_var(sizeof(char) * 8);
      }

      text[10 - 1] = '\0';
    }
    else
    {
      
    }

    if (numTokens < 1)
    {
      printf("Erro, nada foi lido do input");
      continue;
    }
    else
    {
      
    }

    switch (token)
    {
      case 'a':
        for (int produtos_index = 0; produtos_index < 10; produtos_index++)
      {
        produtos[countP].description[produtos_index] = new_sym_var(sizeof(char) * 8);
      }

        produtos[countP].description[10 - 1] = '\0';
        produtos[countP].value = new_sym_var(sizeof(int) * 8);
        produtos[countP].weight = new_sym_var(sizeof(int) * 8);
        produtos[countP].stock = new_sym_var(sizeof(int) * 8);
        produtos[countP].idp = countP;
        printf("Novo produto %d.\n", produtos[countP].idp);
        countP++;
        break;

      case 'q':
        givenID = new_sym_var(sizeof(int) * 8);
        auxNum = new_sym_var(sizeof(int) * 8);
        if (countP == 0)
      {
        printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < countP; i++)
      {
        if (givenID == produtos[i].idp)
        {
          produtos[i].stock += auxNum;
          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", givenID);
      }
      else
      {
        
      }

        break;

      case 'N':
        encomendas[countE].ide = countE;
        countEprodutos[countE] = 0;
        printf("Nova encomenda %d.\n", encomendas[countE].ide);
        encomendas[countE].weight = 0;
        for (i = 0; i < 100; i++)
      {
        encomendas[countE].idp[i] = -1;
        encomendas[countE].units[i] = 0;
      }

        countE++;
        break;

      case 'A':
        givenID = new_sym_var(sizeof(int) * 8);
        auxNum = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        if (countE == 0)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < countE; i++)
      {
        if (givenID == encomendas[i].ide)
        {
          locE = i;
          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        k = 0;
        if (countP == 0)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        for (j = 0; j < countP; j++)
      {
        if (auxNum == produtos[j].idp)
        {
          for (i = 0; i < 100; i++)
          {
            if (encomendas[locE].idp[i] == (-1))
            {
              savedloc = i;
              k = 1;
              break;
            }
            else
            {
              
            }

            if (encomendas[locE].idp[i] == auxNum)
            {
              savedloc = i;
              k = 2;
              break;
            }
            else
            {
              
            }

          }

          y = j;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        if (qtd > produtos[y].stock)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        if (((produtos[y].weight * qtd) + encomendas[locE].weight) > 200)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        if (k == 2)
      {
        encomendas[locE].units[savedloc] += qtd;
        produtos[y].stock -= qtd;
        encomendas[locE].weight += produtos[y].weight * qtd;
        break;
      }
      else
      {
        encomendas[locE].idp[savedloc] = auxNum;
        produtos[y].stock -= qtd;
        encomendas[locE].units[savedloc] += qtd;
        encomendas[locE].weight += produtos[y].weight * qtd;
        strcpy(encomendas[locE].description[savedloc], produtos[y].description);
        countEprodutos[locE]++;
      }

        break;

      case 'E':
        givenID = new_sym_var(sizeof(int) * 8);
        auxNum = new_sym_var(sizeof(int) * 8);
        if (countE == 0)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < countE; i++)
      {
        if (givenID == encomendas[i].ide)
        {
          locE = i;
          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        k = 0;
        if (countP <= auxNum)
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", auxNum);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < 100; i++)
      {
        if (auxNum == encomendas[locE].idp[i])
        {
          printf("%s %d.\n", encomendas[locE].description[i], encomendas[locE].units[i]);
          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        for (i = 0; i < countP; i++)
        {
          if (auxNum == produtos[i].idp)
          {
            printf("%s %d.\n", produtos[i].description, 0);
          }
          else
          {
            
          }

        }

      }
      else
      {
        
      }

        break;

      case 'r':
        givenID = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        if (countP == 0)
      {
        printf("Impossivel remover stock do produto %d. Produto inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < countP; i++)
      {
        if (givenID == produtos[i].idp)
        {
          if (produtos[i].stock < qtd)
          {
            printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, givenID);
          }
          else
          {
            produtos[i].stock -= qtd;
          }

          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel remover stock do produto %d. Produto inexistente.\n", givenID);
      }
      else
      {
        
      }

        break;

      case 'R':
        givenID = new_sym_var(sizeof(int) * 8);
        auxNum = new_sym_var(sizeof(int) * 8);
        if (countE == 0)
      {
        printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < countE; i++)
      {
        if (givenID == encomendas[i].ide)
        {
          locE = i;
          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        k = 0;
        if (countP == 0)
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.", auxNum, givenID);
        break;
      }
      else
      {
        
      }

        for (h = 0; h < countP; h++)
      {
        if (auxNum == produtos[h].idp)
        {
          k = 1;
          for (i = 0; i < 100; i++)
          {
            if (encomendas[locE].idp[i] == auxNum)
            {
              encomendas[locE].idp[i] = -1;
              for (j = 0; j < 64; j++)
              {
                encomendas[locE].description[i][j] = '\0';
              }

              encomendas[locE].weight -= encomendas[locE].units[i] * produtos[h].weight;
              produtos[h].stock += encomendas[locE].units[i];
              encomendas[locE].units[i] = 0;
              countEprodutos[locE]--;
              if (encomendas[locE].idp[i + 1] >= 0)
              {
                for (y = i + 2; y < 100; y++)
                {
                  if (encomendas[locE].idp[y] == (-1))
                  {
                    encomendas[locE].idp[i] = encomendas[locE].idp[y - 1];
                    encomendas[locE].idp[y - 1] = -1;
                    encomendas[locE].units[i] = encomendas[locE].units[y - 1];
                    encomendas[locE].units[y - 1] = 0;
                    strcpy(encomendas[locE].description[i], encomendas[locE].description[y - 1]);
                    for (j = 0; j < 64; j++)
                    {
                      encomendas[locE].description[y - 1][j] = '\0';
                    }

                    break;
                  }
                  else
                  {
                    
                  }

                }

              }
              else
              {
                
              }

              break;
            }
            else
            {
              
            }

          }

          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", auxNum, givenID);
      }
      else
      {
        
      }

        break;

      case 'C':
        givenID = new_sym_var(sizeof(int) * 8);
        auxNum = 0;
        if (countE == 0)
      {
        printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < countE; i++)
      {
        if (givenID == encomendas[i].ide)
        {
          locE = i;
          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < 100; i++)
      {
        if (encomendas[locE].idp[i] > (-1))
        {
          for (j = 0; j < countP; j++)
          {
            if (encomendas[locE].idp[i] == produtos[j].idp)
            {
              auxNum += produtos[j].value * encomendas[locE].units[i];
              break;
            }
            else
            {
              
            }

          }

        }
        else
        {
          
        }

      }

        printf("Custo da encomenda %d %d.\n", encomendas[locE].ide, auxNum);
        break;

      case 'p':
        givenID = new_sym_var(sizeof(int) * 8);
        auxNum = new_sym_var(sizeof(int) * 8);
        if (countP == 0)
      {
        printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        for (i = 0; i < countP; i++)
      {
        if (givenID == produtos[i].idp)
        {
          produtos[i].value = auxNum;
          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", givenID);
      }
      else
      {
        
      }

        break;

      case 'm':
        givenID = new_sym_var(sizeof(int) * 8);
        if (countP == 0)
      {
        printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        if (countE == 0)
      {
        break;
      }
      else
      {
        
      }

        for (i = 0; i < countP; i++)
      {
        if (givenID == produtos[i].idp)
        {
          k = 1;
          break;
        }
        else
        {
          
        }

      }

        if (k == 0)
      {
        printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        savedloc = -1;
        for (j = 0; j < countE; j++)
      {
        for (i = 0; i < 100; i++)
        {
          if (encomendas[j].idp[i] == givenID)
          {
            if (encomendas[j].units[i] >= auxNum)
            {
              if (encomendas[j].units[i] > auxNum)
              {
                locE = j;
                savedloc = i;
                auxNum = encomendas[j].units[i];
              }
              else
              {
                if (encomendas[j].idp[i] < encomendas[locE].idp[savedloc])
                {
                  locE = j;
                  savedloc = i;
                  auxNum = encomendas[j].units[i];
                }
                else
                {
                  
                }

              }

            }
            else
            {
              
            }

          }
          else
          {
            
          }

        }

      }

        if (savedloc >= 0)
      {
        printf("Maximo produto %d %d %d.\n", givenID, encomendas[locE].ide, encomendas[locE].units[savedloc]);
      }
      else
      {
        
      }

        break;

      case 'l':
        printf("Produtos\n");
        lL = -1;
        mergesort(lL, 0, countP - 1);
        for (i = 0; i < countP; i++)
      {
        printf("* %s %d %d\n", produtos[i].description, produtos[i].value, produtos[i].stock);
      }

        break;

      case 'L':
        givenID = new_sym_var(sizeof(int) * 8);
        if ((countE == 0) || (givenID >= countE))
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", givenID);
        break;
      }
      else
      {
        
      }

        mergesort(givenID, 0, countEprodutos[givenID] - 1);
        printf("Encomenda %d\n", givenID);
        for (i = 0; i < countEprodutos[givenID]; i++)
      {
        for (j = 0; j < 10000; j++)
        {
          if (encomendas[givenID].idp[i] == produtos[j].idp)
          {
            encomendas[givenID].value[i] = produtos[j].value;
            break;
          }
          else
          {
            
          }

        }

        printf("* %s %d %d\n", encomendas[givenID].description[i], encomendas[givenID].value[i], encomendas[givenID].units[i]);
      }

        break;

      case 'x':
        variavel = 100;
        break;

      default:
      {
        printf("Erro default");
        break;
      }

    }

  }

}

int main()
{
  processInput();
  return 0;
}

