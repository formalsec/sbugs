#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "proj1.h"


struct Product productList[10000] = {0};
int idCount = 0;
struct Order orderList[500] = {0};
int orderCount = 0;
int main(void)
{
  while (inputHandler())
  {
  }

  return 0;
}

int inputHandler(void)
{
  char inputstring[100];
  char command[1];
  char temp[4][64] = {0};
  int i = 0;
  char *token;
  char description[64];
  int price;
  int weight;
  int stock;
  int idp;
  int ide;
  fgets(inputstring, 100, stdin);
  inputstring[strcspn(inputstring, "\n")] = 0;
  strcpy(command, strtok(inputstring, " "));
  token = strtok(0, ":");
  while ((token != 0) && (i < 4))
  {
    strcpy(temp[i], token);
    i++;
    token = strtok(0, ":");
  }

  strcat(inputstring, ":");
  switch (command[0])
  {
    case 'a':
      strcpy(description, temp[0]);
      price = strtol(temp[1], 0, 10);
      weight = strtol(temp[2], 0, 10);
      stock = strtol(temp[3], 0, 10);
      commandAddProduct(description, price, weight, stock);
      return 1;

    case 'q':
      idp = strtol(temp[0], 0, 10);
      stock = strtol(temp[1], 0, 10);
      commandAddStock(idp, stock);
      return 1;

    case 'N':
      commandAddOrder();
      return 1;

    case 'A':
      ide = strtol(temp[0], 0, 10);
      idp = strtol(temp[1], 0, 10);
      stock = strtol(temp[2], 0, 10);
      commandAddProdOrder(ide, idp, stock);
      return 1;

    case 'r':
      idp = strtol(temp[0], 0, 10);
      stock = strtol(temp[1], 0, 10);
      commandRemoveStock(idp, stock);
      return 1;

    case 'R':
      ide = strtol(temp[0], 0, 10);
      idp = strtol(temp[1], 0, 10);
      commandRemoveProdOrder(ide, idp);
      return 1;

    case 'C':
      ide = strtol(temp[0], 0, 10);
      commandOrderPrice(ide);
      return 1;

    case 'p':
      idp = strtol(temp[0], 0, 10);
      price = strtol(temp[1], 0, 10);
      commandChangePrice(idp, price);
      return 1;

    case 'E':
      ide = strtol(temp[0], 0, 10);
      idp = strtol(temp[1], 0, 10);
      commandProdOrder(ide, idp);
      return 1;

    case 'm':
      idp = strtol(temp[0], 0, 10);
      commandMostProdOrder(idp);
      return 1;

    case 'l':
      commandListProd();
      return 1;

    case 'L':
      ide = strtol(temp[0], 0, 10);
      commandListProdOrder(ide);
      return 1;

    case 'x':
      return 0;

    default:
      return 1;

  }

}

void commandAddProduct(char description[64], int price, int weight, int stock)
{
  int idp = idCount;
  strcpy(productList[idp].description, description);
  productList[idp].price = price;
  productList[idp].weight = weight;
  productList[idp].stock = stock;
  idCount++;
  printf("Novo produto %d.\n", idp);
  return;
}

void commandAddStock(int idp, int stock)
{
  if (idp >= idCount)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  productList[idp].stock += stock;
  return;
}

void commandAddOrder()
{
  int ide = orderCount;
  orderCount++;
  printf("Nova encomenda %d.\n", ide);
  return;
}

void commandAddProdOrder(int ide, int idp, int stock)
{
  int i = 0;
  if (ide >= orderCount)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (idp >= idCount)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      if (stock > findIdpStock(idp))
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
        return;
      }
      else
      {
        if ((findOrderWeight(ide) + (stock * findIdpWeight(idp))) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
          return;
        }
        else
        {
          
        }

      }

    }

  }

  productList[idp].stock -= stock;
  while (i < orderList[ide].prodcount)
  {
    if (orderList[ide].products[i][0] == idp)
    {
      orderList[ide].products[i][1] += stock;
      return;
    }
    else
    {
      
    }

    i++;
  }

  orderList[ide].products[orderList[ide].prodcount][0] = idp;
  orderList[ide].products[orderList[ide].prodcount][1] = stock;
  orderList[ide].prodcount++;
  return;
}

void commandRemoveStock(int idp, int stock)
{
  if (idp >= idCount)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    if (stock > findIdpStock(idp))
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", stock, idp);
      return;
    }
    else
    {
      
    }

  }

  productList[idp].stock -= stock;
  return;
}

void commandRemoveProdOrder(int ide, int idp)
{
  int index = findIdpInOrder(ide, idp);
  if (ide >= orderCount)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    if (idp >= idCount)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
      return;
    }
    else
    {
      
    }

  }

  if (index >= 0)
  {
    commandAddStock(idp, orderList[ide].products[index][1]);
    while (index < (orderList[ide].prodcount - 1))
    {
      orderList[ide].products[index][0] = orderList[ide].products[index + 1][0];
      orderList[ide].products[index][1] = orderList[ide].products[index + 1][1];
      index++;
    }

    orderList[ide].prodcount--;
    orderList[ide].products[index][0] = 0;
    orderList[ide].products[index][1] = 0;
  }
  else
  {
    
  }

  return;
}

void commandOrderPrice(int ide)
{
  int i = 0;
  unsigned long int price = 0;
  int idp;
  if (ide >= orderCount)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  while (i < orderList[ide].prodcount)
  {
    idp = orderList[ide].products[i][0];
    price += orderList[ide].products[i][1] * findIdpPrice(idp);
    i++;
  }

  printf("Custo da encomenda %d %lu.\n", ide, price);
  return;
}

void commandChangePrice(int idp, int price)
{
  if (idp >= idCount)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  productList[idp].price = price;
  return;
}

void commandProdOrder(int ide, int idp)
{
  char description[64];
  int stock = 0;
  int idporder = findIdpInOrder(ide, idp);
  strcpy(description, productList[idp].description);
  if (ide >= orderCount)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    if (idp >= idCount)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
      return;
    }
    else
    {
      
    }

  }

  if (idporder > (-1))
  {
    stock = orderList[ide].products[idporder][1];
  }
  else
  {
    
  }

  printf("%s %d.\n", description, stock);
  return;
}

void commandMostProdOrder(int idp)
{
  int i = 0;
  int idporder;
  int maxstock = 0;
  int tempstock = 0;
  int ide = 0;
  if (idp >= idCount)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  if (orderCount == 0)
  {
    return;
  }
  else
  {
    
  }

  while (i < orderCount)
  {
    idporder = findIdpInOrder(i, idp);
    if (idporder > (-1))
    {
      tempstock = orderList[i].products[idporder][1];
      if (maxstock < tempstock)
      {
        maxstock = tempstock;
        ide = i;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

    i++;
  }

  if (maxstock != 0)
  {
    printf("Maximo produto %d %d %d.\n", idp, ide, maxstock);
  }
  else
  {
    
  }

  return;
}

void commandListProd(void)
{
  int i = 0;
  int array[10000] = {0};
  while (i < idCount)
  {
    array[i] = i;
    i++;
  }

  printf("Produtos\n");
  mergeSort(array, 0, idCount - 1, -1);
  printSortedArray(array, idCount, -1);
  return;
}

void commandListProdOrder(int ide)
{
  int i = 0;
  int array[200] = {0};
  int prodcount = orderList[ide].prodcount;
  if (ide >= orderCount)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  while (i < prodcount)
  {
    array[i] = orderList[ide].products[i][0];
    i++;
  }

  printf("Encomenda %d\n", ide);
  mergeSort(array, 0, prodcount - 1, ide);
  printSortedArray(array, prodcount, ide);
  return;
}

int findOrderWeight(int ide)
{
  int weight = 0;
  int i = 0;
  while (i <= orderList[ide].prodcount)
  {
    weight += orderList[ide].products[i][1] * productList[orderList[ide].products[i][0]].weight;
    i++;
  }

  return weight;
}

int findIdpInOrder(int ide, int idp)
{
  int i = 0;
  while (i < orderList[ide].prodcount)
  {
    if (idp == orderList[ide].products[i][0])
    {
      return i;
    }
    else
    {
      
    }

    i++;
  }

  return -1;
}

void printSortedArray(int array[], int n, int m)
{
  int i = 0;
  if (m == (-1))
  {
    while (i < n)
    {
      printf("* %s %d %d\n", productList[array[i]].description, findIdpPrice(array[i]), findIdpStock(array[i]));
      i++;
    }

  }
  else
  {
    while (i < n)
    {
      printf("* %s %d %d\n", productList[array[i]].description, findIdpPrice(array[i]), findStockInOrder(m, array[i]));
      i++;
    }

  }

  return;
}

void mergeSort(int array[], int l, int r, int n)
{
  int m = (l + r) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergeSort(array, l, m, n);
  mergeSort(array, m + 1, r, n);
  merge(array, l, m, r, n);
  return;
}

void merge(int array[], int l, int m, int r, int n)
{
  int i;
  int j;
  int k;
  int aux[10000];
  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = array[i - 1];
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = array[j + 1];
  }

  if (n == (-1))
  {
    for (k = l; k <= r; k++)
    {
      if ((productList[aux[j]].price < productList[aux[i]].price) || (i > m))
      {
        array[k] = aux[j--];
      }
      else
      {
        array[k] = aux[i++];
      }

    }

  }
  else
  {
    for (k = l; k <= r; k++)
    {
      if ((strcmp(productList[aux[j]].description, productList[aux[i]].description) < 0) || (i > m))
      {
        array[k] = aux[j--];
      }
      else
      {
        array[k] = aux[i++];
      }

    }

  }

  return;
}

int findIdpPrice(int idp)
{
  return productList[idp].price;
}

int findIdpWeight(int idp)
{
  return productList[idp].weight;
}

int findIdpStock(int idp)
{
  return productList[idp].stock;
}

int findStockInOrder(int ide, int idp)
{
  return orderList[ide].products[findIdpInOrder(ide, idp)][1];
}

