#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct produto
{
  char desc[63];
  int custo;
  int peso;
  int quantidade;
} Produto;
typedef struct encomenda
{
  int idp_produtos[200];
  int quantidade_produtos[200];
  int peso;
} Encomenda;
Produto produtos[10000];
Encomenda encomendas[500];
int idp;
int ide;
void inicia_registo_encomendas();
void adiciona_produto();
void adiciona_stock();
void cria_encomenda();
void fornece_encomenda();
void remove_stock();
void remove_produto_encomenda();
void calcula_custo_encomenda();
void altera_preco_produto();
void lista_quantidade_produto();
void lista_produto_mais_referenciado();
void lista_produtos_sistema();
void quick_sort(int custo_produtos[], int idp_produtos[], int esquerda, int direita);
int particao(int custo_produtos[], int idp_produtos[], int esquerda, int direita);
void selection_sort(int custo_produtos[], int idp_produtos[], int indice_1, int indice_2);
void lista_produtos_encomenda();
int main()
{
  int comando;
  inicia_registo_encomendas();
  while (comando = getchar())
  {
    switch (comando)
    {
      case 'a':
        adiciona_produto();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        fornece_encomenda();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_produto_encomenda();
        break;

      case 'C':
        calcula_custo_encomenda();
        break;

      case 'p':
        altera_preco_produto();
        break;

      case 'E':
        lista_quantidade_produto();
        break;

      case 'm':
        lista_produto_mais_referenciado();
        break;

      case 'l':
        lista_produtos_sistema();
        break;

      case 'L':
        lista_produtos_encomenda();
        break;

      case 'x':
        return 0;

    }

  }

  return 1;
}

void inicia_registo_encomendas()
{
  int indice_encomenda;
  int indice_produto;
  for (indice_encomenda = 0; indice_encomenda < 500; ++indice_encomenda)
    for (indice_produto = 0; indice_produto < 200; ++indice_produto)
    encomendas[indice_encomenda].idp_produtos[indice_produto] = -1;


}

void adiciona_produto()
{
  for (int produtos_index = 0; produtos_index < 10; produtos_index++)
  {
    produtos[idp].desc[produtos_index] = new_sym_var(sizeof(char) * 8);
  }

  produtos[idp].desc[10 - 1] = '\0';
  produtos[idp].custo = new_sym_var(sizeof(int) * 8);
  produtos[idp].peso = new_sym_var(sizeof(int) * 8);
  produtos[idp].quantidade = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", idp);
  ++idp;
}

void adiciona_stock()
{
  int idp_instrucao;
  int quantidade;
  idp_instrucao = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (idp_instrucao < idp)
  {
    produtos[idp_instrucao].quantidade += quantidade;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp_instrucao);
  }

}

void cria_encomenda()
{
  printf("Nova encomenda %d.\n", ide);
  ++ide;
}

void fornece_encomenda()
{
  int ide_instrucao;
  int idp_instrucao;
  int quantidade;
  int estado_produto;
  int indice_produto;
  ide_instrucao = new_sym_var(sizeof(int) * 8);
  idp_instrucao = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if ((((ide_instrucao < ide) && (idp_instrucao < idp)) && (quantidade <= produtos[idp_instrucao].quantidade)) && ((encomendas[ide_instrucao].peso + (quantidade * produtos[idp_instrucao].peso)) <= 200))
  {
    estado_produto = -1;
    for (indice_produto = 0; indice_produto < 200; ++indice_produto)
      if (encomendas[ide_instrucao].idp_produtos[indice_produto] == idp_instrucao)
    {
      estado_produto = 1;
      encomendas[ide_instrucao].peso += quantidade * produtos[idp_instrucao].peso;
      encomendas[ide_instrucao].quantidade_produtos[indice_produto] += quantidade;
      produtos[idp_instrucao].quantidade -= quantidade;
      indice_produto = 200;
    }
    else
    {
      
    }


    if (estado_produto == (-1))
    {
      for (indice_produto = 0; (indice_produto < 200) && (encomendas[ide_instrucao].idp_produtos[indice_produto] != (-1)); ++indice_produto)
        ;

      encomendas[ide_instrucao].idp_produtos[indice_produto] = idp_instrucao;
      encomendas[ide_instrucao].peso += quantidade * produtos[idp_instrucao].peso;
      encomendas[ide_instrucao].quantidade_produtos[indice_produto] = quantidade;
      produtos[idp_instrucao].quantidade -= quantidade;
    }
    else
    {
      
    }

  }
  else
  {
    if (ide_instrucao >= ide)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp_instrucao, ide_instrucao);
    }
    else
    {
      if (idp_instrucao >= idp)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp_instrucao, ide_instrucao);
      }
      else
      {
        if (quantidade > produtos[idp_instrucao].quantidade)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp_instrucao, ide_instrucao);
        }
        else
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp_instrucao, ide_instrucao);
        }

      }

    }

  }

}

void remove_stock()
{
  int idp_instrucao;
  int quantidade;
  idp_instrucao = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (idp_instrucao < idp)
  {
    if (quantidade <= produtos[idp_instrucao].quantidade)
    {
      produtos[idp_instrucao].quantidade -= quantidade;
    }
    else
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantidade, idp_instrucao);
    }

  }
  else
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp_instrucao);
  }

}

void remove_produto_encomenda()
{
  int ide_instrucao;
  int idp_instrucao;
  int indice_produto;
  ide_instrucao = new_sym_var(sizeof(int) * 8);
  idp_instrucao = new_sym_var(sizeof(int) * 8);
  if (ide_instrucao < ide)
  {
    if (idp_instrucao < idp)
    {
      for (indice_produto = 0; indice_produto < 200; ++indice_produto)
        if (encomendas[ide_instrucao].idp_produtos[indice_produto] == idp_instrucao)
      {
        produtos[idp_instrucao].quantidade += encomendas[ide_instrucao].quantidade_produtos[indice_produto];
        encomendas[ide_instrucao].peso -= encomendas[ide_instrucao].quantidade_produtos[indice_produto] * produtos[idp_instrucao].peso;
        encomendas[ide_instrucao].quantidade_produtos[indice_produto] = 0;
        encomendas[ide_instrucao].idp_produtos[indice_produto] = -1;
        indice_produto = 200;
      }
      else
      {
        
      }


    }
    else
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp_instrucao, ide_instrucao);
    }

  }
  else
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp_instrucao, ide_instrucao);
  }

}

void calcula_custo_encomenda()
{
  int ide_instrucao;
  int custo = 0;
  int indice_produto;
  ide_instrucao = new_sym_var(sizeof(int) * 8);
  if (ide_instrucao < ide)
  {
    for (indice_produto = 0; indice_produto < 200; ++indice_produto)
      custo += produtos[encomendas[ide_instrucao].idp_produtos[indice_produto]].custo * encomendas[ide_instrucao].quantidade_produtos[indice_produto];

    printf("Custo da encomenda %d %d.\n", ide_instrucao, custo);
  }
  else
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide_instrucao);
  }

}

void altera_preco_produto()
{
  int idp_instrucao;
  int custo_instrucao;
  idp_instrucao = new_sym_var(sizeof(int) * 8);
  custo_instrucao = new_sym_var(sizeof(int) * 8);
  if (idp_instrucao < idp)
  {
    produtos[idp_instrucao].custo = custo_instrucao;
  }
  else
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp_instrucao);
  }

}

void lista_quantidade_produto()
{
  int ide_instrucao;
  int idp_instrucao;
  int indice_produto;
  ide_instrucao = new_sym_var(sizeof(int) * 8);
  idp_instrucao = new_sym_var(sizeof(int) * 8);
  if (ide_instrucao < ide)
  {
    if (idp_instrucao < idp)
    {
      for (indice_produto = 0; (encomendas[ide_instrucao].idp_produtos[indice_produto] != idp_instrucao) && (indice_produto < 200); ++indice_produto)
        ;

      if (indice_produto != 200)
      {
        printf("%s %d.\n", produtos[idp_instrucao].desc, encomendas[ide_instrucao].quantidade_produtos[indice_produto]);
      }
      else
      {
        printf("%s 0.\n", produtos[idp_instrucao].desc);
      }

    }
    else
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp_instrucao);
    }

  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide_instrucao);
  }

}

void lista_produto_mais_referenciado()
{
  int idp_instrucao;
  int indice_encomenda;
  int indice_produto;
  int estado_produto;
  int max_referencia = 0;
  int ide_referencia = 0;
  int idp_referencia = 0;
  idp_instrucao = new_sym_var(sizeof(int) * 8);
  if (idp_instrucao < idp)
  {
    estado_produto = -1;
    for (indice_encomenda = 0; indice_encomenda < 500; ++indice_encomenda)
    {
      for (indice_produto = 0; indice_produto < 200; ++indice_produto)
        if (encomendas[indice_encomenda].idp_produtos[indice_produto] == idp_instrucao)
      {
        if ((encomendas[indice_encomenda].quantidade_produtos[indice_produto] > max_referencia) || ((encomendas[indice_encomenda].quantidade_produtos[indice_produto] == max_referencia) && (indice_encomenda < ide_referencia)))
        {
          max_referencia = encomendas[indice_encomenda].quantidade_produtos[indice_produto];
          ide_referencia = indice_encomenda;
          idp_referencia = indice_produto;
          indice_produto = 200;
          estado_produto = 1;
        }
        else
        {
          
        }

      }
      else
      {
        
      }


    }

    if (estado_produto == 1)
    {
      printf("Maximo produto %d %d %d.\n", idp_instrucao, ide_referencia, encomendas[ide_referencia].quantidade_produtos[idp_referencia]);
    }
    else
    {
      
    }

  }
  else
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp_instrucao);
  }

}

void lista_produtos_sistema()
{
  int custo_produtos[10000];
  int idp_produtos[10000];
  int indice_produto;
  int indice_1;
  int indice_2;
  for (indice_produto = 0; indice_produto < idp; ++indice_produto)
  {
    idp_produtos[indice_produto] = indice_produto;
    custo_produtos[indice_produto] = produtos[indice_produto].custo;
  }

  quick_sort(custo_produtos, idp_produtos, 0, idp - 1);
  for (indice_1 = 0; indice_1 < (idp - 1); ++indice_1)
    for (indice_2 = indice_1 + 1; indice_2 < idp; ++indice_2)
    if (custo_produtos[indice_1] == custo_produtos[indice_2])
  {
    for (; (custo_produtos[indice_1] == custo_produtos[indice_2 + 1]) && (indice_2 < idp); ++indice_2)
      ;

    selection_sort(custo_produtos, idp_produtos, indice_1, indice_2);
    indice_1 = indice_2;
    break;
  }
  else
  {
    
  }



  printf("Produtos\n");
  for (indice_produto = 0; indice_produto < idp; ++indice_produto)
    printf("* %s %d %d\n", produtos[idp_produtos[indice_produto]].desc, produtos[idp_produtos[indice_produto]].custo, produtos[idp_produtos[indice_produto]].quantidade);

}

void quick_sort(int custo_produtos[], int idp_produtos[], int esquerda, int direita)
{
  int indice;
  if (direita <= esquerda)
  {
    return;
  }
  else
  {
    
  }

  indice = particao(custo_produtos, idp_produtos, esquerda, direita);
  quick_sort(custo_produtos, idp_produtos, esquerda, indice - 1);
  quick_sort(custo_produtos, idp_produtos, indice + 1, direita);
}

int particao(int custo_produtos[], int idp_produtos[], int esquerda, int direita)
{
  int indice_e = esquerda - 1;
  int indice_d = direita;
  int v = custo_produtos[direita];
  int auxiliar_custo;
  int auxiliar_idp;
  while (indice_e < indice_d)
  {
    while (custo_produtos[++indice_e] < v)
      ;

    while (v < custo_produtos[--indice_d])
      if (indice_d == esquerda)
    {
      break;
    }
    else
    {
      
    }


    if (indice_e < indice_d)
    {
      auxiliar_custo = custo_produtos[indice_e];
      auxiliar_idp = idp_produtos[indice_e];
      custo_produtos[indice_e] = custo_produtos[indice_d];
      idp_produtos[indice_e] = idp_produtos[indice_d];
      custo_produtos[indice_d] = auxiliar_custo;
      idp_produtos[indice_d] = auxiliar_idp;
    }
    else
    {
      
    }

  }

  auxiliar_custo = custo_produtos[indice_e];
  auxiliar_idp = idp_produtos[indice_e];
  custo_produtos[indice_e] = custo_produtos[direita];
  idp_produtos[indice_e] = idp_produtos[direita];
  custo_produtos[direita] = auxiliar_custo;
  idp_produtos[direita] = auxiliar_idp;
  return indice_e;
}

void selection_sort(int custo_produtos[], int idp_produtos[], int indice_1, int indice_2)
{
  int indice_e;
  int indice_d;
  int auxiliar_custo;
  int auxiliar_idp;
  int min;
  for (indice_e = indice_1; indice_e <= (indice_2 - 1); indice_e++)
  {
    min = indice_e;
    for (indice_d = indice_e + 1; indice_d <= indice_2; indice_d++)
    {
      if ((custo_produtos[indice_d] == custo_produtos[min]) && (idp_produtos[indice_d] < idp_produtos[min]))
      {
        min = indice_d;
      }
      else
      {
        
      }

      if (custo_produtos[indice_d] != custo_produtos[min])
      {
        indice_d = idp;
      }
      else
      {
        
      }

    }

    auxiliar_custo = custo_produtos[indice_e];
    auxiliar_idp = idp_produtos[indice_e];
    custo_produtos[indice_e] = custo_produtos[min];
    idp_produtos[indice_e] = idp_produtos[min];
    custo_produtos[min] = auxiliar_custo;
    idp_produtos[min] = auxiliar_idp;
  }

}

void lista_produtos_encomenda()
{
  int ide_instrucao;
  int indice_e;
  int indice_d;
  int indice_produto;
  int min;
  int auxiliar_idp;
  int auxiliar_quantidade;
  ide_instrucao = new_sym_var(sizeof(int) * 8);
  if (ide_instrucao < ide)
  {
    for (indice_e = 0; indice_e < (200 - 1); indice_e++)
    {
      min = indice_e;
      for (indice_d = indice_e + 1; indice_d < 200; indice_d++)
      {
        if ((encomendas[ide_instrucao].idp_produtos[indice_e] != (-1)) && (encomendas[ide_instrucao].idp_produtos[indice_d] != (-1)))
        {
          if (strcmp(produtos[encomendas[ide_instrucao].idp_produtos[indice_d]].desc, produtos[encomendas[ide_instrucao].idp_produtos[min]].desc) < 0)
          {
            min = indice_d;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

      auxiliar_idp = encomendas[ide_instrucao].idp_produtos[indice_e];
      auxiliar_quantidade = encomendas[ide_instrucao].quantidade_produtos[indice_e];
      encomendas[ide_instrucao].idp_produtos[indice_e] = encomendas[ide_instrucao].idp_produtos[min];
      encomendas[ide_instrucao].quantidade_produtos[indice_e] = encomendas[ide_instrucao].quantidade_produtos[min];
      encomendas[ide_instrucao].idp_produtos[min] = auxiliar_idp;
      encomendas[ide_instrucao].quantidade_produtos[min] = auxiliar_quantidade;
    }

    printf("Encomenda %d\n", ide_instrucao);
    for (indice_produto = 0; indice_produto < 200; ++indice_produto)
      if (encomendas[ide_instrucao].idp_produtos[indice_produto] != (-1))
    {
      printf("* %s %d %d\n", produtos[encomendas[ide_instrucao].idp_produtos[indice_produto]].desc, produtos[encomendas[ide_instrucao].idp_produtos[indice_produto]].custo, encomendas[ide_instrucao].quantidade_produtos[indice_produto]);
    }
    else
    {
      
    }


  }
  else
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide_instrucao);
  }

}

