/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef int Item;
typedef struct 
{
  char desc[64];
  int preco;
  int peso;
  int qtd;
} Produto;
typedef struct 
{
  int idp;
  int qtd;
} ProdutoEncomenda;
typedef struct 
{
  ProdutoEncomenda produtos[200];
  int peso;
  int qtd_produtos;
} Encomenda;
Produto sistema_produtos[10000] = {{"", 0, 0, 0}};
int produtos_existentes = 0;
Encomenda sistema_encomendas[500] = {0};
int encomendas_existentes = 0;
int encomenda = 0;
int encontra_produto(int id_encomenda, int id_produto)
{
  int contador;
  int pos = -1;
  for (contador = 0; contador < sistema_encomendas[id_encomenda].qtd_produtos; contador++)
  {
    if (id_produto == sistema_encomendas[id_encomenda].produtos[contador].idp)
    {
      pos = contador;
      break;
    }
    else
    {
      
    }

  }

  return pos;
}

void adiciona_stock(int id_produto, int qtd_produto)
{
  if (id_produto >= produtos_existentes)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id_produto);
  }
  else
  {
    sistema_produtos[id_produto].qtd += qtd_produto;
  }

}

void remove_stock(int id_produto, int qtd_produto)
{
  if (id_produto >= produtos_existentes)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id_produto);
  }
  else
  {
    if ((sistema_produtos[id_produto].qtd - qtd_produto) < 0)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd_produto, id_produto);
    }
    else
    {
      sistema_produtos[id_produto].qtd -= qtd_produto;
    }

  }

}

void adiciona_produto(int id_encomenda, int id_produto, int qtd_produto)
{
  int pos;
  int encomenda_produtos;
  if (id_encomenda >= encomendas_existentes)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id_produto, id_encomenda);
  }
  else
  {
    if (id_produto >= produtos_existentes)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id_produto, id_encomenda);
    }
    else
    {
      if (qtd_produto > sistema_produtos[id_produto].qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_produto, id_encomenda);
      }
      else
      {
        if (((qtd_produto * sistema_produtos[id_produto].peso) + sistema_encomendas[id_encomenda].peso) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_produto, id_encomenda);
        }
        else
        {
          pos = encontra_produto(id_encomenda, id_produto);
          if (pos != (-1))
          {
            sistema_encomendas[id_encomenda].produtos[pos].qtd += qtd_produto;
          }
          else
          {
            encomenda_produtos = sistema_encomendas[id_encomenda].qtd_produtos;
            sistema_encomendas[id_encomenda].produtos[encomenda_produtos].idp = id_produto;
            sistema_encomendas[id_encomenda].produtos[encomenda_produtos].qtd = qtd_produto;
            sistema_encomendas[id_encomenda].qtd_produtos += 1;
          }

          sistema_encomendas[id_encomenda].peso += sistema_produtos[id_produto].peso * qtd_produto;
          remove_stock(id_produto, qtd_produto);
        }

      }

    }

  }

}

void remove_produto(int id_encomenda, int id_produto)
{
  int pos;
  int encomenda_produtos;
  if (id_encomenda >= encomendas_existentes)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id_produto, id_encomenda);
  }
  else
  {
    if (id_produto >= produtos_existentes)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_produto, id_encomenda);
    }
    else
    {
      pos = encontra_produto(id_encomenda, id_produto);
      if (pos != (-1))
      {
        sistema_encomendas[id_encomenda].qtd_produtos -= 1;
        sistema_encomendas[id_encomenda].peso -= sistema_encomendas[id_encomenda].produtos[pos].qtd * sistema_produtos[id_produto].peso;
        adiciona_stock(id_produto, sistema_encomendas[id_encomenda].produtos[pos].qtd);
        sistema_encomendas[id_encomenda].produtos[pos].idp = sistema_encomendas[id_encomenda].produtos[encomenda_produtos = sistema_encomendas[id_encomenda].qtd_produtos].idp;
        sistema_encomendas[id_encomenda].produtos[pos].qtd = sistema_encomendas[id_encomenda].produtos[encomenda_produtos].qtd;
        sistema_encomendas[id_encomenda].produtos[encomenda_produtos].idp = 0;
        sistema_encomendas[id_encomenda].produtos[encomenda_produtos].qtd = 0;
      }
      else
      {
        
      }

    }

  }

}

void calcula_custo(int id_encomenda)
{
  int contador;
  int custo = 0;
  int produto_id;
  int produto_qtd;
  if (id_encomenda >= encomendas_existentes)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", id_encomenda);
  }
  else
  {
    for (contador = 0; contador < sistema_encomendas[id_encomenda].qtd_produtos; contador++)
    {
      produto_id = sistema_encomendas[id_encomenda].produtos[contador].idp;
      produto_qtd = sistema_encomendas[id_encomenda].produtos[contador].qtd;
      custo += sistema_produtos[produto_id].preco * produto_qtd;
    }

    printf("Custo da encomenda %d %d.\n", id_encomenda, custo);
  }

}

void altera_preco(int id_produto, int preco)
{
  if (id_produto >= produtos_existentes)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id_produto);
  }
  else
  {
    sistema_produtos[id_produto].preco = preco;
  }

}

void lista_produto(int id_encomenda, int id_produto)
{
  int pos;
  int produto_qtd;
  if (id_encomenda >= encomendas_existentes)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_encomenda);
  }
  else
  {
    if (id_produto >= produtos_existentes)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", id_produto);
    }
    else
    {
      printf("%s ", sistema_produtos[id_produto].desc);
      pos = encontra_produto(id_encomenda, id_produto);
      if (pos != (-1))
      {
        produto_qtd = sistema_encomendas[id_encomenda].produtos[pos].qtd;
      }
      else
      {
        produto_qtd = 0;
      }

      printf("%d.\n", produto_qtd);
    }

  }

}

void lista_ocorrencia(int id_produto)
{
  int contador;
  int pos;
  int produto_qtd;
  int encomenda_pqtd[2] = {0};
  if (id_produto >= produtos_existentes)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id_produto);
  }
  else
  {
    for (contador = 0; contador < encomendas_existentes; contador++)
    {
      pos = encontra_produto(contador, id_produto);
      if ((pos != (-1)) && ((produto_qtd = sistema_encomendas[contador].produtos[pos].qtd) > encomenda_pqtd[1]))
      {
        encomenda_pqtd[0] = contador;
        encomenda_pqtd[1] = produto_qtd;
      }
      else
      {
        
      }

    }

    if (encomenda_pqtd[1] > 0)
    {
      printf("Maximo produto %d %d %d.\n", id_produto, encomenda_pqtd[0], encomenda_pqtd[1]);
    }
    else
    {
      
    }

  }

}

void quick_sort(Item tabela[], int l, int r, int flag);
void partition(Item tabela[], int l, int r, int flag)
{
  int i = l;
  int j = r;
  Item pivot = tabela[(l + r) / 2];
  while (i <= j)
  {
    while ((flag == 0) ? (strcmp(sistema_produtos[sistema_encomendas[encomenda].produtos[tabela[i]].idp].desc, sistema_produtos[sistema_encomendas[encomenda].produtos[pivot].idp].desc) < 0) : ((sistema_produtos[tabela[i]].preco == sistema_produtos[pivot].preco) ? (tabela[i] < pivot) : (sistema_produtos[tabela[i]].preco < sistema_produtos[pivot].preco)))
    {
      i++;
    }

    while ((flag == 0) ? (strcmp(sistema_produtos[sistema_encomendas[encomenda].produtos[pivot].idp].desc, sistema_produtos[sistema_encomendas[encomenda].produtos[tabela[j]].idp].desc) < 0) : ((sistema_produtos[pivot].preco == sistema_produtos[tabela[j]].preco) ? (pivot < tabela[j]) : (sistema_produtos[pivot].preco < sistema_produtos[tabela[j]].preco)))
    {
      j--;
    }

    if (i <= j)
    {
      {
        Item t = tabela[i];
        tabela[i] = tabela[j];
        tabela[j] = t;
      }
      ;
      i++;
      j--;
    }
    else
    {
      
    }

  }

  quick_sort(tabela, l, j, flag);
  quick_sort(tabela, i, r, flag);
}

void quick_sort(Item tabela[], int l, int r, int flag)
{
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  partition(tabela, l, r, flag);
}

void lista_sistema(void)
{
  int contador;
  int produtos_ids[10000] = {0};
  for (contador = 0; contador < produtos_existentes; contador++)
  {
    produtos_ids[contador] = contador;
  }

  if (produtos_existentes > 1)
  {
    quick_sort(produtos_ids, 0, produtos_existentes - 1, 1);
  }
  else
  {
    
  }

  printf("Produtos\n");
  for (contador = 0; contador < produtos_existentes; contador++)
  {
    printf("* %s %d %d\n", sistema_produtos[produtos_ids[contador]].desc, sistema_produtos[produtos_ids[contador]].preco, sistema_produtos[produtos_ids[contador]].qtd);
  }

}

void lista_encomenda(int id_encomenda)
{
  int contador;
  int encomenda_produtos;
  int posicoes[200] = {0};
  if (id_encomenda >= encomendas_existentes)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_encomenda);
  }
  else
  {
    encomenda = id_encomenda;
    for (contador = 0; contador < (encomenda_produtos = sistema_encomendas[id_encomenda].qtd_produtos); contador++)
    {
      posicoes[contador] = contador;
    }

    if (encomenda_produtos > 1)
    {
      quick_sort(posicoes, 0, encomenda_produtos - 1, 0);
    }
    else
    {
      
    }

    printf("Encomenda %d\n", id_encomenda);
    for (contador = 0; contador < encomenda_produtos; contador++)
    {
      printf("* %s %d %d\n", sistema_produtos[sistema_encomendas[id_encomenda].produtos[posicoes[contador]].idp].desc, sistema_produtos[sistema_encomendas[id_encomenda].produtos[posicoes[contador]].idp].preco, sistema_encomendas[id_encomenda].produtos[posicoes[contador]].qtd);
    }

  }

}

int main()
{
  char caracter;
  int arg_1;
  int arg_2;
  int arg_3;
  while (((caracter = getchar()) != 'x') && (caracter != EOF))
  {
    switch (caracter)
    {
      case 'a':
        for (int sistema_produtos_index = 0; sistema_produtos_index < 10; sistema_produtos_index++)
      {
        sistema_produtos[produtos_existentes].desc[sistema_produtos_index] = new_sym_var(sizeof(char) * 8);
      }

        sistema_produtos[produtos_existentes].desc[10 - 1] = '\0';
        sistema_produtos[produtos_existentes].preco = new_sym_var(sizeof(int) * 8);
        sistema_produtos[produtos_existentes].peso = new_sym_var(sizeof(int) * 8);
        sistema_produtos[produtos_existentes].qtd = new_sym_var(sizeof(int) * 8);
        printf("Novo produto %d.\n", produtos_existentes);
        produtos_existentes += 1;
        break;

      case 'q':
        arg_1 = new_sym_var(sizeof(int) * 8);
        arg_2 = new_sym_var(sizeof(int) * 8);
        adiciona_stock(arg_1, arg_2);
        break;

      case 'N':
        printf("Nova encomenda %d.\n", encomendas_existentes);
        encomendas_existentes += 1;
        break;

      case 'A':
        arg_1 = new_sym_var(sizeof(int) * 8);
        arg_2 = new_sym_var(sizeof(int) * 8);
        arg_3 = new_sym_var(sizeof(int) * 8);
        adiciona_produto(arg_1, arg_2, arg_3);
        break;

      case 'r':
        arg_1 = new_sym_var(sizeof(int) * 8);
        arg_2 = new_sym_var(sizeof(int) * 8);
        remove_stock(arg_1, arg_2);
        break;

      case 'R':
        arg_1 = new_sym_var(sizeof(int) * 8);
        arg_2 = new_sym_var(sizeof(int) * 8);
        remove_produto(arg_1, arg_2);
        break;

      case 'C':
        arg_1 = new_sym_var(sizeof(int) * 8);
        calcula_custo(arg_1);
        break;

      case 'p':
        arg_1 = new_sym_var(sizeof(int) * 8);
        arg_2 = new_sym_var(sizeof(int) * 8);
        altera_preco(arg_1, arg_2);
        break;

      case 'E':
        arg_1 = new_sym_var(sizeof(int) * 8);
        arg_2 = new_sym_var(sizeof(int) * 8);
        lista_produto(arg_1, arg_2);
        break;

      case 'm':
        arg_1 = new_sym_var(sizeof(int) * 8);
        lista_ocorrencia(arg_1);
        break;

      case 'l':
        lista_sistema();
        break;

      case 'L':
        arg_1 = new_sym_var(sizeof(int) * 8);
        lista_encomenda(arg_1);
        break;

    }

  }

  return 0;
}

