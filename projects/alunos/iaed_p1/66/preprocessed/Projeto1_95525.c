#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


struct struct_produtos
{
  int id;
  char desc[64];
  int preco;
  int peso;
  int qtd;
};
struct struct_produtos inventario[10000];
struct struct_produtos temp[10000];
struct struct_produtos aux[10000];
struct struct_encomendas
{
  int produtos[10000];
  int preco;
  int peso;
};
struct struct_encomendas encomendas[10000];
int i = 0;
int j = 0;
void command_a(char d[64], int p, int w, int q)
{
  inventario[i].id = i;
  inventario[i].preco = p;
  inventario[i].peso = w;
  inventario[i].qtd = q;
  strncpy(inventario[i].desc, d + 1, 64 - 1);
}

void command_q(int p, int q)
{
  inventario[p].qtd += q;
}

void command_A(int e, int p, int q)
{
  encomendas[e].produtos[p] += q;
  encomendas[e].peso = encomendas[e].peso + (inventario[p].peso * q);
  encomendas[e].preco = encomendas[e].preco + (inventario[p].preco * q);
}

void command_r(int p, int q)
{
  inventario[p].qtd = inventario[p].qtd - q;
}

void command_R(int e, int p, int q)
{
  encomendas[e].peso = encomendas[e].peso - (inventario[p].peso * q);
  encomendas[e].preco = encomendas[e].preco - (inventario[p].preco * q);
  encomendas[e].produtos[p] = 0;
}

int command_m(int p)
{
  int k;
  int e = -1;
  int m = 0;
  for (k = 0; k < j; k++)
    if (encomendas[k].produtos[p] > m)
  {
    m = encomendas[k].produtos[p];
    e = k;
  }
  else
  {
    
  }


  return e;
}

void merge(struct struct_produtos t[], int left, int m, int right, int mode)
{
  int k;
  int l;
  int n;
  for (k = m + 1; k > left; k--)
    aux[k - 1] = t[k - 1];

  for (l = m; l < right; l++)
    aux[(right + m) - l] = t[l + 1];

  for (n = left; n <= right; n++)
    if (mode)
  {
    if (strcmp(aux[l].desc, aux[k].desc) < 0)
    {
      t[n] = aux[l--];
    }
    else
    {
      t[n] = aux[k++];
    }

  }
  else
  {
    if ((aux[l].preco == aux[k].preco) && (aux[l].id < aux[k].id))
    {
      t[n] = aux[l--];
    }
    else
    {
      if ((aux[l].preco == aux[k].preco) && (aux[l].id > aux[k].id))
      {
        t[n] = aux[k++];
      }
      else
      {
        if (aux[l].preco < aux[k].preco)
        {
          t[n] = aux[l--];
        }
        else
        {
          t[n] = aux[k++];
        }

      }

    }

  }


}

void mergesort(struct struct_produtos t[], int left, int right, int mode)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(t, left, m, mode);
  mergesort(t, m + 1, right, mode);
  merge(t, left, m, right, mode);
}

int main()
{
  int command;
  int idp;
  int ide;
  int preco;
  int peso;
  int qtd;
  char desc[64];
  int k;
  int c;
  while ((command = getchar()) != 'x')
  {
    switch (command)
    {
      case 'a':
        for (int desc_index = 0; desc_index < 10; desc_index++)
      {
        desc[desc_index] = new_sym_var(sizeof(char) * 8);
      }

        desc[10 - 1] = '\0';
        preco = new_sym_var(sizeof(int) * 8);
        peso = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        command_a(desc, preco, peso, qtd);
        printf("Novo produto %d.\n", i);
        i++;
        break;

      case 'q':
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        if (i > idp)
      {
        command_q(idp, qtd);
      }
      else
      {
        printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
      }

        break;

      case 'N':
        encomendas[j].preco = 0;
        encomendas[j].peso = 0;
        printf("Nova encomenda %d.\n", j);
        j++;
        break;

      case 'A':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        if (j <= ide)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      }
      else
      {
        if (i <= idp)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
        }
        else
        {
          if (qtd > inventario[idp].qtd)
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
          }
          else
          {
            if ((encomendas[ide].peso + (inventario[idp].peso * qtd)) > 200)
            {
              printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
            }
            else
            {
              command_A(ide, idp, qtd);
              command_r(idp, qtd);
            }

          }

        }

      }

        break;

      case 'r':
        idp = new_sym_var(sizeof(int) * 8);
        qtd = new_sym_var(sizeof(int) * 8);
        if (i > idp)
      {
        if (qtd > inventario[idp].qtd)
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
        }
        else
        {
          command_r(idp, qtd);
        }

      }
      else
      {
        printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
      }

        break;

      case 'R':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        if (j <= ide)
      {
        printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      }
      else
      {
        if (i <= idp)
        {
          printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
        }
        else
        {
          command_q(idp, encomendas[ide].produtos[idp]);
          command_R(ide, idp, encomendas[ide].produtos[idp]);
        }

      }

        break;

      case 'C':
        ide = new_sym_var(sizeof(int) * 8);
        if (j <= ide)
      {
        printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
      }
      else
      {
        printf("Custo da encomenda %d %d.\n", ide, encomendas[ide].preco);
      }

        break;

      case 'p':
        idp = new_sym_var(sizeof(int) * 8);
        preco = new_sym_var(sizeof(int) * 8);
        if (i > idp)
      {
        for (ide = 0; ide <= j; ide++)
          if (encomendas[ide].produtos[idp] != 0)
        {
          encomendas[ide].preco = encomendas[ide].preco - (inventario[idp].preco * encomendas[ide].produtos[idp]);
          encomendas[ide].preco = encomendas[ide].preco + (preco * encomendas[ide].produtos[idp]);
        }
        else
        {
          
        }


        inventario[idp].preco = preco;
      }
      else
      {
        printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
      }

        break;

      case 'E':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        if (j <= ide)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      }
      else
      {
        if (i <= idp)
        {
          printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
        }
        else
        {
          printf("%s %d.\n", inventario[idp].desc, encomendas[ide].produtos[idp]);
        }

      }

        break;

      case 'm':
        idp = new_sym_var(sizeof(int) * 8);
        if (i <= idp)
      {
        printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
      }
      else
      {
        if (command_m(idp) == (-1))
        {
          ;
        }
        else
        {
          printf("Maximo produto %d %d %d.\n", idp, command_m(idp), encomendas[command_m(idp)].produtos[idp]);
        }

      }

        break;

      case 'l':
        printf("Produtos\n");
        for (k = 0; k < i; k++)
      {
        temp[k] = inventario[k];
      }

        mergesort(temp, 0, i - 1, 0);
        for (k = 0; k < i; k++)
        printf("* %s %d %d\n", temp[k].desc, temp[k].preco, temp[k].qtd);

        break;

      case 'L':
        ide = new_sym_var(sizeof(int) * 8);
        if (j <= ide)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      }
      else
      {
        printf("Encomenda %d\n", ide);
        c = 0;
        for (k = 0; k < i; k++)
          if (encomendas[ide].produtos[k] != 0)
        {
          temp[c] = inventario[k];
          temp[c].qtd = encomendas[ide].produtos[k];
          c++;
        }
        else
        {
          
        }


        mergesort(temp, 0, c - 1, 1);
        for (k = 0; k < c; k++)
          printf("* %s %d %d\n", temp[k].desc, temp[k].preco, temp[k].qtd);

      }

        break;

      case 'x':
        break;

    }

  }

  return 0;
}

