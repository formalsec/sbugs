/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef enum 
{
  ADD_PRODUCT = 'a',
  ADD_STOCK = 'q',
  ADD_ORDER = 'N',
  ADD_PRODUCT_ORDER = 'A',
  SUB_STOCK_PRODUCT = 'r',
  SUB_PRODUCT_ORDER = 'R',
  CALC_ORDER = 'C',
  CHANGE_PRICE = 'p',
  RETURN_DESC_QNT = 'E',
  RETURN_ORDER = 'm',
  LIST_PRODUCT_SIST = 'l',
  LIST_PRODUCT_ORDER = 'L',
  END_PROG = 'x',
  UNKNOWN_COMMAND = '\0'
} Command;
typedef struct 
{
  int id;
  char desc[64];
  int preco;
  int peso;
  int qtd;
} Product;
typedef struct 
{
  int id;
  int product_count;
  int weight;
  Product *products[200];
  int qtds[200];
} Order;
char buffer[100];
Product products[10000];
Order orders[500];
int product_count;
int order_count;
void swap(Product **p1, Product **p2)
{
  Product *temp = *p1;
  *p1 = *p2;
  *p2 = temp;
}

void swapQtd(int *q1, int *q2)
{
  int temp = *q1;
  *q1 = *q2;
  *q2 = temp;
}

void sort_preco(Product *products[], int product_count)
{
  int i;
  int j;
  int min;
  for (i = 0; i < (product_count - 1); i++)
  {
    min = i;
    for (j = i + 1; j < product_count; j++)
      if ((products[j]->preco < products[min]->preco) || ((products[j]->preco == products[min]->preco) && (products[j]->id < products[min]->id)))
    {
      min = j;
    }
    else
    {
      
    }


    swap(&products[min], &products[i]);
  }

}

void sort_desc(Product *products[], int qtds[], int product_count)
{
  int i;
  int j;
  int min;
  int cmp;
  for (i = 0; i < (product_count - 1); i++)
  {
    min = i;
    for (j = i + 1; j < product_count; j++)
    {
      cmp = strcmp(products[j]->desc, products[min]->desc);
      if (cmp < 0)
      {
        min = j;
      }
      else
      {
        
      }

    }

    swap(&products[min], &products[i]);
    swapQtd(&qtds[min], &qtds[i]);
  }

}

int find_product(int ide, int idp)
{
  int i;
  for (i = 0; i < orders[ide].product_count; i++)
    if (orders[ide].products[i]->id == idp)
  {
    return i;
  }
  else
  {
    
  }


  return -1;
}

void add_product(char *desc, int preco, int peso, int qtd)
{
  products[product_count].id = product_count;
  strcpy(products[product_count].desc, desc);
  products[product_count].preco = preco;
  products[product_count].peso = peso;
  products[product_count].qtd = qtd;
  printf("Novo produto %d.\n", products[product_count].id);
  product_count++;
}

void add_stock(int idp, int qtd)
{
  if (products[idp].id != idp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  products[idp].qtd += qtd;
}

void add_order()
{
  orders[order_count].id = order_count;
  orders[order_count].product_count = 0;
  printf("Nova encomenda %d.\n", order_count++);
}

void add_product_order(int ide, int idp, int qtd)
{
  int index;
  if (orders[ide].id != ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (products[idp].id != idp)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (products[idp].qtd < qtd)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if ((orders[ide].weight + (products[idp].peso * qtd)) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  products[idp].qtd -= qtd;
  index = find_product(ide, idp);
  if (index != (-1))
  {
    orders[ide].qtds[index] += qtd;
    orders[ide].weight += products[idp].peso * qtd;
    return;
  }
  else
  {
    
  }

  orders[ide].products[orders[ide].product_count] = &products[idp];
  orders[ide].qtds[orders[ide].product_count] = qtd;
  orders[ide].weight += products[idp].peso * qtd;
  orders[ide].product_count++;
}

void sub_stock_product(int idp, int qtd)
{
  if (products[idp].id != idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (products[idp].qtd < qtd)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    return;
  }
  else
  {
    
  }

  products[idp].qtd -= qtd;
}

void sub_product_order(int ide, int idp)
{
  int index;
  if (orders[ide].id != ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  if (products[idp].id != idp)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    return;
  }
  else
  {
    
  }

  index = find_product(ide, idp);
  if (index == (-1))
  {
    return;
  }
  else
  {
    
  }

  products[idp].qtd += orders[ide].qtds[index];
  orders[ide].product_count--;
  orders[ide].weight -= orders[ide].products[index]->peso * orders[ide].qtds[index];
  orders[ide].products[index] = orders[ide].products[orders[ide].product_count];
  orders[ide].qtds[index] = orders[ide].qtds[orders[ide].product_count];
}

void calc_order(int ide)
{
  int i;
  int total = 0;
  if (orders[ide].id != ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < orders[ide].product_count; i++)
    total += orders[ide].products[i]->preco * orders[ide].qtds[i];

  printf("Custo da encomenda %d %d.\n", ide, total);
}

void change_price(int idp, int preco)
{
  if (products[idp].id != idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  products[idp].preco = preco;
}

void return_desc_qnt(int ide, int idp)
{
  int index;
  if (orders[ide].id != ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  if (products[idp].id != idp)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  index = find_product(ide, idp);
  if (index == (-1))
  {
    printf("%s 0.\n", products[idp].desc);
  }
  else
  {
    printf("%s %d.\n", products[idp].desc, orders[ide].qtds[index]);
  }

}

void return_order(int idp)
{
  int i;
  int index;
  int max_ide;
  int max_qtd = -1;
  if (products[idp].id != idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < order_count; i++)
  {
    index = find_product(i, idp);
    if ((index != (-1)) && (orders[i].qtds[index] > max_qtd))
    {
      max_ide = i;
      max_qtd = orders[i].qtds[index];
    }
    else
    {
      
    }

  }

  if (max_qtd != (-1))
  {
    printf("Maximo produto %d %d %d.\n", idp, max_ide, max_qtd);
  }
  else
  {
    
  }

}

void list_product_sist()
{
  int i;
  Product *sorted_products[10000];
  for (i = 0; i < product_count; i++)
    sorted_products[i] = &products[i];

  sort_preco(sorted_products, product_count);
  printf("Produtos\n");
  for (i = 0; i < product_count; i++)
    printf("* %s %d %d\n", sorted_products[i]->desc, sorted_products[i]->preco, sorted_products[i]->qtd);

}

void list_product_order(int ide)
{
  int i;
  if (orders[ide].id != ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
    return;
  }
  else
  {
    
  }

  sort_desc(orders[ide].products, orders[ide].qtds, orders[ide].product_count);
  printf("Encomenda %d\n", ide);
  for (i = 0; i < orders[ide].product_count; i++)
    printf("* %s %d %d\n", orders[ide].products[i]->desc, orders[ide].products[i]->preco, orders[ide].qtds[i]);

}

void end_prog()
{
  exit(0);
}

void run_command(Command com, char *args)
{
  char desc[64];
  char *remaining_args;
  int preco;
  int peso;
  int qtd;
  int idp;
  int ide;
  switch (com)
  {
    case ADD_PRODUCT:
      remaining_args = strchr(args, ':');
      remaining_args[0] = '\0';
      remaining_args++;
      strcpy(desc, args);
      preco = new_sym_var(sizeof(int) * 8);
      peso = new_sym_var(sizeof(int) * 8);
      qtd = new_sym_var(sizeof(int) * 8);
      add_product(desc, preco, peso, qtd);
      break;

    case ADD_STOCK:
      idp = new_sym_var(sizeof(int) * 8);
      qtd = new_sym_var(sizeof(int) * 8);
      add_stock(idp, qtd);
      break;

    case ADD_ORDER:
      add_order();
      break;

    case ADD_PRODUCT_ORDER:
      ide = new_sym_var(sizeof(int) * 8);
      idp = new_sym_var(sizeof(int) * 8);
      qtd = new_sym_var(sizeof(int) * 8);
      add_product_order(ide, idp, qtd);
      break;

    case SUB_STOCK_PRODUCT:
      idp = new_sym_var(sizeof(int) * 8);
      qtd = new_sym_var(sizeof(int) * 8);
      sub_stock_product(idp, qtd);
      break;

    case SUB_PRODUCT_ORDER:
      ide = new_sym_var(sizeof(int) * 8);
      idp = new_sym_var(sizeof(int) * 8);
      sub_product_order(ide, idp);
      break;

    case CALC_ORDER:
      ide = new_sym_var(sizeof(int) * 8);
      calc_order(ide);
      break;

    case CHANGE_PRICE:
      idp = new_sym_var(sizeof(int) * 8);
      preco = new_sym_var(sizeof(int) * 8);
      change_price(idp, preco);
      break;

    case RETURN_DESC_QNT:
      ide = new_sym_var(sizeof(int) * 8);
      idp = new_sym_var(sizeof(int) * 8);
      return_desc_qnt(ide, idp);
      break;

    case RETURN_ORDER:
      idp = new_sym_var(sizeof(int) * 8);
      return_order(idp);
      break;

    case LIST_PRODUCT_SIST:
      list_product_sist();
      break;

    case LIST_PRODUCT_ORDER:
      ide = new_sym_var(sizeof(int) * 8);
      list_product_order(ide);
      break;

    case END_PROG:
      end_prog();
      break;

    default:
      break;

  }

}

Command read_command(char **args)
{
  if (!fgets(buffer, 100, stdin))
  {
    return UNKNOWN_COMMAND;
  }
  else
  {
    
  }

  *args = buffer + 2;
  return (Command) buffer[0];
}

void setup()
{
  int i;
  product_count = 0;
  order_count = 0;
  for (i = 0; i < 10000; i++)
    products[i].id = -1;

  for (i = 0; i < 500; i++)
    orders[i].id = -1;

}

int main()
{
  char *args = 0;
  setup();
  while (1)
  {
    Command com = read_command(&args);
    run_command(com, args);
  }

}

