/*File generated by PreProcessor.py*/


#include <stdio.h>


typedef struct 
{
  int identifier;
  char description[64];
  int price;
  int weight;
  int quantity;
} product;
typedef struct 
{
  int identifier;
  int quantity;
  int active;
} product_info;
typedef struct 
{
  product_info products_info[200];
} order;
int num_products = 0;
int num_orders = 0;
product products[10000];
order orders[500];
void command_a();
void command_q();
void command_N();
void command_A();
void command_r();
void command_R();
void command_C();
void command_p();
void command_E();
void command_m();
void command_l();
void command_L();
int main()
{
  char command;
  while ((command = getchar()) != 'x')
  {
    switch (command)
    {
      case 'a':
        command_a();
        break;

      case 'q':
        command_q();
        break;

      case 'N':
        command_N();
        break;

      case 'A':
        command_A();
        break;

      case 'r':
        command_r();
        break;

      case 'R':
        command_R();
        break;

      case 'C':
        command_C();
        break;

      case 'p':
        command_p();
        break;

      case 'E':
        command_E();
        break;

      case 'm':
        command_m();
        break;

      case 'l':
        command_l();
        break;

      case 'L':
        command_L();
        break;

      default:
        continue;

    }

  }

  return 0;
}

int calc_weight(order ord)
{
  int i;
  int weight_total = 0;
  for (i = 0; i < 200; i++)
  {
    if (ord.products_info[i].active)
    {
      weight_total += products[ord.products_info[i].identifier].weight * ord.products_info[i].quantity;
    }
    else
    {
      
    }

  }

  return weight_total;
}

int product_in_order(int product_id, order ord)
{
  int i;
  int in_order = -1;
  for (i = 0; i < 200; i++)
  {
    if (ord.products_info[i].active && (ord.products_info[i].identifier == product_id))
    {
      in_order = i;
      break;
    }
    else
    {
      
    }

  }

  return in_order;
}

int available_space(order ord)
{
  int i;
  int index = 0;
  for (i = 0; i < 200; i++)
  {
    if (ord.products_info[i].active == 0)
    {
      index = i;
      break;
    }
    else
    {
      
    }

  }

  return index;
}

int product_quantity_order(int product_id, order ord)
{
  int quantity = 0;
  int product_index;
  if ((product_index = product_in_order(product_id, ord)) != (-1))
  {
    quantity = ord.products_info[product_index].quantity;
  }
  else
  {
    
  }

  return quantity;
}

product prod_aux[10000];
int prod_less(product a, product b)
{
  return ((a.price == b.price) && (a.identifier < b.identifier)) || (a.price < b.price);
}

void prod_merge(product prods[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    prod_aux[i - 1] = prods[i - 1];
  }

  for (j = m; j < right; j++)
  {
    prod_aux[(right + m) - j] = prods[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if (prod_less(prod_aux[j], prod_aux[i]) || (i > m))
    {
      prods[k] = prod_aux[j--];
    }
    else
    {
      prods[k] = prod_aux[i++];
    }

  }

}

void prod_mergesort(product prods[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  prod_mergesort(prods, left, m);
  prod_mergesort(prods, m + 1, right);
  prod_merge(prods, left, m, right);
}

product_info order_aux[200];
int order_less(product_info a, product_info b)
{
  int i;
  int char_a;
  int char_b;
  for (i = 0; i < 64; i++)
  {
    char_b = products[b.identifier].description[i];
    char_a = products[a.identifier].description[i];
    if (char_b == '\0')
    {
      return 0;
    }
    else
    {
      if (char_a == '\0')
      {
        return 1;
      }
      else
      {
        if (char_a == char_b)
        {
          continue;
        }
        else
        {
          return char_a < char_b;
        }

      }

    }

  }

  return 0;
}

void order_merge(product_info prods[], int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
  {
    order_aux[i - 1] = prods[i - 1];
  }

  for (j = m; j < right; j++)
  {
    order_aux[(right + m) - j] = prods[j + 1];
  }

  for (k = left; k <= right; k++)
  {
    if (order_less(order_aux[j], order_aux[i]) || (i > m))
    {
      prods[k] = order_aux[j--];
    }
    else
    {
      prods[k] = order_aux[i++];
    }

  }

}

void order_mergesort(product_info prods[], int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  order_mergesort(prods, left, m);
  order_mergesort(prods, m + 1, right);
  order_merge(prods, left, m, right);
}

void command_a()
{
  int identifier;
  num_products++;
  identifier = num_products - 1;
  products[identifier].identifier = identifier;
  for (int products_index = 0; products_index < 10; products_index++)
  {
    products[identifier].description[products_index] = new_sym_var(sizeof(char) * 8);
  }

  products[identifier].description[10 - 1] = '\0';
  products[identifier].price = new_sym_var(sizeof(int) * 8);
  products[identifier].weight = new_sym_var(sizeof(int) * 8);
  products[identifier].quantity = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", identifier);
}

void command_q()
{
  int product_id;
  int quantity;
  product_id = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (product_id >= num_products)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", product_id);
  }
  else
  {
    products[product_id].quantity += quantity;
  }

}

void command_N()
{
  int order_id;
  num_orders++;
  order_id = num_orders - 1;
  printf("Nova encomenda %d.\n", order_id);
}

void command_A()
{
  int order_id;
  int product_id;
  int quantity;
  int product_index;
  order_id = new_sym_var(sizeof(int) * 8);
  product_id = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (order_id >= num_orders)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", product_id, order_id);
  }
  else
  {
    if (product_id >= num_products)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", product_id, order_id);
    }
    else
    {
      if (quantity > products[product_id].quantity)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", product_id, order_id);
      }
      else
      {
        if ((calc_weight(orders[order_id]) + (products[product_id].weight * quantity)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", product_id, order_id);
        }
        else
        {
          products[product_id].quantity -= quantity;
          if ((product_index = product_in_order(product_id, orders[order_id])) != (-1))
          {
            orders[order_id].products_info[product_index].quantity += quantity;
          }
          else
          {
            product_index = available_space(orders[order_id]);
            orders[order_id].products_info[product_index].active = 1;
            orders[order_id].products_info[product_index].identifier = products[product_id].identifier;
            orders[order_id].products_info[product_index].quantity = quantity;
          }

        }

      }

    }

  }

}

void command_r()
{
  int product_id;
  int quantity;
  product_id = new_sym_var(sizeof(int) * 8);
  quantity = new_sym_var(sizeof(int) * 8);
  if (product_id >= num_products)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", product_id);
  }
  else
  {
    if (quantity > products[product_id].quantity)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantity, product_id);
    }
    else
    {
      products[product_id].quantity -= quantity;
    }

  }

}

void command_R()
{
  int order_id;
  int product_id;
  int product_index;
  order_id = new_sym_var(sizeof(int) * 8);
  product_id = new_sym_var(sizeof(int) * 8);
  if (order_id >= num_orders)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", product_id, order_id);
  }
  else
  {
    if (product_id >= num_products)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", product_id, order_id);
    }
    else
    {
      if ((product_index = product_in_order(product_id, orders[order_id])) != (-1))
      {
        orders[order_id].products_info[product_index].active = 0;
        products[product_id].quantity += orders[order_id].products_info[product_index].quantity;
      }
      else
      {
        
      }

    }

  }

}

void command_C()
{
  int i;
  int price_total = 0;
  int order_id;
  order_id = new_sym_var(sizeof(int) * 8);
  if (order_id >= num_orders)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", order_id);
  }
  else
  {
    for (i = 0; i < 200; i++)
    {
      if (orders[order_id].products_info[i].active)
      {
        price_total += products[orders[order_id].products_info[i].identifier].price * orders[order_id].products_info[i].quantity;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d %d.\n", order_id, price_total);
  }

}

void command_p()
{
  int product_id;
  int price;
  product_id = new_sym_var(sizeof(int) * 8);
  price = new_sym_var(sizeof(int) * 8);
  if (product_id >= num_products)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", product_id);
  }
  else
  {
    products[product_id].price = price;
  }

}

void command_E()
{
  int order_id;
  int product_id;
  order_id = new_sym_var(sizeof(int) * 8);
  product_id = new_sym_var(sizeof(int) * 8);
  if (order_id >= num_orders)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order_id);
  }
  else
  {
    if (product_id >= num_products)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", product_id);
    }
    else
    {
      printf("%s %d.\n", products[product_id].description, product_quantity_order(product_id, orders[order_id]));
    }

  }

}

void command_m()
{
  int i;
  int product_id;
  int quantity_temp = 0;
  int order_id_max = 0;
  int quantity_max = 0;
  product_id = new_sym_var(sizeof(int) * 8);
  if (product_id >= num_products)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", product_id);
  }
  else
  {
    if (num_orders == 0)
    {
      return;
    }
    else
    {
      for (i = 0; i < num_orders; i++)
      {
        if ((quantity_temp = product_quantity_order(product_id, orders[i])) > quantity_max)
        {
          quantity_max = quantity_temp;
          order_id_max = i;
        }
        else
        {
          
        }

      }

      if (quantity_max == 0)
      {
        return;
      }
      else
      {
        printf("Maximo produto %d %d %d.\n", product_id, order_id_max, quantity_max);
      }

    }

  }

}

void command_l()
{
  int i;
  product products_copy[10000];
  for (i = 0; i < num_products; i++)
  {
    products_copy[i] = products[i];
  }

  prod_mergesort(products_copy, 0, num_products - 1);
  printf("Produtos\n");
  for (i = 0; i < num_products; i++)
  {
    printf("* %s %d %d\n", products_copy[i].description, products_copy[i].price, products_copy[i].quantity);
  }

}

void command_L()
{
  int i;
  int order_id;
  int max_index_copy = 0;
  product_info products_info_copy[200];
  order_id = new_sym_var(sizeof(int) * 8);
  if (order_id >= num_orders)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", order_id);
  }
  else
  {
    for (i = 0; i < 200; i++)
    {
      if (orders[order_id].products_info[i].active)
      {
        products_info_copy[max_index_copy++] = orders[order_id].products_info[i];
      }
      else
      {
        
      }

    }

    order_mergesort(products_info_copy, 0, max_index_copy - 1);
    printf("Encomenda %d\n", order_id);
    for (i = 0; i < max_index_copy; i++)
    {
      if (products_info_copy[i].active)
      {
        printf("* %s %d %d\n", products[products_info_copy[i].identifier].description, products[products_info_copy[i].identifier].price, products_info_copy[i].quantity);
      }
      else
      {
        
      }

    }

  }

}

