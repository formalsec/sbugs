#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  int idp;
  char descricao[63];
  int preco;
  int peso;
  int qtd;
} Produto;
typedef struct encomenda
{
  int ide;
  int peso;
  int cont_produtos;
  Produto lista_p[200];
} Encomenda;
int cont_idp = 0;
int cont_ide = 0;
Produto catalogo[10000] = {0};
Encomenda encomendas[500] = {0};
Produto aux_preco[10000];
Produto aux_descricao[200];
void merge_preco(Produto a[], int esquerda, int meio, int direita)
{
  int i;
  int j;
  int k;
  for (i = meio + 1; i > esquerda; i--)
  {
    aux_preco[i - 1] = a[i - 1];
  }

  for (j = meio; j < direita; j++)
  {
    aux_preco[(direita + meio) - j] = a[j + 1];
  }

  for (k = esquerda; k <= direita; k++)
  {
    if (aux_preco[j].preco <= aux_preco[i].preco)
    {
      if ((aux_preco[j].preco == aux_preco[i].preco) && (aux_preco[i].idp < aux_preco[j].idp))
      {
        a[k] = aux_preco[i++];
        continue;
      }
      else
      {
        
      }

      a[k] = aux_preco[j--];
    }
    else
    {
      a[k] = aux_preco[i++];
    }

  }

  return;
}

void merge_descricao(Produto a[], int esquerda, int meio, int direita)
{
  int i;
  int j;
  int k;
  for (i = meio + 1; i > esquerda; i--)
  {
    aux_descricao[i - 1] = a[i - 1];
  }

  for (j = meio; j < direita; j++)
  {
    aux_descricao[(direita + meio) - j] = a[j + 1];
  }

  for (k = esquerda; k <= direita; k++)
  {
    if (strcmp(aux_descricao[j].descricao, aux_descricao[i].descricao) < 0)
    {
      a[k] = aux_descricao[j--];
    }
    else
    {
      a[k] = aux_descricao[i++];
    }

  }

  return;
}

void merge_sort(Produto a[], int esquerda, int direita, char funcao)
{
  int meio = (direita + esquerda) / 2;
  if (direita <= esquerda)
  {
    return;
  }
  else
  {
    
  }

  merge_sort(a, esquerda, meio, funcao);
  merge_sort(a, meio + 1, direita, funcao);
  if (funcao == 'l')
  {
    merge_preco(a, esquerda, meio, direita);
  }
  else
  {
    if (funcao == 'L')
    {
      merge_descricao(a, esquerda, meio, direita);
    }
    else
    {
      
    }

  }

  return;
}

void adiciona_produto()
{
  Produto p;
  for (int p_index = 0; p_index < 10; p_index++)
  {
    p.descricao[p_index] = new_sym_var(sizeof(char) * 8);
  }

  p.descricao[10 - 1] = '\0';
  p.preco = new_sym_var(sizeof(int) * 8);
  p.peso = new_sym_var(sizeof(int) * 8);
  p.qtd = new_sym_var(sizeof(int) * 8);
  p.idp = cont_idp;
  catalogo[cont_idp] = p;
  cont_idp++;
  printf("Novo produto %d.\n", p.idp);
  return;
}

void adiciona_stock()
{
  int id_produto;
  int stock;
  id_produto = new_sym_var(sizeof(int) * 8);
  stock = new_sym_var(sizeof(int) * 8);
  if (id_produto < cont_idp)
  {
    catalogo[id_produto].qtd += stock;
    return;
  }
  else
  {
    
  }

  printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id_produto);
  return;
}

void nova_encomenda()
{
  Encomenda e;
  e.ide = cont_ide;
  encomendas[cont_ide] = e;
  cont_ide++;
  printf("Nova encomenda %d.\n", e.ide);
  return;
}

void adiciona_produto_encomenda()
{
  int id_encomenda;
  int id_produto;
  int quantidade;
  int i;
  int encontrou = 0;
  id_encomenda = new_sym_var(sizeof(int) * 8);
  id_produto = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (id_encomenda >= cont_ide)
  {
    ;
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", id_produto, id_encomenda);
    return;
  }
  else
  {
    
  }

  if (id_produto >= cont_idp)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", id_produto, id_encomenda);
    return;
  }
  else
  {
    
  }

  if (quantidade > catalogo[id_produto].qtd)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", id_produto, id_encomenda);
    return;
  }
  else
  {
    
  }

  encomendas[id_encomenda].peso += catalogo[id_produto].peso * quantidade;
  if (encomendas[id_encomenda].peso > 200)
  {
    encomendas[id_encomenda].peso -= catalogo[id_produto].peso * quantidade;
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", id_produto, id_encomenda);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[id_encomenda].cont_produtos; i++)
  {
    if (encomendas[id_encomenda].lista_p[i].idp == id_produto)
    {
      encontrou = 1;
      encomendas[id_encomenda].lista_p[i].qtd += quantidade;
      catalogo[id_produto].qtd -= quantidade;
      return;
    }
    else
    {
      
    }

  }

  if (encontrou == 0)
  {
    encomendas[id_encomenda].lista_p[encomendas[id_encomenda].cont_produtos] = catalogo[id_produto];
    encomendas[id_encomenda].lista_p[encomendas[id_encomenda].cont_produtos].qtd = 0;
    encomendas[id_encomenda].lista_p[i].qtd += quantidade;
    encomendas[id_encomenda].cont_produtos++;
    catalogo[id_produto].qtd -= quantidade;
  }
  else
  {
    
  }

  return;
}

void remove_stock()
{
  int id_produto;
  int quantidade;
  id_produto = new_sym_var(sizeof(int) * 8);
  quantidade = new_sym_var(sizeof(int) * 8);
  if (id_produto >= cont_idp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", id_produto);
    return;
  }
  else
  {
    
  }

  if (catalogo[id_produto].qtd < quantidade)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantidade, id_produto);
    return;
  }
  else
  {
    
  }

  catalogo[id_produto].qtd -= quantidade;
  return;
}

void remove_produto_encomenda()
{
  int i;
  int id_produto;
  int id_encomenda;
  int encontrou = 0;
  id_encomenda = new_sym_var(sizeof(int) * 8);
  id_produto = new_sym_var(sizeof(int) * 8);
  if (id_encomenda >= cont_ide)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", id_produto, id_encomenda);
    return;
  }
  else
  {
    
  }

  if (id_produto >= cont_idp)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", id_produto, id_encomenda);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[id_encomenda].cont_produtos; i++)
  {
    if (encomendas[id_encomenda].lista_p[i].idp == id_produto)
    {
      catalogo[id_produto].qtd += encomendas[id_encomenda].lista_p[i].qtd;
      encomendas[id_encomenda].peso -= catalogo[id_produto].peso * encomendas[id_encomenda].lista_p[i].qtd;
      encontrou = 1;
    }
    else
    {
      
    }

    if (encontrou == 1)
    {
      encomendas[id_encomenda].lista_p[i] = encomendas[id_encomenda].lista_p[i + 1];
    }
    else
    {
      
    }

  }

  if (encontrou == 1)
  {
    encomendas[id_encomenda].cont_produtos--;
  }
  else
  {
    
  }

  return;
}

void custo_encomenda()
{
  int id_encomenda;
  int i;
  int custo = 0;
  id_encomenda = new_sym_var(sizeof(int) * 8);
  if (id_encomenda >= cont_ide)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", id_encomenda);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[id_encomenda].cont_produtos; i++)
  {
    custo += encomendas[id_encomenda].lista_p[i].preco * encomendas[id_encomenda].lista_p[i].qtd;
  }

  printf("Custo da encomenda %d %d.\n", id_encomenda, custo);
  return;
}

void altera_preco()
{
  int id_produto;
  int novo_preco;
  int i;
  int j;
  id_produto = new_sym_var(sizeof(int) * 8);
  novo_preco = new_sym_var(sizeof(int) * 8);
  if (id_produto >= cont_idp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", id_produto);
    return;
  }
  else
  {
    
  }

  catalogo[id_produto].preco = novo_preco;
  for (i = 0; i < cont_ide; i++)
  {
    for (j = 0; j < encomendas[i].cont_produtos; j++)
    {
      if (encomendas[i].lista_p[j].idp == id_produto)
      {
        encomendas[i].lista_p[j].preco = novo_preco;
        break;
      }
      else
      {
        
      }

    }

  }

  return;
}

void lista_descricao_qtd()
{
  int id_produto;
  int id_encomenda;
  int i;
  id_encomenda = new_sym_var(sizeof(int) * 8);
  id_produto = new_sym_var(sizeof(int) * 8);
  if (id_encomenda >= cont_ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_encomenda);
    return;
  }
  else
  {
    
  }

  if (id_produto >= cont_idp)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", id_produto);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < encomendas[id_encomenda].cont_produtos; i++)
  {
    if (encomendas[id_encomenda].lista_p[i].idp == id_produto)
    {
      printf("%s %d.\n", encomendas[id_encomenda].lista_p[i].descricao, encomendas[id_encomenda].lista_p[i].qtd);
      return;
    }
    else
    {
      
    }

  }

  printf("%s 0.\n", catalogo[id_produto].descricao);
  return;
}

void encomenda_mais_produto()
{
  int id_produto;
  int i;
  int j;
  int maior_qtd = 0;
  int encontrou = 0;
  int id_encomenda;
  id_produto = new_sym_var(sizeof(int) * 8);
  if (id_produto >= cont_idp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", id_produto);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < cont_ide; i++)
  {
    for (j = 0; j < encomendas[i].cont_produtos; j++)
    {
      if ((encomendas[i].lista_p[j].idp == id_produto) && (encomendas[i].lista_p[j].qtd > maior_qtd))
      {
        maior_qtd = encomendas[i].lista_p[j].qtd;
        id_encomenda = i;
        encontrou = 1;
      }
      else
      {
        
      }

    }

  }

  if (encontrou == 1)
  {
    printf("Maximo produto %d %d %d.\n", id_produto, id_encomenda, maior_qtd);
  }
  else
  {
    
  }

  return;
}

void lista_por_preco()
{
  int i;
  Produto lista[10000];
  for (i = 0; i < cont_idp; i++)
  {
    lista[i] = catalogo[i];
  }

  merge_sort(lista, 0, cont_idp - 1, 'l');
  printf("Produtos\n");
  for (i = 0; i < cont_idp; i++)
  {
    printf("* %s %d %d\n", lista[i].descricao, lista[i].preco, lista[i].qtd);
  }

  return;
}

void lista_alfabeticamente()
{
  int id_encomenda;
  int i;
  id_encomenda = new_sym_var(sizeof(int) * 8);
  if (id_encomenda >= cont_ide)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", id_encomenda);
    return;
  }
  else
  {
    
  }

  merge_sort(encomendas[id_encomenda].lista_p, 0, encomendas[id_encomenda].cont_produtos - 1, 'L');
  printf("Encomenda %d\n", id_encomenda);
  for (i = 0; i < encomendas[id_encomenda].cont_produtos; i++)
  {
    printf("* %s %d %d\n", encomendas[id_encomenda].lista_p[i].descricao, encomendas[id_encomenda].lista_p[i].preco, encomendas[id_encomenda].lista_p[i].qtd);
  }

  return;
}

int main()
{
  char c;
  while ((c = getchar()) != 'x')
  {
    switch (c)
    {
      case 'a':
        adiciona_produto();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        nova_encomenda();
        break;

      case 'A':
        adiciona_produto_encomenda();
        break;

      case 'r':
        remove_stock();
        break;

      case 'R':
        remove_produto_encomenda();
        break;

      case 'C':
        custo_encomenda();
        break;

      case 'p':
        altera_preco();
        break;

      case 'E':
        lista_descricao_qtd();
        break;

      case 'm':
        encomenda_mais_produto();
        break;

      case 'l':
        lista_por_preco();
        break;

      case 'L':
        lista_alfabeticamente();
        break;

      default:
        break;

    }

  }

  return 0;
}

