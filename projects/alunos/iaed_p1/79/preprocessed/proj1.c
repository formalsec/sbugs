/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct produto
{
  int id;
  char desc[63];
  int preco;
  int peso;
  int stock;
} produto;
typedef struct encomenda_info
{
  struct produto produtos[200];
  int ponteiro;
  int peso;
  int custo;
} encomenda_info;
int tam_sistema;
int ide_atual;
int ide;
int idp;
int qtd;
int custo;
int preco;
int i;
int k;
int j;
produto sistema[100000];
encomenda_info encomendas[500];
void adiciona_produtos();
void adiciona_stock();
void cria_nova_encomenda();
void adiciona_produto_encomenda();
void remover_stock_produto();
void remover_produto_encomenda();
void custo_encomenda();
void alterar_preco_produto();
void lista_descricao();
void max_produto();
void listar_produtos();
void listar_produtos_encomenda();
void resetar_produto_da_encomenda(int ide, int id_ide);
void acertar_lista(int ide, int idp);
int listar_encomendas(int, int idp);
int verifica_menor(char a[], char b[]);
void merge_sort_sistema(int esquerda, int direita, int a[], int aux[]);
void merge_sort_encomenda(int esquerda, int direita, int ide, int a[], int aux[]);
void merge_encomenda(int esquerda, int meio, int direita, int ide, int a[], int aux[]);
void merge_sistema(int esquerda, int meio, int direita, int a[], int aux[]);
int main()
{
  char c;
  c = getchar();
  while (c != 'x')
  {
    switch (c)
    {
      case 'a':
        adiciona_produtos();
        break;

      case 'q':
        adiciona_stock();
        break;

      case 'N':
        cria_nova_encomenda();
        break;

      case 'A':
        adiciona_produto_encomenda();
        break;

      case 'r':
        remover_stock_produto();
        break;

      case 'R':
        remover_produto_encomenda();
        break;

      case 'C':
        custo_encomenda();
        break;

      case 'p':
        alterar_preco_produto();
        break;

      case 'E':
        lista_descricao();
        break;

      case 'm':
        max_produto();
        break;

      case 'l':
        listar_produtos();
        break;

      case 'L':
        listar_produtos_encomenda();
        break;

    }

    c = getchar();
  }

  return 0;
}

void adiciona_produtos()
{
  for (int sistema_index = 0; sistema_index < 10; sistema_index++)
  {
    sistema[tam_sistema].desc[sistema_index] = new_sym_var(sizeof(char) * 8);
  }

  sistema[tam_sistema].desc[10 - 1] = '\0';
  sistema[tam_sistema].preco = new_sym_var(sizeof(int) * 8);
  sistema[tam_sistema].peso = new_sym_var(sizeof(int) * 8);
  sistema[tam_sistema].stock = new_sym_var(sizeof(int) * 8);
  sistema[tam_sistema].id = tam_sistema;
  tam_sistema++;
  printf("Novo produto %d.\n", tam_sistema - 1);
}

void adiciona_stock()
{
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if ((idp >= 100000) || (sistema[idp].peso == 0))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }
  else
  {
    
  }

  sistema[idp].stock += qtd;
}

void cria_nova_encomenda()
{
  printf("Nova encomenda %d.\n", ide_atual);
  ide_atual++;
}

void adiciona_produto_encomenda()
{
  int total_peso = 0;
  int id_ide;
  int stock;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  stock = sistema[idp].stock - qtd;
  total_peso += encomendas[ide].peso + (sistema[idp].peso * qtd);
  if (ide >= ide_atual)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= tam_sistema)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      if (stock < 0)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        if (total_peso > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          if (listar_encomendas(ide, idp) != 201)
          {
            id_ide = listar_encomendas(ide, idp);
            encomendas[ide].produtos[id_ide].stock += qtd;
            encomendas[ide].peso = total_peso;
            strcpy(encomendas[ide].produtos[id_ide].desc, sistema[idp].desc);
            remover_stock_produto(idp, qtd);
          }
          else
          {
            encomendas[ide].produtos[encomendas[ide].ponteiro] = sistema[idp];
            encomendas[ide].produtos[encomendas[ide].ponteiro].stock = qtd;
            strcpy(encomendas[ide].produtos[encomendas[ide].ponteiro].desc, sistema[idp].desc);
            encomendas[ide].peso = total_peso;
            encomendas[ide].ponteiro++;
            remover_stock_produto(idp, qtd);
          }

        }

      }

    }

  }

}

void remover_stock_produto()
{
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= tam_sistema)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    if (qtd > sistema[idp].stock)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      sistema[idp].stock -= qtd;
    }

  }

}

int listar_encomendas(int ide, int idp)
{
  for (i = 0; i < ide_atual; i++)
    if (i == ide)
  {
    for (k = 0; k < encomendas[i].ponteiro; k++)
      if (encomendas[i].produtos[k].id == idp)
    {
      return k;
    }
    else
    {
      
    }


  }
  else
  {
    
  }


  return 201;
}

void remover_produto_encomenda()
{
  int id_ide;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_atual)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= tam_sistema)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      id_ide = listar_encomendas(ide, idp);
      if (id_ide != 201)
      {
        sistema[idp].stock += encomendas[ide].produtos[id_ide].stock;
        encomendas[ide].peso -= encomendas[ide].produtos[id_ide].stock * encomendas[ide].produtos[id_ide].peso;
        resetar_produto_da_encomenda(ide, id_ide);
        acertar_lista(ide, idp);
      }
      else
      {
        
      }

    }

  }

}

void acertar_lista(int ide, int idp)
{
  int indice1;
  indice1 = listar_encomendas(ide, idp);
  for (; indice1 <= (encomendas[ide].ponteiro - 2); indice1++)
  {
    encomendas[ide].produtos[indice1].id = encomendas[ide].produtos[indice1 + 1].id;
    encomendas[ide].produtos[indice1].peso = encomendas[ide].produtos[indice1 + 1].peso;
    encomendas[ide].produtos[indice1].stock = encomendas[ide].produtos[indice1 + 1].stock;
    encomendas[ide].produtos[indice1].preco = encomendas[ide].produtos[indice1 + 1].preco;
    strcpy(encomendas[ide].produtos[indice1].desc, encomendas[ide].produtos[indice1 + 1].desc);
  }

  encomendas[ide].ponteiro = encomendas[ide].ponteiro - 1;
}

void resetar_produto_da_encomenda(int ide, int id_ide)
{
  for (i = 0; i < 63; i++)
    encomendas[ide].produtos[id_ide].desc[i] = 0;

  encomendas[ide].produtos[id_ide].stock = 0;
  encomendas[ide].produtos[id_ide].preco = 0;
  encomendas[ide].produtos[id_ide].peso = 0;
}

void custo_encomenda(int ide)
{
  int custo_total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_atual)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (k = 0; k < encomendas[ide].ponteiro; k++)
      custo_total += encomendas[ide].produtos[k].stock * encomendas[ide].produtos[k].preco;

    encomendas[ide].custo = custo_total;
    printf("Custo da encomenda %d %d.\n", ide, encomendas[ide].custo);
  }

}

void alterar_preco_produto()
{
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= tam_sistema)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    sistema[idp].preco = preco;
    for (i = 0; i < ide_atual; i++)
      for (k = 0; k < encomendas[i].ponteiro; k++)
      if (encomendas[i].produtos[k].id == idp)
    {
      encomendas[i].produtos[k].preco = sistema[idp].preco;
    }
    else
    {
      
    }



  }

}

void lista_descricao()
{
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= ide_atual)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    if (idp >= tam_sistema)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      if (listar_encomendas(ide, idp) != 201)
      {
        printf("%s %d.\n", sistema[idp].desc, encomendas[ide].produtos[listar_encomendas(ide, idp)].stock);
      }
      else
      {
        printf("%s %d.\n", sistema[idp].desc, 0);
      }

    }

  }

}

void max_produto()
{
  int max_produto = 0;
  int max_ide;
  int dentro = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= tam_sistema)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; i < ide_atual; i++)
      for (k = 0; k < encomendas[i].ponteiro; k++)
    {
      if ((encomendas[i].produtos[k].id == idp) && (encomendas[i].produtos[k].stock > max_produto))
      {
        max_produto = encomendas[i].produtos[k].stock;
        max_ide = i;
        dentro = 1;
      }
      else
      {
        
      }

    }


    if (dentro == 1)
    {
      printf("Maximo produto %d %d %d.\n", idp, max_ide, max_produto);
    }
    else
    {
      
    }

  }

}

void listar_produtos()
{
  int v[100000];
  int aux[100000];
  for (i = 0; i < tam_sistema; i++)
  {
    v[i] = i;
  }

  merge_sort_sistema(0, tam_sistema - 1, v, aux);
  printf("Produtos\n");
  for (i = 0; i < tam_sistema; i++)
    printf("* %s %d %d\n", sistema[v[i]].desc, sistema[v[i]].preco, sistema[v[i]].stock);

}

void merge_sort_sistema(int esquerda, int direita, int a[], int aux[])
{
  int meio = (esquerda + direita) / 2;
  if (direita <= esquerda)
  {
    return;
  }
  else
  {
    
  }

  merge_sort_sistema(esquerda, meio, a, aux);
  merge_sort_sistema(meio + 1, direita, a, aux);
  merge_sistema(esquerda, meio, direita, a, aux);
}

void merge_sistema(int esquerda, int meio, int direita, int a[], int aux[])
{
  for (i = meio + 1; i > esquerda; i--)
    aux[i - 1] = a[i - 1];

  for (j = meio; j < direita; j++)
    aux[(direita + meio) - j] = a[j + 1];

  for (k = esquerda; k <= direita; k++)
    if ((sistema[aux[j]].preco < sistema[aux[i]].preco) || (i > meio))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

void listar_produtos_encomenda()
{
  int tamanho;
  int vetor[200];
  int aux[200];
  ide = new_sym_var(sizeof(int) * 8);
  tamanho = encomendas[ide].ponteiro;
  if (ide >= ide_atual)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < tamanho; i++)
      vetor[i] = i;

    merge_sort_encomenda(0, tamanho - 1, ide, vetor, aux);
    printf("Encomenda %d\n", ide);
    for (i = 0; i < tamanho; i++)
      printf("* %s %d %d\n", encomendas[ide].produtos[vetor[i]].desc, encomendas[ide].produtos[vetor[i]].preco, encomendas[ide].produtos[vetor[i]].stock);

  }

}

void merge_sort_encomenda(int esquerda, int direita, int ide, int a[], int aux[])
{
  int meio = (esquerda + direita) / 2;
  if (direita <= esquerda)
  {
    return;
  }
  else
  {
    
  }

  merge_sort_encomenda(esquerda, meio, ide, a, aux);
  merge_sort_encomenda(meio + 1, direita, ide, a, aux);
  merge_encomenda(esquerda, meio, direita, ide, a, aux);
}

void merge_encomenda(int esquerda, int meio, int direita, int ide, int a[], int aux[])
{
  for (i = meio + 1; i > esquerda; i--)
    aux[i - 1] = a[i - 1];

  for (j = meio; j < direita; j++)
    aux[(direita + meio) - j] = a[j + 1];

  for (k = esquerda; k <= direita; k++)
    if ((verifica_menor(encomendas[ide].produtos[aux[j]].desc, encomendas[ide].produtos[aux[i]].desc) < 0) || (i > meio))
  {
    a[k] = aux[j--];
  }
  else
  {
    a[k] = aux[i++];
  }


}

int verifica_menor(char a[], char b[])
{
  int i = 0;
  int comp = 0;
  while ((comp == 0) && (i < 63))
  {
    comp = a[i] - b[i];
    i++;
  }

  return comp;
}

