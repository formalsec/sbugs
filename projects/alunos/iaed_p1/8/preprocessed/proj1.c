#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>


int converte_string_int(char *str, int i);
int main()
{
  struct produto
  {
    char descricao[64];
    int preco;
    int peso;
    int qtd;
    int idp;
  };
  struct encomenda
  {
    int ide;
    int produtos_na_encomenda[1000];
    int qtd[1000];
  };
  struct produto lista_produtos[10000];
  struct encomenda lista_encomendas[500];
  char comando[100];
  char letra_comando;
  char ch;
  int m = 0;
  int i;
  int k;
  int n;
  int estado = -1;
  int left;
  int right;
  int a;
  int b;
  int max;
  int index_produto;
  int index_encomenda;
  int total_produtos = -1;
  int total_encomendas = -1;
  int identificador_temporario;
  int quantidade_temporaria;
  int peso_temporario;
  int preco_temporario;
  char preco_temp[8];
  char peso_temp[8];
  char qtd_temp[8];
  char idp_temp[6];
  char ide_temp[4];
  while (1)
  {
    for (i = 0; (ch = getchar()) != '\n'; i++)
    {
      comando[i] = ch;
    }

    comando[i] = '\0';
    letra_comando = comando[0];
    if (letra_comando == 'x')
    {
      return 0;
    }
    else
    {
      
    }

    switch (letra_comando)
    {
      case 'a':
        if (total_produtos == (10000 - 1))
      {
        printf("Limite de produtos alcan?ado. Imposs?vel adicionar mais.\n");
        break;
      }
      else
      {
        
      }

        total_produtos++;
        for (k = 2; comando[k] != ':'; k++)
        lista_produtos[total_produtos].descricao[k - 2] = comando[k];

        lista_produtos[total_produtos].descricao[k - 2] = '\0';
        k++;
        for (i = 0; comando[k] != ':'; k++, i++)
        preco_temp[i] = comando[k];

        preco_temp[i] = '\0';
        i--;
        k++;
        lista_produtos[total_produtos].preco = converte_string_int(preco_temp, i);
        for (i = 0; comando[k] != ':'; k++, i++)
        peso_temp[i] = comando[k];

        peso_temp[i] = '\0';
        i--;
        k++;
        lista_produtos[total_produtos].peso = converte_string_int(peso_temp, i);
        for (i = 0; comando[k] != '\0'; k++, i++)
        qtd_temp[i] = comando[k];

        qtd_temp[i] = '\0';
        i--;
        k++;
        lista_produtos[total_produtos].qtd = converte_string_int(qtd_temp, i);
        lista_produtos[total_produtos].idp = total_produtos;
        printf("Novo produto %d.\n", lista_produtos[total_produtos].idp);
        break;

      case 'q':
        for (k = 2, i = 0; comando[k] != ':'; k++, i++)
        idp_temp[i] = comando[k];

        idp_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(idp_temp, i);
        estado = 0;
        for (i = 0; i <= total_produtos; i++)
      {
        if (lista_produtos[i].idp == identificador_temporario)
        {
          estado = 1;
          index_produto = i;
          break;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel adicionar produto %d ao stock. Produto inexistente.\n", identificador_temporario);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = -1;
        for (i = 0; comando[k] != '\0'; k++, i++)
        qtd_temp[i] = comando[k];

        qtd_temp[i] = '\0';
        i--;
        k++;
        quantidade_temporaria = converte_string_int(qtd_temp, i);
        lista_produtos[index_produto].qtd += quantidade_temporaria;
        break;

      case 'N':
        if (total_encomendas == (500 - 1))
      {
        printf("Total de encomendas alcan?ado. Imposs?vel adicionar mais.\n");
        break;
      }
      else
      {
        
      }

        total_encomendas++;
        lista_encomendas[total_encomendas].ide = total_encomendas;
        for (i = 0; i < 10000; i++)
      {
        lista_encomendas[total_encomendas].produtos_na_encomenda[i] = -1;
        lista_encomendas[total_encomendas].qtd[i] = 0;
      }

        break;

      case 'A':
        for (k = 2, i = 0; comando[k] != ':'; k++, i++)
        ide_temp[i] = comando[k];

        ide_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(ide_temp, i);
        n = identificador_temporario;
        for (i = 0; comando[k] != ':'; k++, i++)
        idp_temp[i] = comando[k];

        idp_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(idp_temp, i);
        estado = 0;
        for (i = 0; i <= total_encomendas; i++)
      {
        if (lista_encomendas[i].ide == n)
        {
          estado = 1;
          index_encomenda = i;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", identificador_temporario, n);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = 0;
        for (i = 0; i <= total_produtos; i++)
      {
        if (lista_produtos[i].idp == identificador_temporario)
        {
          estado = 1;
          index_produto = i;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel adicionar produto %d a encomenda %d. Produto inexistente.\n", identificador_temporario, n);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = -1;
        for (i = 0; comando[k] != '\0'; k++, i++)
        qtd_temp[i] = comando[k];

        qtd_temp[i] = '\0';
        i--;
        k++;
        quantidade_temporaria = converte_string_int(qtd_temp, i);
        if (lista_produtos[index_produto].qtd < quantidade_temporaria)
      {
        printf("Imposs?vel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", identificador_temporario, n);
        break;
      }
      else
      {
        
      }

        peso_temporario = lista_produtos[index_produto].peso * quantidade_temporaria;
        for (i = 0; lista_encomendas[n].produtos_na_encomenda[i] != (-1); i++)
        peso_temporario += lista_encomendas[n].qtd[i] * lista_produtos[index_produto].peso;

        if (peso_temporario > 200)
      {
        printf("Imposs?vel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", identificador_temporario, n);
        break;
      }
      else
      {
        
      }

        estado = 0;
        for (i = 0; lista_encomendas[n].produtos_na_encomenda[i] != (-1); i++)
        if (lista_encomendas[n].produtos_na_encomenda[i] == identificador_temporario)
      {
        estado = 1;
        break;
      }
      else
      {
        
      }


        if (estado == 1)
      {
        lista_encomendas[n].qtd[i] += quantidade_temporaria;
      }
      else
      {
        lista_encomendas[n].produtos_na_encomenda[i] = identificador_temporario;
        lista_encomendas[n].qtd[i] = quantidade_temporaria;
      }

        estado = -1;
        lista_produtos[index_produto].qtd -= quantidade_temporaria;
        break;

      case 'r':
        for (k = 2, i = 0; comando[k] != ':'; k++, i++)
        idp_temp[i] = comando[k];

        idp_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(idp_temp, i);
        estado = 0;
        for (i = 0; i <= total_produtos; i++)
      {
        if (lista_produtos[i].idp == identificador_temporario)
        {
          estado = 1;
          index_produto = i;
          break;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel remover stock do produto %d. Produto inexistente.\n", identificador_temporario);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = -1;
        for (i = 0; comando[k] != '\0'; k++, i++)
        qtd_temp[i] = comando[k];

        qtd_temp[i] = '\0';
        i--;
        k++;
        quantidade_temporaria = converte_string_int(qtd_temp, i);
        if (quantidade_temporaria > lista_produtos[identificador_temporario].qtd)
      {
        printf("Imposs?vel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", quantidade_temporaria, lista_produtos[identificador_temporario].idp);
        break;
      }
      else
      {
        
      }

        lista_produtos[identificador_temporario].qtd -= quantidade_temporaria;
        break;

      case 'R':
        for (k = 2, i = 0; comando[k] != ':'; k++, i++)
        ide_temp[i] = comando[k];

        ide_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(ide_temp, i);
        n = identificador_temporario;
        for (i = 0; comando[k] != '\0'; k++, i++)
        idp_temp[i] = comando[k];

        idp_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(idp_temp, i);
        estado = 0;
        for (i = 0; i <= total_encomendas; i++)
      {
        if (lista_encomendas[i].ide == n)
        {
          estado = 1;
          index_encomenda = i;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel remover produto %d a encomenda %d. Encomenda inexistente.\n", identificador_temporario, n);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = 0;
        for (m = 0; m <= total_produtos; m++)
      {
        if (lista_produtos[m].idp == identificador_temporario)
        {
          estado = 1;
          index_produto = m;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel remover produto %d a encomenda %d. Produto inexistente.\n", identificador_temporario, n);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = -1;
        for (i = 0; lista_encomendas[index_encomenda].produtos_na_encomenda[i] != identificador_temporario; i++)
        ;

        lista_produtos[index_produto].qtd += lista_encomendas[index_encomenda].qtd[i];
        for (k = i; i < (10000 - 1); k++)
      {
        lista_encomendas[index_encomenda].produtos_na_encomenda[k] = lista_encomendas[index_encomenda].produtos_na_encomenda[k + 1];
        lista_encomendas[index_encomenda].qtd[k] = lista_encomendas[index_encomenda].qtd[k + 1];
        if (lista_encomendas[index_encomenda].produtos_na_encomenda[k] == (-1))
        {
          break;
        }
        else
        {
          
        }

      }

        break;

      case 'C':
        for (k = 2, i = 0; comando[k] != '\0'; k++, i++)
        ide_temp[i] = comando[k];

        ide_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(ide_temp, i);
        for (i = 0; i < 500; i++)
      {
        if (lista_encomendas[i].ide == identificador_temporario)
        {
          index_encomenda = i;
          break;
        }
        else
        {
          
        }

      }

        if (i == 500)
      {
        printf("Imposs?vel calcular custo da encomenda %d. Encomenda inexistente.\n", identificador_temporario);
        break;
      }
      else
      {
        
      }

        preco_temporario = 0;
        for (i = 0; lista_encomendas[index_encomenda].produtos_na_encomenda[i] != (-1); i++)
      {
        index_produto = lista_encomendas[index_encomenda].produtos_na_encomenda[i];
        preco_temporario += lista_encomendas[index_encomenda].qtd[i] * lista_produtos[index_produto].preco;
      }

        printf("Custo da encomenda %d %d.\n", lista_encomendas[index_encomenda].ide, preco_temporario);
        break;

      case 'p':
        for (k = 2, i = 0; comando[k] != ':'; k++, i++)
        idp_temp[i] = comando[k];

        idp_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(idp_temp, i);
        estado = 0;
        for (i = 0; i <= total_produtos; i++)
      {
        if (lista_produtos[i].idp == identificador_temporario)
        {
          estado = 1;
          index_produto = i;
          break;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel alterar preco do produto %d. Produto inexistente.\n", identificador_temporario);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = -1;
        for (i = 0; comando[k] != '\0'; k++, i++)
        preco_temp[i] = comando[k];

        preco_temp[i] = '\0';
        i--;
        k++;
        lista_produtos[identificador_temporario].preco = converte_string_int(preco_temp, i);
        break;

      case 'E':
        for (k = 2, i = 0; comando[k] != ':'; k++, i++)
        ide_temp[i] = comando[k];

        ide_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(ide_temp, i);
        n = identificador_temporario;
        for (i = 0; comando[k] != '\0'; k++, i++)
        idp_temp[i] = comando[k];

        idp_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(idp_temp, i);
        estado = 0;
        for (i = 0; i <= total_encomendas; i++)
      {
        if (lista_encomendas[i].ide == n)
        {
          estado = 1;
          index_encomenda = i;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel listar encomenda %d. Encomenda inexistente.\n", n);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = 0;
        for (i = 0; i <= total_produtos; i++)
      {
        if (lista_produtos[i].idp == identificador_temporario)
        {
          estado = 1;
          index_produto = i;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Impossivel listar produto %d. Produto inexistente.\n", identificador_temporario);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = -1;
        for (i = 0; lista_encomendas[index_encomenda].produtos_na_encomenda[i] != (-1); i++)
      {
        if (lista_encomendas[index_encomenda].produtos_na_encomenda[i] == identificador_temporario)
        {
          break;
        }
        else
        {
          
        }

      }

        if (lista_encomendas[index_encomenda].qtd[i] == (-1))
      {
        lista_encomendas[index_encomenda].qtd[i] = 0;
      }
      else
      {
        
      }

        printf("%s %d.\n", lista_produtos[identificador_temporario].descricao, lista_encomendas[index_encomenda].qtd[i]);
        break;

      case 'm':
        if (total_encomendas == (-1))
      {
        break;
      }
      else
      {
        
      }

        for (k = 2, i = 0; comando[k] != '\0'; k++, i++)
        idp_temp[i] = comando[k];

        idp_temp[i] = '\0';
        i--;
        k++;
        identificador_temporario = converte_string_int(idp_temp, i);
        estado = 0;
        for (i = 0; i <= total_produtos; i++)
      {
        if (lista_produtos[i].idp == identificador_temporario)
        {
          estado = 1;
          index_produto = i;
          break;
        }
        else
        {
          
        }

      }

        if (estado == 0)
      {
        printf("Imposs?vel listar maximo do produto %d. Produto inexistente.\n", identificador_temporario);
        estado = -1;
        break;
      }
      else
      {
        
      }

        estado = -1;
        max = -1;
        for (i = 0; i <= total_encomendas; i++)
      {
        for (k = 0; lista_encomendas[i].produtos_na_encomenda[k] != (-1); k++)
        {
          if (lista_encomendas[i].produtos_na_encomenda[k] == identificador_temporario)
          {
            if (lista_encomendas[i].qtd[k] > max)
            {
              max = lista_encomendas[i].qtd[k];
              n = i;
              m = k;
            }
            else
            {
              
            }

            break;
          }
          else
          {
            
          }

        }

      }

        if (max == (-1))
      {
        break;
      }
      else
      {
        
      }

        printf("Maximo produto %d %d %d.\n", identificador_temporario, lista_encomendas[n].ide, max);
        break;

      case 'l':
        printf("Produtos\n");
        if (total_produtos >= 0)
      {
        left = 0;
        right = total_produtos;
        for (a = 0 + left; a <= right; a++)
        {
          struct produto v = lista_produtos[a];
          b = a - 1;
          while ((b >= left) && (v.preco < lista_produtos[b].preco))
          {
            lista_produtos[b + 1] = lista_produtos[b];
            b--;
          }

          lista_produtos[b + 1] = v;
        }

        for (i = 0; i <= total_produtos; i++)
        {
          printf("* %s %d %d\n", lista_produtos[i].descricao, lista_produtos[i].preco, lista_produtos[i].qtd);
        }

      }
      else
      {
        
      }

        break;

      case 'L':
        break;

    }

    ;
  }

  return 0;
}

int converte_string_int(char *str, int i)
{
  int n;
  switch (i)
  {
    case 0:
      n = str[i] - '0';
      break;

    case 1:
      n = (str[i] - '0') + ((str[i - 1] - '0') * 10);
      break;

    case 2:
      n = ((str[i] - '0') + ((str[i - 1] - '0') * 10)) + ((str[i - 2] - '0') * 100);
      break;

    case 3:
      n = (((str[i] - '0') + ((str[i - 1] - '0') * 10)) + ((str[i - 2] - '0') * 100)) + ((str[i - 3] - '0') * 1000);
      break;

    case 4:
      n = ((((str[i] - '0') + ((str[i - 1] - '0') * 10)) + ((str[i - 2] - '0') * 100)) + ((str[i - 3] - '0') * 1000)) + ((str[i - 4] - '0') * 10000);
      break;

    case 5:
      n = (((((str[i] - '0') + ((str[i - 1] - '0') * 10)) + ((str[i - 2] - '0') * 100)) + ((str[i - 3] - '0') * 1000)) + ((str[i - 4] - '0') * 10000)) + ((str[i - 5] - '0') * 100000);
      break;

    case 6:
      n = ((((((str[i] - '0') + ((str[i - 1] - '0') * 10)) + ((str[i - 2] - '0') * 100)) + ((str[i - 3] - '0') * 1000)) + ((str[i - 4] - '0') * 10000)) + ((str[i - 5] - '0') * 100000)) + ((str[i - 6] - '0') * 1000000);
      break;

  }

  ;
  return n;
}

