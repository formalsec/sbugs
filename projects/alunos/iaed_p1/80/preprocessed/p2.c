#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct produto
{
  char descricao[63];
  int preco;
  int peso;
  int qtp;
} produto;
typedef struct encomenda
{
  int pro[200];
  int peso;
  int n_elem;
  int qtp[200];
} encomenda;
produto __a__()
{
  produto a;
  int pres;
  int peso;
  int quan;
  int i = 0;
  char c;
  c = getchar();
  c = getchar();
  while (c != ':')
  {
    a.descricao[i] = c;
    i++;
    c = getchar();
  }

  a.descricao[i] = '\0';
  pres = new_sym_var(sizeof(int) * 8);
  peso = new_sym_var(sizeof(int) * 8);
  quan = new_sym_var(sizeof(int) * 8);
  a.preco = pres;
  a.peso = peso;
  a.qtp = quan;
  return a;
}

encomenda cria_encomenda()
{
  encomenda a;
  a.peso = 200;
  a.n_elem = 0;
  return a;
}

int verifica(int pro[200], int idp, int elem)
{
  int i;
  for (i = 0; i < elem; i++)
  {
    if (pro[i] == idp)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void por_produto_enc(encomenda iden_encomenda[500], produto p[10000], int idp, int qtp, int ide)
{
  int n;
  int m;
  n = iden_encomenda[ide].n_elem;
  m = verifica(iden_encomenda[ide].pro, idp, n);
  if (m != (-1))
  {
    iden_encomenda[ide].qtp[m] += qtp;
  }
  else
  {
    iden_encomenda[ide].qtp[n] = qtp;
    iden_encomenda[ide].pro[n] = idp;
    iden_encomenda[ide].n_elem++;
  }

  iden_encomenda[ide].peso -= p[idp].peso * qtp;
  p[idp].qtp -= qtp;
}

void remove_produto(encomenda iden_encomenda[500], int idp, int ide, produto p[10000])
{
  int n;
  int i;
  int m;
  i = 0;
  n = iden_encomenda[ide].n_elem;
  m = verifica(iden_encomenda[ide].pro, idp, n);
  if (m != (-1))
  {
    p[idp].qtp += iden_encomenda[ide].qtp[m];
    iden_encomenda[ide].peso += iden_encomenda[ide].qtp[m] * p[idp].peso;
    for (i = m + 1; m < n; m++)
    {
      iden_encomenda[ide].pro[m] = iden_encomenda[ide].pro[i];
      iden_encomenda[ide].qtp[m] = iden_encomenda[ide].qtp[i];
      i++;
    }

    iden_encomenda[ide].n_elem--;
  }
  else
  {
    
  }

}

int custo(encomenda enc[500], produto p[10000], int ide)
{
  int i;
  int total;
  int n;
  n = enc[ide].n_elem;
  total = 0;
  for (i = 0; i < n; i++)
  {
    total += p[enc[ide].pro[i]].preco * enc[ide].qtp[i];
  }

  return total;
}

void maximo_produto(encomenda iden_encomenda[500], int idp, int n_enc)
{
  int i;
  int m;
  int ide;
  int qtp;
  qtp = 0;
  ide = -1;
  for (i = 0; i < n_enc; i++)
  {
    m = verifica(iden_encomenda[i].pro, idp, iden_encomenda[i].n_elem);
    if (m != (-1))
    {
      if (qtp < iden_encomenda[i].qtp[m])
      {
        ide = i;
        qtp = iden_encomenda[i].qtp[m];
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  if (ide != (-1))
  {
    printf("Maximo produto %d %d %d.\n", idp, ide, qtp);
  }
  else
  {
    
  }

}

int particao(int idp_ord[10000], int inicio, int fim, produto p[10000])
{
  int i = inicio - 1;
  int aux;
  int j = fim;
  int v = idp_ord[fim];
  while (i < j)
  {
    while ((p[idp_ord[++i]].preco < p[v].preco) || ((p[idp_ord[i]].preco == p[v].preco) && (idp_ord[i] < v)))
      ;

    while ((p[v].preco < p[idp_ord[--j]].preco) || ((p[idp_ord[j]].preco == p[v].preco) && (idp_ord[j] > v)))
      if (j == inicio)
    {
      break;
    }
    else
    {
      
    }


    if (i < j)
    {
      aux = idp_ord[i];
      idp_ord[i] = idp_ord[j];
      idp_ord[j] = aux;
    }
    else
    {
      
    }

  }

  aux = idp_ord[i];
  idp_ord[i] = idp_ord[fim];
  idp_ord[fim] = aux;
  return i;
}

void ordena_lista(produto p[10000], int inicio, int fim, int idp_ord[10000])
{
  int i;
  if (fim <= inicio)
  {
    return;
  }
  else
  {
    
  }

  i = particao(idp_ord, inicio, fim, p);
  ordena_lista(p, inicio, i - 1, idp_ord);
  ordena_lista(p, i + 1, fim, idp_ord);
}

void ordena_enc(encomenda enc, produto p[10000])
{
  int i;
  int n;
  int j;
  int aux;
  int pro[200];
  int qtp[200];
  char desc[63];
  n = enc.n_elem;
  for (i = 0; i < n; i++)
  {
    pro[i] = enc.pro[i];
    qtp[i] = enc.qtp[i];
  }

  for (i = 0; i < n; i++)
  {
    strcpy(desc, p[pro[i]].descricao);
    for (j = i + 1; j < n; j++)
    {
      if (strcmp(desc, p[pro[j]].descricao) > 0)
      {
        strcpy(desc, p[pro[j]].descricao);
        aux = pro[i];
        pro[i] = pro[j];
        pro[j] = aux;
        aux = qtp[i];
        qtp[i] = qtp[j];
        qtp[j] = aux;
      }
      else
      {
        
      }

    }

    printf("* %s %d %d\n", desc, p[pro[i]].preco, qtp[i]);
  }

}

int main()
{
  char l;
  int iden;
  int iden_enc;
  int ord_lis;
  int idp;
  int qtp;
  int ide;
  int arg1;
  int idp_ord[10000];
  produto iden_pro[10000];
  encomenda iden_encomenda[500];
  l = getchar();
  iden = 0;
  iden_enc = 0;
  ord_lis = 0;
  while (l != 'x')
  {
    switch (l)
    {
      case 'a':
        iden_pro[iden] = __a__();
        printf("Novo produto %d.\n", iden);
        idp_ord[iden] = iden;
        iden++;
        ord_lis = 0;
        break;

      case 'q':
        idp = new_sym_var(sizeof(int) * 8);
        qtp = new_sym_var(sizeof(int) * 8);
        if (idp >= iden)
      {
        printf("Impossivel adicionar produto %d ", idp);
        printf("ao stock. Produto inexistente.\n");
      }
      else
      {
        iden_pro[idp].qtp += qtp;
      }

        break;

      case 'N':
        iden_encomenda[iden_enc] = cria_encomenda();
        printf("Nova encomenda %d.\n", iden_enc);
        iden_enc++;
        break;

      case 'A':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        qtp = new_sym_var(sizeof(int) * 8);
        if (iden_enc <= ide)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      }
      else
      {
        if (iden <= idp)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
        }
        else
        {
          if (qtp > iden_pro[idp].qtp)
          {
            printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
          }
          else
          {
            if ((qtp * iden_pro[idp].peso) > iden_encomenda[ide].peso)
            {
              printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
            }
            else
            {
              por_produto_enc(iden_encomenda, iden_pro, idp, qtp, ide);
            }

          }

        }

      }

        break;

      case 'r':
        idp = new_sym_var(sizeof(int) * 8);
        qtp = new_sym_var(sizeof(int) * 8);
        if (idp >= iden)
      {
        printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
      }
      else
      {
        if (qtp > iden_pro[idp].qtp)
        {
          printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtp, idp);
        }
        else
        {
          iden_pro[idp].qtp -= qtp;
        }

      }

        break;

      case 'R':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        if (ide >= iden_enc)
      {
        printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
      }
      else
      {
        if (idp >= iden)
        {
          printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
        }
        else
        {
          remove_produto(iden_encomenda, idp, ide, iden_pro);
        }

      }

        break;

      case 'C':
        ide = new_sym_var(sizeof(int) * 8);
        if (ide >= iden_enc)
      {
        printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
      }
      else
      {
        printf("Custo da encomenda %d %d.\n", ide, custo(iden_encomenda, iden_pro, ide));
      }

        break;

      case 'p':
        idp = new_sym_var(sizeof(int) * 8);
        arg1 = new_sym_var(sizeof(int) * 8);
        if (idp >= iden)
      {
        printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
      }
      else
      {
        iden_pro[idp].preco = arg1;
        ord_lis = 0;
      }

        break;

      case 'E':
        ide = new_sym_var(sizeof(int) * 8);
        idp = new_sym_var(sizeof(int) * 8);
        if (ide >= iden_enc)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      }
      else
      {
        if (idp >= iden)
        {
          printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
        }
        else
        {
          arg1 = verifica(iden_encomenda[ide].pro, idp, iden_encomenda[ide].n_elem);
          if (arg1 == (-1))
          {
            printf("%s 0.\n", iden_pro[idp].descricao);
          }
          else
          {
            printf("%s %d.\n", iden_pro[idp].descricao, iden_encomenda[ide].qtp[arg1]);
          }

        }

      }

        break;

      case 'm':
        idp = new_sym_var(sizeof(int) * 8);
        if (idp >= iden)
      {
        printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
      }
      else
      {
        maximo_produto(iden_encomenda, idp, iden_enc);
      }

        break;

      case 'l':
        printf("Produtos\n");
        arg1 = iden - 1;
        if (ord_lis == 0)
      {
        ordena_lista(iden_pro, 0, arg1, idp_ord);
      }
      else
      {
        
      }

        for (arg1 = 0; arg1 < iden; arg1++)
      {
        printf("* %s %d %d\n", iden_pro[idp_ord[arg1]].descricao, iden_pro[idp_ord[arg1]].preco, iden_pro[idp_ord[arg1]].qtp);
      }

        ord_lis = 1;
        break;

      case 'L':
        ide = new_sym_var(sizeof(int) * 8);
        if (ide >= iden_enc)
      {
        printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
      }
      else
      {
        printf("Encomenda %d\n", ide);
        ordena_enc(iden_encomenda[ide], iden_pro);
      }

        break;

    }

    l = getchar();
  }

  return 0;
}

