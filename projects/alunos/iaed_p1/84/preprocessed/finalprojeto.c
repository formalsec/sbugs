#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


long len;
int idp = 0;
int ide = 0;
typedef struct Produtos
{
  char descricao[62];
  int preco;
  int peso;
  int qtd;
} List_Prod;
typedef struct encomenda
{
  int qtd_produto[200];
  int iden_prod;
  int peso;
  int produtos[200];
} Encomenda;
List_Prod lista_main[10000];
Encomenda order[500];
int achar_produto(int s[200], int idp, int qtd)
{
  int i;
  for (i = 0; i < qtd; i++)
  {
    if (idp == s[i])
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

int Novo_Prod(char s[10000])
{
  int pontos = 0;
  int d = 0;
  int i;
  len = strlen(s);
  lista_main[idp].preco = (lista_main[idp].peso = (lista_main[idp].qtd = 0));
  for (i = 2; i < (len - 1); i++)
  {
    if (s[i] == ':')
    {
      pontos++;
    }
    else
    {
      if (pontos == 0)
      {
        lista_main[idp].descricao[d] = s[i];
        d++;
      }
      else
      {
        if (pontos == 1)
        {
          lista_main[idp].preco = ((lista_main[idp].preco * 10) + s[i]) - 48;
        }
        else
        {
          if (pontos == 2)
          {
            lista_main[idp].peso = ((lista_main[idp].peso * 10) + s[i]) - 48;
          }
          else
          {
            if (pontos == 3)
            {
              lista_main[idp].qtd = ((lista_main[idp].qtd * 10) + s[i]) - 48;
            }
            else
            {
              
            }

          }

        }

      }

    }

  }

  idp++;
  return idp - 1;
}

void Add_Stock(char s[200])
{
  int pontos = 0;
  int d = 0;
  int n = 0;
  int i;
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    if (s[i] == ':')
    {
      pontos++;
    }
    else
    {
      if (pontos == 0)
      {
        d = ((d * 10) + s[i]) - 48;
      }
      else
      {
        if (pontos == 1)
        {
          n = ((n * 10) + s[i]) - 48;
        }
        else
        {
          
        }

      }

    }

  }

  if (d > (idp - 1))
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", d);
  }
  else
  {
    lista_main[d].qtd += n;
  }

}

int New_Order()
{
  order[ide].peso = 0;
  order[ide].iden_prod = 0;
  ide++;
  return ide - 1;
}

void New_Prod_Ord(char s[10000])
{
  int pontos = 0;
  int d = 0;
  int n = 0;
  int q = 0;
  int i;
  int num_lista;
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    if (s[i] == ':')
    {
      pontos++;
    }
    else
    {
      if (pontos == 0)
      {
        d = ((d * 10) + s[i]) - 48;
      }
      else
      {
        if (pontos == 1)
        {
          n = ((n * 10) + s[i]) - 48;
        }
        else
        {
          if (pontos == 2)
          {
            q = ((q * 10) + s[i]) - 48;
          }
          else
          {
            
          }

        }

      }

    }

  }

  num_lista = achar_produto(order[d].produtos, n, order[d].iden_prod);
  if (d >= ide)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", n, d);
  }
  else
  {
    if (n > (idp - 1))
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", n, d);
    }
    else
    {
      if (q > lista_main[n].qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", n, d);
      }
      else
      {
        if ((order[d].peso + (lista_main[n].peso * q)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", n, d);
        }
        else
        {
          if (num_lista != (-1))
          {
            order[d].qtd_produto[num_lista] += q;
            order[d].peso += lista_main[n].peso * q;
            lista_main[n].qtd -= q;
          }
          else
          {
            order[d].produtos[order[d].iden_prod] = n;
            order[d].qtd_produto[order[d].iden_prod] = q;
            order[d].peso += lista_main[n].peso * q;
            lista_main[n].qtd -= q;
            order[d].iden_prod += 1;
          }

        }

      }

    }

  }

}

void Remove_Stock(char s[10000])
{
  int pontos = 0;
  int d = 0;
  int n = 0;
  int i;
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    if (s[i] == ':')
    {
      pontos++;
    }
    else
    {
      if (pontos == 0)
      {
        d = ((d * 10) + s[i]) - 48;
      }
      else
      {
        if (pontos == 1)
        {
          n = ((n * 10) + s[i]) - 48;
        }
        else
        {
          
        }

      }

    }

  }

  if (d > (idp - 1))
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", d);
  }
  else
  {
    if (n > lista_main[d].qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", n, d);
    }
    else
    {
      lista_main[d].qtd -= n;
    }

  }

}

void Remove_Stock_Order(char s[10000])
{
  int pontos = 0;
  int d = 0;
  int n = 0;
  int i;
  int q;
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    if (s[i] == ':')
    {
      pontos++;
    }
    else
    {
      if (pontos == 0)
      {
        d = ((d * 10) + s[i]) - 48;
      }
      else
      {
        if (pontos == 1)
        {
          n = ((n * 10) + s[i]) - 48;
        }
        else
        {
          
        }

      }

    }

  }

  q = achar_produto(order[d].produtos, n, order[d].iden_prod);
  if (d > (ide - 1))
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", n, d);
  }
  else
  {
    if (n > (idp - 1))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", n, d);
    }
    else
    {
      if (q != (-1))
      {
        order[d].peso -= order[d].qtd_produto[q] * lista_main[n].peso;
        lista_main[n].qtd += order[d].qtd_produto[q];
        order[d].qtd_produto[q] = 0;
      }
      else
      {
        
      }

    }

  }

}

void Cal_Price(char s[10000])
{
  int n = 0;
  int total = 0;
  int i;
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    n = ((n * 10) + s[i]) - 48;
  }

  if (n > (ide - 1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", n);
  }
  else
  {
    for (i = 0; i < order[n].iden_prod; i++)
    {
      total += lista_main[order[n].produtos[i]].preco * order[n].qtd_produto[i];
    }

    printf("Custo da encomenda %d %d.\n", n, total);
  }

  return;
}

void Change_Price(char s[10000])
{
  int pontos = 0;
  int d = 0;
  int p = 0;
  int i;
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    if (s[i] == ':')
    {
      pontos++;
    }
    else
    {
      if (pontos == 0)
      {
        d = ((d * 10) + s[i]) - 48;
      }
      else
      {
        if (pontos == 1)
        {
          p = ((p * 10) + s[i]) - 48;
        }
        else
        {
          
        }

      }

    }

  }

  if ((idp - 1) < d)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", d);
  }
  else
  {
    lista_main[d].preco = p;
  }

}

void Des_Prod_Order(char s[10000])
{
  int pontos = 0;
  int e = 0;
  int p = 0;
  int i;
  int iden;
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    if (s[i] == ':')
    {
      pontos++;
    }
    else
    {
      if (pontos == 0)
      {
        e = ((e * 10) + s[i]) - 48;
      }
      else
      {
        if (pontos == 1)
        {
          p = ((p * 10) + s[i]) - 48;
        }
        else
        {
          
        }

      }

    }

  }

  iden = achar_produto(order[e].produtos, p, order[e].iden_prod);
  if (e > (ide - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", e);
  }
  else
  {
    if ((idp - 1) < p)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", p);
    }
    else
    {
      if (iden == (-1))
      {
        printf("%s 0.\n", lista_main[p].descricao);
      }
      else
      {
        printf("%s %d.\n", lista_main[p].descricao, order[e].qtd_produto[iden]);
      }

    }

  }

}

void Ocorre_mais(char s[10000])
{
  int i;
  int p;
  int n = 0;
  int max_prod = 0;
  int max_enc = 0;
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    n = ((n * 10) + s[i]) - 48;
  }

  if (n > (idp - 1))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", n);
  }
  else
  {
    for (i = 0; i < ide; i++)
    {
      p = achar_produto(order[i].produtos, n, order[i].iden_prod);
      if (p != (-1))
      {
        if (order[i].qtd_produto[p] > max_prod)
        {
          max_enc = i;
          max_prod = order[i].qtd_produto[p];
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

    if (max_prod != 0)
    {
      printf("Maximo produto %d %d %d.\n", n, max_enc, max_prod);
    }
    else
    {
      
    }

  }

}

void merge(int arr[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  int n1 = (m - l) + 1;
  int n2 = r - m;
  int L[10000 / 2];
  int R[10000 / 2];
  for (i = 0; i < n1; i++)
  {
    L[i] = arr[l + i];
  }

  for (j = 0; j < n2; j++)
  {
    R[j] = arr[(m + 1) + j];
  }

  i = 0;
  j = 0;
  k = l;
  while ((i < n1) && (j < n2))
  {
    if (lista_main[L[i]].preco <= lista_main[R[j]].preco)
    {
      arr[k] = L[i];
      i++;
    }
    else
    {
      arr[k] = R[j];
      j++;
    }

    k++;
  }

  while (i < n1)
  {
    arr[k] = L[i];
    i++;
    k++;
  }

  while (j < n2)
  {
    arr[k] = R[j];
    j++;
    k++;
  }

}

void mergeSort(int arr[], int l, int r)
{
  if (l < r)
  {
    int m = l + ((r - l) / 2);
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    merge(arr, l, m, r);
  }
  else
  {
    
  }

}

void Price_Growing()
{
  int i;
  int j;
  int arr[10000];
  for (i = 0; i < idp; i++)
  {
    arr[i] = i;
  }

  mergeSort(arr, 0, idp - 1);
  printf("Produtos\n");
  for (j = 0; j < idp; j++)
  {
    printf("* %s %d %d\n", lista_main[arr[j]].descricao, lista_main[arr[j]].preco, lista_main[arr[j]].qtd);
  }

}

void Order_AZ(char s[10000])
{
  int i;
  int j;
  int V;
  int tam;
  int e = 0;
  char a[10000][62];
  char v[62];
  int n[10000];
  len = strlen(s);
  for (i = 2; i < (len - 1); i++)
  {
    e = ((e * 10) + s[i]) - 48;
  }

  if (e > (ide - 1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", e);
  }
  else
  {
    printf("Encomenda %d\n", e);
    tam = order[e].iden_prod;
    for (i = 0; i < tam; i++)
      n[i] = order[e].produtos[i];

    for (i = 0; i < tam; i++)
      strcpy(a[i], lista_main[n[i]].descricao);

    for (i = 0; i < tam; i++)
    {
      for (i = 1; i < tam; i++)
      {
        strcpy(v, a[i]);
        V = n[i];
        j = i - 1;
        while ((j >= 0) && (strcmp(v, a[j]) < 0))
        {
          strcpy(a[j + 1], a[j]);
          n[j + 1] = n[j];
          j--;
        }

        strcpy(a[j + 1], v);
        n[j + 1] = V;
      }

    }

    for (i = 0; i < tam; i++)
    {
      j = achar_produto(order[e].produtos, n[i], tam);
      if (order[e].qtd_produto[j] != 0)
      {
        printf("* %s %d %d\n", a[i], lista_main[n[i]].preco, order[e].qtd_produto[j]);
      }
      else
      {
        
      }

    }

  }

}

int main()
{
  char entrada[10000];
  while (entrada[0] != 'x')
  {
    fgets(entrada, 10000, stdin);
    switch (entrada[0])
    {
      case 'a':
        printf("Novo produto %d.\n", Novo_Prod(entrada));
        break;

      case 'q':
        Add_Stock(entrada);
        break;

      case 'N':
        printf("Nova encomenda %d.\n", New_Order());
        break;

      case 'A':
        New_Prod_Ord(entrada);
        break;

      case 'r':
        Remove_Stock(entrada);
        break;

      case 'R':
        Remove_Stock_Order(entrada);
        break;

      case 'C':
        Cal_Price(entrada);
        break;

      case 'p':
        Change_Price(entrada);
        break;

      case 'E':
        Des_Prod_Order(entrada);
        break;

      case 'm':
        Ocorre_mais(entrada);
        break;

      case 'l':
        Price_Growing();
        break;

      case 'L':
        Order_AZ(entrada);
        break;

    }

  }

  return 0;
}

