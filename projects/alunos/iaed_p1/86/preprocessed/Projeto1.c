/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  char nome[64];
  int preco;
  int peso;
  int qtd;
} produto;
produto produtos[10000];
char comm;
int encomendas[500][10000];
int contador_prod = 0;
int contador_enc = 0;
int ord[10000];
void comm_a(int contador_prod)
{
  for (int produtos_index = 0; produtos_index < 10; produtos_index++)
  {
    produtos[contador_prod].nome[produtos_index] = new_sym_var(sizeof(char) * 8);
  }

  produtos[contador_prod].nome[10 - 1] = '\0';
  produtos[contador_prod].preco = new_sym_var(sizeof(int) * 8);
  produtos[contador_prod].peso = new_sym_var(sizeof(int) * 8);
  produtos[contador_prod].qtd = new_sym_var(sizeof(int) * 8);
  printf("Novo produto %d.\n", contador_prod);
}

void comm_q(int contador_prod)
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp < contador_prod)
  {
    qtd = new_sym_var(sizeof(int) * 8);
    produtos[idp].qtd += qtd;
  }
  else
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
  }

}

void comm_N(int contador_enc)
{
  printf("Nova encomenda %d.\n", contador_enc);
}

void comm_A(int contador_prod, int contador_enc)
{
  int ide;
  int idp;
  int qtd;
  int peso = 0;
  int i;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_enc)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= contador_prod)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      qtd = new_sym_var(sizeof(int) * 8);
      if (produtos[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ide);
      }
      else
      {
        for (i = 0; (i < contador_prod) && (peso <= 200); i++)
          peso += produtos[i].peso * encomendas[ide][i];

        peso += produtos[idp].peso * qtd;
        if (peso > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ide);
        }
        else
        {
          encomendas[ide][idp] += qtd;
          produtos[idp].qtd -= qtd;
        }

      }

    }

  }

}

void comm_r(int contador_prod)
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= contador_prod)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    qtd = new_sym_var(sizeof(int) * 8);
    if (qtd > produtos[idp].qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      produtos[idp].qtd -= qtd;
    }

  }

}

void comm_R(int contador_prod, int contador_enc)
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_enc)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ide);
  }
  else
  {
    if (idp >= contador_prod)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ide);
    }
    else
    {
      produtos[idp].qtd += encomendas[ide][idp];
      encomendas[ide][idp] = 0;
    }

  }

}

void comm_C(int contador_prod, int contador_enc)
{
  int ide;
  int i;
  int total = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_enc)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    for (i = 0; i < contador_prod; i++)
      total += encomendas[ide][i] * produtos[i].preco;

    printf("Custo da encomenda %d %d.\n", ide, total);
  }

}

void comm_p(int contador_prod)
{
  int idp;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= contador_prod)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    produtos[idp].preco = new_sym_var(sizeof(int) * 8);
  }

}

void comm_E(int contador_prod, int contador_enc)
{
  int ide;
  int idp;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_enc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    idp = new_sym_var(sizeof(int) * 8);
    if (idp >= contador_prod)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      printf("%s %d.\n", produtos[idp].nome, encomendas[ide][idp]);
    }

  }

}

void comm_m(int contador_prod, int contador_enc)
{
  int idp;
  int ide;
  int ide_max;
  int qtd = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= contador_prod)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (ide = 0; ide < contador_enc; ide++)
    {
      if (encomendas[ide][idp] > qtd)
      {
        ide_max = ide;
        qtd = encomendas[ide][idp];
      }
      else
      {
        
      }

    }

    if (qtd > 0)
    {
      printf("Maximo produto %d %d %d.\n", idp, ide_max, qtd);
    }
    else
    {
      
    }

  }

}

void merge(int flag, int esq, int meio, int dir)
{
  int aux[10000];
  int i;
  int j;
  int k;
  int cmp;
  for (i = meio + 1; i > esq; i--)
    aux[i - 1] = ord[i - 1];

  for (j = meio; j < dir; j++)
    aux[(dir + meio) - j] = ord[j + 1];

  for (k = esq; k <= dir; k++)
  {
    if (flag)
    {
      cmp = produtos[aux[j]].preco < produtos[aux[i]].preco;
    }
    else
    {
      cmp = strcmp(produtos[aux[j]].nome, produtos[aux[i]].nome) < 0;
    }

    if (cmp || ((produtos[aux[j]].preco == produtos[aux[i]].preco) && (aux[j] < aux[i])))
    {
      ord[k] = aux[j--];
    }
    else
    {
      ord[k] = aux[i++];
    }

  }

}

void mergesort(int flag, int esq, int dir)
{
  int meio = (dir + esq) / 2;
  if (dir <= esq)
  {
    return;
  }
  else
  {
    
  }

  mergesort(flag, esq, meio);
  mergesort(flag, meio + 1, dir);
  merge(flag, esq, meio, dir);
}

void comm_l(int contador_prod)
{
  int i;
  int j;
  puts("Produtos");
  for (i = 0; i < contador_prod; i++)
    ord[i] = i;

  mergesort(1, 0, contador_prod - 1);
  for (j = 0; j < contador_prod; j++)
    printf("* %s %d %d\n", produtos[ord[j]].nome, produtos[ord[j]].preco, produtos[ord[j]].qtd);

}

void comm_L(int contador_prod, int contador_enc)
{
  int ide;
  int i;
  int j;
  int contador = 0;
  ide = new_sym_var(sizeof(int) * 8);
  if (ide >= contador_enc)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ide);
  }
  else
  {
    printf("Encomenda %d\n", ide);
    for (i = 0; i < contador_prod; i++)
      if (encomendas[ide][i] != 0)
    {
      ord[contador++] = i;
    }
    else
    {
      
    }


    mergesort(0, 0, contador - 1);
    for (j = 0; j < contador; j++)
      if (encomendas[ide][ord[j]] > 0)
    {
      printf("* %s %d %d\n", produtos[ord[j]].nome, produtos[ord[j]].preco, encomendas[ide][ord[j]]);
    }
    else
    {
      
    }


  }

}

int main()
{
  while ((comm = getchar()) != 'x')
  {
    switch (comm)
    {
      case 'a':
        comm_a(contador_prod++);
        break;

      case 'q':
        comm_q(contador_prod);
        break;

      case 'N':
        comm_N(contador_enc++);
        break;

      case 'A':
        comm_A(contador_prod, contador_enc);
        break;

      case 'r':
        comm_r(contador_prod);
        break;

      case 'R':
        comm_R(contador_prod, contador_enc);
        break;

      case 'C':
        comm_C(contador_prod, contador_enc);
        break;

      case 'p':
        comm_p(contador_prod);
        break;

      case 'E':
        comm_E(contador_prod, contador_enc);
        break;

      case 'm':
        comm_m(contador_prod, contador_enc);
        break;

      case 'l':
        comm_l(contador_prod);
        break;

      case 'L':
        comm_L(contador_prod, contador_enc);
        break;

    }

  }

  return 0;
}

