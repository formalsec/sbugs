#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct 
{
  int id;
  char descricao[63];
  int preco;
  int peso;
  int quantidade;
} Produto;
typedef struct 
{
  Produto produtos[200];
  int index;
  int preco;
  int peso;
} Encomenda;
void adiciona_produto(char cmd[]);
void adiciona_stock(char cmd[]);
void cria_encomenda();
void adiciona_produto_encomenda(char cmd[]);
void remove_stock(char cmd[]);
void remove_produto_encomenda(char cmd[]);
void custo_encomenda(char cmd[]);
void altera_preco(char cmd[]);
void lista_descricao_quantidade(char cmd[]);
void lista_encomenda(char cmd[]);
void ordena_produtos();
void ordena_alfabetico(char cmd[]);
void mergesort(Produto vetor[], int esq, int dir, int cmp);
void merge(Produto vetor[], int esq, int m, int dir, int cmp);
int compara_menor(Produto p1, Produto p2, int cmp);
Produto idproduto[10000];
Encomenda idencomenda[500];
Produto aux[10000];
int indexidp;
int indexiden;
int main()
{
  char cmd[100] = {0};
  while (cmd[0] != 'x')
  {
    for (int cmd_index = 0; cmd_index < 10; cmd_index++)
    {
      cmd[cmd_index] = new_sym_var(sizeof(char) * 8);
    }

    cmd[10 - 1] = '\0';
    switch (cmd[0])
    {
      case 'a':
        adiciona_produto(cmd);
        break;

      case 'q':
        adiciona_stock(cmd);
        break;

      case 'N':
        cria_encomenda();
        break;

      case 'A':
        adiciona_produto_encomenda(cmd);
        break;

      case 'r':
        remove_stock(cmd);
        break;

      case 'R':
        remove_produto_encomenda(cmd);
        break;

      case 'C':
        custo_encomenda(cmd);
        break;

      case 'p':
        altera_preco(cmd);
        break;

      case 'E':
        lista_descricao_quantidade(cmd);
        break;

      case 'm':
        lista_encomenda(cmd);
        break;

      case 'l':
        ordena_produtos();
        break;

      case 'L':
        ordena_alfabetico(cmd);
        break;

      default:
        break;

    }

  }

  return 0;
}

void adiciona_produto(char cmd[])
{
  Produto res;
  for (int res_index = 0; res_index < 10; res_index++)
  {
    res.descricao[res_index] = new_sym_var(sizeof(char) * 8);
  }

  res.descricao[10 - 1] = '\0';
  res.preco = new_sym_var(sizeof(int) * 8);
  res.peso = new_sym_var(sizeof(int) * 8);
  res.quantidade = new_sym_var(sizeof(int) * 8);
  res.id = indexidp;
  idproduto[indexidp] = res;
  printf("Novo produto %d.\n", indexidp);
  indexidp++;
}

void adiciona_stock(char cmd[])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= indexidp)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  idproduto[idp].quantidade += qtd;
}

void cria_encomenda()
{
  printf("Nova encomenda %d.\n", indexiden);
  indexiden++;
}

void adiciona_produto_encomenda(char cmd[])
{
  int i;
  int iden;
  int idp;
  int qtd;
  iden = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (iden >= indexiden)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, iden);
    return;
  }
  else
  {
    
  }

  if (idp >= indexidp)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, iden);
    return;
  }
  else
  {
    
  }

  if (qtd > idproduto[idp].quantidade)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, iden);
    return;
  }
  else
  {
    
  }

  if (((idproduto[idp].peso * qtd) + idencomenda[iden].peso) > 200)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, iden);
    return;
  }
  else
  {
    
  }

  idproduto[idp].quantidade -= qtd;
  idencomenda[iden].preco += idproduto[idp].preco * qtd;
  idencomenda[iden].peso += idproduto[idp].peso * qtd;
  for (i = 0; i < idencomenda[iden].index; i++)
  {
    if (idencomenda[iden].produtos[i].id == idproduto[idp].id)
    {
      idencomenda[iden].produtos[i].quantidade += qtd;
      return;
    }
    else
    {
      
    }

  }

  idencomenda[iden].produtos[idencomenda[iden].index] = idproduto[idp];
  idencomenda[iden].produtos[idencomenda[iden].index].quantidade = qtd;
  idencomenda[iden].index++;
}

void remove_stock(char cmd[])
{
  int idp;
  int qtd;
  idp = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (idp >= indexidp)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (qtd > idproduto[idp].quantidade)
  {
    printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    return;
  }
  else
  {
    
  }

  idproduto[idp].quantidade -= qtd;
}

void remove_produto_encomenda(char cmd[])
{
  int i;
  int indexremove;
  int iden;
  int idp;
  int flag = 0;
  iden = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (iden >= indexiden)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, iden);
    return;
  }
  else
  {
    
  }

  if (idp >= indexidp)
  {
    printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, iden);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < idencomenda[iden].index; i++)
  {
    if (idencomenda[iden].produtos[i].id == idproduto[idp].id)
    {
      indexremove = i;
      flag = 1;
      break;
    }
    else
    {
      
    }

  }

  if (flag == 0)
  {
    return;
  }
  else
  {
    
  }

  idencomenda[iden].preco -= idencomenda[iden].produtos[indexremove].preco * idencomenda[iden].produtos[indexremove].quantidade;
  idencomenda[iden].peso -= idencomenda[iden].produtos[indexremove].peso * idencomenda[iden].produtos[indexremove].quantidade;
  idproduto[idp].quantidade += idencomenda[iden].produtos[indexremove].quantidade;
  for (i = indexremove; i < idencomenda[iden].index; i++)
    idencomenda[iden].produtos[i] = idencomenda[iden].produtos[i + 1];

  idencomenda[iden].index--;
}

void custo_encomenda(char cmd[])
{
  int iden;
  int custo;
  iden = new_sym_var(sizeof(int) * 8);
  if (iden >= indexiden)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", iden);
    return;
  }
  else
  {
    
  }

  custo = idencomenda[iden].preco;
  printf("Custo da encomenda %d %d.\n", iden, custo);
}

void altera_preco(char cmd[])
{
  int idp;
  int iden;
  int preco;
  int prod;
  idp = new_sym_var(sizeof(int) * 8);
  preco = new_sym_var(sizeof(int) * 8);
  if (idp >= indexidp)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  idproduto[idp].preco = preco;
  for (iden = 0; iden < indexiden; iden++)
  {
    for (prod = 0; prod < idencomenda[iden].index; prod++)
    {
      if (idencomenda[iden].produtos[prod].id == idproduto[idp].id)
      {
        idencomenda[iden].preco -= idencomenda[iden].produtos[prod].preco * idencomenda[iden].produtos[prod].quantidade;
        idencomenda[iden].produtos[prod].preco = preco;
        idencomenda[iden].preco += preco * idencomenda[iden].produtos[prod].quantidade;
        break;
      }
      else
      {
        
      }

    }

  }

}

void lista_descricao_quantidade(char cmd[])
{
  int idp;
  int iden;
  int prod;
  int qtd;
  int flag = 0;
  iden = new_sym_var(sizeof(int) * 8);
  idp = new_sym_var(sizeof(int) * 8);
  if (iden >= indexiden)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", iden);
    return;
  }
  else
  {
    
  }

  if (idp >= indexidp)
  {
    printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  for (prod = 0; prod < idencomenda[iden].index; prod++)
  {
    if (idencomenda[iden].produtos[prod].id == idproduto[idp].id)
    {
      qtd = idencomenda[iden].produtos[prod].quantidade;
      flag = 1;
      break;
    }
    else
    {
      
    }

  }

  if (flag == 0)
  {
    qtd = 0;
  }
  else
  {
    
  }

  printf("%s %d.\n", idproduto[idp].descricao, qtd);
}

void lista_encomenda(char cmd[])
{
  int idp;
  int iden;
  int prod;
  int idenmaior;
  int qtdmaior = 0;
  idp = new_sym_var(sizeof(int) * 8);
  if (idp >= indexidp)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
    return;
  }
  else
  {
    
  }

  if (!indexiden)
  {
    return;
  }
  else
  {
    
  }

  for (iden = 0; iden < indexiden; iden++)
  {
    for (prod = 0; prod < idencomenda[iden].index; prod++)
    {
      if (idencomenda[iden].produtos[prod].id == idproduto[idp].id)
      {
        if (idencomenda[iden].produtos[prod].quantidade > qtdmaior)
        {
          qtdmaior = idencomenda[iden].produtos[prod].quantidade;
          idenmaior = iden;
        }
        else
        {
          
        }

        break;
      }
      else
      {
        
      }

    }

  }

  if (!qtdmaior)
  {
    return;
  }
  else
  {
    
  }

  printf("Maximo produto %d %d %d.\n", idp, idenmaior, qtdmaior);
}

void ordena_produtos()
{
  Produto res[10000] = {0};
  int i;
  for (i = 0; i < indexidp; i++)
    res[i] = idproduto[i];

  mergesort(res, 0, indexidp - 1, 0);
  puts("Produtos");
  for (i = 0; i < indexidp; i++)
    printf("* %s %d %d\n", res[i].descricao, res[i].preco, res[i].quantidade);

}

void ordena_alfabetico(char cmd[])
{
  Produto res[200] = {0};
  int i;
  int iden;
  iden = new_sym_var(sizeof(int) * 8);
  if (iden >= indexiden)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", iden);
    return;
  }
  else
  {
    
  }

  printf("Encomenda %d\n", iden);
  if (!idencomenda[iden].peso)
  {
    return;
  }
  else
  {
    
  }

  for (i = 0; i < idencomenda[iden].index; i++)
    res[i] = idencomenda[iden].produtos[i];

  mergesort(res, 0, idencomenda[iden].index - 1, 1);
  for (i = 0; i < idencomenda[iden].index; i++)
    printf("* %s %d %d\n", res[i].descricao, res[i].preco, res[i].quantidade);

}

void mergesort(Produto vetor[], int esq, int dir, int cmp)
{
  int m = (esq + dir) / 2;
  if (dir <= esq)
  {
    return;
  }
  else
  {
    
  }

  mergesort(vetor, esq, m, cmp);
  mergesort(vetor, m + 1, dir, cmp);
  merge(vetor, esq, m, dir, cmp);
}

void merge(Produto vetor[], int esq, int m, int dir, int cmp)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > esq; i--)
    aux[i - 1] = vetor[i - 1];

  for (j = m; j < dir; j++)
    aux[(dir + m) - j] = vetor[j + 1];

  for (k = esq; k <= dir; k++)
  {
    if (compara_menor(aux[j], aux[i], cmp) || (i > m))
    {
      vetor[k] = aux[j--];
    }
    else
    {
      vetor[k] = aux[i++];
    }

  }

}

int compara_menor(Produto p1, Produto p2, int cmp)
{
  if ((cmp == 0) && (p1.preco < p2.preco))
  {
    return 1;
  }
  else
  {
    
  }

  if ((cmp == 1) && (strcmp(p1.descricao, p2.descricao) < 0))
  {
    return 1;
  }
  else
  {
    
  }

  return 0;
}

