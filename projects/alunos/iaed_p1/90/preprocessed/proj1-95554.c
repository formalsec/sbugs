/*File generated by PreProcessor.py*/


#include <stdio.h>


typedef struct 
{
  int id;
  char description[63 + 1];
  int price;
  int weight;
  int amount;
} product;
typedef struct 
{
  product items[9999];
  int weight;
  int state;
  int n_products;
} order;
void function_a();
void function_q();
void function_N();
void function_A();
void function_r();
void function_R();
void function_C();
void function_p();
void function_E();
void function_m();
void function_l();
void function_L();
void countingsort(int left, int right);
void mergesort(int o_id, int left, int right);
void merge(int o_id, int left, int m, int right);
product warehouse[9999];
order shipping[999];
int warehouse_size;
product aux_wh[9999];
order aux_order;
int main()
{
  char command;
  while (command != 'x')
  {
    command = getchar();
    switch (command)
    {
      case 'a':
        function_a();
        break;

      case 'q':
        function_q();
        break;

      case 'N':
        function_N();
        break;

      case 'A':
        function_A();
        break;

      case 'r':
        function_r();
        break;

      case 'R':
        function_R();
        break;

      case 'C':
        function_C();
        break;

      case 'p':
        function_p();
        break;

      case 'E':
        function_E();
        break;

      case 'm':
        function_m();
        break;

      case 'l':
        function_l();
        break;

      case 'L':
        function_L();
        break;

    }

    getchar();
  }

  return 0;
}

void function_a()
{
  int new_product_id;
  int str_read;
  int c;
  new_product_id = warehouse_size;
  warehouse[new_product_id].id = new_product_id;
  c = getchar();
  c = getchar();
  for (str_read = 0; (str_read < 63) && (c != ':'); str_read++)
  {
    warehouse[new_product_id].description[str_read] = c;
    c = getchar();
  }

  warehouse[new_product_id].description[str_read] = '\0';
  warehouse[new_product_id].price = new_sym_var(sizeof(int) * 8);
  warehouse[new_product_id].weight = new_sym_var(sizeof(int) * 8);
  warehouse[new_product_id].amount = new_sym_var(sizeof(int) * 8);
  warehouse_size++;
  printf("Novo produto %d.\n", warehouse[new_product_id].id);
}

void function_q()
{
  int p_id;
  int add_amount;
  p_id = new_sym_var(sizeof(int) * 8);
  add_amount = new_sym_var(sizeof(int) * 8);
  if (strcmp(warehouse[p_id].description, "") == 0)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", p_id);
    return;
  }
  else
  {
    
  }

  warehouse[p_id].amount += add_amount;
}

void function_N()
{
  int o_id;
  for (o_id = 0; (o_id < 999) && (shipping[o_id].state == 1); o_id++)
  {
    ;
  }

  shipping[o_id].state = 1;
  printf("Nova encomenda %d.\n", o_id);
}

void function_A()
{
  int o_id;
  int p_id;
  int qtt;
  int check;
  int search_order;
  o_id = new_sym_var(sizeof(int) * 8);
  p_id = new_sym_var(sizeof(int) * 8);
  qtt = new_sym_var(sizeof(int) * 8);
  if (shipping[o_id].state == 0)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", p_id, o_id);
    return;
  }
  else
  {
    if (strcmp(warehouse[p_id].description, "") == 0)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", p_id, o_id);
      return;
    }
    else
    {
      if (warehouse[p_id].amount < qtt)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", p_id, o_id);
        return;
      }
      else
      {
        if ((shipping[o_id].weight + (warehouse[p_id].weight * qtt)) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", p_id, o_id);
          return;
        }
        else
        {
          
        }

      }

    }

  }

  check = 0;
  for (search_order = 0; search_order < shipping[o_id].n_products; search_order++)
  {
    if (shipping[o_id].items[search_order].id == p_id)
    {
      check = 1;
      break;
    }
    else
    {
      
    }

  }

  if (check == 0)
  {
    search_order = shipping[o_id].n_products;
    shipping[o_id].items[search_order] = warehouse[p_id];
    shipping[o_id].n_products++;
    shipping[o_id].items[search_order].amount = qtt;
    warehouse[p_id].amount -= qtt;
    shipping[o_id].weight += qtt * shipping[o_id].items[search_order].weight;
  }
  else
  {
    if (check == 1)
    {
      warehouse[p_id].amount -= qtt;
      shipping[o_id].items[search_order].amount += qtt;
      shipping[o_id].weight += qtt * shipping[o_id].items[search_order].weight;
    }
    else
    {
      
    }

  }

}

void function_r()
{
  int p_id;
  int qtd;
  p_id = new_sym_var(sizeof(int) * 8);
  qtd = new_sym_var(sizeof(int) * 8);
  if (strcmp(warehouse[p_id].description, "") == 0)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", p_id);
    return;
  }
  else
  {
    if (warehouse[p_id].amount < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, p_id);
      return;
    }
    else
    {
      
    }

  }

  warehouse[p_id].amount -= qtd;
}

void function_R()
{
  int o_id;
  int p_id;
  int search_order;
  int delete;
  o_id = new_sym_var(sizeof(int) * 8);
  p_id = new_sym_var(sizeof(int) * 8);
  if (shipping[o_id].state == 0)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", p_id, o_id);
    return;
  }
  else
  {
    if (strcmp(warehouse[p_id].description, "") == 0)
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", p_id, o_id);
      return;
    }
    else
    {
      
    }

  }

  for (search_order = 0; search_order < shipping[o_id].n_products; search_order++)
  {
    if (shipping[o_id].items[search_order].id == p_id)
    {
      warehouse[p_id].amount += shipping[o_id].items[search_order].amount;
      shipping[o_id].weight -= shipping[o_id].items[search_order].amount * shipping[o_id].items[search_order].weight;
      for (delete = search_order; delete < shipping[o_id].n_products; delete++)
      {
        shipping[o_id].items[delete] = shipping[o_id].items[delete + 1];
      }

      --shipping[o_id].n_products;
      break;
    }
    else
    {
      
    }

  }

}

void function_C()
{
  int o_id;
  int cicle;
  int cost = 0;
  o_id = new_sym_var(sizeof(int) * 8);
  if (shipping[o_id].state == 0)
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", o_id);
    return;
  }
  else
  {
    
  }

  for (cicle = 0; cicle < shipping[o_id].n_products; cicle++)
  {
    cost += shipping[o_id].items[cicle].price * shipping[o_id].items[cicle].amount;
  }

  printf("Custo da encomenda %d %d.\n", o_id, cost);
}

void function_p()
{
  int p_id;
  int new_price;
  int search_order;
  int search_items;
  p_id = new_sym_var(sizeof(int) * 8);
  new_price = new_sym_var(sizeof(int) * 8);
  if (strcmp(warehouse[p_id].description, "") == 0)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", p_id);
    return;
  }
  else
  {
    
  }

  warehouse[p_id].price = new_price;
  for (search_order = 0; (search_order < 999) && (shipping[search_order].state == 1); search_order++)
  {
    for (search_items = 0; search_items < shipping[search_order].n_products; search_items++)
    {
      if (shipping[search_order].items[search_items].id == p_id)
      {
        shipping[search_order].items[search_items].price = new_price;
      }
      else
      {
        
      }

    }

  }

}

void function_E()
{
  int o_id;
  int p_id;
  int search_order;
  o_id = new_sym_var(sizeof(int) * 8);
  p_id = new_sym_var(sizeof(int) * 8);
  if (shipping[o_id].state == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", o_id);
    return;
  }
  else
  {
    if (strcmp(warehouse[p_id].description, "") == 0)
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", p_id);
      return;
    }
    else
    {
      
    }

  }

  for (search_order = 0; search_order < warehouse_size; search_order++)
  {
    if ((shipping[o_id].items[search_order].id == p_id) && (shipping[o_id].items[search_order].amount != 0))
    {
      printf("%s %d.\n", shipping[o_id].items[search_order].description, shipping[o_id].items[search_order].amount);
      return;
    }
    else
    {
      
    }

  }

  printf("%s %d.\n", warehouse[p_id].description, 0);
}

void function_m()
{
  int p_id;
  int search_order;
  int search_items;
  int order_max = 0;
  int qtt_max = 0;
  p_id = new_sym_var(sizeof(int) * 8);
  if (strcmp(warehouse[p_id].description, "") == 0)
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", p_id);
    return;
  }
  else
  {
    
  }

  for (search_order = 0; (search_order < 999) && (shipping[search_order].state == 1); search_order++)
  {
    for (search_items = 0; search_items < shipping[search_order].n_products; search_items++)
    {
      if ((shipping[search_order].items[search_items].id == p_id) && (shipping[search_order].items[search_items].amount > qtt_max))
      {
        order_max = search_order;
        qtt_max = shipping[search_order].items[search_items].amount;
      }
      else
      {
        
      }

    }

  }

  if (qtt_max != 0)
  {
    printf("Maximo produto %d %d %d.\n", p_id, order_max, qtt_max);
  }
  else
  {
    
  }

}

void function_l()
{
  int print;
  countingsort(0, warehouse_size);
  puts("Produtos");
  for (print = 0; print < warehouse_size; print++)
  {
    printf("* %s %d %d\n", aux_wh[print].description, aux_wh[print].price, aux_wh[print].amount);
  }

}

void function_L()
{
  int o_id;
  int print;
  o_id = new_sym_var(sizeof(int) * 8);
  if (shipping[o_id].state == 0)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", o_id);
    return;
  }
  else
  {
    
  }

  mergesort(o_id, 0, shipping[o_id].n_products - 1);
  printf("Encomenda %d\n", o_id);
  for (print = 0; print < shipping[o_id].n_products; print++)
  {
    printf("* %s %d %d\n", shipping[o_id].items[print].description, shipping[o_id].items[print].price, shipping[o_id].items[print].amount);
  }

}

void countingsort(int left, int right)
{
  int index;
  int counter_array[32768 + 1] = {0};
  for (index = 0; index < right; index++)
  {
    ++counter_array[warehouse[index].price];
  }

  counter_array[0] = left;
  for (index = 1; index <= 32768; index++)
  {
    counter_array[index] += counter_array[index - 1];
  }

  for (index = right - 1; index >= 0; index--)
  {
    aux_wh[counter_array[warehouse[index].price] - 1] = warehouse[index];
    --counter_array[warehouse[index].price];
  }

}

void mergesort(int o_id, int left, int right)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(o_id, left, m);
  mergesort(o_id, m + 1, right);
  merge(o_id, left, m, right);
}

void merge(int o_id, int left, int m, int right)
{
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux_order.items[i - 1] = shipping[o_id].items[i - 1];

  for (j = m; (j < right) && (strcmp(aux_order.items[j].description, "") != 0); j++)
    aux_order.items[(right + m) - j] = shipping[o_id].items[j + 1];

  for (k = left; k <= right; k++)
    if ((strcmp(aux_order.items[j].description, aux_order.items[i].description) < 0) || (i > m))
  {
    shipping[o_id].items[k] = aux_order.items[j--];
  }
  else
  {
    shipping[o_id].items[k] = aux_order.items[i++];
  }


}

