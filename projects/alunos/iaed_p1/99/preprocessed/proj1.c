/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>


typedef struct product
{
  int idp;
  char desc[63];
  int qtd;
  int prc;
  int wght;
} prct;
typedef struct order
{
  int ido;
  int wght;
  int nbprdct;
  int products[200][2];
} ordr;
prct products[10000];
ordr orders[500];
void getcmd(char cmd[]);
int cmd_a(char cmd[], int next_idp);
void cmd_q(char cmd[]);
void cmd_r(char cmd[]);
void cmd_p(char cmd[]);
void cmd_m(char cmd[]);
void cmd_l();
int cmd_N(int next_ido);
void cmd_A(char cmd[]);
void cmd_R(char cmd[]);
void cmd_C(char cmd[]);
void cmd_E(char cmd[]);
void cmd_L(char cmd[]);
void init_products();
void init_orders();
int str_int(char string[]);
int up_string(char string[], char next_char, int free_space);
void quicksort(prct items[], int (*less)(prct, prct), int left, int right);
int less_l(prct prct1, prct prct2);
int less_L(prct prct1, prct prct2);
int partition(prct items[], int left, int right, int (*less)(prct, prct));
int exch(prct items[], int pos1, int pos2);
int main()
{
  char cmd[80];
  int next_idp = 0;
  int next_ido = 0;
  init_products();
  init_orders();
  getcmd(cmd);
  while (cmd[0] != 'x')
  {
    switch (cmd[0])
    {
      case 'a':
        next_idp = cmd_a(cmd, next_idp);
        break;

      case 'q':
        cmd_q(cmd);
        break;

      case 'r':
        cmd_r(cmd);
        break;

      case 'p':
        cmd_p(cmd);
        break;

      case 'm':
        cmd_m(cmd);
        break;

      case 'l':
        cmd_l();
        break;

      case 'N':
        next_ido = cmd_N(next_ido);
        break;

      case 'A':
        cmd_A(cmd);
        break;

      case 'R':
        cmd_R(cmd);
        break;

      case 'C':
        cmd_C(cmd);
        break;

      case 'E':
        cmd_E(cmd);
        break;

      case 'L':
        cmd_L(cmd);
        break;

    }

    getcmd(cmd);
  }

  return 0;
}

void getcmd(char cmd[])
{
  char c;
  int i = 0;
  while (((c = getchar()) != '\n') && (c != EOF))
  {
    cmd[i] = c;
    i++;
  }

  cmd[i] = '\0';
}

int cmd_a(char cmd[], int next_idp)
{
  int i;
  int state = 0;
  char middle_man[63];
  int man_trc = 0;
  products[next_idp].idp = next_idp;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    switch (state)
    {
      case 0:
        if (cmd[i] == ':')
      {
        state = 1;
        man_trc = up_string(middle_man, '\0', man_trc);
        for (man_trc = 0; middle_man[man_trc] != '\0'; man_trc++)
        {
          products[next_idp].desc[man_trc] = middle_man[man_trc];
        }

        man_trc = 0;
      }
      else
      {
        man_trc = up_string(middle_man, cmd[i], man_trc);
      }

        break;

      case 1:
        if (cmd[i] == ':')
      {
        state = 2;
        man_trc = up_string(middle_man, '\0', man_trc);
        products[next_idp].prc = str_int(middle_man);
      }
      else
      {
        man_trc = up_string(middle_man, cmd[i], man_trc);
      }

        break;

      case 2:
        if (cmd[i] == ':')
      {
        state = 3;
        man_trc = up_string(middle_man, '\0', man_trc);
        products[next_idp].wght = str_int(middle_man);
      }
      else
      {
        man_trc = up_string(middle_man, cmd[i], man_trc);
      }

        break;

      case 3:
        man_trc = up_string(middle_man, cmd[i], man_trc);
        break;

    }

  }

  up_string(middle_man, '\0', man_trc);
  products[next_idp].qtd = str_int(middle_man);
  printf("Novo produto %d.\n", next_idp);
  return next_idp + 1;
}

void cmd_q(char cmd[])
{
  char middle_man[63];
  int middle_trc = 0;
  int state = 4;
  int id;
  int i;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    switch (state)
    {
      case 4:
        if (cmd[i] == ':')
      {
        state = 3;
        middle_trc = up_string(middle_man, '\0', middle_trc);
        id = str_int(middle_man);
        if (products[id].idp == (-1))
        {
          state = 6;
        }
        else
        {
          
        }

      }
      else
      {
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
      }

        break;

      case 3:
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
        break;

    }

  }

  if (state == 6)
  {
    printf("Impossivel adicionar produto %d ao stock. Produto inexistente.\n", id);
  }
  else
  {
    up_string(middle_man, '\0', middle_trc);
    products[id].qtd += str_int(middle_man);
  }

}

void cmd_r(char cmd[])
{
  int state = 4;
  int i;
  char middle_man[63];
  int middle_trc = 0;
  int idp;
  int qtd;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    switch (state)
    {
      case 4:
        if (cmd[i] == ':')
      {
        state = 3;
        middle_trc = up_string(middle_man, '\0', middle_trc);
        idp = str_int(middle_man);
        if (products[idp].idp == (-1))
        {
          state = 6;
        }
        else
        {
          
        }

      }
      else
      {
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
      }

        break;

      case 3:
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
        break;

    }

  }

  if (state == 6)
  {
    printf("Impossivel remover stock do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    up_string(middle_man, '\0', middle_trc);
    qtd = str_int(middle_man);
    if (products[idp].qtd < qtd)
    {
      printf("Impossivel remover %d unidades do produto %d do stock. Quantidade insuficiente.\n", qtd, idp);
    }
    else
    {
      products[idp].qtd -= qtd;
    }

  }

}

void cmd_p(char cmd[])
{
  int i;
  int state = 4;
  int middle_trc = 0;
  char middle_man[63];
  int idp;
  int price;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    switch (state)
    {
      case 4:
        if (cmd[i] == ':')
      {
        state = 1;
        middle_trc = up_string(middle_man, '\0', middle_trc);
        idp = str_int(middle_man);
        if (products[idp].idp == (-1))
        {
          state = 6;
        }
        else
        {
          
        }

      }
      else
      {
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
      }

        break;

      case 1:
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
        break;

    }

  }

  if (state == 6)
  {
    printf("Impossivel alterar preco do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    up_string(middle_man, '\0', middle_trc);
    price = str_int(middle_man);
    products[idp].prc = price;
  }

}

void cmd_m(char cmd[])
{
  int i;
  int j;
  int middle_trc = 0;
  char middle_man[63];
  int idp;
  int max = 0;
  int ido = -1;
  int o_idp = -1;
  int nbprdct;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    middle_trc = up_string(middle_man, cmd[i], middle_trc);
  }

  up_string(middle_man, '\0', middle_trc);
  idp = str_int(middle_man);
  if (products[idp].idp == (-1))
  {
    printf("Impossivel listar maximo do produto %d. Produto inexistente.\n", idp);
  }
  else
  {
    for (i = 0; (orders[i].ido != (-1)) && (i < 500); i++)
    {
      nbprdct = orders[i].nbprdct;
      for (j = 0; (nbprdct != 0) && (j < 200); j++)
      {
        if (orders[i].products[j][0] == idp)
        {
          if (ido == (-1))
          {
            max = orders[i].products[j][1];
            ido = i;
            o_idp = j;
          }
          else
          {
            
          }

          if (orders[i].products[j][1] > max)
          {
            max = orders[i].products[j][1];
            ido = i;
            o_idp = j;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

        if (orders[i].products[j][0] != (-1))
        {
          nbprdct--;
        }
        else
        {
          
        }

      }

    }

    if (ido != (-1))
    {
      printf("Maximo produto %d %d %d.\n", idp, ido, orders[ido].products[o_idp][1]);
    }
    else
    {
      
    }

  }

}

void cmd_l()
{
  prct new_products[10000];
  int sz;
  for (sz = 0; (products[sz].idp != (-1)) && (sz < 10000); sz++)
  {
    new_products[sz] = products[sz];
  }

  new_products[sz].idp = -1;
  quicksort(new_products, less_l, 0, sz - 1);
  printf("Produtos\n");
  for (sz = 0; (new_products[sz].idp != (-1)) && (sz < 10000); sz++)
  {
    printf("* %s %d %d\n", new_products[sz].desc, new_products[sz].prc, new_products[sz].qtd);
  }

}

int cmd_N(int next_ido)
{
  orders[next_ido].ido = next_ido;
  orders[next_ido].wght = 0;
  printf("Nova encomenda %d.\n", next_ido);
  return next_ido + 1;
}

void cmd_A(char cmd[])
{
  char middle_man[63];
  int middle_trc = 0;
  int state = 5;
  int nbprdcts;
  int idp;
  int ido;
  int qtd;
  int error = -1;
  int i;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    switch (state)
    {
      case 5:
        if (cmd[i] == ':')
      {
        state = 4;
        middle_trc = up_string(middle_man, '\0', middle_trc);
        ido = str_int(middle_man);
        if (orders[ido].ido == (-1))
        {
          error = 7;
        }
        else
        {
          
        }

      }
      else
      {
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
      }

        break;

      case 4:
        if (cmd[i] == ':')
      {
        state = 3;
        middle_trc = up_string(middle_man, '\0', middle_trc);
        idp = str_int(middle_man);
        if (products[idp].idp == (-1))
        {
          if (error == (-1))
          {
            error = 6;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }
      else
      {
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
      }

        break;

      case 3:
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
        break;

    }

  }

  if (error == 7)
  {
    printf("Impossivel adicionar produto %d a encomenda %d. Encomenda inexistente.\n", idp, ido);
  }
  else
  {
    if (error == 6)
    {
      printf("Impossivel adicionar produto %d a encomenda %d. Produto inexistente.\n", idp, ido);
    }
    else
    {
      up_string(middle_man, '\0', middle_trc);
      qtd = str_int(middle_man);
      if (products[idp].qtd < qtd)
      {
        printf("Impossivel adicionar produto %d a encomenda %d. Quantidade em stock insuficiente.\n", idp, ido);
      }
      else
      {
        if (((qtd * products[idp].wght) + orders[ido].wght) > 200)
        {
          printf("Impossivel adicionar produto %d a encomenda %d. Peso da encomenda excede o maximo de 200.\n", idp, ido);
        }
        else
        {
          products[idp].qtd -= qtd;
          nbprdcts = orders[ido].nbprdct;
          for (i = 0; ((nbprdcts != 0) && (orders[ido].products[i][0] != idp)) && (i < 500); i++)
          {
            if (orders[ido].products[i][0] != (-1))
            {
              nbprdcts--;
            }
            else
            {
              
            }

          }

          if (nbprdcts == 0)
          {
            for (i = 0; (orders[ido].products[i][0] != (-1)) && (i < 200); i++)
              ;

          }
          else
          {
            
          }

          if (orders[ido].products[i][0] == (-1))
          {
            orders[ido].nbprdct++;
          }
          else
          {
            
          }

          orders[ido].products[i][0] = idp;
          orders[ido].products[i][1] += qtd;
          orders[ido].wght += qtd * products[idp].wght;
        }

      }

    }

  }

}

void cmd_R(char cmd[])
{
  int i;
  int state = 5;
  int error = -1;
  int idp;
  int ido;
  int nbprdcts;
  char middle_man[63];
  int middle_trc = 0;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    switch (state)
    {
      case 5:
        if (cmd[i] == ':')
      {
        state = 4;
        middle_trc = up_string(middle_man, '\0', middle_trc);
        ido = str_int(middle_man);
        if (orders[ido].ido == (-1))
        {
          error = 7;
        }
        else
        {
          
        }

      }
      else
      {
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
      }

        break;

      case 4:
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
        break;

    }

  }

  up_string(middle_man, '\0', middle_trc);
  idp = str_int(middle_man);
  if (error == 7)
  {
    printf("Impossivel remover produto %d a encomenda %d. Encomenda inexistente.\n", idp, ido);
  }
  else
  {
    if (products[idp].idp == (-1))
    {
      printf("Impossivel remover produto %d a encomenda %d. Produto inexistente.\n", idp, ido);
    }
    else
    {
      nbprdcts = orders[ido].nbprdct;
      for (i = 0; (i < 200) && (nbprdcts != 0); i++)
      {
        if (orders[ido].products[i][0] == idp)
        {
          orders[ido].products[i][0] = -1;
          orders[ido].wght -= orders[ido].products[i][1] * products[idp].wght;
          products[idp].qtd += orders[ido].products[i][1];
          orders[ido].products[i][1] = 0;
          orders[ido].nbprdct--;
          break;
        }
        else
        {
          
        }

        if (orders[ido].products[i][0] != (-1))
        {
          nbprdcts--;
        }
        else
        {
          
        }

      }

    }

  }

}

void cmd_C(char cmd[])
{
  int i;
  int ido;
  int idp;
  int cost = 0;
  int nbrprdcts;
  int middle_trc = 0;
  char middle_man[63];
  for (i = 2; cmd[i] != '\0'; i++)
  {
    middle_trc = up_string(middle_man, cmd[i], middle_trc);
  }

  up_string(middle_man, '\0', middle_trc);
  ido = str_int(middle_man);
  if (orders[ido].ido == (-1))
  {
    printf("Impossivel calcular custo da encomenda %d. Encomenda inexistente.\n", ido);
  }
  else
  {
    nbrprdcts = orders[ido].nbprdct;
    for (i = 0; (i < 200) && (nbrprdcts != 0); i++)
    {
      if (orders[ido].products[i][0] != (-1))
      {
        idp = orders[ido].products[i][0];
        cost += orders[ido].products[i][1] * products[idp].prc;
        nbrprdcts--;
      }
      else
      {
        
      }

    }

    printf("Custo da encomenda %d %d.\n", ido, cost);
  }

}

void cmd_E(char cmd[])
{
  int i;
  int state = 5;
  int middle_trc = 0;
  char middle_man[63];
  int ido;
  int idp;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    switch (state)
    {
      case 5:
        if (cmd[i] == ':')
      {
        state = 4;
        middle_trc = up_string(middle_man, '\0', middle_trc);
        ido = str_int(middle_man);
        if (orders[ido].ido == (-1))
        {
          state = 7;
        }
        else
        {
          
        }

      }
      else
      {
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
      }

        break;

      case 4:
        middle_trc = up_string(middle_man, cmd[i], middle_trc);
        break;

    }

  }

  if (state == 7)
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ido);
  }
  else
  {
    up_string(middle_man, '\0', middle_trc);
    idp = str_int(middle_man);
    if (products[idp].idp == (-1))
    {
      printf("Impossivel listar produto %d. Produto inexistente.\n", idp);
    }
    else
    {
      for (i = 0; (orders[ido].products[i][0] != idp) && (i < 200); i++)
        ;

      printf("%s", products[idp].desc);
      if ((i == 200) && (orders[ido].products[i][0] != idp))
      {
        printf(" 0.\n");
      }
      else
      {
        printf(" %d.\n", orders[ido].products[i][1]);
      }

    }

  }

}

void cmd_L(char cmd[])
{
  int ido;
  int i;
  int j;
  int middle_trc = 0;
  char middle_man[63];
  prct new_products[200];
  int nbprdct;
  for (i = 2; cmd[i] != '\0'; i++)
  {
    middle_trc = up_string(middle_man, cmd[i], middle_trc);
  }

  up_string(middle_man, '\0', middle_trc);
  ido = str_int(middle_man);
  if (orders[ido].ido == (-1))
  {
    printf("Impossivel listar encomenda %d. Encomenda inexistente.\n", ido);
  }
  else
  {
    nbprdct = orders[ido].nbprdct;
    i = 0;
    j = 0;
    while (nbprdct != 0)
    {
      if (orders[ido].products[i][0] != (-1))
      {
        new_products[j] = products[orders[ido].products[i][0]];
        nbprdct--;
        j++;
      }
      else
      {
        
      }

      i++;
    }

    new_products[j].idp = -1;
    quicksort(new_products, less_L, 0, orders[ido].nbprdct - 1);
    printf("Encomenda %d\n", ido);
    for (i = 0; new_products[i].idp != (-1); i++)
    {
      for (j = 0; orders[ido].products[j][0] != new_products[i].idp; j++)
        ;

      printf("* %s %d %d\n", new_products[i].desc, new_products[i].prc, orders[ido].products[j][1]);
    }

  }

}

void init_products()
{
  int i;
  for (i = 0; i < 10000; i++)
  {
    products[i].idp = -1;
  }

}

void init_orders()
{
  int i;
  int j;
  for (i = 0; i < 500; i++)
  {
    orders[i].ido = -1;
    for (j = 0; j < 200; j++)
    {
      orders[i].products[j][0] = -1;
    }

    orders[i].wght = 0;
    orders[i].nbprdct = 0;
  }

}

int str_int(char string[])
{
  int i;
  int nbr = 0;
  for (i = 0; string[i] != '\0'; i++)
  {
    nbr *= 10;
    nbr += string[i] - 48;
  }

  return nbr;
}

int up_string(char string[], char next_char, int free_space)
{
  string[free_space] = next_char;
  if (next_char == '\0')
  {
    return 0;
  }
  else
  {
    return free_space + 1;
  }

}

void quicksort(prct items[], int (*less)(prct, prct), int left, int right)
{
  int i;
  if (right > left)
  {
    i = partition(items, left, right, *less);
    quicksort(items, *less, left, i - 1);
    quicksort(items, *less, i + 1, right);
  }
  else
  {
    
  }

}

int partition(prct items[], int left, int right, int (*less)(prct, prct))
{
  int i = left - 1;
  int j = right;
  prct pivot = items[right];
  while (i < j)
  {
    while ((i != right) && (*less)(items[++i], pivot))
      ;

    while ((j != 0) && (*less)(pivot, items[--j]))
      ;

    if (j == left)
    {
      break;
    }
    else
    {
      
    }

    if (i < j)
    {
      exch(items, i, j);
    }
    else
    {
      
    }

  }

  exch(items, i, right);
  return i;
}

int exch(prct items[], int pos1, int pos2)
{
  prct aux_prct = items[pos1];
  items[pos1] = items[pos2];
  items[pos2] = aux_prct;
  return 0;
}

int less_l(prct prct1, prct prct2)
{
  if (prct1.prc < prct2.prc)
  {
    return 1;
  }
  else
  {
    if (prct1.prc == prct2.prc)
    {
      if (prct1.idp < prct2.idp)
      {
        return 1;
      }
      else
      {
        
      }

      return 0;
    }
    else
    {
      
    }

  }

  return 0;
}

int less_L(prct prct1, prct prct2)
{
  int i;
  for (i = 0; prct1.desc[i] != '\0'; i++)
  {
    if (prct2.desc[i] == '\0')
    {
      return 0;
    }
    else
    {
      if (prct1.desc[i] < prct2.desc[i])
      {
        return 1;
      }
      else
      {
        if (prct1.desc[i] > prct2.desc[i])
        {
          return 0;
        }
        else
        {
          
        }

      }

    }

  }

  if (prct2.desc[i] != '\0')
  {
    return 1;
  }
  else
  {
    return 0;
  }

}

