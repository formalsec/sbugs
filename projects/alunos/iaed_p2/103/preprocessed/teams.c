#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "teams.h"


int compare(const void *a, const void *b)
{
  return strcmp(*((char **) a), *((char **) b));
}

char *myStrdup(char *string)
{
  char *new_string = (char *) malloc((sizeof(char)) * (strlen(string) + 1));
  strcpy(new_string, string);
  return new_string;
}

int hash(char *string)
{
  int h = 0;
  int a = 127;
  for (; (*string) != '\0'; string++)
    h = ((a * h) + (*string)) % 1061;

  return h;
}

team_node **makeHashTeams()
{
  team_node **hash_table = (team_node **) malloc((sizeof(team_node *)) * 1061);
  int i;
  for (i = 0; i < 1061; i++)
  {
    hash_table[i] = 0;
  }

  return hash_table;
}

team_node *insertBeginList(team_node *head, team *t)
{
  team_node *new_head = (team_node *) malloc(sizeof(team_node));
  new_head->next = head;
  new_head->tptr = t;
  return new_head;
}

void insertTeam(team_node **hastable, team *t)
{
  int i = hash(t->name);
  hastable[i] = insertBeginList(hastable[i], t);
}

team *searchListTeams(team_node *head, char *name)
{
  while (head)
  {
    if (!strcmp(head->tptr->name, name))
    {
      return head->tptr;
    }
    else
    {
      
    }

    head = head->next;
  }

  return 0;
}

team *searchHashTeams(team_node **hastable, char *name)
{
  int i = hash(name);
  return searchListTeams(hastable[i], name);
}

void freeAllMemoryTeams(team_node **hashteams)
{
  int i;
  for (i = 0; i < 1061; i++)
  {
    team_node *t = hashteams[i];
    while (t)
    {
      team_node *old = t;
      free(t->tptr->name);
      free(t->tptr);
      t = t->next;
      free(old);
    }

  }

  free(hashteams);
}

void searchTeam(team_node **hastable, int line)
{
  char *name = (char *) malloc((sizeof(char)) * 1024);
  team *t;
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  t = searchHashTeams(hastable, name);
  if (!t)
  {
    printf("%d Equipa inexistente.\n", line);
    free(name);
    return;
  }
  else
  {
    
  }

  printf("%d %s %d\n", line, name, t->number_of_wins);
  free(name);
}

void addTeam(team_node **hashtable, int line)
{
  char *name = (char *) malloc((sizeof(char)) * 1024);
  team *t;
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  if (searchHashTeams(hashtable, name))
  {
    printf("%d Equipa existente.\n", line);
    free(name);
    return;
  }
  else
  {
    
  }

  t = (team *) malloc(sizeof(team));
  t->number_of_wins = 0;
  t->name = myStrdup(name);
  free(name);
  insertTeam(hashtable, t);
}

void findChampions(team_node **hashtable, int line)
{
  int i;
  int max_wins = -1;
  int number_of_teams;
  for (i = 0; i < 1061; i++)
  {
    if (hashtable[i] != 0)
    {
      team_node *t = hashtable[i];
      while (t)
      {
        if (t->tptr->number_of_wins > max_wins)
        {
          max_wins = t->tptr->number_of_wins;
          number_of_teams = 1;
        }
        else
        {
          if (t->tptr->number_of_wins == max_wins)
          {
            number_of_teams++;
          }
          else
          {
            
          }

        }

        t = t->next;
      }

    }
    else
    {
      
    }

  }

  if (max_wins > (-1))
  {
    char **strings = (char **) malloc((sizeof(char *)) * number_of_teams);
    int j = 0;
    for (i = 0; i < 1061; i++)
    {
      if (hashtable[i] != 0)
      {
        team_node *t = hashtable[i];
        while (t)
        {
          if (t->tptr->number_of_wins == max_wins)
          {
            strings[j] = t->tptr->name;
            j++;
          }
          else
          {
            
          }

          t = t->next;
        }

      }
      else
      {
        
      }

    }

    qsort(strings, number_of_teams, sizeof(char *), compare);
    printf("%d Melhores %d\n", line, max_wins);
    for (i = 0; i < number_of_teams; i++)
    {
      printf("%d * %s\n", line, strings[i]);
    }

    free(strings);
  }
  else
  {
    
  }

}

