#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "equipa.h"
#include "jogo.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


void a(LinkE *ETable, Link *JTable, Lista lista, int Linha_Input)
{
  char nome_max[1024];
  char equipa0[1024];
  char equipa1[1024];
  char *nome;
  int score[2];
  int validade;
  int index;
  Jogo *novo_jogo;
  Equipa *e_vencedora;
  for (int nome_max_index = 0; nome_max_index < 10; nome_max_index++)
  {
    nome_max[nome_max_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_max[10 - 1] = '\0';
  for (int equipa0_index = 0; equipa0_index < 10; equipa0_index++)
  {
    equipa0[equipa0_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa0[10 - 1] = '\0';
  for (int equipa1_index = 0; equipa1_index < 10; equipa1_index++)
  {
    equipa1[equipa1_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa1[10 - 1] = '\0';
  score[0] = new_sym_var(sizeof(int) * 8);
  score[1] = new_sym_var(sizeof(int) * 8);
  nome = (char *) malloc((strlen(nome_max) + 1) * (sizeof(char)));
  strcpy(nome, nome_max);
  novo_jogo = (Jogo *) malloc(sizeof(Jogo));
  novo_jogo->nome = nome;
  novo_jogo->score[0] = score[0];
  novo_jogo->score[1] = score[1];
  validade = jogo_invalido(JTable, ETable, nome, equipa0, equipa1);
  if (validade == 0)
  {
    index = hashEquipa(equipa0, 12049);
    novo_jogo->equipa0 = search_lista_e(ETable[index], equipa0);
    index = hashEquipa(equipa1, 12049);
    novo_jogo->equipa1 = search_lista_e(ETable[index], equipa1);
    lista->head = add_j_to_main_list(lista->head, novo_jogo);
    add_linkj_hash(JTable, lista->head, novo_jogo->nome);
    if (lista->tail == 0)
    {
      lista->tail = lista->head;
    }
    else
    {
      
    }

    e_vencedora = vencedor(novo_jogo);
    if (e_vencedora != 0)
    {
      e_vencedora->wins++;
    }
    else
    {
      
    }

  }
  else
  {
    if (validade == 1)
    {
      printf("%d Jogo existente.\n", Linha_Input);
    }
    else
    {
      if (validade == 2)
      {
        printf("%d Equipa inexistente.\n", Linha_Input);
      }
      else
      {
        
      }

    }

    free(novo_jogo->nome);
    free(novo_jogo);
  }

}

void A(LinkE *ETable, int Linha_Input)
{
  char nome_max[1024];
  char *nome;
  Equipa *nova_equipa;
  for (int nome_max_index = 0; nome_max_index < 10; nome_max_index++)
  {
    nome_max[nome_max_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_max[10 - 1] = '\0';
  nome = (char *) malloc((strlen(nome_max) + 1) * (sizeof(char)));
  strcpy(nome, nome_max);
  nova_equipa = (Equipa *) malloc(sizeof(Equipa));
  nova_equipa->nome = nome;
  nova_equipa->wins = 0;
  if (add_e_to_hash(ETable, nova_equipa) == 0)
  {
    printf("%d Equipa existente.\n", Linha_Input);
    free(nova_equipa->nome);
    free(nova_equipa);
  }
  else
  {
    
  }

}

void s(Link *JTable, int Linha_Input)
{
  char nome[1024];
  int score[2];
  Link link;
  Equipa *equipa;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  score[0] = new_sym_var(sizeof(int) * 8);
  score[1] = new_sym_var(sizeof(int) * 8);
  link = search_j_Table(JTable, nome);
  if (link == 0)
  {
    printf("%d Jogo inexistente.\n", Linha_Input);
  }
  else
  {
    equipa = vencedor(link->linkj->jogo);
    if (equipa != 0)
    {
      equipa->wins -= 1;
    }
    else
    {
      
    }

    link->linkj->jogo->score[0] = score[0];
    link->linkj->jogo->score[1] = score[1];
    equipa = vencedor(link->linkj->jogo);
    if (equipa != 0)
    {
      equipa->wins++;
    }
    else
    {
      
    }

  }

}

void r(Link *JTable, Lista lista, int Linha_Input)
{
  char nome[1024];
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  if (destroy(JTable, &lista->head, &lista->tail, nome) == 0)
  {
    printf("%d Jogo inexistente.\n", Linha_Input);
  }
  else
  {
    
  }

}

void p(Link *JTable, int Linha_Input)
{
  char nome[1024];
  Link link;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  link = search_j_Table(JTable, nome);
  if (link == 0)
  {
    printf("%d Jogo inexistente.\n", Linha_Input);
  }
  else
  {
    printf("%d %s %s %s %d %d\n", Linha_Input, link->linkj->jogo->nome, link->linkj->jogo->equipa0->nome, link->linkj->jogo->equipa1->nome, link->linkj->jogo->score[0], link->linkj->jogo->score[1]);
  }

}

void P(LinkE *ETable, int Linha_Input)
{
  char nome[1024];
  Equipa *equipa;
  for (int nome_index = 0; nome_index < 10; nome_index++)
  {
    nome[nome_index] = new_sym_var(sizeof(char) * 8);
  }

  nome[10 - 1] = '\0';
  equipa = search_lista_e(ETable[hashEquipa(nome, 12049)], nome);
  if (equipa == 0)
  {
    printf("%d Equipa inexistente.\n", Linha_Input);
  }
  else
  {
    printf("%d %s %d\n", Linha_Input, equipa->nome, equipa->wins);
  }

}

void l(Lista lista, int Linha_Input)
{
  LinkJ linkj = lista->tail;
  while (linkj != 0)
  {
    printf("%d %s %s %s %d %d\n", Linha_Input, linkj->jogo->nome, linkj->jogo->equipa0->nome, linkj->jogo->equipa1->nome, linkj->jogo->score[0], linkj->jogo->score[1]);
    linkj = linkj->prev;
  }

}

void g(LinkE *ETable, int Linha_Input)
{
  int contador;
  int max_wins = 0;
  int array_size = 0;
  int array_size2;
  int existem_equipas = 0;
  LinkE linke = 0;
  pEquipa *equipas = 0;
  for (contador = 0; contador < 12049; contador++)
  {
    linke = ETable[contador];
    while (linke != 0)
    {
      existem_equipas = 1;
      if (linke->equipa->wins > max_wins)
      {
        max_wins = linke->equipa->wins;
        array_size = 1;
      }
      else
      {
        if (linke->equipa->wins == max_wins)
        {
          array_size++;
        }
        else
        {
          
        }

      }

      linke = linke->next;
    }

  }

  equipas = malloc(array_size * (sizeof(pEquipa)));
  array_size2 = array_size;
  for (contador = 0; contador < 12049; contador++)
  {
    linke = ETable[contador];
    while (linke != 0)
    {
      if (linke->equipa->wins == max_wins)
      {
        equipas[array_size2 - 1] = linke->equipa;
        array_size2 -= 1;
      }
      else
      {
        
      }

      if (array_size2 == (-1))
      {
        contador = 12049;
      }
      else
      {
        
      }

      linke = linke->next;
    }

  }

  if (existem_equipas == 1)
  {
    qsort(equipas, array_size, sizeof(pEquipa), cmpstr);
    printf("%d Melhores %d\n", Linha_Input, max_wins);
    for (contador = 0; contador < array_size; contador++)
      printf("%d * %s\n", Linha_Input, equipas[contador]->nome);

  }
  else
  {
    
  }

  free(equipas);
}

void x(Link *JTable, LinkE *ETable, Lista lista)
{
  clear_j(JTable);
  clear_e(ETable);
  free(lista);
}

int main()
{
  LinkE ETable[12049];
  Link JTable[14149];
  Lista lista;
  int Linha_Input = 1;
  char comando = 'O';
  lista = malloc(sizeof(struct lista));
  lista->head = 0;
  lista->tail = 0;
  ETable_init(ETable);
  JTable_init(JTable);
  while (comando != 'x')
  {
    comando = getchar();
    switch (comando)
    {
      case 'a':
        a(ETable, JTable, lista, Linha_Input);
        Linha_Input++;
        break;

      case 'A':
        A(ETable, Linha_Input);
        Linha_Input++;
        break;

      case 's':
        s(JTable, Linha_Input);
        Linha_Input++;
        break;

      case 'r':
        r(JTable, lista, Linha_Input);
        Linha_Input++;
        break;

      case 'p':
        p(JTable, Linha_Input);
        Linha_Input++;
        break;

      case 'P':
        P(ETable, Linha_Input);
        Linha_Input++;
        break;

      case 'l':
        l(lista, Linha_Input);
        Linha_Input++;
        break;

      case 'g':
        g(ETable, Linha_Input);
        Linha_Input++;
        break;

      case 'x':
        x(JTable, ETable, lista);
        Linha_Input++;
        break;

    }

  }

  return 0;
}

