#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "equipas.h"
#include "jogos.h"


void new_team();
void search_team_in_hash();
NodeGame *new_game();
void search_in_games_hash();
void change_score();
void print_games();
NodeGame *remove_game();
void more_victories();
char *str_dup();
int cmpstr();
int main()
{
  unsigned long int NL = 1;
  char funcao;
  int Mod = 739;
  NodeGame *listRefs = 0;
  NodeTeam **headsT = (NodeTeam **) malloc(Mod * (sizeof(NodeTeam)));
  NodeGame **headsG = (NodeGame **) malloc(Mod * (sizeof(NodeGame)));
  init_hash_teams(headsT, Mod);
  init_hash_games(headsG, Mod);
  while ((funcao = getchar()) != EOF)
  {
    switch (funcao)
    {
      case 'A':
        new_team(headsT, Mod, NL);
        NL++;
        break;

      case 'P':
        search_team_in_hash(headsT, Mod, NL);
        NL++;
        break;

      case 'a':
        listRefs = new_game(headsG, listRefs, headsT, Mod, NL);
        NL++;
        break;

      case 'p':
        search_in_games_hash(headsG, Mod, NL);
        NL++;
        break;

      case 'l':
        print_games(listRefs, NL);
        NL++;
        break;

      case 's':
        change_score(headsG, headsT, Mod, NL);
        NL++;
        break;

      case 'r':
        listRefs = remove_game(headsG, listRefs, headsT, Mod, NL);
        NL++;
        break;

      case 'g':
        more_victories(headsT, Mod, NL);
        NL++;
        break;

      case 'x':
        destroy_hash_teams(headsT, Mod);
        destroy_refs_list(listRefs);
        destroy_hash_games(headsG, Mod);
        free(headsT);
        free(headsG);
        return 0;
        break;

    }

  }

  return 0;
}

void new_team(NodeTeam **headsT, int mod, unsigned long int NL)
{
  char nameTeam[1024];
  Team *errorCheck;
  Team *newTeam;
  for (int nameTeam_index = 0; nameTeam_index < 10; nameTeam_index++)
  {
    nameTeam[nameTeam_index] = new_sym_var(sizeof(char) * 8);
  }

  nameTeam[10 - 1] = '\0';
  errorCheck = hash_search_team(headsT, nameTeam, mod);
  if (errorCheck != 0)
  {
    printf("%lu Equipa existente.\n", NL);
    return;
  }
  else
  {
    
  }

  newTeam = create_team(nameTeam);
  hash_insert_team(headsT, newTeam, mod);
}

void search_team_in_hash(NodeTeam **headsT, int mod, unsigned long int NL)
{
  char nameTeam[1024];
  Team *teamHash;
  for (int nameTeam_index = 0; nameTeam_index < 10; nameTeam_index++)
  {
    nameTeam[nameTeam_index] = new_sym_var(sizeof(char) * 8);
  }

  nameTeam[10 - 1] = '\0';
  teamHash = hash_search_team(headsT, nameTeam, mod);
  if (teamHash == 0)
  {
    printf("%lu Equipa inexistente.\n", NL);
    return;
  }
  else
  {
    
  }

  printf("%lu %s %d\n", NL, teamHash->name, teamHash->victories);
}

NodeGame *new_game(NodeGame **headsG, NodeGame *headRefs, NodeTeam **headsT, int mod, unsigned long int NL)
{
  char nameGame[1024];
  char nameTeam1[1024];
  char nameTeam2[1024];
  int score1;
  int score2;
  Team *team1;
  Team *team2;
  Game *errorCheck;
  Game *newGame;
  for (int nameGame_index = 0; nameGame_index < 10; nameGame_index++)
  {
    nameGame[nameGame_index] = new_sym_var(sizeof(char) * 8);
  }

  nameGame[10 - 1] = '\0';
  for (int nameTeam1_index = 0; nameTeam1_index < 10; nameTeam1_index++)
  {
    nameTeam1[nameTeam1_index] = new_sym_var(sizeof(char) * 8);
  }

  nameTeam1[10 - 1] = '\0';
  for (int nameTeam2_index = 0; nameTeam2_index < 10; nameTeam2_index++)
  {
    nameTeam2[nameTeam2_index] = new_sym_var(sizeof(char) * 8);
  }

  nameTeam2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  errorCheck = hash_search_game(headsG, nameGame, mod);
  if (errorCheck != 0)
  {
    printf("%lu Jogo existente.\n", NL);
    return headRefs;
  }
  else
  {
    
  }

  team1 = hash_search_team(headsT, nameTeam1, mod);
  team2 = hash_search_team(headsT, nameTeam2, mod);
  if ((team1 == 0) || (team2 == 0))
  {
    printf("%lu Equipa inexistente.\n", NL);
    return headRefs;
  }
  else
  {
    
  }

  if (score1 > score2)
  {
    team1->victories++;
  }
  else
  {
    if (score2 > score1)
    {
      team2->victories++;
    }
    else
    {
      
    }

  }

  newGame = create_game(nameGame, nameTeam1, nameTeam2, score1, score2);
  hash_insert_game(headsG, newGame, mod);
  headRefs = hash_put_begin_games(headRefs, newGame);
  return headRefs;
}

void search_in_games_hash(NodeGame **headsG, int mod, unsigned long int NL)
{
  char nameGame[1024];
  Game *gameHash;
  for (int nameGame_index = 0; nameGame_index < 10; nameGame_index++)
  {
    nameGame[nameGame_index] = new_sym_var(sizeof(char) * 8);
  }

  nameGame[10 - 1] = '\0';
  gameHash = hash_search_game(headsG, nameGame, mod);
  if (gameHash == 0)
  {
    printf("%lu Jogo inexistente.\n", NL);
    return;
  }
  else
  {
    
  }

  printf("%lu %s %s %s %d %d\n", NL, gameHash->name, gameHash->team1, gameHash->team2, gameHash->score1, gameHash->score2);
}

void change_score(NodeGame **headsG, NodeTeam **headsT, int mod, unsigned long int NL)
{
  char nameGame[1024];
  char *nameTeam1;
  char *nameTeam2;
  int score1;
  int score2;
  Team *team1;
  Team *team2;
  Game *game;
  for (int nameGame_index = 0; nameGame_index < 10; nameGame_index++)
  {
    nameGame[nameGame_index] = new_sym_var(sizeof(char) * 8);
  }

  nameGame[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  game = hash_search_game(headsG, nameGame, mod);
  if (game == 0)
  {
    printf("%lu Jogo inexistente.\n", NL);
    return;
  }
  else
  {
    
  }

  nameTeam1 = game->team1;
  nameTeam2 = game->team2;
  team1 = hash_search_team(headsT, nameTeam1, mod);
  team2 = hash_search_team(headsT, nameTeam2, mod);
  if ((score1 > score2) && (game->score2 > game->score1))
  {
    team1->victories++;
    team2->victories--;
  }
  else
  {
    if ((score2 > score1) && (game->score1 > game->score2))
    {
      team1->victories--;
      team2->victories++;
    }
    else
    {
      if ((score1 > score2) && (game->score1 == game->score2))
      {
        team1->victories++;
      }
      else
      {
        if ((score2 > score1) && (game->score1 == game->score2))
        {
          team2->victories++;
        }
        else
        {
          if ((score1 == score2) && (game->score1 > game->score2))
          {
            team1->victories--;
          }
          else
          {
            if ((score1 == score2) && (game->score2 > game->score1))
            {
              team2->victories--;
            }
            else
            {
              
            }

          }

        }

      }

    }

  }

  hash_change_score(headsG, nameGame, score1, score2, mod);
}

void print_games(NodeGame *head, unsigned long int NL)
{
  if (head == 0)
  {
    return;
  }
  else
  {
    
  }

  print_games(head->next, NL);
  printf("%lu %s %s %s %d %d\n", NL, head->game->name, head->game->team1, head->game->team2, head->game->score1, head->game->score2);
}

NodeGame *remove_game(NodeGame **headsGames, NodeGame *headRefs, NodeTeam **headsTeams, int mod, unsigned long int NL)
{
  char nameGame[1024];
  Game *gameHash;
  Team *teamAux;
  int score1;
  int score2;
  for (int nameGame_index = 0; nameGame_index < 10; nameGame_index++)
  {
    nameGame[nameGame_index] = new_sym_var(sizeof(char) * 8);
  }

  nameGame[10 - 1] = '\0';
  gameHash = hash_search_game(headsGames, nameGame, mod);
  if (gameHash == 0)
  {
    printf("%lu Jogo inexistente.\n", NL);
    return headRefs;
  }
  else
  {
    
  }

  score1 = gameHash->score1;
  score2 = gameHash->score2;
  if (score1 > score2)
  {
    teamAux = hash_search_team(headsTeams, gameHash->team1, mod);
    teamAux->victories--;
  }
  else
  {
    if (score2 > score1)
    {
      teamAux = hash_search_team(headsTeams, gameHash->team2, mod);
      teamAux->victories--;
    }
    else
    {
      
    }

  }

  headRefs = remove_el_list(headRefs, nameGame);
  hash_remove_game(headsGames, nameGame, mod);
  return headRefs;
}

void more_victories(NodeTeam **headsT, int mod, unsigned long int NL)
{
  int currentMoreWins = 0;
  int i;
  int j;
  NodeTeam *current;
  char **teamsMoreWins;
  int numTeams = 0;
  for (i = 0; i < mod; i++)
  {
    current = headsT[i];
    while (current != 0)
    {
      if (currentMoreWins < current->team->victories)
      {
        currentMoreWins = current->team->victories;
        numTeams = 0;
      }
      else
      {
        
      }

      if (currentMoreWins == current->team->victories)
      {
        numTeams++;
      }
      else
      {
        
      }

      current = current->next;
    }

  }

  if (numTeams == 0)
  {
    return;
  }
  else
  {
    
  }

  j = 0;
  teamsMoreWins = (char **) malloc((sizeof(char *)) * numTeams);
  for (i = 0; i < mod; i++)
  {
    current = headsT[i];
    while (current != 0)
    {
      if (currentMoreWins == current->team->victories)
      {
        teamsMoreWins[j] = current->team->name;
        j++;
      }
      else
      {
        
      }

      current = current->next;
    }

  }

  qsort(teamsMoreWins, numTeams, sizeof(char *), cmpstr);
  printf("%lu Melhores %d\n", NL, currentMoreWins);
  for (i = 0; i < numTeams; i++)
  {
    if (teamsMoreWins[i] != 0)
    {
      printf("%lu * %s\n", NL, teamsMoreWins[i]);
    }
    else
    {
      
    }

  }

  free(teamsMoreWins);
}

int cmpstr(const void *a, const void *b)
{
  return strcmp(*((char **) a), *((char **) b));
}

