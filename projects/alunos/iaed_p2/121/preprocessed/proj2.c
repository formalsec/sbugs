/*File generated by PreProcessor.py*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "hashMatch.h"
#include "hashTeam.h"
#include "strdup.h"
#include "stack.h"


void addMatch(int commandCounter, linkMatch *HashTableMatch, linkTeam *HashTableTeam, StackNode **headSTACK, StackNode **tailSTACK)
{
  char matchName[1024];
  char team1Name[1024];
  char team2Name[1024];
  unsigned int score1;
  unsigned int score2;
  int indexMatch;
  int indexTeam1;
  int indexTeam2;
  linkMatch listMatch;
  linkMatch head;
  linkTeam list1;
  linkTeam list2;
  linkTeam team1;
  linkTeam team2;
  for (int matchName_index = 0; matchName_index < 10; matchName_index++)
  {
    matchName[matchName_index] = new_sym_var(sizeof(char) * 8);
  }

  matchName[10 - 1] = '\0';
  for (int team1Name_index = 0; team1Name_index < 10; team1Name_index++)
  {
    team1Name[team1Name_index] = new_sym_var(sizeof(char) * 8);
  }

  team1Name[10 - 1] = '\0';
  for (int team2Name_index = 0; team2Name_index < 10; team2Name_index++)
  {
    team2Name[team2Name_index] = new_sym_var(sizeof(char) * 8);
  }

  team2Name[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(unsigned int) * 8);
  score2 = new_sym_var(sizeof(unsigned int) * 8);
  indexMatch = hashFunction(matchName);
  listMatch = HashTableMatch[indexMatch];
  indexTeam1 = hashFunction(team1Name);
  list1 = HashTableTeam[indexTeam1];
  team1 = getTeam(list1, team1Name);
  indexTeam2 = hashFunction(team2Name);
  list2 = HashTableTeam[indexTeam2];
  team2 = getTeam(list2, team2Name);
  if (getMatch(listMatch, matchName) != 0)
  {
    printf("%d Jogo existente.\n", commandCounter);
  }
  else
  {
    if ((team1 == 0) || (team2 == 0))
    {
      printf("%d Equipa inexistente.\n", commandCounter);
    }
    else
    {
      if (listMatch == 0)
      {
        head = 0;
        NewNodeMatch(&head, matchName, team1Name, team2Name, score1, score2);
        HashTableMatch[indexMatch] = head;
        addNode(headSTACK, tailSTACK, matchName);
      }
      else
      {
        head = listMatch;
        NewNodeMatch(&head, matchName, team1Name, team2Name, score1, score2);
        HashTableMatch[indexMatch] = head;
        addNode(headSTACK, tailSTACK, matchName);
      }

      if (whoWonTheGame(score1, score2) == 1)
      {
        team1->teamWins++;
      }
      else
      {
        if (whoWonTheGame(score1, score2) == 2)
        {
          team2->teamWins++;
        }
        else
        {
          
        }

      }

    }

  }

}

void deleteMatch(int commandCounter, linkMatch *HashTableMatch, linkTeam *HashTableTeam, StackNode **headSTACK, StackNode **tailSTACK)
{
  int index;
  int index1;
  int index2;
  int flag = 0;
  char matchName[1024];
  linkMatch list;
  linkMatch temp;
  linkMatch prev;
  linkTeam list1;
  linkTeam team1;
  linkTeam list2;
  linkTeam team2;
  for (int matchName_index = 0; matchName_index < 10; matchName_index++)
  {
    matchName[matchName_index] = new_sym_var(sizeof(char) * 8);
  }

  matchName[10 - 1] = '\0';
  index = hashFunction(matchName);
  list = HashTableMatch[index];
  temp = getMatch(list, matchName);
  if (temp == 0)
  {
    printf("%d Jogo inexistente.\n", commandCounter);
  }
  else
  {
    if (temp->score1 > temp->score2)
    {
      index1 = hashFunction(temp->team1);
      list1 = HashTableTeam[index1];
      team1 = getTeam(list1, temp->team1);
      team1->teamWins--;
    }
    else
    {
      if (temp->score2 > temp->score1)
      {
        index2 = hashFunction(temp->team2);
        list2 = HashTableTeam[index2];
        team2 = getTeam(list2, temp->team2);
        team2->teamWins--;
      }
      else
      {
        
      }

    }

    deleteMatchStack(headSTACK, tailSTACK, matchName);
    if (list->next == 0)
    {
      flag = 1;
    }
    else
    {
      
    }

    for (temp = list, prev = 0; temp != 0; prev = temp, temp = temp->next)
    {
      if (strcmp(matchName, temp->matchName) == 0)
      {
        if (temp == list)
        {
          HashTableMatch[index] = temp->next;
          return;
        }
        else
        {
          prev->next = temp->next;
        }

        FreeNodeMatch(temp);
      }
      else
      {
        
      }

    }

    if (flag == 1)
    {
      HashTableMatch[index] = 0;
    }
    else
    {
      
    }

  }

}

void searchForMatch(int commandCounter, linkMatch *HashTableMatch)
{
  char matchName[1024];
  int index;
  linkMatch list;
  linkMatch temp;
  for (int matchName_index = 0; matchName_index < 10; matchName_index++)
  {
    matchName[matchName_index] = new_sym_var(sizeof(char) * 8);
  }

  matchName[10 - 1] = '\0';
  index = hashFunction(matchName);
  list = HashTableMatch[index];
  temp = getMatch(list, matchName);
  if (temp == 0)
  {
    printf("%d Jogo inexistente.\n", commandCounter);
  }
  else
  {
    printf("%d %s %s %s %u %u\n", commandCounter, matchName, temp->team1, temp->team2, temp->score1, temp->score2);
  }

}

void changeScore(int commandCounter, linkMatch *HashTableMatch, linkTeam *HashTableTeam)
{
  char matchName[1024];
  int index;
  int index1;
  int index2;
  int beforeChanging;
  int afterChanging;
  unsigned int score1;
  unsigned int score2;
  linkMatch list;
  linkMatch temp;
  linkTeam list1;
  linkTeam team1;
  linkTeam list2;
  linkTeam team2;
  for (int matchName_index = 0; matchName_index < 10; matchName_index++)
  {
    matchName[matchName_index] = new_sym_var(sizeof(char) * 8);
  }

  matchName[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(unsigned int) * 8);
  score2 = new_sym_var(sizeof(unsigned int) * 8);
  index = hashFunction(matchName);
  list = HashTableMatch[index];
  temp = getMatch(list, matchName);
  if (temp == 0)
  {
    printf("%d Jogo inexistente.\n", commandCounter);
  }
  else
  {
    beforeChanging = whoWonTheGame(temp->score1, temp->score2);
    afterChanging = whoWonTheGame(score1, score2);
    temp->score1 = score1;
    temp->score2 = score2;
    index1 = hashFunction(temp->team1);
    list1 = HashTableTeam[index1];
    team1 = getTeam(list1, temp->team1);
    index2 = hashFunction(temp->team2);
    list2 = HashTableTeam[index2];
    team2 = getTeam(list2, temp->team2);
    if ((beforeChanging == 0) && (afterChanging != beforeChanging))
    {
      if (afterChanging == 1)
      {
        team1->teamWins++;
      }
      else
      {
        team2->teamWins++;
      }

    }
    else
    {
      if (beforeChanging != afterChanging)
      {
        if (afterChanging == 0)
        {
          if (beforeChanging == 1)
          {
            team1->teamWins--;
          }
          else
          {
            team2->teamWins--;
          }

        }
        else
        {
          if (beforeChanging == 1)
          {
            team1->teamWins--;
            team2->teamWins++;
          }
          else
          {
            team2->teamWins--;
            team1->teamWins++;
          }

        }

      }
      else
      {
        
      }

    }

  }

}

void addTeam(int commandCounter, linkTeam *HashTableTeam)
{
  char teamName[1024];
  int index;
  linkTeam list;
  linkTeam head;
  for (int teamName_index = 0; teamName_index < 10; teamName_index++)
  {
    teamName[teamName_index] = new_sym_var(sizeof(char) * 8);
  }

  teamName[10 - 1] = '\0';
  index = hashFunction(teamName);
  list = HashTableTeam[index];
  if (teamInTable(list, teamName) != (-1))
  {
    printf("%d Equipa existente.\n", commandCounter);
  }
  else
  {
    if (list == 0)
    {
      head = 0;
      NewNodeTeam(&head, teamName);
      HashTableTeam[index] = head;
    }
    else
    {
      head = list;
      NewNodeTeam(&head, teamName);
      HashTableTeam[index] = head;
    }

  }

}

void searchForTeam(int commandCounter, linkTeam *HashTableTeam)
{
  char teamName[1024];
  int index;
  linkTeam list;
  linkTeam temp;
  for (int teamName_index = 0; teamName_index < 10; teamName_index++)
  {
    teamName[teamName_index] = new_sym_var(sizeof(char) * 8);
  }

  teamName[10 - 1] = '\0';
  index = hashFunction(teamName);
  list = HashTableTeam[index];
  temp = getTeam(list, teamName);
  if (temp == 0)
  {
    printf("%d Equipa inexistente.\n", commandCounter);
  }
  else
  {
    printf("%d %s %d\n", commandCounter, temp->teamName, temp->teamWins);
  }

}

void showAllMatches(int commandCounter, linkMatch *HashTableMatch, StackNode **headSTACK)
{
  int index;
  StackNode *temp = *headSTACK;
  linkMatch match;
  linkMatch list;
  while (isStackEmpty(&temp) != 1)
  {
    index = hashFunction(temp->matchName);
    list = HashTableMatch[index];
    match = getMatch(list, temp->matchName);
    printf("%d %s %s %s %u %u\n", commandCounter, match->matchName, match->team1, match->team2, match->score1, match->score2);
    temp = temp->next;
  }

}

void showBestTeams(int commandCounter, linkTeam *HashTableTeam, StackNode **StackTeams)
{
  int i;
  int max = getMaxWins(HashTableTeam);
  linkTeam temp;
  linkTeam list;
  for (i = 0; i < 1087; i++)
  {
    list = HashTableTeam[i];
    temp = list;
    while (temp != 0)
    {
      if (temp->teamWins == max)
      {
        addNodeBegin(StackTeams, temp->teamName);
      }
      else
      {
        
      }

      temp = temp->next;
    }

  }

  if (isStackEmpty(StackTeams) != 1)
  {
    printf("%d Melhores %d\n", commandCounter, max);
    MergeSort(StackTeams);
    printTeams(commandCounter, StackTeams);
  }
  else
  {
    
  }

  DestroyStack(StackTeams);
}

int main()
{
  int commandCounter = 0;
  linkMatch *HashTableMatch = CreateTableMatches();
  linkTeam *HashTableTeam = CreateTableTeams();
  StackNode *StackMatches = 0;
  StackNode *TailMatches = 0;
  StackNode *StackTeams = 0;
  char c;
  do
  {
    switch (c = getchar())
    {
      case 'a':
        ++commandCounter;
        addMatch(commandCounter, HashTableMatch, HashTableTeam, &StackMatches, &TailMatches);
        break;

      case 'l':
        ++commandCounter;
        showAllMatches(commandCounter, HashTableMatch, &StackMatches);
        break;

      case 'p':
        ++commandCounter;
        searchForMatch(commandCounter, HashTableMatch);
        break;

      case 'r':
        ++commandCounter;
        deleteMatch(commandCounter, HashTableMatch, HashTableTeam, &StackMatches, &TailMatches);
        break;

      case 's':
        ++commandCounter;
        changeScore(commandCounter, HashTableMatch, HashTableTeam);
        break;

      case 'A':
        ++commandCounter;
        addTeam(commandCounter, HashTableTeam);
        break;

      case 'P':
        ++commandCounter;
        searchForTeam(commandCounter, HashTableTeam);
        break;

      case 'g':
        ++commandCounter;
        showBestTeams(commandCounter, HashTableTeam, &StackTeams);
        break;

      default:
        break;

    }

  }
  while (c != 'x');
  DestroyHashMatch(HashTableMatch);
  free(HashTableMatch);
  DestroyHashTeam(HashTableTeam);
  free(HashTableTeam);
  DestroyStack(&StackMatches);
  free(StackMatches);
  DestroyStack(&StackTeams);
  free(StackTeams);
  return 0;
}

