#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "equipas.h"
#include "jogos.h"


int hashU(char *v, int m)
{
  int h;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*v) != '\0'; v++, a = (a * b) % (m - 1))
    h = ((a * h) + (*v)) % m;

  return h;
}

char *strdup(const char *palavra)
{
  char *ponteiro;
  ponteiro = malloc(strlen(palavra) + 1);
  if (ponteiro == 0)
  {
    return ponteiro;
  }
  else
  {
    strcpy(ponteiro, palavra);
    return ponteiro;
  }

}

Hash *STinit(int m)
{
  int i;
  link *heads;
  Hash *HashTable = (Hash *) malloc(sizeof(Hash));
  heads = malloc(m * (sizeof(link)));
  for (i = 0; i < m; i++)
    heads[i] = 0;

  HashTable->heads = heads;
  return HashTable;
}

link lookup(link head, char *name)
{
  link t;
  for (t = head; t != 0; t = t->next)
    if (strcmp(t->equipa->name, name) == 0)
  {
    return t;
  }
  else
  {
    
  }


  return 0;
}

link STsearch(Hash *HashTable, char name[], int m)
{
  link *heads;
  int i;
  heads = HashTable->heads;
  i = hashU(name, m);
  return lookup(heads[i], name);
}

equipas NEW(char *buffer)
{
  equipas x;
  x = malloc(sizeof(struct equipas));
  x->name = strdup(buffer);
  x->vitorias = 0;
  return x;
}

link insertBegin(link head, char text[])
{
  link y;
  equipas x;
  y = (struct node *) malloc(sizeof(struct node));
  x = NEW(text);
  if (head == 0)
  {
    y->equipa = x;
    y->next = 0;
    y->previous = 0;
    return y;
  }
  else
  {
    
  }

  y->equipa = x;
  head->previous = y;
  y->next = head;
  y->previous = 0;
  return y;
}

void STinsert(Hash *HashTable, char name[], int m)
{
  link *heads;
  int i;
  heads = HashTable->heads;
  i = hashU(name, m);
  heads[i] = insertBegin(heads[i], name);
}

int comparator(const void *p, const void *q)
{
  struct node *l;
  struct node *r;
  l = *((struct node **) p);
  r = *((struct node **) q);
  return strcmp(l->equipa->name, r->equipa->name);
}

void delete(link head)
{
  link t;
  link t2;
  t = head;
  while (t != 0)
  {
    free(t->equipa->name);
    free(t->equipa);
    t2 = t->next;
    free(t);
    t = t2;
  }

}

void STdelete(Hash *HashTable, int tamanhohash)
{
  link *heads;
  int m = 0;
  heads = HashTable->heads;
  while (m < tamanhohash)
  {
    delete(heads[m]);
    m++;
  }

  free(HashTable->heads);
  free(HashTable);
}

