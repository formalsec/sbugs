#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "equipas.h"
#include "jogos.h"


Hash_Jogo *STinit_jogos(int m)
{
  int i;
  Hash_Jogo *HashTable = (Hash_Jogo *) malloc(sizeof(Hash_Jogo));
  linkjogo *heads;
  heads = malloc(m * (sizeof(linkjogo)));
  for (i = 0; i < m; i++)
    heads[i] = 0;

  HashTable->heads = heads;
  return HashTable;
}

linkjogo lookup_jogo(linkjogo head, char *name)
{
  linkjogo t;
  for (t = head; t != 0; t = t->nextHash)
  {
    if (strcmp(t->jogo->name, name) == 0)
    {
      return t;
    }
    else
    {
      
    }

  }

  return 0;
}

linkjogo STsearch_jogo(Hash_Jogo *HashTable, char name[], int m)
{
  linkjogo *heads;
  int i;
  heads = HashTable->heads;
  i = hashU(name, m);
  return lookup_jogo(heads[i], name);
}

jogo NEW_jogo(Hash *HashTable, char *buffer, char equipa1[], char equipa2[], int score1, int score2, int m)
{
  link s;
  link t;
  jogo x;
  x = malloc(sizeof(struct jogo));
  x->name = strdup(buffer);
  t = STsearch(HashTable, equipa1, m);
  x->equipa1 = t->equipa;
  s = STsearch(HashTable, equipa2, m);
  x->equipa2 = s->equipa;
  x->score1 = score1;
  x->score2 = score2;
  return x;
}

linkjogo insertBegin_jogo(Hash *HashTable, linkjogo head, char name[], char equipa1[], char equipa2[], int score1, int score2, int m)
{
  linkjogo y;
  jogo x;
  y = (struct nodejogo *) malloc(sizeof(struct nodejogo));
  x = NEW_jogo(HashTable, name, equipa1, equipa2, score1, score2, m);
  if (head == 0)
  {
    y->jogo = x;
    y->nextHash = 0;
    y->previousHash = 0;
    return y;
  }
  else
  {
    
  }

  y->jogo = x;
  head->previousHash = y;
  y->nextHash = head;
  y->previousHash = 0;
  return y;
}

void STinsert_jogo(Hash *HashTable, Hash_Jogo *HashTablejogo, char name[], char equipa1[], char equipa2[], int score1, int score2, int m, int m_jogo)
{
  linkjogo *heads;
  int i;
  heads = HashTablejogo->heads;
  i = hashU(name, m_jogo);
  heads[i] = insertBegin_jogo(HashTable, heads[i], name, equipa1, equipa2, score1, score2, m);
}

list *STinit_Lista_ordenada()
{
  list *lst;
  lst = (list *) malloc(sizeof(list));
  lst->head = 0;
  lst->tail = 0;
  return lst;
}

void add_last(list *lista, char name[], Hash_Jogo *HashTable, int m)
{
  linkordenado *lst;
  linkjogo t;
  linkordenado *antiga_tail;
  lst = (linkordenado *) malloc(sizeof(linkordenado));
  t = STsearch_jogo(HashTable, name, m);
  lst->nextLista = 0;
  lst->previouslista = 0;
  lst->jogo = t->jogo;
  if (lista->head == 0)
  {
    lista->head = lst;
    lista->tail = lst;
  }
  else
  {
    antiga_tail = lista->tail;
    antiga_tail->nextLista = lst;
    lst->previouslista = antiga_tail;
    lista->tail = lst;
  }

}

void free_lista(list *lst)
{
  linkordenado *head;
  linkordenado *next;
  for (head = lst->head; head != 0;)
  {
    next = head->nextLista;
    free(head);
    head = next;
  }

  free(lst);
}

void procurar_ordenado(list *ponteiro_lista_unica, linkjogo linkjogo)
{
  linkordenado *y;
  linkordenado *yantes;
  linkordenado *ydepois;
  y = ponteiro_lista_unica->head;
  while (strcmp(y->jogo->name, linkjogo->jogo->name) != 0)
  {
    y = y->nextLista;
  }

  if ((y->previouslista == 0) && (y->nextLista != 0))
  {
    ydepois = y->nextLista;
    ydepois->previouslista = 0;
    ponteiro_lista_unica->head = ydepois;
  }
  else
  {
    if ((y->previouslista != 0) && (y->nextLista == 0))
    {
      yantes = y->previouslista;
      yantes->nextLista = 0;
      ponteiro_lista_unica->tail = yantes;
    }
    else
    {
      if ((y->previouslista == 0) && (y->nextLista == 0))
      {
        ponteiro_lista_unica->head = 0;
        ponteiro_lista_unica->tail = 0;
      }
      else
      {
        yantes = y->previouslista;
        ydepois = y->nextLista;
        yantes->nextLista = ydepois;
        ydepois->previouslista = yantes;
      }

    }

  }

  free(y);
}

void deletejogos(linkjogo head)
{
  linkjogo t;
  linkjogo t2;
  t = head;
  while (t != 0)
  {
    free(t->jogo->name);
    free(t->jogo);
    t2 = t->nextHash;
    free(t);
    t = t2;
  }

}

void STdeletejogos(Hash_Jogo *HashTable, int tamanhohash)
{
  linkjogo *heads;
  int m = 0;
  heads = HashTable->heads;
  while (m < tamanhohash)
  {
    deletejogos(heads[m]);
    m++;
  }

  free(HashTable->heads);
  free(HashTable);
}

