#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "hashtable.h"


int hash(char *s, int m)
{
  int h = 0;
  int a = 127;
  for (; (*s) != '\0'; s++)
    h = ((a * h) + (*s)) % m;

  return h;
}

tnode **init_teams(tnode **teams_tab)
{
  int i;
  teams_tab = malloc(911 * (sizeof(tnode)));
  for (i = 0; i < 911; i++)
    teams_tab[i] = 0;

  return teams_tab;
}

void destroy_teams(tnode **teams_tab)
{
  int i;
  for (i = 0; i < 911; i++)
    destroy_tnode(teams_tab[i]);

  free(teams_tab);
}

void table_insert_team(tnode **teams_tab, team *t)
{
  int i;
  i = hash(t->name, 911);
  teams_tab[i] = insert_team_begin(teams_tab[i], t);
}

team *table_search_team(tnode **teams_tab, char *name)
{
  int i;
  i = hash(name, 911);
  return lookup_team(teams_tab[i], name);
}

team *new_team(char *name)
{
  team *t = malloc(sizeof(team));
  t->name = strdup(name);
  t->wins = 0;
  return t;
}

tnode *insert_team_begin(tnode *head, team *t)
{
  tnode *new = malloc(sizeof(tnode));
  new->t = t;
  new->next = head;
  return new;
}

team *lookup_team(tnode *head, char *name)
{
  tnode *tmp;
  for (tmp = head; tmp != 0; tmp = tmp->next)
    if (strcmp(tmp->t->name, name) == 0)
  {
    return tmp->t;
  }
  else
  {
    
  }


  return 0;
}

tnode *destroy_tnode(tnode *head)
{
  tnode *tmp;
  while (head != 0)
  {
    tmp = head->next;
    free_tnode(head);
    head = tmp;
  }

  return head;
}

void free_tnode(tnode *n)
{
  free(n->t->name);
  free(n->t);
  free(n);
}

int table_search_higher(tnode **teams_tab)
{
  int i;
  int higher = -1;
  for (i = 0; i < 911; i++)
    higher = lookup_higher(teams_tab[i], higher);

  return higher;
}

int lookup_higher(tnode *head, int higher)
{
  tnode *tmp;
  for (tmp = head; tmp != 0; tmp = tmp->next)
    if (tmp->t->wins > higher)
  {
    higher = tmp->t->wins;
  }
  else
  {
    
  }


  return higher;
}

tnode *table_search_top_teams(tnode **teams_tab, tnode *top_teams, int higher)
{
  int i;
  for (i = 0; i < 911; i++)
    top_teams = lookup_top_team(teams_tab[i], top_teams, higher);

  return top_teams;
}

tnode *lookup_top_team(tnode *head, tnode *top_teams, int higher)
{
  tnode *tmp;
  for (tmp = head; tmp != 0; tmp = tmp->next)
    if (tmp->t->wins == higher)
  {
    top_teams = insert_team_sorted(top_teams, tmp->t);
  }
  else
  {
    
  }


  return top_teams;
}

tnode *insert_team_sorted(tnode *top_teams, team *t)
{
  tnode *tmp;
  tnode *next;
  tnode *new = malloc(sizeof(tnode));
  if ((top_teams == 0) || (strcmp(top_teams->t->name, t->name) < 0))
  {
    new->t = t;
    new->next = top_teams;
    return new;
  }
  else
  {
    
  }

  for (tmp = top_teams, next = tmp->next; next != 0; tmp = tmp->next, next = tmp->next)
  {
    if ((strcmp(tmp->t->name, t->name) > 0) && (strcmp(next->t->name, t->name) < 0))
    {
      break;
    }
    else
    {
      
    }

  }

  new->t = t;
  tmp->next = new;
  new->next = next;
  return top_teams;
}

tnode *destroy_teams_list(tnode *head)
{
  tnode *tmp;
  while (head != 0)
  {
    tmp = head->next;
    free(head);
    head = tmp;
  }

  return head;
}

gnode **init_games(gnode **games_tab)
{
  int i;
  games_tab = malloc(911 * (sizeof(gnode)));
  for (i = 0; i < 911; i++)
    games_tab[i] = 0;

  return games_tab;
}

void destroy_games(gnode **games_tab)
{
  int i;
  for (i = 0; i < 911; i++)
    destroy_gnode(games_tab[i]);

  free(games_tab);
}

void table_insert_game(gnode **games_tab, game *g)
{
  int i;
  i = hash(g->name, 911);
  games_tab[i] = insert_game_begin(games_tab[i], g);
}

void table_delete_game(gnode **games_tab, char *name)
{
  int i;
  i = hash(name, 911);
  games_tab[i] = delete_game(games_tab[i], name);
}

game *table_search_game(gnode **games_tab, char *name)
{
  int i;
  i = hash(name, 911);
  return lookup_game(games_tab[i], name);
}

game *new_game(char *name, char *team1, char *team2, int score1, int score2)
{
  game *g = malloc(sizeof(game));
  g->name = strdup(name);
  g->t1 = strdup(team1);
  g->t2 = strdup(team2);
  g->score1 = score1;
  g->score2 = score2;
  return g;
}

gnode *insert_game_begin(gnode *head, game *g)
{
  gnode *new = malloc(sizeof(gnode));
  new->g = g;
  new->next = head;
  return new;
}

gnode *delete_game(gnode *head, char *name)
{
  gnode *tmp;
  gnode *prev;
  for (tmp = head, prev = 0; tmp != 0; prev = tmp, tmp = tmp->next)
  {
    if (!strcmp(tmp->g->name, name))
    {
      if (tmp == head)
      {
        head = tmp->next;
      }
      else
      {
        prev->next = tmp->next;
      }

      free(tmp);
      break;
    }
    else
    {
      
    }

  }

  return head;
}

game *lookup_game(gnode *head, char *name)
{
  gnode *tmp;
  for (tmp = head; tmp != 0; tmp = tmp->next)
    if (!strcmp(tmp->g->name, name))
  {
    return tmp->g;
  }
  else
  {
    
  }


  return 0;
}

gnode *destroy_gnode(gnode *head)
{
  gnode *tmp;
  while (head != 0)
  {
    tmp = head->next;
    free(head);
    head = tmp;
  }

  return head;
}

gnode *del_from_glist(gnode *head, char *name)
{
  gnode *tmp;
  gnode *prev;
  for (tmp = head, prev = 0; tmp != 0; prev = tmp, tmp = tmp->next)
  {
    if (!strcmp(tmp->g->name, name))
    {
      if (tmp == head)
      {
        head = tmp->next;
      }
      else
      {
        prev->next = tmp->next;
      }

      free_gnode(tmp);
      return head;
    }
    else
    {
      
    }

  }

  return head;
}

gnode *destroy_games_list(gnode *games_list)
{
  gnode *tmp;
  while (games_list != 0)
  {
    tmp = games_list->next;
    free_gnode(games_list);
    games_list = tmp;
  }

  return 0;
}

void free_gnode(gnode *n)
{
  free(n->g->name);
  free(n->g->t1);
  free(n->g->t2);
  free(n->g);
  free(n);
}

