#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "jogos.h"


Jogo newJogo(char *nome, char *e1, char *e2, int s1, int s2, ulong *ordem, link *hashEquipas)
{
  Jogo final = malloc(sizeof(struct jogo));
  final->e1 = newPar(e1, s1, hashEquipas);
  final->e2 = newPar(e2, s2, hashEquipas);
  final->nome = malloc((sizeof(char *)) * (strlen(nome) + 1));
  strcpy(final->nome, nome);
  final->ordem = *ordem;
  if (s1 > s2)
  {
    final->e1->equipa->ganhos += 1;
  }
  else
  {
    if (s2 > s1)
    {
      final->e2->equipa->ganhos += 1;
    }
    else
    {
      
    }

  }

  return final;
}

Par newPar(char *equipa, int pontos, link *hashEquipas)
{
  Par final = malloc(sizeof(struct par));
  final->equipa = EhashSearch(hashEquipas, equipa);
  final->pontos = pontos;
  return final;
}

jlink JinsertBegin(jlink head, Jogo jogo)
{
  jlink new;
  new = malloc(sizeof(struct jnode));
  new->jogo = jogo;
  new->next = head;
  return new;
}

Jogo JsearchList(jlink head, char *nome)
{
  jlink p;
  for (p = head; p != 0; p = p->next)
  {
    if (strcmp(nome, p->jogo->nome) == 0)
    {
      return p->jogo;
    }
    else
    {
      
    }

  }

  return 0;
}

void freeJogo(Jogo jogo)
{
  free(jogo->e1);
  free(jogo->e2);
  free(jogo->nome);
  free(jogo);
}

void freeJNode(jlink link)
{
  freeJogo(link->jogo);
  free(link);
}

jlink removeJogo(jlink head, char *nome)
{
  jlink t;
  jlink prev;
  for (prev = 0, t = head; t != 0; prev = t, t = t->next)
  {
    if (strcmp(t->jogo->nome, nome) == 0)
    {
      if (t == head)
      {
        head = t->next;
      }
      else
      {
        if (t != head)
        {
          prev->next = t->next;
        }
        else
        {
          
        }

      }

      if (t->jogo->e1->pontos > t->jogo->e2->pontos)
      {
        t->jogo->e1->equipa->ganhos -= 1;
      }
      else
      {
        if (t->jogo->e1->pontos < t->jogo->e2->pontos)
        {
          t->jogo->e2->equipa->ganhos -= 1;
        }
        else
        {
          
        }

      }

      freeJNode(t);
      break;
    }
    else
    {
      
    }

  }

  return head;
}

jlink *JhashInit()
{
  int i;
  jlink *heads = malloc(2269 * (sizeof(jlink)));
  for (i = 0; i < 2269; i++)
  {
    heads[i] = 0;
  }

  return heads;
}

Jogo JhashSearch(jlink *heads, char *nome)
{
  int i = hash(nome);
  return JsearchList(heads[i], nome);
}

jlink *JhashInsert(jlink *heads, Jogo jogo)
{
  int i = hash(jogo->nome);
  heads[i] = JinsertBegin(heads[i], jogo);
  return heads;
}

jlink *JhashDelete(jlink *heads, char *nome)
{
  int i = hash(nome);
  heads[i] = removeJogo(heads[i], nome);
  return heads;
}

void freeJList(jlink head)
{
  jlink aux;
  while (head != 0)
  {
    aux = head;
    head = head->next;
    freeJNode(aux);
  }

}

void JfreeHash(jlink *heads)
{
  int i;
  for (i = 0; i < 2269; i++)
  {
    freeJList(heads[i]);
  }

  free(heads);
}

Jogo *listaOrdenada(jlink *hashJogos, ulong *size)
{
  int i;
  jlink t;
  Jogo *lista;
  lista = 0;
  for (i = 0; i < 2269; i++)
  {
    for (t = hashJogos[i]; t != 0; t = t->next)
    {
      *size += 1;
      lista = realloc(lista, (sizeof(Jogo)) * (*size));
      lista[(*size) - 1] = t->jogo;
    }

  }

  qsort(lista, *size, sizeof(Jogo), Jcmp);
  return lista;
}

int Jcmp(const void *a, const void *b)
{
  Jogo j1;
  Jogo j2;
  j1 = *((Jogo *) a);
  j2 = *((Jogo *) b);
  return j1->ordem - j2->ordem;
}

