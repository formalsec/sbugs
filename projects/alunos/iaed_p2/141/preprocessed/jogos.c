#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "jogos.h" 


void imprime_jogo(Jogo jogo)
{
  if (jogo != 0)
  {
    printf("%s %s %s %d %d\n", jogo->nome, jogo->equipa1->nome, jogo->equipa2->nome, jogo->score1, jogo->score2);
  }
  else
  {
    
  }

}

Lista criaLista()
{
  Lista new = malloc(sizeof(struct lista));
  new->primeiro = 0;
  new->ult = 0;
  return new;
}

void insereLista(Lista l, char *c)
{
  Node new = malloc(sizeof(struct node));
  new->c = c;
  new->prox = 0;
  if (l->primeiro == 0)
  {
    l->primeiro = new;
    l->ult = new;
  }
  else
  {
    l->ult->prox = new;
    l->ult = new;
  }

}

void apagaLista(Lista l, char *c)
{
  Node atual = l->primeiro;
  Node aux;
  if (strcmp(atual->c, c) == 0)
  {
    if (atual->prox == 0)
    {
      l->ult = 0;
      l->primeiro = 0;
      free(atual);
      return;
    }
    else
    {
      l->primeiro = l->primeiro->prox;
      free(atual);
      return;
    }

  }
  else
  {
    
  }

  while (atual->prox != 0)
  {
    if (strcmp(atual->prox->c, c) == 0)
    {
      aux = atual->prox;
      atual->prox = atual->prox->prox;
      if (atual->prox == 0)
      {
        l->ult = atual;
      }
      else
      {
        
      }

      free(aux);
      return;
    }
    else
    {
      
    }

    atual = atual->prox;
  }

}

void freeLista(Lista l)
{
  Node aux = l->primeiro;
  while (aux != 0)
  {
    l->primeiro = l->primeiro->prox;
    free(aux->c);
    free(aux);
    aux = l->primeiro;
  }

  free(l);
}

int hash_j(Chave_Jogos k, int M)
{
  int h = 0;
  int a = 127;
  for (; (*k) != '\0'; k++)
    h = ((a * h) + (*k)) % M;

  return h;
}

Hashtable_j inicializaHT_j(int max)
{
  Hashtable_j ht = malloc(sizeof(struct hashtable_j));
  Jogo *tab = malloc(max * (sizeof(Jogo)));
  int i;
  ht->N = 0;
  ht->M = max;
  for (i = 0; i < ht->M; i++)
    tab[i] = 0;

  ht->tabela = tab;
  return ht;
}

void insereHT_j(Hashtable_j ht, Jogo jogo)
{
  Chave_Jogos k = jogo->nome;
  int i = hash_j(k, ht->M);
  Jogo *tab = ht->tabela;
  while (tab[i] != 0)
    i = (i + 1) % ht->M;

  tab[i] = jogo;
  if ((ht->N++) > (ht->M / 2))
  {
    expandeHT_j(ht);
  }
  else
  {
    
  }

}

void expandeHT_j(Hashtable_j ht)
{
  int i;
  int tam_ant = ht->M;
  Jogo *aux = ht->tabela;
  int novo_tam = prox_primo(ht->M + ht->M);
  Jogo *tab = malloc(novo_tam * (sizeof(Jogo)));
  for (i = 0; i < novo_tam; i++)
    tab[i] = 0;

  ht->tabela = tab;
  ht->M = novo_tam;
  ht->N = 0;
  for (i = 0; i < tam_ant; i++)
    if (aux[i] != 0)
  {
    insereHT_j(ht, aux[i]);
  }
  else
  {
    
  }


  free(aux);
}

Jogo procuraHT_j(Hashtable_j ht, Chave_Jogos k)
{
  int i = hash_j(k, ht->M);
  Jogo *tab = ht->tabela;
  while (tab[i] != 0)
  {
    if (strcmp(k, tab[i]->nome) == 0)
    {
      return tab[i];
    }
    else
    {
      i = (i + 1) % ht->M;
    }

  }

  return 0;
}

void apagaHT_j(Hashtable_j ht, Chave_Jogos k)
{
  int j;
  int i = hash_j(k, ht->M);
  Jogo *tab = ht->tabela;
  Jogo aux;
  while (tab[i] != 0)
    if (strcmp(k, tab[i]->nome) == 0)
  {
    break;
  }
  else
  {
    i = (i + 1) % ht->M;
  }


  if (tab[i] == 0)
  {
    return;
  }
  else
  {
    
  }

  ht->N--;
  free(tab[i]->nome);
  free(tab[i]);
  tab[i] = 0;
  for (j = (i + 1) % ht->M; tab[j] != 0; j = (j + 1) % ht->M)
  {
    aux = tab[j];
    tab[j] = 0;
    insereHT_j(ht, aux);
    ht->N--;
  }

}

void freeHT_j(Hashtable_j ht)
{
  int i = 0;
  Jogo *tab = ht->tabela;
  while (i < ht->M)
  {
    free(tab[i]);
    i++;
  }

  free(tab);
  free(ht);
}

