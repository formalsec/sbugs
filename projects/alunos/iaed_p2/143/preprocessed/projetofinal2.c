/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "hash.h"


Hash_Jogos *add_novo_jogo(int NL, Hash_Jogos *hash_j, Hash_Equipa *hash_e, equipa *e);
void todos_jogos(int NL, Hash_Jogos *J, jogo *j);
void procura_jogo(int NL, Hash_Jogos *J, jogo *j);
void apaga_jogo(int NL, Hash_Jogos *J, jogo *j);
void altera_score(int NL, Hash_Jogos *J, jogo *j);
Hash_Equipa *add_nova_equipa(int NL, Hash_Equipa *hash);
void procura_equipa(int NL, Hash_Equipa *E, equipa *e);
void equipas_ganharam_mais_jogos(int NL, Hash_Equipa *E, equipa *e);
void quicksort(jogo *J, int first, int last);
int compara(const void *a, const void *b);
int main()
{
  int NL = 1;
  char ch_main;
  Hash_Equipa *Equipas;
  Hash_Jogos *Jogos;
  Equipas = (Hash_Equipa *) malloc(sizeof(Hash_Equipa));
  Equipas->tam_hash = 11;
  Equipas->equipas = Equipa_init(Equipas->tam_hash, &Equipas->tam_hash, Equipas->equipas);
  Equipas->n_equipas = 0;
  Jogos = (Hash_Jogos *) malloc(sizeof(Hash_Jogos));
  Jogos->tam_hash = 11;
  Jogos->jogos = Jogo_init(Jogos->tam_hash, &Jogos->tam_hash, Jogos->jogos);
  Jogos->n_jogos = 0;
  Jogos->numero_jogos = 0;
  while ((ch_main = getchar()) != EOF)
  {
    switch (ch_main)
    {
      case 'a':
        Jogos = add_novo_jogo(NL, Jogos, Equipas, Equipas->equipas);
        NL++;
        break;

      case 'l':
        todos_jogos(NL, Jogos, Jogos->jogos);
        NL++;
        break;

      case 'p':
        procura_jogo(NL, Jogos, Jogos->jogos);
        NL++;
        break;

      case 'r':
        apaga_jogo(NL, Jogos, Jogos->jogos);
        NL++;
        break;

      case 's':
        altera_score(NL, Jogos, Jogos->jogos);
        NL++;
        break;

      case 'A':
        Equipas = add_nova_equipa(NL, Equipas);
        NL++;
        break;

      case 'P':
        procura_equipa(NL, Equipas, Equipas->equipas);
        NL++;
        break;

      case 'g':
        equipas_ganharam_mais_jogos(NL, Equipas, Equipas->equipas);
        NL++;
        break;

      case 'x':
        Equipa_FREE(Equipas->tam_hash, Equipas->equipas);
        Jogo_FREE(Jogos->tam_hash, Jogos->jogos);
        free(Equipas);
        free(Jogos);
        return 0;

    }

  }

  return 0;
}

Hash_Equipa *add_nova_equipa(int NL, Hash_Equipa *hash)
{
  char nome_equipa[1024];
  equipa p;
  for (int nome_equipa_index = 0; nome_equipa_index < 10; nome_equipa_index++)
  {
    nome_equipa[nome_equipa_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_equipa[10 - 1] = '\0';
  if (Equipa_search(hash->tam_hash, nome_equipa, hash->equipas) == 0)
  {
    p = (equipa) malloc(sizeof(struct Equipa));
    p->nome = (char *) malloc((sizeof(char)) * (strlen(nome_equipa) + 1));
    strcpy(p->nome, nome_equipa);
    p->n_vitorias = 0;
    Equipa_insert(hash->tam_hash, hash->equipas, p);
    hash->n_equipas++;
    if (hash->n_equipas == (hash->tam_hash / 2))
    {
      hash->equipas = Equipa_expand(&hash->tam_hash, hash->equipas);
    }
    else
    {
      
    }

  }
  else
  {
    printf("%d Equipa existente.\n", NL);
  }

  return hash;
}

void procura_equipa(int NL, Hash_Equipa *E, equipa *e)
{
  char nome_equipa[1024];
  equipa e1;
  for (int nome_equipa_index = 0; nome_equipa_index < 10; nome_equipa_index++)
  {
    nome_equipa[nome_equipa_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_equipa[10 - 1] = '\0';
  e1 = Equipa_search(E->tam_hash, nome_equipa, e);
  if (e1 != 0)
  {
    printf("%d %s %d\n", NL, e1->nome, e1->n_vitorias);
    return;
  }
  else
  {
    
  }

  printf("%d Equipa inexistente.\n", NL);
}

Hash_Jogos *add_novo_jogo(int NL, Hash_Jogos *hash_j, Hash_Equipa *hash_e, equipa *e)
{
  char nome_jogo[1024];
  char equipa1[1024];
  char equipa2[1024];
  int score1;
  int score2;
  jogo p;
  equipa e1;
  equipa e2;
  for (int nome_jogo_index = 0; nome_jogo_index < 10; nome_jogo_index++)
  {
    nome_jogo[nome_jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_jogo[10 - 1] = '\0';
  for (int equipa1_index = 0; equipa1_index < 10; equipa1_index++)
  {
    equipa1[equipa1_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa1[10 - 1] = '\0';
  for (int equipa2_index = 0; equipa2_index < 10; equipa2_index++)
  {
    equipa2[equipa2_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  if (Jogo_search(hash_j->tam_hash, nome_jogo, hash_j->jogos) == 0)
  {
    e1 = Equipa_search(hash_e->tam_hash, equipa1, e);
    e2 = Equipa_search(hash_e->tam_hash, equipa2, e);
    if ((e1 != 0) && (e2 != 0))
    {
      p = (jogo) malloc(sizeof(struct Jogo));
      p->nome = (char *) malloc((sizeof(char)) * (strlen(nome_jogo) + 1));
      strcpy(p->nome, nome_jogo);
      p->equipa1 = e1;
      p->equipa2 = e2;
      p->ordem_input = hash_j->n_jogos;
      p->score_equipa1 = score1;
      p->score_equipa2 = score2;
      if (score1 > score2)
      {
        e1->n_vitorias++;
      }
      else
      {
        if (score1 < score2)
        {
          e2->n_vitorias++;
        }
        else
        {
          
        }

      }

      Jogo_insert(hash_j->tam_hash, hash_j->jogos, p);
      hash_j->n_jogos++;
      hash_j->numero_jogos++;
      if (hash_j->n_jogos == (hash_j->tam_hash / 2))
      {
        hash_j->jogos = Jogo_expand(&hash_j->tam_hash, hash_j->jogos);
      }
      else
      {
        
      }

    }
    else
    {
      printf("%d Equipa inexistente.\n", NL);
    }

  }
  else
  {
    printf("%d Jogo existente.\n", NL);
  }

  return hash_j;
}

void todos_jogos(int NL, Hash_Jogos *J, jogo *j)
{
  unsigned int i;
  unsigned int s = 0;
  int x;
  jogo *v_jogos;
  v_jogos = (jogo *) malloc((sizeof(jogo)) * J->numero_jogos);
  for (i = 0; i < J->tam_hash; i++)
  {
    if (j[i] != 0)
    {
      v_jogos[s] = j[i];
      s++;
    }
    else
    {
      
    }

  }

  quicksort(v_jogos, 0, J->numero_jogos - 1);
  for (x = 0; x < J->numero_jogos; x++)
  {
    printf("%d %s %s %s %d %d\n", NL, v_jogos[x]->nome, v_jogos[x]->equipa1->nome, v_jogos[x]->equipa2->nome, v_jogos[x]->score_equipa1, v_jogos[x]->score_equipa2);
  }

  free(v_jogos);
}

void quicksort(jogo *J, int first, int last)
{
  int i;
  int j;
  int pivot;
  jogo temp;
  if (first < last)
  {
    pivot = first;
    i = first;
    j = last;
    while (i < j)
    {
      while ((J[i]->ordem_input <= J[pivot]->ordem_input) && (i < last))
        i++;

      while (J[j]->ordem_input > J[pivot]->ordem_input)
        j--;

      if (i < j)
      {
        temp = J[i];
        J[i] = J[j];
        J[j] = temp;
      }
      else
      {
        
      }

    }

    temp = J[pivot];
    J[pivot] = J[j];
    J[j] = temp;
    quicksort(J, first, j - 1);
    quicksort(J, j + 1, last);
  }
  else
  {
    
  }

}

void procura_jogo(int NL, Hash_Jogos *J, jogo *j)
{
  char nome_jogo[1024];
  jogo j1;
  for (int nome_jogo_index = 0; nome_jogo_index < 10; nome_jogo_index++)
  {
    nome_jogo[nome_jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_jogo[10 - 1] = '\0';
  j1 = Jogo_search(J->tam_hash, nome_jogo, j);
  if (j1 != 0)
  {
    printf("%d %s %s %s %d %d\n", NL, j1->nome, j1->equipa1->nome, j1->equipa2->nome, j1->score_equipa1, j1->score_equipa2);
    return;
  }
  else
  {
    
  }

  printf("%d Jogo inexistente.\n", NL);
}

void apaga_jogo(int NL, Hash_Jogos *J, jogo *j)
{
  char nome_jogo[1024];
  jogo p;
  for (int nome_jogo_index = 0; nome_jogo_index < 10; nome_jogo_index++)
  {
    nome_jogo[nome_jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_jogo[10 - 1] = '\0';
  p = Jogo_search(J->tam_hash, nome_jogo, j);
  if (p != 0)
  {
    if (p->score_equipa1 > p->score_equipa2)
    {
      p->equipa1->n_vitorias--;
      Jogo_delete(J->tam_hash, nome_jogo, j);
      J->numero_jogos--;
    }
    else
    {
      if (p->score_equipa1 < p->score_equipa2)
      {
        p->equipa2->n_vitorias--;
        Jogo_delete(J->tam_hash, nome_jogo, j);
        J->numero_jogos--;
      }
      else
      {
        Jogo_delete(J->tam_hash, nome_jogo, j);
        J->numero_jogos--;
      }

    }

    return;
  }
  else
  {
    
  }

  printf("%d Jogo inexistente.\n", NL);
}

void altera_score(int NL, Hash_Jogos *J, jogo *j)
{
  char nome_jogo[1024];
  int score1;
  int score2;
  jogo jogo;
  for (int nome_jogo_index = 0; nome_jogo_index < 10; nome_jogo_index++)
  {
    nome_jogo[nome_jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  nome_jogo[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  jogo = Jogo_search(J->tam_hash, nome_jogo, j);
  if (jogo != 0)
  {
    if (jogo->score_equipa1 > jogo->score_equipa2)
    {
      if (score1 < score2)
      {
        jogo->equipa2->n_vitorias++;
        jogo->equipa1->n_vitorias--;
      }
      else
      {
        if (score1 == score2)
        {
          jogo->equipa1->n_vitorias--;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (jogo->score_equipa1 < jogo->score_equipa2)
      {
        if (score1 > score2)
        {
          jogo->equipa1->n_vitorias++;
          jogo->equipa2->n_vitorias--;
        }
        else
        {
          if (score1 == score2)
          {
            jogo->equipa2->n_vitorias--;
          }
          else
          {
            
          }

        }

      }
      else
      {
        if (jogo->score_equipa1 == jogo->score_equipa2)
        {
          if (score1 < score2)
          {
            jogo->equipa2->n_vitorias++;
          }
          else
          {
            
          }

          if (score1 > score2)
          {
            jogo->equipa1->n_vitorias++;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }

    }

    jogo->score_equipa1 = score1;
    jogo->score_equipa2 = score2;
    return;
  }
  else
  {
    
  }

  printf("%d Jogo inexistente.\n", NL);
}

void equipas_ganharam_mais_jogos(int NL, Hash_Equipa *E, equipa *e)
{
  unsigned int i;
  unsigned int x;
  int s = 0;
  int t = 0;
  int max_vitorias = 0;
  char **vetor_strings;
  if (E->n_equipas == 0)
  {
    return;
  }
  else
  {
    
  }

  for (x = 0; x < E->tam_hash; x++)
  {
    if (e[x])
    {
      if (e[x]->n_vitorias > max_vitorias)
      {
        s = 0;
        max_vitorias = e[x]->n_vitorias;
      }
      else
      {
        
      }

      if (e[x]->n_vitorias == max_vitorias)
      {
        s++;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  vetor_strings = (char **) malloc((sizeof(char *)) * s);
  for (i = 0; i < E->tam_hash; i++)
  {
    if (e[i])
    {
      if (e[i]->n_vitorias == max_vitorias)
      {
        vetor_strings[t] = (char *) malloc(((sizeof(char)) * strlen(e[i]->nome)) + 1);
        strcpy(vetor_strings[t], e[i]->nome);
        t++;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  qsort(vetor_strings, s, sizeof(char *), compara);
  printf("%d Melhores %d\n", NL, max_vitorias);
  for (t = 0; t < s; t++)
  {
    printf("%d * %s\n", NL, vetor_strings[t]);
  }

  for (t = 0; t < s; t++)
  {
    free(vetor_strings[t]);
  }

  free(vetor_strings);
}

int compara(const void *a, const void *b)
{
  int i;
  const char **ia = (const char **) a;
  const char **ib = (const char **) b;
  i = strcmp(*ia, *ib);
  return i;
}

