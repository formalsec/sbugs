#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "btgame.h"


BTGame *newBTGameNode(Game *game, BTGame *left, BTGame *right)
{
  BTGame *node = (BTGame *) malloc(sizeof(BTGame));
  node->game = game;
  node->left = left;
  node->right = right;
  node->height = 1;
  return node;
}

void freeBTGameNode(BTGame *node)
{
  free(node);
}

BTGame *newBTGame()
{
  return 0;
}

void freeBTGame(BTGame *node)
{
  if (node != 0)
  {
    freeBTGame(node->left);
    freeBTGame(node->right);
    freeGame(node->game);
    freeBTGameNode(node);
  }
  else
  {
    
  }

}

int countBTGame(BTGame *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return (1 + countBTGame(node->left)) + countBTGame(node->right);
}

Game *searchBTGame(BTGame *node, char *name)
{
  int cmp;
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  cmp = gameKeyOrder(name, node->game);
  if (cmp == 0)
  {
    return node->game;
  }
  else
  {
    if (cmp < 0)
    {
      return searchBTGame(node->left, name);
    }
    else
    {
      return searchBTGame(node->right, name);
    }

  }

}

int existsBTGame(BTGame *node, char *name)
{
  return searchBTGame(node, name) != 0;
}

int heightBBGame(BTGame *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return node->height;
}

BTGame *rotLBTGame(BTGame *node)
{
  int hleft;
  int hright;
  int xleft;
  int xright;
  BTGame *x = node->right;
  node->right = x->left;
  x->left = node;
  hleft = heightBBGame(node->left);
  hright = heightBBGame(node->right);
  node->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
  xleft = heightBBGame(x->left);
  xright = heightBBGame(x->right);
  x->height = (xleft > xright) ? (xleft + 1) : (xright + 1);
  return x;
}

BTGame *rotRBTGame(BTGame *node)
{
  int hleft;
  int hright;
  int xleft;
  int xright;
  BTGame *x = node->left;
  node->left = x->right;
  x->right = node;
  hleft = heightBBGame(node->left);
  hright = heightBBGame(node->right);
  node->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
  xleft = heightBBGame(x->left);
  xright = heightBBGame(x->right);
  x->height = (xleft > xright) ? (xleft + 1) : (xright + 1);
  return x;
}

BTGame *rotLRBTGame(BTGame *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  node->left = rotLBTGame(node->left);
  return rotRBTGame(node);
}

BTGame *rotRLBTGame(BTGame *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  node->right = rotRBTGame(node->right);
  return rotLBTGame(node);
}

int balanceBBGame(BTGame *node)
{
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return heightBBGame(node->left) - heightBBGame(node->right);
}

BTGame *AVLbalanceBBGame(BTGame *node)
{
  int balanceFactor;
  int hleft;
  int hright;
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  balanceFactor = balanceBBGame(node);
  if (balanceFactor > 1)
  {
    if (balanceBBGame(node->left) >= 0)
    {
      node = rotRBTGame(node);
    }
    else
    {
      node = rotLRBTGame(node);
    }

  }
  else
  {
    if (balanceFactor < (-1))
    {
      if (balanceBBGame(node->right) <= 0)
      {
        node = rotLBTGame(node);
      }
      else
      {
        node = rotRLBTGame(node);
      }

    }
    else
    {
      hleft = heightBBGame(node->left);
      hright = heightBBGame(node->right);
      node->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
    }

  }

  return node;
}

BTGame *insertBTGameAux(BTGame *node, Game *game)
{
  int cmp;
  if (node == 0)
  {
    return newBTGameNode(game, 0, 0);
  }
  else
  {
    
  }

  cmp = gamesOrder(game, node->game);
  if (cmp < 0)
  {
    node->left = insertBTGameAux(node->left, game);
  }
  else
  {
    node->right = insertBTGameAux(node->right, game);
  }

  return AVLbalanceBBGame(node);
}

void insertBTGame(BTGame **node, Game *game)
{
  *node = insertBTGameAux(*node, game);
}

BTGame *maxBBGame(BTGame *node)
{
  if ((node == 0) || (node->right == 0))
  {
    return node;
  }
  else
  {
    
  }

  return maxBBGame(node->right);
}

BTGame *deleteRBTGame(BTGame *node, char *name)
{
  BTGame *aux;
  Game *x;
  int cmp;
  if (node == 0)
  {
    return 0;
  }
  else
  {
    
  }

  cmp = gameKeyOrder(name, node->game);
  if (cmp < 0)
  {
    node->left = deleteRBTGame(node->left, name);
  }
  else
  {
    if (cmp > 0)
    {
      node->right = deleteRBTGame(node->right, name);
    }
    else
    {
      if ((node->left != 0) && (node->right != 0))
      {
        aux = maxBBGame(node->left);
        x = node->game;
        node->game = aux->game;
        aux->game = x;
        node->left = deleteRBTGame(node->left, name);
      }
      else
      {
        aux = node;
        if ((node->left == 0) && (node->right == 0))
        {
          node = 0;
        }
        else
        {
          if (node->left == 0)
          {
            node = node->right;
          }
          else
          {
            node = node->left;
          }

        }

        freeGame(aux->game);
        freeBTGameNode(aux);
      }

    }

  }

  return AVLbalanceBBGame(node);
}

void deleteBTGame(BTGame **node, char *name)
{
  *node = deleteRBTGame(*node, name);
}

void dumpGame(Game *array[], BTGame *node, int index)
{
  array[index] = node->game;
  index++;
  if (node->right != 0)
  {
    dumpGame(array, node->right, index);
    index = index + countBTGame(node->right);
  }
  else
  {
    
  }

  if (node->left != 0)
  {
    dumpGame(array, node->left, index);
  }
  else
  {
    
  }

}

void dumpBTGame(Game *array[], BTGame *node)
{
  if (node != 0)
  {
    dumpGame(array, node, 0);
  }
  else
  {
    
  }

}

