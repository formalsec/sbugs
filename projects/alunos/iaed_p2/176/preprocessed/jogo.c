#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "jogo.h"


lista_jogos inicia_lista_jogos()
{
  lista_jogos lj = (lista_jogos) malloc(sizeof(struct jlist));
  lj->head = 0;
  lj->tail = 0;
  lj->tamanho = 0;
  return lj;
}

pjogo novo_jogo(char *buffer, pequipa pe1, pequipa pe2, int score1, int score2)
{
  pjogo x = (pjogo) malloc(sizeof(struct jogo));
  x->nome = (char *) malloc((sizeof(char)) * (strlen(buffer) + 1));
  strcpy(x->nome, buffer);
  x->e1 = pe1;
  x->e2 = pe2;
  x->s1 = score1;
  x->s2 = score2;
  return x;
}

void inserir_jogo(lista_jogos lj, char *texto, pequipa pe1, pequipa pe2, int score1, int score2)
{
  jlink x = (jlink) malloc(sizeof(struct jnode));
  x->j = novo_jogo(texto, pe1, pe2, score1, score2);
  if (lj->tamanho == 0)
  {
    lj->head = x;
  }
  else
  {
    lj->tail->next = x;
    x->prev = lj->tail;
  }

  lj->tail = x;
  lj->tamanho++;
}

void libertar_jogo(jlink x)
{
  if (x != 0)
  {
    free(x->j->nome);
    x->j->e1 = 0;
    x->j->e2 = 0;
    free(x->j);
    free(x);
  }
  else
  {
    
  }

}

void aumenta_vitorias(pjogo x)
{
  if (x->s1 > x->s2)
  {
    x->e1->vitorias++;
  }
  else
  {
    if (x->s1 < x->s2)
    {
      x->e2->vitorias++;
    }
    else
    {
      
    }

  }

}

void diminui_vitorias(pjogo x)
{
  if (x->s1 > x->s2)
  {
    x->e1->vitorias--;
  }
  else
  {
    if (x->s1 < x->s2)
    {
      x->e2->vitorias--;
    }
    else
    {
      
    }

  }

}

void elimina_jogo_lista_jogos(lista_jogos lj, jlink x)
{
  if (lj->tamanho == 1)
  {
    lj->head = 0;
    lj->tail = 0;
  }
  else
  {
    if ((x != lj->tail) && (x != lj->head))
    {
      x->prev->next = x->next;
      x->next->prev = x->prev;
    }
    else
    {
      if (x == lj->head)
      {
        lj->head = x->next;
        lj->head->prev = 0;
      }
      else
      {
        if (x == lj->tail)
        {
          lj->tail = x->prev;
          lj->tail->next = 0;
        }
        else
        {
          
        }

      }

    }

  }

  libertar_jogo(x);
  lj->tamanho--;
}

void imprimir_lista_jogos(int cont, lista_jogos lj)
{
  jlink x;
  for (x = lj->head; x != lj->tail; x = x->next)
  {
    printf("%d %s %s %s %d %d\n", cont, x->j->nome, x->j->e1->nome, x->j->e2->nome, x->j->s1, x->j->s2);
  }

  if (lj->tail != 0)
  {
    printf("%d %s %s %s %d %d\n", cont, lj->tail->j->nome, lj->tail->j->e1->nome, lj->tail->j->e2->nome, lj->tail->j->s1, lj->tail->j->s2);
  }
  else
  {
    
  }

}

void eliminar_lista_jogos(lista_jogos lj)
{
  jlink atual;
  jlink prox;
  atual = lj->head;
  while (atual != lj->tail)
  {
    prox = atual->next;
    libertar_jogo(atual);
    atual = prox;
  }

  libertar_jogo(lj->tail);
  free(lj);
}

ht_jogos iniciar_tabela_jogos()
{
  ht_jogos ht_j = (ht_jogos) malloc(sizeof(struct hashtable_jogos));
  ht_j->hash_jogos = 0;
  ht_j->max = 499;
  ht_j->atual = 0;
  return ht_j;
}

jlink *iniciar_hash_jogos(int M)
{
  int i;
  jlink *hash_jogos = (jlink *) malloc(M * (sizeof(jlink)));
  for (i = 0; i < M; i++)
    hash_jogos[i] = 0;

  return hash_jogos;
}

void eliminar_hash_jogos(jlink *hash_jogos, int M)
{
  int i;
  for (i = 0; i < M; i++)
  {
    if (hash_jogos[i] != 0)
    {
      hash_jogos[i] = 0;
    }
    else
    {
      
    }

  }

  free(hash_jogos);
}

void expandir_hash_jogos(ht_jogos ht_j);
void insere_jogo_hash_jogos(ht_jogos ht_j, jlink x)
{
  int i = hash(x->j->nome, ht_j->max);
  while (ht_j->hash_jogos[i] != 0)
    i = (i + 1) % ht_j->max;

  ht_j->hash_jogos[i] = x;
  ht_j->atual++;
  if (ht_j->atual > (ht_j->max / 2))
  {
    expandir_hash_jogos(ht_j);
  }
  else
  {
    
  }

}

void expandir_hash_jogos(ht_jogos ht_j)
{
  int i;
  jlink *t = ht_j->hash_jogos;
  ht_j->hash_jogos = iniciar_hash_jogos(2 * ht_j->max);
  ht_j->max = 2 * ht_j->max;
  ht_j->atual = 0;
  for (i = 0; i < (ht_j->max / 2); i++)
  {
    if (t[i] != 0)
    {
      insere_jogo_hash_jogos(ht_j, t[i]);
    }
    else
    {
      
    }

  }

  free(t);
}

int procura_jogo_hash_jogos(ht_jogos ht_j, char *texto)
{
  int i = hash(texto, ht_j->max);
  while (ht_j->hash_jogos[i] != 0)
    if (strcmp(ht_j->hash_jogos[i]->j->nome, texto) == 0)
  {
    return i;
  }
  else
  {
    i = (i + 1) % ht_j->max;
  }


  return -1;
}

void elimina_jogo_hash_jogos(ht_jogos ht_j, int i)
{
  int j;
  jlink x;
  ht_j->hash_jogos[i] = 0;
  for (j = (i + 1) % ht_j->max; ht_j->hash_jogos[j] != 0; j = (j + 1) % ht_j->max)
  {
    x = ht_j->hash_jogos[j];
    ht_j->hash_jogos[j] = 0;
    insere_jogo_hash_jogos(ht_j, x);
  }

  ht_j->atual--;
}

void altera_scores(jlink x, int novo_s1, int novo_s2)
{
  if (novo_s1 > novo_s2)
  {
    if (x->j->s2 > x->j->s1)
    {
      x->j->e1->vitorias++;
      x->j->e2->vitorias--;
    }
    else
    {
      if (x->j->s1 == x->j->s2)
      {
        x->j->e1->vitorias++;
      }
      else
      {
        
      }

    }

  }
  else
  {
    if (novo_s2 > novo_s1)
    {
      if (x->j->s1 > x->j->s2)
      {
        x->j->e2->vitorias++;
        x->j->e1->vitorias--;
      }
      else
      {
        if (x->j->s1 == x->j->s2)
        {
          x->j->e2->vitorias++;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (x->j->s1 > x->j->s2)
      {
        x->j->e1->vitorias--;
      }
      else
      {
        if (x->j->s2 > x->j->s1)
        {
          x->j->e2->vitorias--;
        }
        else
        {
          
        }

      }

    }

  }

  x->j->s1 = novo_s1;
  x->j->s2 = novo_s2;
}

