#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "wrapper_futebol.h"


int vencedor(int score1, int score2);
equipa cria_equipa(char *nome, int jogos_ganhos)
{
  equipa nova_equipa;
  nova_equipa.nome = nome;
  nova_equipa.jogos_ganhos = jogos_ganhos;
  return nova_equipa;
}

jogo cria_jogo(char *nome, char *nome_equipa1, char *nome_equipa2, int score_eq1, int score_eq2)
{
  jogo novo_jogo;
  novo_jogo.nome = nome;
  novo_jogo.nome_equipa1 = nome_equipa1;
  novo_jogo.nome_equipa2 = nome_equipa2;
  novo_jogo.score_eq1 = score_eq1;
  novo_jogo.score_eq2 = score_eq2;
  return novo_jogo;
}

lista_equipas cria_lista()
{
  lista_equipas l;
  l.head = 0;
  return l;
}

void *copiar_equipa(void *equipa_original)
{
  equipa *temp = (equipa *) equipa_original;
  equipa *copia = (equipa *) malloc(sizeof(struct equipa));
  if (copia != 0)
  {
    copia->nome = dupstring(temp->nome);
    copia->jogos_ganhos = temp->jogos_ganhos;
    if (copia->nome != 0)
    {
      return (void *) copia;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  return 0;
}

void *copiar_jogo(void *jogo_original)
{
  jogo *temp = (jogo *) jogo_original;
  jogo *copia = (jogo *) malloc(sizeof(struct jogo));
  if (copia != 0)
  {
    copia->nome = dupstring(temp->nome);
    copia->nome_equipa1 = dupstring(temp->nome_equipa1);
    copia->nome_equipa2 = dupstring(temp->nome_equipa2);
    copia->score_eq1 = temp->score_eq1;
    copia->score_eq2 = temp->score_eq2;
    if (((copia->nome != 0) && (copia->nome_equipa1 != 0)) && (copia->nome_equipa2 != 0))
    {
      return (void *) copia;
    }
    else
    {
      
    }

  }
  else
  {
    
  }

  return 0;
}

void destroi_jogo(void *jogo_original)
{
  jogo *temp = (jogo *) jogo_original;
  free(temp->nome);
  free(temp->nome_equipa1);
  free(temp->nome_equipa2);
  free(temp);
}

void destroi_equipa(void *equipa_original)
{
  equipa *temp = (equipa *) equipa_original;
  free(temp->nome);
  free(temp);
}

void destroi_lista(lista_equipas *l)
{
  node_equipa *temp = l->head;
  node_equipa *next;
  while (temp != 0)
  {
    next = temp->next;
    free(temp);
    temp = next;
  }

  l->head = 0;
}

bool insere_equipa(tabela *t, char *chave, equipa *equipa)
{
  return insere_tabela(t, chave, (void *) equipa, copiar_equipa);
}

bool insere_jogo(tabela *t_jogos, tabela *t_equipas, char *chave, jogo *jogo)
{
  equipa *equipa1;
  equipa *equipa2;
  bool status = insere_tabela(t_jogos, chave, (void *) jogo, copiar_jogo);
  equipa1 = procura_equipa(t_equipas, jogo->nome_equipa1);
  equipa2 = procura_equipa(t_equipas, jogo->nome_equipa2);
  if ((equipa1 != 0) && (equipa2 != 0))
  {
    if (jogo->score_eq1 > jogo->score_eq2)
    {
      equipa1->jogos_ganhos++;
    }
    else
    {
      if (jogo->score_eq2 > jogo->score_eq1)
      {
        equipa2->jogos_ganhos++;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  return status;
}

bool insere_lista(lista_equipas *l, equipa *equipa)
{
  node_equipa *novo_elemento;
  node_equipa *temp;
  novo_elemento = (node_equipa *) malloc(sizeof(struct node_equipa));
  if (novo_elemento != 0)
  {
    temp = l->head;
    novo_elemento->equipa = equipa;
    novo_elemento->next = temp;
    l->head = novo_elemento;
    return true;
  }
  else
  {
    
  }

  return false;
}

bool remove_equipa(tabela *t, char *chave)
{
  return remove_tabela(t, chave, destroi_equipa);
}

bool remove_jogo(tabela *t_jogos, tabela *t_equipas, char *chave)
{
  equipa *equipa1;
  equipa *equipa2;
  jogo *jogo;
  int vencedor_jogo;
  jogo = procura_jogo(t_jogos, chave);
  equipa1 = procura_equipa(t_equipas, jogo->nome_equipa1);
  equipa2 = procura_equipa(t_equipas, jogo->nome_equipa2);
  vencedor_jogo = vencedor(jogo->score_eq1, jogo->score_eq2);
  if (vencedor_jogo == 1)
  {
    equipa1->jogos_ganhos--;
  }
  else
  {
    if (vencedor_jogo == 2)
    {
      equipa2->jogos_ganhos--;
    }
    else
    {
      
    }

  }

  return remove_tabela(t_jogos, chave, destroi_jogo);
}

equipa *procura_equipa(tabela *t, char *chave)
{
  return (equipa *) procura_tabela(t, chave);
}

jogo *procura_jogo(tabela *t, char *chave)
{
  return (jogo *) procura_tabela(t, chave);
}

node_equipa *obtem_inicio_lista(lista_equipas *l)
{
  return l->head;
}

int vencedor(int score1, int score2)
{
  if (score1 > score2)
  {
    return 1;
  }
  else
  {
    if (score2 > score1)
    {
      return 2;
    }
    else
    {
      return 0;
    }

  }

}

bool muda_pontuacao(tabela *t_equipas, jogo *jogo, int novo_score1, int novo_score2)
{
  equipa *equipa1;
  equipa *equipa2;
  int anterior_vencedor = vencedor(jogo->score_eq1, jogo->score_eq2);
  int novo_vencedor = vencedor(novo_score1, novo_score2);
  jogo->score_eq1 = novo_score1;
  jogo->score_eq2 = novo_score2;
  equipa1 = procura_equipa(t_equipas, jogo->nome_equipa1);
  equipa2 = procura_equipa(t_equipas, jogo->nome_equipa2);
  if ((equipa1 != 0) && (equipa2 != 0))
  {
    switch (anterior_vencedor)
    {
      case 0:
        switch (novo_vencedor)
      {
        case 0:
          return true;

        case 1:
          equipa1->jogos_ganhos++;
          return true;

        case 2:
          equipa2->jogos_ganhos++;
          return true;

      }

        break;

      case 1:
        switch (novo_vencedor)
      {
        case 0:
          equipa1->jogos_ganhos--;
          return true;

        case 1:
          return true;

        case 2:
          equipa1->jogos_ganhos--;
          equipa2->jogos_ganhos++;
          return true;

      }

        break;

      case 2:
        switch (novo_vencedor)
      {
        case 0:
          equipa2->jogos_ganhos--;
          return true;

        case 1:
          equipa2->jogos_ganhos--;
          equipa1->jogos_ganhos++;
          return true;

        case 2:
          return true;

      }


    }

  }
  else
  {
    
  }

  return false;
}

int compara_equipas(const void *e1_void, const void *e2_void)
{
  equipa *e1 = *((equipa **) e1_void);
  equipa *e2 = *((equipa **) e2_void);
  if ((((e1 != 0) && (e2 != 0)) && (e1->nome != 0)) && (e2->nome != 0))
  {
    return -strcmp(e1->nome, e2->nome);
  }
  else
  {
    
  }

  return 0;
}

void ordenar_lista_equipas(lista_equipas *l, lista_equipas *resultados)
{
  int i;
  int num_equipas = 0;
  node_equipa *temp;
  equipa **equipas_ordenadas;
  for (temp = obtem_inicio_lista(l); temp != 0; temp = temp->next)
  {
    num_equipas++;
  }

  equipas_ordenadas = (equipa **) malloc(num_equipas * (sizeof(struct equipa *)));
  for (temp = obtem_inicio_lista(l), i = 0; (temp != 0) && (i < num_equipas); temp = temp->next, i++)
  {
    equipas_ordenadas[i] = temp->equipa;
  }

  if (equipas_ordenadas != 0)
  {
    qsort(equipas_ordenadas, num_equipas, sizeof(struct equipa *), compara_equipas);
  }
  else
  {
    
  }

  for (i = 0; i < num_equipas; i++)
  {
    insere_lista(resultados, equipas_ordenadas[i]);
  }

  free(equipas_ordenadas);
}

