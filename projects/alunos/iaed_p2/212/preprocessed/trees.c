/*File generated by PreProcessor.py*/


#include "trees.h"


Tree *initTree()
{
  return 0;
}

Tree *newNode(struct node *x)
{
  Tree *n = (Tree *) calloc(1, sizeof(Tree));
  n->x = x;
  n->height = 1;
  n->l = (n->r = 0);
  return n;
}

int height(Tree *h)
{
  if (h == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return h->height;
}

Tree *insertTree(Tree *t, struct node *x)
{
  Tree *n;
  if (t == 0)
  {
    n = newNode(x);
    return n;
  }
  else
  {
    if (strcmp(x->game.nome, t->x->game.nome) < 0)
    {
      t->l = insertTree(t->l, x);
    }
    else
    {
      t->r = insertTree(t->r, x);
    }

  }

  t = AVLbalance(t);
  return t;
}

Tree *searchTree(Tree *t, char *nome)
{
  if (t == 0)
  {
    return 0;
  }
  else
  {
    
  }

  if (strcmp(nome, t->x->game.nome) == 0)
  {
    return t;
  }
  else
  {
    
  }

  if (strcmp(nome, t->x->game.nome) < 0)
  {
    return searchTree(t->l, nome);
  }
  else
  {
    return searchTree(t->r, nome);
  }

}

Tree *max(Tree *h)
{
  if ((h == 0) || (h->r == 0))
  {
    return h;
  }
  else
  {
    return max(h->r);
  }

}

Tree *deleteR(Tree *h, char *nome, link *head, link *last, int nl)
{
  Tree *aux;
  struct node *x;
  if (h == 0)
  {
    printf("%d Jogo inexistente.\n", nl);
    return h;
  }
  else
  {
    if (strcmp(nome, h->x->game.nome) < 0)
    {
      h->l = deleteR(h->l, nome, head, last, nl);
    }
    else
    {
      if (strcmp(h->x->game.nome, nome) < 0)
      {
        h->r = deleteR(h->r, nome, head, last, nl);
      }
      else
      {
        if ((h->l != 0) && (h->r != 0))
        {
          aux = max(h->l);
          x = h->x;
          h->x = aux->x;
          aux->x = x;
          h->l = deleteR(h->l, aux->x->game.nome, head, last, nl);
        }
        else
        {
          aux = h;
          if ((h->l == 0) && (h->r == 0))
          {
            h = 0;
          }
          else
          {
            if (h->l == 0)
            {
              h = h->r;
            }
            else
            {
              h = h->l;
            }

          }

          rmNode(aux->x, head, last);
          free(aux);
        }

      }

    }

  }

  h = AVLbalance(h);
  return h;
}

Tree *freeR(Tree *h, link head, link last)
{
  if (h == 0)
  {
    return h;
  }
  else
  {
    
  }

  h->l = freeR(h->l, head, last);
  h->r = freeR(h->r, head, last);
  return deleteR(h, h->x->game.nome, &head, &last, 0);
}

void freeTree(Tree *node)
{
  if (node != 0)
  {
    freeTree(node->r);
    free(node->x->game.nome);
    free(node->x->game.equipa1);
    free(node->x->game.equipa2);
    free(node->x);
    freeTree(node->l);
    free(node);
  }
  else
  {
    
  }

}

Tree *rotL(Tree *h)
{
  int hleft;
  int hright;
  int xleft;
  int xright;
  Tree *x = h->r;
  h->r = x->l;
  x->l = h;
  hleft = height(h->l);
  hright = height(h->r);
  h->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
  xleft = height(x->l);
  xright = height(x->r);
  x->height = (xleft > xright) ? (xleft + 1) : (xright + 1);
  return x;
}

Tree *rotR(Tree *h)
{
  int hleft;
  int hright;
  int xleft;
  int xright;
  Tree *x = h->l;
  h->l = x->r;
  x->r = h;
  hleft = height(h->l);
  hright = height(h->r);
  h->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
  xleft = height(x->l);
  xright = height(x->r);
  x->height = (xleft > xright) ? (xleft + 1) : (xright + 1);
  return x;
}

Tree *rotLR(Tree *h)
{
  if (h == 0)
  {
    return h;
  }
  else
  {
    
  }

  h->l = rotL(h->l);
  return rotR(h);
}

Tree *rotRL(Tree *h)
{
  if (h == 0)
  {
    return h;
  }
  else
  {
    
  }

  h->r = rotR(h->r);
  return rotL(h);
}

int balance(Tree *h)
{
  if (h == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return height(h->l) - height(h->r);
}

Tree *AVLbalance(Tree *h)
{
  int balanceFactor;
  int hleft;
  int hright;
  if (h == 0)
  {
    return h;
  }
  else
  {
    
  }

  balanceFactor = balance(h);
  if (balanceFactor > 1)
  {
    if (balance(h->l) >= 0)
    {
      h = rotR(h);
    }
    else
    {
      h = rotLR(h);
    }

  }
  else
  {
    if (balanceFactor < (-1))
    {
      if (balance(h->r) <= 0)
      {
        h = rotL(h);
      }
      else
      {
        h = rotRL(h);
      }

    }
    else
    {
      hleft = height(h->l);
      hright = height(h->r);
      h->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
    }

  }

  return h;
}

Tree2 *initTree2()
{
  return 0;
}

Tree2 *newNode2(char *x)
{
  Tree2 *n = (Tree2 *) calloc(1, sizeof(Tree2));
  n->x = x;
  n->height = 1;
  n->l = (n->r = 0);
  return n;
}

int height2(Tree2 *h)
{
  if (h == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return h->height;
}

Tree2 *insertTree2(Tree2 *t, char *x)
{
  Tree2 *n;
  if (t == 0)
  {
    n = newNode2(x);
    return n;
  }
  else
  {
    if (strcmp(x, t->x) < 0)
    {
      t->l = insertTree2(t->l, x);
    }
    else
    {
      t->r = insertTree2(t->r, x);
    }

  }

  t = AVLbalance2(t);
  return t;
}

Tree2 *searchTree2(Tree2 *t, char *nome)
{
  if (t == 0)
  {
    return 0;
  }
  else
  {
    
  }

  if (strcmp(nome, t->x) == 0)
  {
    return t;
  }
  else
  {
    
  }

  if (strcmp(nome, t->x) < 0)
  {
    return searchTree2(t->l, nome);
  }
  else
  {
    return searchTree2(t->r, nome);
  }

}

Tree2 *rotL2(Tree2 *h)
{
  int hleft;
  int hright;
  int xleft;
  int xright;
  Tree2 *x = h->r;
  h->r = x->l;
  x->l = h;
  hleft = height2(h->l);
  hright = height2(h->r);
  h->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
  xleft = height2(x->l);
  xright = height2(x->r);
  x->height = (xleft > xright) ? (xleft + 1) : (xright + 1);
  return x;
}

Tree2 *rotR2(Tree2 *h)
{
  int hleft;
  int hright;
  int xleft;
  int xright;
  Tree2 *x = h->l;
  h->l = x->r;
  x->r = h;
  hleft = height2(h->l);
  hright = height2(h->r);
  h->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
  xleft = height2(x->l);
  xright = height2(x->r);
  x->height = (xleft > xright) ? (xleft + 1) : (xright + 1);
  return x;
}

Tree2 *rotLR2(Tree2 *h)
{
  if (h == 0)
  {
    return h;
  }
  else
  {
    
  }

  h->l = rotL2(h->l);
  return rotR2(h);
}

Tree2 *rotRL2(Tree2 *h)
{
  if (h == 0)
  {
    return h;
  }
  else
  {
    
  }

  h->r = rotR2(h->r);
  return rotL2(h);
}

int balance2(Tree2 *h)
{
  if (h == 0)
  {
    return 0;
  }
  else
  {
    
  }

  return height2(h->l) - height2(h->r);
}

Tree2 *AVLbalance2(Tree2 *h)
{
  int balanceFactor;
  int hleft;
  int hright;
  if (h == 0)
  {
    return h;
  }
  else
  {
    
  }

  balanceFactor = balance2(h);
  if (balanceFactor > 1)
  {
    if (balance2(h->l) >= 0)
    {
      h = rotR2(h);
    }
    else
    {
      h = rotLR2(h);
    }

  }
  else
  {
    if (balanceFactor < (-1))
    {
      if (balance2(h->r) <= 0)
      {
        h = rotL2(h);
      }
      else
      {
        h = rotRL2(h);
      }

    }
    else
    {
      hleft = height2(h->l);
      hright = height2(h->r);
      h->height = (hleft > hright) ? (hleft + 1) : (hright + 1);
    }

  }

  return h;
}

void freeTree2(Tree2 *node)
{
  if (node != 0)
  {
    freeTree2(node->r);
    free(node->x);
    freeTree2(node->l);
    free(node);
  }
  else
  {
    
  }

}

void traverse(Tree2 *h, int *win)
{
  if (h == 0)
  {
    return;
  }
  else
  {
    
  }

  traverse(h->l, win);
  if (h->win > (*win))
  {
    *win = h->win;
  }
  else
  {
    
  }

  traverse(h->r, win);
}

void printMostWins(Tree2 *t, int win, int nl)
{
  if (t != 0)
  {
    printMostWins(t->l, win, nl);
    if (t->win == win)
    {
      printf("%d * %s\n", nl, t->x);
    }
    else
    {
      
    }

    printMostWins(t->r, win, nl);
  }
  else
  {
    
  }

}

