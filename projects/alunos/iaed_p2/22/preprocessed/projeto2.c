/*File generated by PreProcessor.py*/


#include "hash.h"


int line = 0;
void comando_a(struct game **hash_games, struct team **hash_teams, struct game **lastGame, struct game **firstGame)
{
  char *name = malloc((sizeof(char)) * 1023);
  char *team1 = malloc((sizeof(char)) * 1023);
  char *team2 = malloc((sizeof(char)) * 1023);
  int s1;
  int s2;
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  for (int team1_index = 0; team1_index < 10; team1_index++)
  {
    team1[team1_index] = new_sym_var(sizeof(char) * 8);
  }

  team1[10 - 1] = '\0';
  for (int team2_index = 0; team2_index < 10; team2_index++)
  {
    team2[team2_index] = new_sym_var(sizeof(char) * 8);
  }

  team2[10 - 1] = '\0';
  s1 = new_sym_var(sizeof(int) * 8);
  s2 = new_sym_var(sizeof(int) * 8);
  if (gameExists(name, hash_games) == 0)
  {
    printf("%d Jogo existente.\n", line);
    free(name);
    free(team1);
    free(team2);
    return;
  }
  else
  {
    
  }

  if ((teamExists(team1, hash_teams) == (-1)) || (teamExists(team2, hash_teams) == (-1)))
  {
    printf("%d Equipa inexistente.\n", line);
    free(name);
    free(team1);
    free(team2);
    return;
  }
  else
  {
    
  }

  addGame(name, team1, team2, s1, s2, hash_games, hash_teams, lastGame, firstGame);
  free(name);
  free(team1);
  free(team2);
  return;
}

void comando_A(char *input, struct team **hash_teams)
{
  unsigned long key;
  struct team *t;
  struct team *t1;
  key = hash(input);
  for (t = hash_teams[key]; t != 0; t = t->nextHash)
  {
    if (strcmp(t->name, input) == 0)
    {
      printf("%d Equipa existente.\n", line);
      return;
    }
    else
    {
      
    }

    t1 = t;
  }

  if (hash_teams[key] == 0)
  {
    addTeam(input, hash_teams, hash_teams[key]);
  }
  else
  {
    addTeam(input, hash_teams, t1);
  }

  return;
}

void comando_l(struct game **firstGame)
{
  struct game *g;
  if (firstGame == 0)
  {
    return;
  }
  else
  {
    
  }

  g = *firstGame;
  while (g != 0)
  {
    printf("%d %s %s %s %d %d\n", line, g->name, g->team1->name, g->team2->name, g->score1, g->score2);
    g = g->nextGeral;
  }

}

void comando_s(struct game **hash_games)
{
  struct game *g;
  char *name = malloc((sizeof(char)) * 1023);
  int s1;
  int s2;
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  s1 = new_sym_var(sizeof(int) * 8);
  s2 = new_sym_var(sizeof(int) * 8);
  if (hash_games[hash(name)] == 0)
  {
    printf("%d Jogo inexistente.\n", line);
    free(name);
    return;
  }
  else
  {
    
  }

  for (g = hash_games[hash(name)]; g != 0; g = g->nextHash)
  {
    if (strcmp(name, g->name) == 0)
    {
      changeScore(g, s1, s2);
      free(name);
      return;
    }
    else
    {
      
    }

  }

  printf("%d Jogo inexistente.\n", line);
  free(name);
  return;
}

void comando_p(char *input, struct game **hash_games)
{
  struct game *g;
  if (hash_games[hash(input)] == 0)
  {
    printf("%d Jogo inexistente.\n", line);
    return;
  }
  else
  {
    
  }

  for (g = hash_games[hash(input)]; g != 0; g = g->nextHash)
  {
    if (strcmp(input, g->name) == 0)
    {
      printf("%d %s %s %s %d %d\n", line, g->name, g->team1->name, g->team2->name, g->score1, g->score2);
      return;
    }
    else
    {
      
    }

  }

  printf("%d Jogo inexistente.\n", line);
  return;
}

void comando_P(char *input, struct team **hash_teams)
{
  struct team *t;
  if (hash_teams[hash(input)] == 0)
  {
    printf("%d Equipa inexistente.\n", line);
    return;
  }
  else
  {
    
  }

  for (t = hash_teams[hash(input)]; t != 0; t = t->nextHash)
  {
    if (strcmp(input, t->name) == 0)
    {
      printf("%d %s %d\n", line, input, t->wins);
      return;
    }
    else
    {
      
    }

  }

  printf("%d Equipa inexistente.\n", line);
  return;
}

void comando_g(struct team **hash_teams)
{
  struct team *t;
  char **teams = malloc((sizeof(char *)) * 500);
  int i;
  int n;
  int max = findMaxWins(hash_teams);
  n = 0;
  for (i = 0; i < 500; i++)
  {
    teams[i] = malloc((sizeof(char)) * 300);
  }

  if (max == (-1))
  {
    for (i = 0; i < 500; i++)
    {
      free(teams[i]);
    }

    free(teams);
    return;
  }
  else
  {
    
  }

  for (i = 0; i < 43100; i++)
  {
    if (hash_teams[i] != 0)
    {
      for (t = hash_teams[i]; t != 0; t = t->nextHash)
      {
        if (t->wins == max)
        {
          strcpy(teams[n], t->name);
          n++;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  sortAlphabetic(teams, n);
  printf("%d Melhores %d\n", line, max);
  for (i = 0; i < n; i++)
  {
    printf("%d * %s\n", line, teams[i]);
  }

  for (i = 0; i < 500; i++)
  {
    free(teams[i]);
  }

  free(teams);
}

void comando_r(char *input, struct game **hash_games, struct game **lastGame, struct game **firstGame)
{
  struct game *g;
  if (gameExists(input, hash_games) == (-1))
  {
    printf("%d Jogo inexistente.\n", line);
    return;
  }
  else
  {
    
  }

  for (g = hash_games[hash(input)]; g != 0; g = g->nextHash)
  {
    if (strcmp(input, g->name) == 0)
    {
      removeGame(g, hash_games, lastGame, firstGame);
      return;
    }
    else
    {
      
    }

  }

}

void comando_x(struct game **hash_games, struct team **hash_teams, struct game *firstGame)
{
  struct game *g;
  struct game *g1;
  if (firstGame != 0)
  {
    g = firstGame;
    while (g != 0)
    {
      g1 = g->nextGeral;
      freeGame(g);
      g = g1;
    }

  }
  else
  {
    
  }

  free(hash_games);
  deleteHashTeams(hash_teams);
}

int main()
{
  char *control = malloc((sizeof(char)) * 6);
  char *input = malloc(((sizeof(char)) * 1023) * 3);
  int end;
  struct game **hash_games = malloc((sizeof(struct game *)) * 43100);
  struct team **hash_teams = malloc((sizeof(struct team *)) * 43100);
  struct game *lastGame;
  struct game *firstGame;
  lastGame = 0;
  firstGame = 0;
  init_hash_games(hash_games);
  init_hash_teams(hash_teams);
  end = 0;
  while (end == 0)
  {
    for (int control_index = 0; control_index < 10; control_index++)
    {
      control[control_index] = new_sym_var(sizeof(char) * 8);
    }

    control[10 - 1] = '\0';
    switch (*control)
    {
      case 'a':
        line++;
        comando_a(hash_games, hash_teams, &lastGame, &firstGame);
        break;

      case 'A':
        line++;
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_A(input, hash_teams);
        break;

      case 'l':
        line++;
        comando_l(&firstGame);
        break;

      case 'p':
        line++;
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_p(input, hash_games);
        break;

      case 's':
        line++;
        comando_s(hash_games);
        break;

      case 'P':
        line++;
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_P(input, hash_teams);
        break;

      case 'g':
        line++;
        comando_g(hash_teams);
        break;

      case 'r':
        line++;
        for (int input_index = 0; input_index < 10; input_index++)
      {
        input[input_index] = new_sym_var(sizeof(char) * 8);
      }

        input[10 - 1] = '\0';
        comando_r(input, hash_games, &lastGame, &firstGame);
        break;

      case 'x':
        comando_x(hash_games, hash_teams, firstGame);
        free(input);
        free(control);
        end = 1;
        return 0;
        break;

    }

  }

  return 0;
}

