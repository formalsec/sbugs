/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct 
{
  char *tName;
  int wins;
} Team;
typedef struct nodeT nodeT;
typedef struct nodeT *linkT;
struct nodeT
{
  Team *team;
  nodeT *next;
};
linkT teams[30011 * 2];
static linkT topT = 0;
static linkT bottomT = 0;
typedef struct 
{
  char *gName;
  linkT team1;
  linkT team2;
  int score1;
  int score2;
  int winTeam;
} Game;
typedef struct nodeG nodeG;
typedef struct nodeG *linkG;
struct nodeG
{
  Game *game;
  nodeG *next;
};
linkG hashT_game[30011];
static linkG top = 0;
static linkG bottom = 0;
int commands = 1;
int hash(char *name, int M)
{
  int h = 0;
  int a = 127;
  for (; (*name) != '\0'; name++)
    h = ((a * h) + (*name)) % M;

  return h;
}

void init_hashT()
{
  int i;
  for (i = 0; i < (30011 * 2); i++)
    teams[i] = 0;

}

void init_hashG()
{
  int i;
  for (i = 0; i < 30011; i++)
    hashT_game[i] = 0;

}

linkG new_nodeG(Game *g)
{
  linkG x = malloc(sizeof(nodeG));
  x->game = g;
  x->next = 0;
  return x;
}

linkT new_nodeT(Team *t)
{
  linkT x = malloc(sizeof(nodeT));
  x->team = t;
  x->next = 0;
  return x;
}

void gameInsert(Game *g, linkG hashT[])
{
  linkG i;
  int k = hash(g->gName, 30011);
  i = new_nodeG(g);
  i->next = hashT[k];
  hashT[k] = i;
}

void teamInsert(Team *t, linkT hashT[])
{
  linkT i;
  int k = hash(t->tName, 30011 * 2);
  i = new_nodeT(t);
  i->next = hashT[k];
  hashT[k] = i;
}

linkT searchT(char *name)
{
  linkT t;
  int i = hash(name, 30011 * 2);
  for (t = teams[i]; t != 0; t = t->next)
    if (!strcmp(t->team->tName, name))
  {
    return t;
  }
  else
  {
    
  }


  return 0;
}

linkG searchG(char *name)
{
  linkG g;
  int i = hash(name, 30011);
  for (g = hashT_game[i]; g != 0; g = g->next)
    if (!strcmp(g->game->gName, name))
  {
    return g;
  }
  else
  {
    
  }


  return 0;
}

void freeMemoryLlistT(linkT head, int mode)
{
  linkT i = head;
  linkT next;
  while (i != 0)
  {
    next = i->next;
    if (mode)
    {
      free(i->team->tName);
      free(i->team);
    }
    else
    {
      
    }

    free(i);
    i = next;
  }

}

void free_node(linkG node, int mode)
{
  if (mode)
  {
    free(node->game->gName);
    node->game->team1 = 0;
    node->game->team2 = 0;
    free(node->game);
  }
  else
  {
    
  }

  free(node);
}

void free_memory_list(linkG head, int mode)
{
  linkG i = head;
  linkG next;
  while (i != 0)
  {
    next = i->next;
    free_node(i, mode);
    i = next;
  }

}

void free_memory()
{
  int i;
  free_memory_list(top, 1);
  for (i = 0; i < 30011; i++)
  {
    free_memory_list(hashT_game[i], 0);
  }

  freeMemoryLlistT(topT, 1);
  for (i = 0; i < (30011 * 2); i++)
  {
    freeMemoryLlistT(teams[i], 0);
  }

}

linkG delete(linkG head, const char *name, int mode)
{
  linkG t;
  linkG prev;
  for (t = head, prev = 0; t != 0; prev = t, t = t->next)
  {
    if (strcmp(t->game->gName, name) == 0)
    {
      if (t == head)
      {
        head = t->next;
      }
      else
      {
        if (head == top)
        {
          if (t->next == 0)
          {
            bottom = prev;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

        prev->next = t->next;
      }

      free_node(t, mode);
      return head;
    }
    else
    {
      
    }

  }

  return head;
}

void a(char *gName, char *team1, char *team2, int score1, int score2)
{
  Game *newG;
  linkG i = searchG(gName);
  int p = 0;
  linkT t1 = searchT(team1);
  linkT t2 = searchT(team2);
  newG = (Game *) malloc(sizeof(Game));
  if (i != 0)
  {
    printf("%d Jogo existente.\n", commands);
    free(newG);
  }
  else
  {
    if ((t1 == 0) || (t2 == 0))
    {
      printf("%d Equipa inexistente.\n", commands);
      free(newG);
    }
    else
    {
      while (gName[p] != '\0')
        p++;

      newG->gName = (char *) malloc((sizeof(char)) * (p + 1));
      strcpy(newG->gName, gName);
      newG->team1 = t1;
      newG->team2 = t2;
      newG->score1 = score1;
      newG->score2 = score2;
      if (newG->score1 > newG->score2)
      {
        t1->team->wins++;
        newG->winTeam = 1;
      }
      else
      {
        if (newG->score2 > newG->score1)
        {
          t2->team->wins++;
          newG->winTeam = 2;
        }
        else
        {
          newG->winTeam = 0;
        }

      }

      if (top == 0)
      {
        top = new_nodeG(newG);
        bottom = top;
      }
      else
      {
        bottom->next = new_nodeG(newG);
        bottom = bottom->next;
      }

      gameInsert(newG, hashT_game);
    }

  }

}

void l()
{
  linkG i = top;
  while (i != 0)
  {
    printf("%d %s %s %s %d %d\n", commands, i->game->gName, i->game->team1->team->tName, i->game->team2->team->tName, i->game->score1, i->game->score2);
    i = i->next;
  }

}

void p(char *name)
{
  linkG i = searchG(name);
  if (i == 0)
  {
    printf("%d Jogo inexistente.\n", commands);
  }
  else
  {
    printf("%d %s %s %s %d %d\n", commands, i->game->gName, i->game->team1->team->tName, i->game->team2->team->tName, i->game->score1, i->game->score2);
  }

}

void r(char *name)
{
  linkG i = searchG(name);
  int gN;
  if (i == 0)
  {
    printf("%d Jogo inexistente.\n", commands);
  }
  else
  {
    gN = hash(name, 30011);
    if (i->game->score1 > i->game->score2)
    {
      i->game->team1->team->wins--;
    }
    else
    {
      if (i->game->score1 < i->game->score2)
      {
        i->game->team2->team->wins--;
      }
      else
      {
        
      }

    }

    hashT_game[gN] = delete(hashT_game[gN], name, 0);
    top = delete(top, name, 1);
  }

}

void s(char *name, int score1, int score2)
{
  linkG i = searchG(name);
  if (i == 0)
  {
    printf("%d Jogo inexistente.\n", commands);
  }
  else
  {
    if (i->game->winTeam == 1)
    {
      i->game->team1->team->wins--;
    }
    else
    {
      if (i->game->winTeam == 2)
      {
        i->game->team2->team->wins--;
      }
      else
      {
        
      }

    }

    i->game->score1 = score1;
    i->game->score2 = score2;
    if (score1 > score2)
    {
      i->game->team1->team->wins++;
      i->game->winTeam = 1;
    }
    else
    {
      if (score1 < score2)
      {
        i->game->team2->team->wins++;
        i->game->winTeam = 2;
      }
      else
      {
        i->game->winTeam = 0;
      }

    }

  }

}

void A(char *name)
{
  Team *newT;
  linkT i = searchT(name);
  int p = 0;
  newT = (Team *) malloc(sizeof(Team));
  if (i != 0)
  {
    printf("%d Equipa existente.\n", commands);
    free(newT);
  }
  else
  {
    while (name[p] != '\0')
      p++;

    newT->tName = (char *) malloc((sizeof(char)) * (p + 1));
    strcpy(newT->tName, name);
    newT->wins = 0;
    if (topT == 0)
    {
      topT = new_nodeT(newT);
      bottomT = topT;
    }
    else
    {
      bottomT->next = new_nodeT(newT);
      bottomT = bottomT->next;
    }

    teamInsert(newT, teams);
  }

}

void P(char *name)
{
  linkT t = searchT(name);
  if (t == 0)
  {
    printf("%d Equipa inexistente.\n", commands);
  }
  else
  {
    printf("%d %s %d\n", commands, name, t->team->wins);
  }

}

void g()
{
  linkT i = topT;
  Team *t;
  Team *aux_x;
  char *aux_aux;
  char **t_aux;
  int k;
  int j;
  int howMany = 0;
  int most_wins = 0;
  t = (Team *) calloc(1, sizeof(Team));
  while (i != 0)
  {
    if ((i->team->wins > most_wins) || ((i->team->wins == 0) && (howMany == 0)))
    {
      t = (Team *) realloc(t, sizeof(Team));
      t[0] = *i->team;
      most_wins = i->team->wins;
      howMany = 1;
    }
    else
    {
      if (i->team->wins == most_wins)
      {
        howMany++;
        aux_x = (Team *) realloc(t, (sizeof(Team)) * howMany);
        if (aux_x)
        {
          t = aux_x;
        }
        else
        {
          
        }

        t[howMany - 1] = *i->team;
      }
      else
      {
        
      }

    }

    i = i->next;
  }

  t_aux = (char **) malloc((sizeof(char *)) * howMany);
  for (k = 0; k < howMany; k++)
  {
    t_aux[k] = (char *) malloc(((sizeof(char)) * strlen((t + k)->tName)) + 1);
    strcpy(t_aux[k], (t + k)->tName);
  }

  for (k = 0; k < howMany; k++)
  {
    for (j = k + 1; j < howMany; j++)
    {
      aux_aux = (char *) malloc(((sizeof(char)) * strlen(t_aux[j])) + 1);
      if (strcmp(t_aux[k], t_aux[j]) > 0)
      {
        strcpy(aux_aux, t_aux[j]);
        t_aux[j] = (char *) realloc(t_aux[j], ((sizeof(char)) * strlen(t_aux[k])) + 1);
        strcpy(t_aux[j], t_aux[k]);
        t_aux[k] = (char *) realloc(t_aux[k], ((sizeof(char)) * strlen(aux_aux)) + 1);
        strcpy(t_aux[k], aux_aux);
      }
      else
      {
        
      }

      free(aux_aux);
    }

  }

  if (howMany)
  {
    printf("%d Melhores %d\n", commands, most_wins);
  }
  else
  {
    
  }

  for (k = 0; k < howMany; k++)
  {
    printf("%d * %s\n", commands, t_aux[k]);
    free(t_aux[k]);
  }

  free(t_aux);
  free(t);
}

int main()
{
  int score1;
  int score2;
  char command;
  char *name;
  char *team1;
  char *team2;
  init_hashT();
  init_hashG();
  name = (char *) malloc((sizeof(char)) * 1025);
  team2 = (char *) malloc((sizeof(char)) * 1025);
  team1 = (char *) malloc((sizeof(char)) * 1025);
  while ((command = getchar()) != 'x')
  {
    switch (command)
    {
      case 'a':
        getchar();
        for (int name_index = 0; name_index < 10; name_index++)
      {
        name[name_index] = new_sym_var(sizeof(char) * 8);
      }

        name[10 - 1] = '\0';
        for (int team1_index = 0; team1_index < 10; team1_index++)
      {
        team1[team1_index] = new_sym_var(sizeof(char) * 8);
      }

        team1[10 - 1] = '\0';
        for (int team2_index = 0; team2_index < 10; team2_index++)
      {
        team2[team2_index] = new_sym_var(sizeof(char) * 8);
      }

        team2[10 - 1] = '\0';
        score1 = new_sym_var(sizeof(int) * 8);
        score2 = new_sym_var(sizeof(int) * 8);
        a(name, team1, team2, score1, score2);
        commands++;
        break;

      case 'l':
        l();
        commands++;
        break;

      case 'p':
        getchar();
        for (int name_index = 0; name_index < 10; name_index++)
      {
        name[name_index] = new_sym_var(sizeof(char) * 8);
      }

        name[10 - 1] = '\0';
        p(name);
        commands++;
        break;

      case 'r':
        getchar();
        for (int name_index = 0; name_index < 10; name_index++)
      {
        name[name_index] = new_sym_var(sizeof(char) * 8);
      }

        name[10 - 1] = '\0';
        r(name);
        commands++;
        break;

      case 's':
        getchar();
        for (int name_index = 0; name_index < 10; name_index++)
      {
        name[name_index] = new_sym_var(sizeof(char) * 8);
      }

        name[10 - 1] = '\0';
        score1 = new_sym_var(sizeof(int) * 8);
        score2 = new_sym_var(sizeof(int) * 8);
        s(name, score1, score2);
        commands++;
        break;

      case 'A':
        getchar();
        for (int name_index = 0; name_index < 10; name_index++)
      {
        name[name_index] = new_sym_var(sizeof(char) * 8);
      }

        name[10 - 1] = '\0';
        A(name);
        commands++;
        break;

      case 'P':
        getchar();
        for (int name_index = 0; name_index < 10; name_index++)
      {
        name[name_index] = new_sym_var(sizeof(char) * 8);
      }

        name[10 - 1] = '\0';
        P(name);
        commands++;
        break;

      case 'g':
        g();
        commands++;
        break;

    }

  }

  free(name);
  free(team1);
  free(team2);
  free_memory();
  return 0;
}

