/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "HASHTABLE.h"


unsigned int hash(char *str)
{
  unsigned int hash = 5381;
  while (*str)
  {
    hash = (33 * hash) ^ ((unsigned char) (*(str++)));
  }

  return hash;
}

equipaHash **criaEquipaHash()
{
  int i;
  equipaHash **equipaTable = malloc((sizeof(equipaHash)) * 503);
  for (i = 0; i < 503; i++)
  {
    *(equipaTable + i) = 0;
  }

  return equipaTable;
}

void freeEquipaHash(equipaHash **equipaTable)
{
  int i;
  equipaHash *current;
  equipaHash *next;
  for (i = 0; i < 503; i++)
  {
    current = *(equipaTable + i);
    while (current != 0)
    {
      next = current->collision;
      free(current->equipa);
      free(current);
      current = next;
    }

  }

  free(equipaTable);
}

equipaHash *encontraEquipa(equipaHash **equipaTable, char *chave)
{
  equipaHash *equipaPtr;
  int equipaIndex = hash(chave) % 503;
  for (equipaPtr = *(equipaTable + equipaIndex); (equipaPtr != 0) && (strcmp(equipaPtr->equipa, chave) != 0); equipaPtr = equipaPtr->collision)
    ;

  return equipaPtr;
}

void AddEquipa(equipaHash **equipaTable, char *chave)
{
  equipaHash *equipaPtr;
  int n = 0;
  int equipaIndex = hash(chave) % 503;
  equipaPtr = *(equipaTable + equipaIndex);
  if (equipaPtr != 0)
  {
    n = equipaPtr->bucketCheio;
  }
  else
  {
    
  }

  equipaPtr = encontraEquipa(equipaTable, chave);
  equipaPtr = malloc(sizeof(equipaHash));
  if (n > 0)
  {
    equipaPtr->bucketCheio = n + 1;
  }
  else
  {
    equipaPtr->bucketCheio = 1;
  }

  equipaPtr->equipa = malloc((sizeof(char)) * (strlen(chave) + 1));
  strcpy(equipaPtr->equipa, chave);
  equipaPtr->jogosGanhos = 0;
  equipaPtr->collision = *(equipaTable + equipaIndex);
  *(equipaTable + equipaIndex) = equipaPtr;
}

int jogosGanhos(equipaHash **equipaTable, char *chave)
{
  equipaHash *equipaPtr;
  equipaPtr = encontraEquipa(equipaTable, chave);
  if (equipaPtr != 0)
  {
    return equipaPtr->jogosGanhos;
  }
  else
  {
    
  }

  return 0;
}

void adicionaVitoria(equipaHash **equipaTable, char *chave)
{
  equipaHash *equipaPtr;
  equipaPtr = encontraEquipa(equipaTable, chave);
  equipaPtr->jogosGanhos++;
}

void removeVitoria(equipaHash **equipaTable, char *chave)
{
  equipaHash *equipaPtr;
  equipaPtr = encontraEquipa(equipaTable, chave);
  if (equipaPtr->jogosGanhos > 0)
  {
    equipaPtr->jogosGanhos--;
  }
  else
  {
    
  }

}

int equipasMaisJogos(equipaHash **equipaTable, char *tab_final[503])
{
  int i;
  int e = 0;
  int n;
  int max = 0;
  int a;
  char *tab_equipa[503];
  equipaHash *current;
  equipaHash *equipaPtr;
  for (i = 0; i < 503; i++)
  {
    equipaPtr = *(equipaTable + i);
    if (equipaPtr != 0)
    {
      for (a = 1; a <= equipaPtr->bucketCheio; a++)
      {
        for (current = *(equipaTable + i); (current != 0) && (current->bucketCheio != a); current = current->collision)
          ;

        if (current->jogosGanhos >= max)
        {
          max = current->jogosGanhos;
          tab_equipa[e] = malloc((sizeof(char)) * (strlen(current->equipa) + 1));
          strcpy(tab_equipa[e], current->equipa);
          e++;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  if (e > 0)
  {
    i = 0;
    for (n = 0; n < e; n++)
    {
      if (jogosGanhos(equipaTable, tab_equipa[n]) == max)
      {
        tab_final[i] = malloc((sizeof(char)) * (strlen(tab_equipa[n]) + 1));
        strcpy(tab_final[i], tab_equipa[n]);
        i++;
      }
      else
      {
        
      }

    }

    n = 0;
    while (n < e)
    {
      free(tab_equipa[n]);
      n++;
    }

    return i;
  }
  else
  {
    
  }

  return 0;
}

