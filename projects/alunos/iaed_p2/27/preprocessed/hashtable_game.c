#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include "hashtable_team.h"
#include "hashtable_game.h"


ht_game *ht_create_hgame(void)
{
  int i = 0;
  ht_game *hashtable = malloc((sizeof(ht_game)) * 1);
  hashtable->entries = malloc((sizeof(entry_game)) * 20000);
  for (; i < 20000; ++i)
  {
    hashtable->entries[i] = 0;
  }

  return hashtable;
}

entry_game *ht_pair_game(GAME *game)
{
  entry_game *entry = malloc(sizeof(entry_game));
  entry->game = game;
  entry->next = 0;
  return entry;
}

unsigned int hash_game(char *game)
{
  unsigned int value = 0;
  unsigned int i = 0;
  unsigned int len = strlen(game);
  for (; i < len; ++i)
  {
    value = (value * 37) + game[i];
  }

  value = value % 20000;
  return value;
}

void ht_set_game(int line, ht_game *hashtable, GAME *game)
{
  entry_game *prev = 0;
  unsigned int slot = hash_game(game->name);
  entry_game *entry = hashtable->entries[slot];
  if (entry == 0)
  {
    hashtable->entries[slot] = ht_pair_game(game);
    return;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->game->name, game->name) == 0)
    {
      printf("%d Jogo existente.\n", line);
      free(game->name);
      free(game);
      return;
    }
    else
    {
      
    }

    prev = entry;
    entry = prev->next;
  }

  prev->next = ht_pair_game(game);
}

GAME *ht_remove_game(ht_game *hashtable, ht_team *hashtable_team, GAME *game, GAME *linkedlist)
{
  entry_game *prev = 0;
  TEAM *aux = 0;
  unsigned int slot = hash_game(game->name);
  int idx = 0;
  entry_game *entry = hashtable->entries[slot];
  if (entry == 0)
  {
    return 0;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->game->name, game->name) == 0)
    {
      if (game->score[0] > game->score[1])
      {
        aux = ht_get_team(hashtable_team, game->team1->name);
        aux->gameswon--;
      }
      else
      {
        if (game->score[0] < game->score[1])
        {
          aux = ht_get_team(hashtable_team, game->team2->name);
          aux->gameswon--;
        }
        else
        {
          
        }

      }

      if ((entry->next == 0) && (idx == 0))
      {
        hashtable->entries[slot] = 0;
      }
      else
      {
        
      }

      if ((entry->next != 0) && (idx == 0))
      {
        hashtable->entries[slot] = entry->next;
      }
      else
      {
        
      }

      if ((entry->next == 0) && (idx != 0))
      {
        prev->next = 0;
      }
      else
      {
        
      }

      if ((entry->next != 0) && (idx != 0))
      {
        prev->next = entry->next;
      }
      else
      {
        
      }

      linkedlist = removeGameFromLinkedList(linkedlist, game);
      return linkedlist;
    }
    else
    {
      
    }

    prev = entry;
    entry = prev->next;
    ++idx;
  }

  return linkedlist;
}

GAME *ht_get_game(ht_game *hashtable, char *game)
{
  unsigned int slot = hash_game(game);
  entry_game *entry = hashtable->entries[slot];
  if (entry == 0)
  {
    return 0;
  }
  else
  {
    
  }

  while (entry != 0)
  {
    if (strcmp(entry->game->name, game) == 0)
    {
      return entry->game;
    }
    else
    {
      
    }

    entry = entry->next;
  }

  return 0;
}

void ht_dump_game(ht_game *hashtable)
{
  entry_game *temp = 0;
  entry_game *entry = 0;
  int i;
  for (i = 0; i < 20000; i++)
  {
    if (hashtable->entries[i] != 0)
    {
      entry = hashtable->entries[i];
      while (entry != 0)
      {
        temp = entry->next;
        free(entry->game->name);
        free(entry->game);
        free(entry);
        entry = temp;
      }

    }
    else
    {
      
    }

  }

}

GAME *addGame(int line, ht_game *hashtable, ht_team *hashtable_team, GAME *linkedlist)
{
  int score1 = 0;
  int score2 = 0;
  char *team1 = 0;
  char *team2 = 0;
  char name[1024] = "\0";
  GAME *game = 0;
  GAME *gameaux = 0;
  TEAM *team = 0;
  TEAM *teamaux = 0;
  team1 = malloc(1024);
  team2 = malloc(1024);
  for (int name_index = 0; name_index < 10; name_index++)
  {
    name[name_index] = new_sym_var(sizeof(char) * 8);
  }

  name[10 - 1] = '\0';
  for (int team1_index = 0; team1_index < 10; team1_index++)
  {
    team1[team1_index] = new_sym_var(sizeof(char) * 8);
  }

  team1[10 - 1] = '\0';
  for (int team2_index = 0; team2_index < 10; team2_index++)
  {
    team2[team2_index] = new_sym_var(sizeof(char) * 8);
  }

  team2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  game = (GAME *) calloc(1, sizeof(GAME));
  gameaux = ht_get_game(hashtable, name);
  if (gameaux != 0)
  {
    printf("%d Jogo existente.\n", line);
    free(game);
    free(team1);
    free(team2);
    return linkedlist;
  }
  else
  {
    
  }

  game->name = malloc(strlen(name) + 1);
  strcpy(game->name, name);
  team = ht_get_team(hashtable_team, team1);
  if (team != 0)
  {
    game->team1 = team;
  }
  else
  {
    printf("%d Equipa inexistente.\n", line);
    free(game->name);
    free(game);
    free(team1);
    free(team2);
    return linkedlist;
  }

  teamaux = ht_get_team(hashtable_team, team2);
  if (teamaux != 0)
  {
    game->team2 = teamaux;
  }
  else
  {
    printf("%d Equipa inexistente.\n", line);
    free(game->name);
    free(game);
    free(team1);
    free(team2);
    return linkedlist;
  }

  game->score[0] = score1;
  game->score[1] = score2;
  if (game->score[0] > game->score[1])
  {
    TEAM *pteam = ht_get_team(hashtable_team, game->team1->name);
    pteam->gameswon++;
  }
  else
  {
    if (game->score[1] > game->score[0])
    {
      TEAM *pteam = ht_get_team(hashtable_team, game->team2->name);
      pteam->gameswon++;
    }
    else
    {
      
    }

  }

  ht_set_game(line, hashtable, game);
  linkedlist = addGameToLinkedList(linkedlist, game);
  free(team1);
  free(team2);
  return linkedlist;
}

GAME *addGameToLinkedList(GAME *linkedlist, GAME *game)
{
  if (linkedlist == 0)
  {
    linkedlist = game;
  }
  else
  {
    GAME *paux = linkedlist;
    while (paux->pnext != 0)
    {
      paux = paux->pnext;
    }

    paux->pnext = game;
  }

  return linkedlist;
}

GAME *removeGameFromLinkedList(GAME *linkedlist, GAME *game)
{
  int idx = 0;
  GAME *prev = 0;
  GAME *paux = linkedlist;
  while (paux != 0)
  {
    if (strcmp(paux->name, game->name) == 0)
    {
      if ((paux->pnext == 0) && (idx == 0))
      {
        linkedlist = 0;
      }
      else
      {
        
      }

      if ((paux->pnext != 0) && (idx == 0))
      {
        linkedlist = paux->pnext;
      }
      else
      {
        
      }

      if ((paux->pnext == 0) && (idx != 0))
      {
        prev->pnext = 0;
      }
      else
      {
        
      }

      if ((paux->pnext != 0) && (idx != 0))
      {
        prev->pnext = paux->pnext;
      }
      else
      {
        
      }

      free(paux);
      return linkedlist;
    }
    else
    {
      
    }

    prev = paux;
    paux = prev->pnext;
    ++idx;
  }

  return linkedlist;
}

