#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int hash(char *v, int M)
{
  int h;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*v) != '\0'; v++, a = (a * b) % (M - 1))
    h = ((a * h) + (*v)) % M;

  return h;
}

typedef struct EQUIPAS
{
  char *nome;
  int score;
} equipa;
typedef struct LISTA_EQUIPAS
{
  equipa *equipa;
  struct LISTA_EQUIPAS *next;
} hash_equipa;
void organiza_lexic(equipa *equipa, hash_equipa **equipas_lexic)
{
  hash_equipa *j;
  hash_equipa *ord;
  hash_equipa *anterior;
  j = malloc(sizeof(hash_equipa));
  j->equipa = equipa;
  j->next = 0;
  if ((*equipas_lexic) == 0)
  {
    *equipas_lexic = j;
  }
  else
  {
    for (ord = *equipas_lexic, anterior = 0; ord != 0; anterior = ord, ord = ord->next)
    {
      if (strcmp(j->equipa->nome, ord->equipa->nome) < 0)
      {
        if (ord == (*equipas_lexic))
        {
          j->next = *equipas_lexic;
          *equipas_lexic = j;
        }
        else
        {
          anterior->next = j;
          j->next = ord;
        }

      }
      else
      {
        if ((strcmp(j->equipa->nome, ord->equipa->nome) > 0) && (ord->next == 0))
        {
          ord->next = j;
          j->next = 0;
        }
        else
        {
          
        }

      }

    }

  }

}

equipa *procura_equipa(hash_equipa **hashtable_e, char *nome)
{
  hash_equipa *j;
  int indice;
  indice = hash(nome, 509);
  for (j = hashtable_e[indice]; j != 0; j = j->next)
  {
    if (strcmp(j->equipa->nome, nome) == 0)
    {
      return j->equipa;
    }
    else
    {
      
    }

  }

  return 0;
}

equipa *cria_equipa(char *nome)
{
  equipa *e;
  e = malloc(sizeof(equipa));
  e->nome = malloc((strlen(nome) + 1) * (sizeof(char)));
  e->score = 0;
  strcpy(e->nome, nome);
  return e;
}

void adiciona_equipa(hash_equipa **hashtable_e, int NL, hash_equipa **equipas_lexic)
{
  hash_equipa *j;
  int indice;
  char buffer[1024];
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  indice = hash(buffer, 509);
  if (procura_equipa(hashtable_e, buffer) != 0)
  {
    printf("%d Equipa existente.\n", NL);
  }
  else
  {
    j = malloc(sizeof(hash_equipa));
    j->equipa = cria_equipa(buffer);
    j->next = hashtable_e[indice];
    hashtable_e[indice] = j;
    organiza_lexic(j->equipa, equipas_lexic);
  }

}

hash_equipa **cria_hashtable_equipa(int m)
{
  int i;
  hash_equipa **heads = malloc(m * (sizeof(hash_equipa)));
  for (i = 0; i < m; ++i)
    heads[i] = 0;

  return heads;
}

int procura_maximo(hash_equipa *equipas_lexic)
{
  int max;
  hash_equipa *j;
  max = 0;
  for (j = equipas_lexic; j != 0; j = j->next)
  {
    if (j->equipa->score > max)
    {
      max = j->equipa->score;
    }
    else
    {
      
    }

  }

  return max;
}

void mais_jogos_ganhos(hash_equipa *equipas_lexic, int NL, int max)
{
  hash_equipa *j;
  if (equipas_lexic != 0)
  {
    printf("%d Melhores %d\n", NL, max);
    for (j = equipas_lexic; j != 0; j = j->next)
    {
      if (j->equipa->score == max)
      {
        printf("%d * %s\n", NL, j->equipa->nome);
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

}

typedef struct JOGOS
{
  char *nome;
  equipa *equipa1;
  equipa *equipa2;
  int score1;
  int score2;
} jogo;
typedef struct LISTA_JOGOS
{
  jogo *jogo;
  struct LISTA_JOGOS *next;
} hash_jogo;
jogo *procura_jogo(hash_jogo **hashtable_j, char *nome)
{
  hash_jogo *i;
  int indice;
  indice = hash(nome, 509);
  for (i = hashtable_j[indice]; i != 0; i = i->next)
  {
    if (strcmp(i->jogo->nome, nome) == 0)
    {
      return i->jogo;
    }
    else
    {
      
    }

  }

  return 0;
}

jogo *cria_jogo(hash_equipa **hashtable_e, char *nome, char *equipa1, char *equipa2, int score1, int score2)
{
  jogo *j;
  j = malloc(sizeof(jogo));
  j->nome = malloc((sizeof(char)) * (strlen(nome) + 1));
  strcpy(j->nome, nome);
  j->equipa1 = procura_equipa(hashtable_e, equipa1);
  j->equipa2 = procura_equipa(hashtable_e, equipa2);
  j->score1 = score1;
  j->score2 = score2;
  return j;
}

void adiciona_jogo(hash_jogo **hashtable_j, hash_equipa **hashtable_e, int NL, hash_jogo **jogos_ordem)
{
  hash_jogo *j;
  hash_jogo *ord;
  int indice;
  int score1;
  int score2;
  char jogo[1024];
  char equipa1[1024];
  char equipa2[1024];
  for (int jogo_index = 0; jogo_index < 10; jogo_index++)
  {
    jogo[jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  jogo[10 - 1] = '\0';
  for (int equipa1_index = 0; equipa1_index < 10; equipa1_index++)
  {
    equipa1[equipa1_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa1[10 - 1] = '\0';
  for (int equipa2_index = 0; equipa2_index < 10; equipa2_index++)
  {
    equipa2[equipa2_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa2[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  indice = hash(jogo, 509);
  if (procura_jogo(hashtable_j, jogo) != 0)
  {
    printf("%d Jogo Existente.\n", NL);
  }
  else
  {
    if ((procura_equipa(hashtable_e, equipa1) == 0) || (procura_equipa(hashtable_e, equipa2) == 0))
    {
      printf("%d Equipa inexistente.\n", NL);
    }
    else
    {
      j = malloc(sizeof(hash_jogo));
      j->jogo = cria_jogo(hashtable_e, jogo, equipa1, equipa2, score1, score2);
      ord = malloc(sizeof(hash_jogo));
      ord->jogo = j->jogo;
      if (score1 > score2)
      {
        j->jogo->equipa1->score += 1;
      }
      else
      {
        if (score1 < score2)
        {
          j->jogo->equipa2->score += 1;
        }
        else
        {
          
        }

      }

      j->next = hashtable_j[indice];
      hashtable_j[indice] = j;
      ord->next = *jogos_ordem;
      *jogos_ordem = ord;
    }

  }

}

void compara_scores(int a, int b, equipa *equipa1, equipa *equipa2)
{
  if ((a > 0) && (b == 0))
  {
    equipa1->score -= 1;
  }
  else
  {
    if ((a < 0) && (b == 0))
    {
      equipa2->score -= 1;
    }
    else
    {
      if ((a == 0) && (b > 0))
      {
        equipa1->score += 1;
      }
      else
      {
        if ((a == 0) && (b < 0))
        {
          equipa2->score += 1;
        }
        else
        {
          if ((a < 0) && (b > 0))
          {
            equipa1->score += 1;
            equipa2->score -= 1;
          }
          else
          {
            if ((a > 0) && (b < 0))
            {
              equipa1->score -= 1;
              equipa2->score += 1;
            }
            else
            {
              
            }

          }

        }

      }

    }

  }

}

void altera_pontuacao(hash_jogo **hashtable_j, int NL)
{
  jogo *j;
  char jogo[1024];
  int score1;
  int score2;
  for (int jogo_index = 0; jogo_index < 10; jogo_index++)
  {
    jogo[jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  jogo[10 - 1] = '\0';
  score1 = new_sym_var(sizeof(int) * 8);
  score2 = new_sym_var(sizeof(int) * 8);
  if (procura_jogo(hashtable_j, jogo) == 0)
  {
    printf("%d Jogo inexistente.\n", NL);
  }
  else
  {
    j = procura_jogo(hashtable_j, jogo);
    compara_scores(j->score1 - j->score2, score1 - score2, j->equipa1, j->equipa2);
    j->score1 = score1;
    j->score2 = score2;
  }

}

void apaga_jogo_ordenado(hash_jogo **jogos_ordem, char *jogo)
{
  hash_jogo *j;
  hash_jogo *anterior;
  for (j = *jogos_ordem, anterior = 0; j != 0; anterior = j, j = j->next)
  {
    if (strcmp(j->jogo->nome, jogo) == 0)
    {
      if (j == (*jogos_ordem))
      {
        *jogos_ordem = j->next;
      }
      else
      {
        anterior->next = j->next;
        free(j);
        break;
      }

    }
    else
    {
      
    }

  }

}

void apaga_jogo_main(hash_jogo **hashtable_j, int NL, hash_jogo **jogos_ordem)
{
  hash_jogo *j;
  hash_jogo *anterior;
  char jogo[1024];
  int indice;
  for (int jogo_index = 0; jogo_index < 10; jogo_index++)
  {
    jogo[jogo_index] = new_sym_var(sizeof(char) * 8);
  }

  jogo[10 - 1] = '\0';
  if (procura_jogo(hashtable_j, jogo) == 0)
  {
    printf("%d Jogo inexistente.\n", NL);
  }
  else
  {
    indice = hash(jogo, 509);
    for (j = hashtable_j[indice], anterior = 0; j != 0; anterior = j, j = j->next)
    {
      if (strcmp(j->jogo->nome, jogo) == 0)
      {
        if (j == hashtable_j[indice])
        {
          hashtable_j[indice] = j->next;
        }
        else
        {
          anterior->next = j->next;
        }

        compara_scores(j->jogo->score1 - j->jogo->score2, 0, j->jogo->equipa1, j->jogo->equipa2);
        apaga_jogo_ordenado(jogos_ordem, jogo);
        free(j->jogo->nome);
        free(j->jogo);
        free(j);
        break;
      }
      else
      {
        
      }

    }

  }

}

void lista_jogos(hash_jogo *jogos_ordem, int NL)
{
  if (jogos_ordem == 0)
  {
    return;
  }
  else
  {
    
  }

  lista_jogos(jogos_ordem->next, NL);
  printf("%d %s %s ", NL, jogos_ordem->jogo->nome, jogos_ordem->jogo->equipa1->nome);
  printf("%s %d %d\n", jogos_ordem->jogo->equipa2->nome, jogos_ordem->jogo->score1, jogos_ordem->jogo->score2);
}

hash_jogo **cria_hashtable_jogo(int m)
{
  int i;
  hash_jogo **heads = malloc(m * (sizeof(hash_jogo)));
  for (i = 0; i < m; ++i)
    heads[i] = 0;

  return heads;
}

void liberta(hash_equipa **hashtable_e, hash_jogo **hashtable_j, hash_equipa **equipas_lexic, hash_jogo **jogos_ordem)
{
  int indice;
  hash_jogo *j;
  hash_jogo *q;
  hash_equipa *i;
  hash_equipa *k;
  for (indice = 0; indice < 509; ++indice)
  {
    for (j = hashtable_j[indice]; j != 0; j = q)
    {
      q = j->next;
      free(j->jogo->nome);
      free(j->jogo);
      free(j);
    }

  }

  free(hashtable_j);
  for (j = *jogos_ordem; j != 0; j = q)
  {
    q = j->next;
    free(j);
  }

  for (i = *equipas_lexic; i != 0; i = k)
  {
    k = i->next;
    free(i);
  }

  for (indice = 0; indice < 509; ++indice)
  {
    for (i = hashtable_e[indice]; i != 0; i = k)
    {
      k = i->next;
      free(i->equipa->nome);
      free(i->equipa);
      free(i);
    }

  }

  free(hashtable_e);
}

int main()
{
  hash_equipa **hashtable_e;
  hash_equipa *equipas_lexic;
  hash_jogo **hashtable_j;
  hash_jogo *jogos_ordem;
  equipa *equipa;
  jogo *jogo;
  char cmnd;
  char buffer[1024];
  int NL;
  int max;
  hashtable_e = cria_hashtable_equipa(509);
  hashtable_j = cria_hashtable_jogo(509);
  NL = 0;
  max = 0;
  jogos_ordem = 0;
  equipas_lexic = 0;
  while (1 != 'x')
  {
    cmnd = new_sym_var(sizeof(char) * 8);
    ++NL;
    switch (cmnd)
    {
      case 'a':
        adiciona_jogo(hashtable_j, hashtable_e, NL, &jogos_ordem);
        break;

      case 'A':
        adiciona_equipa(hashtable_e, NL, &equipas_lexic);
        break;

      case 'l':
        lista_jogos(jogos_ordem, NL);
        break;

      case 'P':
        for (int buffer_index = 0; buffer_index < 10; buffer_index++)
      {
        buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
      }

        buffer[10 - 1] = '\0';
        equipa = procura_equipa(hashtable_e, buffer);
        if (equipa != 0)
      {
        printf("%d %s %d\n", NL, equipa->nome, equipa->score);
      }
      else
      {
        printf("%d Equipa inexistente.\n", NL);
      }

        break;

      case 'p':
        for (int buffer_index = 0; buffer_index < 10; buffer_index++)
      {
        buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
      }

        buffer[10 - 1] = '\0';
        jogo = procura_jogo(hashtable_j, buffer);
        if (jogo != 0)
      {
        printf("%d %s %s %s %d %d\n", NL, jogo->nome, jogo->equipa1->nome, jogo->equipa2->nome, jogo->score1, jogo->score2);
      }
      else
      {
        printf("%d Jogo inexistente.\n", NL);
      }

        break;

      case 's':
        altera_pontuacao(hashtable_j, NL);
        break;

      case 'r':
        apaga_jogo_main(hashtable_j, NL, &jogos_ordem);
        break;

      case 'g':
        max = procura_maximo(equipas_lexic);
        mais_jogos_ganhos(equipas_lexic, NL, max);
        break;

      case 'x':
        liberta(hashtable_e, hashtable_j, &equipas_lexic, &jogos_ordem);
        return 0;
        break;

    }

    getchar();
  }

  return 0;
}

