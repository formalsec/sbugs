#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "linkedlist.h"
#include "estruturas.h"


ListNode *new_node(void *structPointer)
{
  ListNode *p = malloc(sizeof(ListNode));
  if (!p)
  {
    perror("new_node: no memory for a new node");
    exit(1);
  }
  else
  {
    
  }

  p->structPointer = structPointer;
  p->prev = 0;
  p->next = 0;
  return p;
}

ListNode *push(ListNode **head_ref, void *structPointer)
{
  ListNode *p = new_node(structPointer);
  p->next = *head_ref;
  if ((*head_ref) != 0)
  {
    (*head_ref)->prev = p;
  }
  else
  {
    
  }

  *head_ref = p;
  return p;
}

void printList(ListNode *tail, int inputLine)
{
  while (tail != 0)
  {
    printNodeJogo(tail, inputLine);
    tail = tail->prev;
  }

}

int changeScore(ListNode *node, int newScore1, int newScore2)
{
  int prevScore1 = ((struct jogo *) node->structPointer)->score1;
  int prevScore2 = ((struct jogo *) node->structPointer)->score2;
  ((struct jogo *) node->structPointer)->score1 = newScore1;
  ((struct jogo *) node->structPointer)->score2 = newScore2;
  if (((prevScore1 - prevScore2) > 0) && ((newScore1 - newScore2) < 0))
  {
    return 2;
  }
  else
  {
    
  }

  if (((prevScore1 - prevScore2) < 0) && ((newScore1 - newScore2) > 0))
  {
    return 1;
  }
  else
  {
    
  }

  if (((prevScore1 - prevScore2) == 0) && ((newScore1 - newScore2) > 0))
  {
    return 3;
  }
  else
  {
    
  }

  if (((prevScore1 - prevScore2) == 0) && ((newScore1 - newScore2) < 0))
  {
    return 4;
  }
  else
  {
    
  }

  if (((prevScore1 - prevScore2) > 0) && ((newScore1 - newScore2) == 0))
  {
    return 5;
  }
  else
  {
    
  }

  if (((prevScore1 - prevScore2) < 0) && ((newScore1 - newScore2) == 0))
  {
    return 6;
  }
  else
  {
    
  }

  return 0;
}

char *winningTeam(ListNode *node)
{
  int Score1 = ((struct jogo *) node->structPointer)->score1;
  int Score2 = ((struct jogo *) node->structPointer)->score2;
  if (Score1 > Score2)
  {
    return ((struct jogo *) node->structPointer)->equipa1;
  }
  else
  {
    
  }

  if (Score1 < Score2)
  {
    return ((struct jogo *) node->structPointer)->equipa2;
  }
  else
  {
    
  }

  return 0;
}

void printNodeJogo(ListNode *node, int inputLine)
{
  printf("%d %s %s %s %d %d\n", inputLine, ((struct jogo *) node->structPointer)->nome, ((struct jogo *) node->structPointer)->equipa1, ((struct jogo *) node->structPointer)->equipa2, ((struct jogo *) node->structPointer)->score1, ((struct jogo *) node->structPointer)->score2);
}

void printNodeEquipa(ListNode *node, int inputLine)
{
  printf("%d %s %d\n", inputLine, ((struct equipa *) node->structPointer)->nome, ((struct equipa *) node->structPointer)->jogosGanhos);
}

void printBestTeams(ListNode **head_ref, int inputLine)
{
  int max;
  ListNode *current = *head_ref;
  if ((*head_ref) == 0)
  {
    return;
  }
  else
  {
    
  }

  max = ((struct equipa *) current->structPointer)->jogosGanhos;
  printf("%d Melhores %d\n", inputLine, max);
  while (((struct equipa *) current->structPointer)->jogosGanhos == max)
  {
    printf("%d * %s\n", inputLine, ((struct equipa *) current->structPointer)->nome);
    current = current->next;
    if (current == 0)
    {
      return;
    }
    else
    {
      
    }

  }

}

void deleteListNode(ListNode **head_ref, ListNode **tail_ref, ListNode *del)
{
  if (((*head_ref) == 0) || (del == 0))
  {
    return;
  }
  else
  {
    
  }

  if ((*tail_ref) == del)
  {
    *tail_ref = del->prev;
  }
  else
  {
    
  }

  if ((*head_ref) == del)
  {
    *head_ref = del->next;
  }
  else
  {
    
  }

  if (del->next != 0)
  {
    del->next->prev = del->prev;
  }
  else
  {
    
  }

  if (del->prev != 0)
  {
    del->prev->next = del->next;
  }
  else
  {
    
  }

  free(del);
  return;
}

void free_dlistJogo(ListNode *head)
{
  if (!head)
  {
    return;
  }
  else
  {
    
  }

  free_dlistJogo(head->next);
  freeGame((jogo *) head->structPointer);
  free(head);
}

void free_dlistEquipa(ListNode *head)
{
  if (!head)
  {
    return;
  }
  else
  {
    
  }

  free_dlistEquipa(head->next);
  freeEquipa((equipa *) head->structPointer);
  free(head);
}

void free_dlist(ListNode *head)
{
  if (!head)
  {
    return;
  }
  else
  {
    
  }

  free_dlist(head->next);
  free(head);
}

void splitList(ListNode *source, ListNode **frontRef, ListNode **backRef)
{
  ListNode *fast;
  ListNode *slow;
  slow = source;
  fast = source->next;
  while (fast != 0)
  {
    fast = fast->next;
    if (fast != 0)
    {
      slow = slow->next;
      fast = fast->next;
    }
    else
    {
      
    }

  }

  *frontRef = source;
  *backRef = slow->next;
  slow->next = 0;
}

ListNode *sortedMerge(ListNode *a, ListNode *b)
{
  ListNode *result = 0;
  if (a == 0)
  {
    return b;
  }
  else
  {
    if (b == 0)
    {
      return a;
    }
    else
    {
      
    }

  }

  if (strcmp(((struct equipa *) a->structPointer)->nome, ((struct equipa *) b->structPointer)->nome) <= 0)
  {
    result = a;
    result->next = sortedMerge(a->next, b);
  }
  else
  {
    result = b;
    result->next = sortedMerge(a, b->next);
  }

  return result;
}

void mergeSort(ListNode **head_ref)
{
  ListNode *head = *head_ref;
  ListNode *a;
  ListNode *b;
  if ((head == 0) || (head->next == 0))
  {
    return;
  }
  else
  {
    
  }

  splitList(head, &a, &b);
  mergeSort(&a);
  mergeSort(&b);
  *head_ref = sortedMerge(a, b);
}

