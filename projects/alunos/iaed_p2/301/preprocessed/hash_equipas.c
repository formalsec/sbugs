/*File generated by PreProcessor.py*/


#include "structs.h"
#include <string.h>
#include <stdio.h>


int hash(char *nome, int M)
{
  int h = 0;
  int a = 127;
  for (; (*nome) != '\0'; nome++)
    h = ((a * h) + (*nome)) % M;

  return h;
}

Hash_tableEq *init_tableEq(int size_table)
{
  Hash_tableEq *new_t = (Hash_tableEq *) malloc(sizeof(Hash_tableEq));
  new_t->capacity = size_table;
  new_t->table = (Hash_nodeEq **) calloc(new_t->capacity, sizeof(Hash_nodeEq *));
  return new_t;
}

void insertEquipa_T(Hash_tableEq *t, NodeEq *equipaIns)
{
  int i = hash(equipaIns->nome, t->capacity);
  if (t->table[i] == 0)
  {
    Hash_nodeEq *head = 0;
    head = insertEquipa_N(head, equipaIns);
    t->table[i] = head;
  }
  else
  {
    Hash_nodeEq *head = t->table[i];
    insertEquipa_N(head, equipaIns);
  }

}

Hash_nodeEq *insertEquipa_N(Hash_nodeEq *head, NodeEq *equipaIns)
{
  Hash_nodeEq *new = (Hash_nodeEq *) malloc(sizeof(Hash_nodeEq));
  new->equipa = equipaIns;
  new->next = 0;
  if (head == 0)
  {
    head = new;
    return head;
  }
  else
  {
    Hash_nodeEq *actual = head;
    while (actual->next != 0)
    {
      actual = actual->next;
    }

    actual->next = new;
  }

  return new;
}

void printTableEq(Hash_tableEq *t)
{
  int i;
  int vazios = 0;
  int colisoes = 0;
  for (i = 0; i < t->capacity; i++)
  {
    Hash_nodeEq *head = t->table[i];
    printf("%d: ", i);
    if (head == 0)
    {
      vazios++;
      printf("NULL");
    }
    else
    {
      Hash_nodeEq *current = head;
      colisoes--;
      while (current != 0)
      {
        colisoes++;
        printf("%s ", current->equipa->nome);
        current = current->next;
      }

    }

    printf("\n");
  }

  printf("Numero de vazios: %d\n", vazios);
  printf("Numero de colisoes: %d\n", colisoes);
}

void destroyTableEq(Hash_tableEq *t)
{
  int i;
  Hash_nodeEq *node;
  Hash_nodeEq *next;
  for (i = 0; i < t->capacity; i++)
  {
    node = t->table[i];
    while (node != 0)
    {
      next = node->next;
      free(node);
      node = next;
    }

  }

  free(t->table);
  free(t);
}

