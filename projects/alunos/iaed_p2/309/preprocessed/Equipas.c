#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "Structs_Jogos.h"
#include "Structs_Equipas.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int Hashcode(char *nome)
{
  int h = 0;
  int a = 127;
  int M = 1997;
  for (; (*nome) != '\0'; nome++)
    h = ((a * h) + (*nome)) % M;

  return h;
}

hashtable *CreateHash()
{
  hashtable *tb = malloc(sizeof(hashtable));
  tb->heads = calloc(1997, sizeof(hash_node *));
  return tb;
}

hash_node *AddNode(Equipa *new, hash_node *next)
{
  hash_node *nn = malloc(sizeof(hash_node));
  nn->pointer = new;
  nn->next = next;
  return nn;
}

int CheckTeam(hashtable *tb, char *buffer, int key)
{
  hash_node *n;
  for (n = tb->heads[key]; n != 0; n = n->next)
  {
    if (strcmp(n->pointer->nome, buffer) == 0)
    {
      return 0;
    }
    else
    {
      
    }

  }

  return 1;
}

Equipa *AddTeam(int NL, Equipa *headE, hashtable *hash)
{
  Equipa *new;
  char buffer[1024];
  int key;
  getchar();
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  key = Hashcode(buffer);
  if (CheckTeam(hash, buffer, key))
  {
    new = malloc(sizeof(Equipa));
    new->nome = malloc((sizeof(char)) * (strlen(buffer) + 1));
    strcpy(new->nome, buffer);
    new->cont_ganhos = 0;
    new->next = headE;
    headE = new;
    hash->heads[key] = AddNode(new, hash->heads[key]);
  }
  else
  {
    printf("%d Equipa existente.\n", NL);
  }

  return headE;
}

void SearchTeam(int NL, hashtable *hash)
{
  hash_node *n;
  char buffer[1024];
  int key;
  getchar();
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  key = Hashcode(buffer);
  if (!CheckTeam(hash, buffer, key))
  {
    for (n = hash->heads[key]; n != 0; n = n->next)
    {
      if (strcmp(n->pointer->nome, buffer) == 0)
      {
        printf("%d %s %d\n", NL, n->pointer->nome, n->pointer->cont_ganhos);
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    printf("%d Equipa inexistente.\n", NL);
  }

}

void AlphabeticalSort(char **vetor, int contador)
{
  char *aux;
  int i;
  int j;
  for (i = 1; i < contador; i++)
  {
    for (j = 1; j < contador; j++)
    {
      if (strcmp(vetor[j - 1], vetor[j]) > 0)
      {
        aux = vetor[j - 1];
        vetor[j - 1] = vetor[j];
        vetor[j] = aux;
      }
      else
      {
        
      }

    }

  }

}

void FindTeamsWithMaxVictories(int NL, Equipa *headE)
{
  char **vetor;
  Equipa *atual = headE;
  Equipa *atual2 = headE;
  int contador = 0;
  int max = -1;
  int i = 0;
  if (headE)
  {
    while (atual != 0)
    {
      if (atual->cont_ganhos > max)
      {
        contador = 1;
        max = atual->cont_ganhos;
      }
      else
      {
        if (atual->cont_ganhos == max)
        {
          contador += 1;
        }
        else
        {
          
        }

      }

      atual = atual->next;
    }

    vetor = malloc((sizeof(char *)) * contador);
    while (atual2 != 0)
    {
      if (atual2->cont_ganhos == max)
      {
        vetor[i] = malloc((sizeof(char)) * (strlen(atual2->nome) + 1));
        strcpy(vetor[i], atual2->nome);
        i += 1;
      }
      else
      {
        
      }

      atual2 = atual2->next;
    }

    AlphabeticalSort(vetor, contador);
    printf("%d Melhores %d\n", NL, max);
    for (i = 0; i < contador; i++)
    {
      printf("%d * %s\n", NL, vetor[i]);
      free(vetor[i]);
    }

    free(vetor);
  }
  else
  {
    
  }

}

void DestroyE(Equipa *headE)
{
  while (headE != 0)
  {
    Equipa *temp = headE;
    headE = headE->next;
    free(temp->nome);
    free(temp);
  }

}

void DestroyH(hashtable *tb)
{
  hash_node *temp;
  size_t i;
  for (i = 0; i < 1997; i++)
  {
    while (tb->heads[i])
    {
      temp = tb->heads[i]->next;
      free(tb->heads[i]);
      tb->heads[i] = temp;
    }

  }

  free(tb->heads);
  free(tb);
}

