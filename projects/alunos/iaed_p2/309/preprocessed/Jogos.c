#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "Structs_Jogos.h"
#include "Structs_Equipas.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


hashtable2 *CreateHash2()
{
  hashtable2 *tb = malloc(sizeof(hashtable2));
  tb->heads2 = calloc(1997, sizeof(hash_node2 *));
  return tb;
}

hash_node2 *AddNode2(Node_Jogo *new, hash_node2 *next)
{
  hash_node2 *nn = malloc(sizeof(hash_node2));
  nn->pointer2 = new;
  nn->next2 = next;
  return nn;
}

void DeleteNode2(hashtable2 *hash2, hash_node2 *n, int key)
{
  hash_node2 *atual;
  hash_node2 *seguinte;
  atual = hash2->heads2[key];
  seguinte = hash2->heads2[key]->next2;
  if (n == atual)
  {
    hash2->heads2[key] = seguinte;
    free(atual);
  }
  else
  {
    while (n != seguinte)
    {
      atual = atual->next2;
      seguinte = seguinte->next2;
    }

    if (seguinte->next2 == 0)
    {
      atual->next2 = 0;
      free(seguinte);
    }
    else
    {
      atual->next2 = seguinte->next2;
      free(seguinte);
    }

  }

}

Jogo *CreateGameList()
{
  Jogo *l = malloc(sizeof(Jogo));
  l->head = (l->last = 0);
  return l;
}

int CheckGame(hashtable2 *tb, char *buffer, int key)
{
  hash_node2 *n;
  for (n = tb->heads2[key]; n != 0; n = n->next2)
  {
    if (strcmp(n->pointer2->nomej, buffer) == 0)
    {
      return 0;
    }
    else
    {
      
    }

  }

  return 1;
}

void IncreaseWins(hashtable *tb, char *buffer, int key)
{
  hash_node *n;
  for (n = tb->heads[key]; n != 0; n = n->next)
  {
    if (strcmp(n->pointer->nome, buffer) == 0)
    {
      n->pointer->cont_ganhos += 1;
      break;
    }
    else
    {
      
    }

  }

}

void DecreaseWins(hashtable *tb, char *buffer, int key)
{
  hash_node *n;
  for (n = tb->heads[key]; n != 0; n = n->next)
  {
    if (strcmp(n->pointer->nome, buffer) == 0)
    {
      if (n->pointer->cont_ganhos == 0)
      {
        break;
      }
      else
      {
        n->pointer->cont_ganhos -= 1;
        break;
      }

    }
    else
    {
      
    }

  }

}

void ChangeWins(int s1, int s2, int snew1, int snew2, hashtable *hash, hash_node2 *n)
{
  int key2 = Hashcode(n->pointer2->equipa1);
  int key3 = Hashcode(n->pointer2->equipa2);
  if ((s1 > s2) && (snew1 < snew2))
  {
    DecreaseWins(hash, n->pointer2->equipa1, key2);
    IncreaseWins(hash, n->pointer2->equipa2, key3);
  }
  else
  {
    if ((s2 > s1) && (snew2 < snew1))
    {
      DecreaseWins(hash, n->pointer2->equipa2, key3);
      IncreaseWins(hash, n->pointer2->equipa1, key2);
    }
    else
    {
      if (s1 == s2)
      {
        if (snew2 < snew1)
        {
          IncreaseWins(hash, n->pointer2->equipa1, key2);
        }
        else
        {
          if (snew1 < snew2)
          {
            IncreaseWins(hash, n->pointer2->equipa2, key3);
          }
          else
          {
            
          }

        }

      }
      else
      {
        if (snew1 == snew2)
        {
          if (s1 > s2)
          {
            DecreaseWins(hash, n->pointer2->equipa1, key2);
          }
          else
          {
            if (s2 > s1)
            {
              DecreaseWins(hash, n->pointer2->equipa2, key3);
            }
            else
            {
              
            }

          }

        }
        else
        {
          
        }

      }

    }

  }

}

void AddGame(int NL, Jogo *headJ, hashtable *hash, hashtable2 *hash2)
{
  Node_Jogo *new;
  char buffer1[1024];
  char buffer2[1024];
  char buffer3[1024];
  int s1;
  int s2;
  int key;
  int key2;
  int key3;
  getchar();
  for (int buffer1_index = 0; buffer1_index < 10; buffer1_index++)
  {
    buffer1[buffer1_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer1[10 - 1] = '\0';
  for (int buffer2_index = 0; buffer2_index < 10; buffer2_index++)
  {
    buffer2[buffer2_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer2[10 - 1] = '\0';
  for (int buffer3_index = 0; buffer3_index < 10; buffer3_index++)
  {
    buffer3[buffer3_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer3[10 - 1] = '\0';
  s1 = new_sym_var(sizeof(int) * 8);
  s2 = new_sym_var(sizeof(int) * 8);
  key = Hashcode(buffer1), key2 = Hashcode(buffer2), key3 = Hashcode(buffer3);
  if (CheckGame(hash2, buffer1, key))
  {
    if ((!CheckTeam(hash, buffer2, key2)) && (!CheckTeam(hash, buffer3, key3)))
    {
      new = malloc(sizeof(Node_Jogo));
      new->previous2 = headJ->last;
      new->next2 = 0;
      new->nomej = malloc((sizeof(char)) * (strlen(buffer1) + 1));
      new->equipa1 = malloc((sizeof(char)) * (strlen(buffer2) + 1));
      new->equipa2 = malloc((sizeof(char)) * (strlen(buffer3) + 1));
      strcpy(new->nomej, buffer1);
      strcpy(new->equipa1, buffer2);
      strcpy(new->equipa2, buffer3);
      new->score1 = s1;
      new->score2 = s2;
      if (headJ->last)
      {
        headJ->last->next2 = new;
      }
      else
      {
        headJ->head = new;
      }

      headJ->last = new;
      if (s1 > s2)
      {
        IncreaseWins(hash, buffer2, key2);
      }
      else
      {
        if (s2 > s1)
        {
          IncreaseWins(hash, buffer3, key3);
        }
        else
        {
          
        }

      }

      hash2->heads2[key] = AddNode2(new, hash2->heads2[key]);
    }
    else
    {
      printf("%d Equipa inexistente.\n", NL);
    }

  }
  else
  {
    printf("%d Jogo existente.\n", NL);
  }

}

void SearchGame(int NL, hashtable2 *hash2)
{
  hash_node2 *n;
  char buffer[1024];
  int key;
  getchar();
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  key = Hashcode(buffer);
  if (!CheckGame(hash2, buffer, key))
  {
    for (n = hash2->heads2[key]; n != 0; n = n->next2)
    {
      if (strcmp(n->pointer2->nomej, buffer) == 0)
      {
        printf("%d %s %s %s %d %d\n", NL, n->pointer2->nomej, n->pointer2->equipa1, n->pointer2->equipa2, n->pointer2->score1, n->pointer2->score2);
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    printf("%d Jogo inexistente.\n", NL);
  }

}

void ChangeScore(int NL, hashtable *hash, hashtable2 *hash2)
{
  hash_node2 *n;
  char buffer[1024];
  int key;
  int snew1;
  int snew2;
  getchar();
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  snew1 = new_sym_var(sizeof(int) * 8);
  snew2 = new_sym_var(sizeof(int) * 8);
  key = Hashcode(buffer);
  if (!CheckGame(hash2, buffer, key))
  {
    for (n = hash2->heads2[key]; n != 0; n = n->next2)
    {
      if (strcmp(n->pointer2->nomej, buffer) == 0)
      {
        int s1 = n->pointer2->score1;
        int s2 = n->pointer2->score2;
        n->pointer2->score1 = snew1;
        n->pointer2->score2 = snew2;
        ChangeWins(s1, s2, snew1, snew2, hash, n);
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    printf("%d Jogo inexistente.\n", NL);
  }

}

void DeleteGame(int NL, Jogo *headJ, hashtable *hash, hashtable2 *hash2)
{
  hash_node2 *n;
  char buffer[1024];
  int key;
  getchar();
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  key = Hashcode(buffer);
  if (!CheckGame(hash2, buffer, key))
  {
    for (n = hash2->heads2[key]; n != 0; n = n->next2)
    {
      if (strcmp(n->pointer2->nomej, buffer) == 0)
      {
        int key2 = Hashcode(n->pointer2->equipa1);
        int key3 = Hashcode(n->pointer2->equipa2);
        if (n->pointer2->score1 > n->pointer2->score2)
        {
          DecreaseWins(hash, n->pointer2->equipa1, key2);
        }
        else
        {
          if (n->pointer2->score2 > n->pointer2->score1)
          {
            DecreaseWins(hash, n->pointer2->equipa2, key3);
          }
          else
          {
            
          }

        }

        if (n->pointer2->previous2 == 0)
        {
          headJ->head = n->pointer2->next2;
        }
        else
        {
          n->pointer2->previous2->next2 = n->pointer2->next2;
        }

        if (n->pointer2->next2 == 0)
        {
          headJ->last = n->pointer2->previous2;
        }
        else
        {
          n->pointer2->next2->previous2 = n->pointer2->previous2;
        }

        free(n->pointer2->nomej);
        free(n->pointer2->equipa1);
        free(n->pointer2->equipa2);
        free(n->pointer2);
        DeleteNode2(hash2, n, key);
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    printf("%d Jogo inexistente.\n", NL);
  }

}

void PrintGames(int NL, Jogo *headJ)
{
  Node_Jogo *atual = headJ->head;
  while (atual != 0)
  {
    printf("%d %s %s %s %d %d\n", NL, atual->nomej, atual->equipa1, atual->equipa2, atual->score1, atual->score2);
    atual = atual->next2;
  }

}

void DestroyJ(Jogo *headJ)
{
  Node_Jogo *temp;
  while (headJ->head)
  {
    temp = headJ->head->next2;
    free(headJ->head->nomej);
    free(headJ->head->equipa1);
    free(headJ->head->equipa2);
    free(headJ->head);
    headJ->head = temp;
  }

  free(headJ);
}

void DestroyH2(hashtable2 *tb)
{
  hash_node2 *temp;
  size_t i;
  for (i = 0; i < 1997; i++)
  {
    while (tb->heads2[i])
    {
      temp = tb->heads2[i]->next2;
      free(tb->heads2[i]);
      tb->heads2[i] = temp;
    }

  }

  free(tb->heads2);
  free(tb);
}

