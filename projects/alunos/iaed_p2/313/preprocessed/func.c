#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "func.h"
#include "struc.h"


int hash_key_e(char *name, lista_equipas *Hash_table[])
{
  int key = 0;
  int a = 127;
  int M = 2027;
  for (; (*name) != '\0'; name++)
  {
    key = ((a * key) + (*name)) % M;
  }

  if (!Hash_table[key])
  {
    Hash_table[key] = malloc(sizeof(lista_equipas));
    Hash_table[key]->head = 0;
    Hash_table[key]->last = 0;
  }
  else
  {
    
  }

  return key;
}

int hash_key_p(char *name, lista_jogos *Hash_table[])
{
  int key = 0;
  int a = 127;
  int M = 2027;
  for (; (*name) != '\0'; name++)
  {
    key = ((a * key) + (*name)) % M;
  }

  if (!Hash_table[key])
  {
    Hash_table[key] = malloc(sizeof(lista_jogos));
    Hash_table[key]->head = 0;
    Hash_table[key]->last = 0;
  }
  else
  {
    
  }

  return key;
}

int find_game(lista_jogos *l, char jogo[])
{
  int logico = 1;
  node_jogos *search;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(jogo, search->jogo) == 0)
    {
      logico = 0;
      break;
    }
    else
    {
      
    }

  }

  return logico;
}

int find_team(lista_equipas *l, char equipa[])
{
  int logico = 0;
  node_equipas *search;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(equipa, search->name) == 0)
    {
      logico = 1;
      break;
    }
    else
    {
      
    }

  }

  return logico;
}

void atualiza_v(lista_equipas *l, char equipa[])
{
  node_equipas *search;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(equipa, search->name) == 0)
    {
      search->Jogos_ganhos += 1;
      break;
    }
    else
    {
      
    }

  }

}

void retira_v(lista_equipas *l, char equipa[])
{
  node_equipas *search;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(equipa, search->name) == 0)
    {
      search->Jogos_ganhos -= 1;
      break;
    }
    else
    {
      
    }

  }

}

void remove_jogo(node_jogos *element, lista_jogos *l)
{
  if (!element->previous)
  {
    l->head = element->next;
  }
  else
  {
    element->previous->next = element->next;
  }

  if (!element->next)
  {
    l->last = element->previous;
  }
  else
  {
    element->next->previous = element->previous;
  }

  free(element->jogo);
  free(element->equipa1);
  free(element->equipa2);
  free(element);
}

void remove_equipa(node_equipas *element, lista_equipas *l)
{
  if (!element->previous)
  {
    l->head = element->next;
  }
  else
  {
    element->previous->next = element->next;
  }

  if (!element->next)
  {
    l->last = element->previous;
  }
  else
  {
    element->next->previous = element->previous;
  }

  free(element->name);
  free(element);
}

void free_lista_jogos(lista_jogos *l)
{
  node_jogos *search;
  while (l->head)
  {
    search = l->head->next;
    remove_jogo(l->head, l);
    l->head = search;
  }

  free(l);
}

void free_lista_equipas(lista_equipas *l)
{
  node_equipas *search;
  while (l->head)
  {
    search = l->head->next;
    remove_equipa(l->head, l);
    l->head = search;
  }

  free(l);
}

void free_hash(lista_equipas *Hash_table[])
{
  int k;
  for (k = 0; k < 2027; k++)
  {
    if (Hash_table[k])
    {
      free_lista_equipas(Hash_table[k]);
    }
    else
    {
      
    }

  }

}

void free_hash_j(lista_jogos *Hash_table[])
{
  int k;
  for (k = 0; k < 2027; k++)
  {
    if (Hash_table[k])
    {
      free_lista_jogos(Hash_table[k]);
    }
    else
    {
      
    }

  }

}

void a(char jogo[], char equipa1[], char equipa2[], int score1, int score2, lista_jogos *l, lista_equipas *Hash_table[], int i, int j)
{
  node_jogos *new_node = malloc(sizeof(node_jogos));
  new_node->previous = l->last;
  new_node->next = 0;
  new_node->jogo = malloc((sizeof(char)) * (strlen(jogo) + 1));
  strcpy(new_node->jogo, jogo);
  new_node->equipa1 = malloc((sizeof(char)) * (strlen(equipa1) + 1));
  strcpy(new_node->equipa1, equipa1);
  new_node->equipa2 = malloc((sizeof(char)) * (strlen(equipa2) + 1));
  strcpy(new_node->equipa2, equipa2);
  new_node->valor1 = score1;
  new_node->valor2 = score2;
  if (l->last)
  {
    l->last->next = new_node;
  }
  else
  {
    l->head = new_node;
  }

  l->last = new_node;
  if (score1 > score2)
  {
    atualiza_v(Hash_table[i], equipa1);
  }
  else
  {
    
  }

  if (score1 < score2)
  {
    atualiza_v(Hash_table[j], equipa2);
  }
  else
  {
    
  }

}

void a__2(char jogo[], char equipa1[], char equipa2[], int score1, int score2, lista_jogos *l)
{
  node_jogos *new_node = malloc(sizeof(node_jogos));
  new_node->previous = l->last;
  new_node->next = 0;
  new_node->jogo = malloc((sizeof(char)) * (strlen(jogo) + 1));
  strcpy(new_node->jogo, jogo);
  new_node->equipa1 = malloc((sizeof(char)) * (strlen(equipa1) + 1));
  strcpy(new_node->equipa1, equipa1);
  new_node->equipa2 = malloc((sizeof(char)) * (strlen(equipa2) + 1));
  strcpy(new_node->equipa2, equipa2);
  new_node->valor1 = score1;
  new_node->valor2 = score2;
  if (l->last)
  {
    l->last->next = new_node;
  }
  else
  {
    l->head = new_node;
  }

  l->last = new_node;
}

void l(lista_jogos *l, int Contador)
{
  node_jogos *search;
  for (search = l->head; search != 0; search = search->next)
  {
    printf("%d %s %s %s %d %d\n", Contador, search->jogo, search->equipa1, search->equipa2, search->valor1, search->valor2);
  }

}

void p(lista_jogos *l, char jogo[], int Contador)
{
  node_jogos *search;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(jogo, search->jogo) == 0)
    {
      printf("%d %s %s %s %d %d\n", Contador, search->jogo, search->equipa1, search->equipa2, search->valor1, search->valor2);
      return;
    }
    else
    {
      
    }

  }

  printf("%d Jogo inexistente.\n", Contador);
}

void r(lista_jogos *l, char jogo[], int Contador, lista_equipas *Hash_table[])
{
  node_jogos *search;
  int i;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(jogo, search->jogo) == 0)
    {
      if (search->valor1 > search->valor2)
      {
        i = hash_key_e(search->equipa1, Hash_table);
        retira_v(Hash_table[i], search->equipa1);
      }
      else
      {
        
      }

      if (search->valor1 < search->valor2)
      {
        i = hash_key_e(search->equipa2, Hash_table);
        retira_v(Hash_table[i], search->equipa2);
      }
      else
      {
        
      }

      remove_jogo(search, l);
      return;
    }
    else
    {
      
    }

  }

  printf("%d Jogo inexistente.\n", Contador);
}

void r__2(lista_jogos *l, char jogo[])
{
  node_jogos *search;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(jogo, search->jogo) == 0)
    {
      remove_jogo(search, l);
      return;
    }
    else
    {
      
    }

  }

}

void s(char jogo[], int score1, int score2, lista_jogos *l, int Contador, lista_equipas *Hash_table[])
{
  node_jogos *search;
  int i;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(jogo, search->jogo) == 0)
    {
      if (search->valor1 > search->valor2)
      {
        i = hash_key_e(search->equipa1, Hash_table);
        retira_v(Hash_table[i], search->equipa1);
      }
      else
      {
        
      }

      if (search->valor1 < search->valor2)
      {
        i = hash_key_e(search->equipa2, Hash_table);
        retira_v(Hash_table[i], search->equipa2);
      }
      else
      {
        
      }

      search->valor1 = score1;
      search->valor2 = score2;
      if (search->valor1 > search->valor2)
      {
        i = hash_key_e(search->equipa1, Hash_table);
        atualiza_v(Hash_table[i], search->equipa1);
      }
      else
      {
        
      }

      if (search->valor1 < search->valor2)
      {
        i = hash_key_e(search->equipa2, Hash_table);
        atualiza_v(Hash_table[i], search->equipa2);
      }
      else
      {
        
      }

      return;
    }
    else
    {
      
    }

  }

  printf("%d Jogo inexistente.\n", Contador);
}

void s__2(char jogo[], int score1, int score2, lista_jogos *l)
{
  node_jogos *search;
  for (search = l->head; search != 0; search = search->next)
  {
    if (strcmp(jogo, search->jogo) == 0)
    {
      search->valor1 = score1;
      search->valor2 = score2;
      return;
    }
    else
    {
      
    }

  }

}

void A(char equipa[], lista_equipas *l)
{
  node_equipas *new_node = malloc(sizeof(node_equipas));
  new_node->previous = l->last;
  new_node->next = 0;
  new_node->name = malloc((sizeof(char)) * (strlen(equipa) + 1));
  strcpy(new_node->name, equipa);
  new_node->Jogos_ganhos = 0;
  if (l->last)
  {
    l->last->next = new_node;
  }
  else
  {
    l->head = new_node;
  }

  l->last = new_node;
}

void P(lista_jogos *l, char equipa[], int Contador)
{
  node_jogos *search;
  int vitorias = 0;
  for (search = l->head; search != 0; search = search->next)
  {
    if ((strcmp(search->equipa1, equipa) == 0) && (search->valor1 > search->valor2))
    {
      vitorias += 1;
    }
    else
    {
      
    }

    if ((strcmp(search->equipa2, equipa) == 0) && (search->valor1 < search->valor2))
    {
      vitorias += 1;
    }
    else
    {
      
    }

  }

  printf("%d %s %d\n", Contador, equipa, vitorias);
}

int Alphabetic(char *A, char *B)
{
  char New_A[1023];
  char New_B[1023];
  strcpy(New_A, A);
  strcpy(New_B, B);
  if (strcmp(New_A, New_B) < 0)
  {
    return 0;
  }
  else
  {
    return 1;
  }

}

void merge(char *a[], int l, int m, int r)
{
  int i;
  int j;
  int k;
  char *aux[2000];
  for (i = 0; i < 2000; i++)
  {
    aux[i] = 0;
  }

  for (i = m + 1; i > l; i--)
  {
    aux[i - 1] = malloc((sizeof(char)) * (strlen(a[i - 1]) + 1));
    strcpy(aux[i - 1], a[i - 1]);
  }

  for (j = m; j < r; j++)
  {
    aux[(r + m) - j] = malloc((sizeof(char)) * (strlen(a[j + 1]) + 1));
    strcpy(aux[(r + m) - j], a[j + 1]);
  }

  for (k = l; k <= r; k++)
  {
    if (Alphabetic(aux[j], aux[i]) == 0)
    {
      if (a[k])
      {
        free(a[k]);
      }
      else
      {
        
      }

      a[k] = malloc((sizeof(char)) * (strlen(aux[j]) + 1));
      strcpy(a[k], aux[j]);
      j -= 1;
    }
    else
    {
      if (a[k])
      {
        free(a[k]);
      }
      else
      {
        
      }

      a[k] = malloc((sizeof(char)) * (strlen(aux[i]) + 1));
      strcpy(a[k], aux[i]);
      i += 1;
    }

  }

  for (i = 0; i < 2000; i++)
  {
    if (aux[i])
    {
      free(aux[i]);
    }
    else
    {
      
    }

  }

}

void mergesort(char *a[], int l, int r)
{
  int m = (r + l) / 2;
  if (r <= l)
  {
    return;
  }
  else
  {
    
  }

  mergesort(a, l, m);
  mergesort(a, m + 1, r);
  merge(a, l, m, r);
}

void g(lista_equipas *Hash_table[], int Contador)
{
  int melhor = 0;
  int i = 0;
  int j;
  int k;
  node_equipas *search;
  char *nomes_equipas[2000];
  nomes_equipas[0] = 0;
  for (k = 0; k < 2027; k++)
  {
    if (Hash_table[k])
    {
      for (search = Hash_table[k]->head; search != 0; search = search->next)
      {
        if (search->Jogos_ganhos > melhor)
        {
          melhor = search->Jogos_ganhos;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  for (k = 0; k < 2027; k++)
  {
    if (Hash_table[k])
    {
      for (search = Hash_table[k]->head; search != 0; search = search->next)
      {
        if (search->Jogos_ganhos == melhor)
        {
          nomes_equipas[i] = malloc(((sizeof(char)) * strlen(search->name)) + 1);
          strcpy(nomes_equipas[i], search->name);
          i++;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }

  if (!nomes_equipas[0])
  {
    return;
  }
  else
  {
    
  }

  printf("%d Melhores %d\n", Contador, melhor);
  j = i;
  mergesort(nomes_equipas, 0, j - 1);
  for (i = 0; i < j; i++)
  {
    printf("%d * %s\n", Contador, nomes_equipas[i]);
    free(nomes_equipas[i]);
  }

}

