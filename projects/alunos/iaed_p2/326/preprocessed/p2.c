/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "structs.h" /* inclui o ficheiro com as estruturas usadas no projeto */


int hash(char *v, int M)
{
  int h = 0;
  int a = 127;
  for (; (*v) != '\0'; v++)
    h = ((a * h) + (*v)) % M;

  return h;
}

void initTeamList(team_list *lista_equipas)
{
  lista_equipas->head = 0;
  lista_equipas->last = 0;
}

void initTeamHash(team_list **teamHash)
{
  int i;
  for (i = 0; i < 1000; i++)
  {
    teamHash[i] = malloc(sizeof(team_list));
    initTeamList(teamHash[i]);
  }

}

void initMatchHash(match_list **matchHash)
{
  int i;
  for (i = 0; i < 1000; i++)
  {
    matchHash[i] = malloc(sizeof(match_list));
    matchHash[i]->head = 0;
    matchHash[i]->last = 0;
  }

}

matches *make_match_list()
{
  matches *matchList = malloc(sizeof(matches));
  matchList->head = 0;
  matchList->last = 0;
  return matchList;
}

void destroy_team_list(team_list *lista_equipas)
{
  team *aux;
  while (lista_equipas->head)
  {
    aux = lista_equipas->head->next;
    free(lista_equipas->head->team_name);
    free(lista_equipas->head);
    lista_equipas->head = aux;
  }

  free(lista_equipas);
}

void destroy_match_list(match_list *lista_jogos)
{
  match *aux;
  while (lista_jogos->head)
  {
    aux = lista_jogos->head->next;
    free(lista_jogos->head->match_name);
    free(lista_jogos->head->team1_name);
    free(lista_jogos->head->team2_name);
    free(lista_jogos->head);
    lista_jogos->head = aux;
  }

  free(lista_jogos);
}

void destroy_match_list2(matches *lista_jogos)
{
  m_name *aux;
  while (lista_jogos->head)
  {
    aux = lista_jogos->head->next;
    free(lista_jogos->head->match_name);
    free(lista_jogos->head);
    lista_jogos->head = aux;
  }

  free(lista_jogos);
}

int team_exists(team_list **teamHash, char *name)
{
  int ind = hash(name, 1000);
  team *head = teamHash[ind]->head;
  if (head)
  {
    if (strcmp(head->team_name, name) == 0)
    {
      return 1;
    }
    else
    {
      
    }

    for (; head->next != 0; head = head->next)
    {
      if (strcmp(head->team_name, name) == 0)
      {
        return 1;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  return 0;
}

void insertTeamList(team_list *team_list, char *team_name)
{
  team *new_team = malloc(sizeof(team));
  new_team->team_name = malloc((strlen(team_name) + 1) * (sizeof(char)));
  strcpy(new_team->team_name, team_name);
  new_team->next = 0;
  if (team_list->last != 0)
  {
    team_list->last->next = new_team;
    team_list->last = new_team;
  }
  else
  {
    team_list->head = new_team;
    team_list->last = new_team;
  }

}

void insertTeam(team_list **teamHash, char *name)
{
  int ind = hash(name, 1000);
  team *new_team = malloc(sizeof(team));
  new_team->team_name = malloc((strlen(name) + 1) * (sizeof(char)));
  strcpy(new_team->team_name, name);
  new_team->wins = 0;
  new_team->next = 0;
  if (teamHash[ind]->last != 0)
  {
    teamHash[ind]->last->next = new_team;
    teamHash[ind]->last = new_team;
  }
  else
  {
    teamHash[ind]->head = new_team;
    teamHash[ind]->last = new_team;
  }

}

void add_team(team_list **teamHash, team_list *lista_equipas, int NL)
{
  char *team_name = malloc(1024 * (sizeof(char)));
  for (int team_name_index = 0; team_name_index < 10; team_name_index++)
  {
    team_name[team_name_index] = new_sym_var(sizeof(char) * 8);
  }

  team_name[10 - 1] = '\0';
  if (team_exists(teamHash, team_name))
  {
    printf("%d Equipa existente.\n", NL);
    free(team_name);
    return;
  }
  else
  {
    insertTeam(teamHash, team_name);
    insertTeamList(lista_equipas, team_name);
    free(team_name);
  }

}

void add_win(team_list **teamHash, char *team_name)
{
  int ind = hash(team_name, 1000);
  team *head = teamHash[ind]->head;
  if (strcmp(head->team_name, team_name) == 0)
  {
    teamHash[ind]->head->wins += 1;
    return;
  }
  else
  {
    for (; head->next != 0; head = head->next)
    {
      if (strcmp(head->team_name, team_name) == 0)
      {
        teamHash[ind]->head->wins += 1;
        return;
      }
      else
      {
        
      }

    }

  }

}

void remove_win(team_list **teamHash, char *team_name)
{
  int ind = hash(team_name, 1000);
  team *head = teamHash[ind]->head;
  if (strcmp(head->team_name, team_name) == 0)
  {
    teamHash[ind]->head->wins -= 1;
    return;
  }
  else
  {
    for (; head->next != 0; head = head->next)
    {
      if (strcmp(head->team_name, team_name) == 0)
      {
        teamHash[ind]->head->wins -= 1;
        return;
      }
      else
      {
        
      }

    }

  }

}

int match_exists(match_list **matchHash, char *name)
{
  int ind = hash(name, 1000);
  if (matchHash[ind]->head)
  {
    match *head = matchHash[ind]->head;
    if (head)
    {
      if (strcmp(head->match_name, name) == 0)
      {
        return 1;
      }
      else
      {
        
      }

      for (; head->next != 0; head = head->next)
      {
        if (strcmp(head->match_name, name) == 0)
        {
          return 1;
        }
        else
        {
          
        }

      }

    }
    else
    {
      
    }

  }
  else
  {
    
  }

  return 0;
}

void insertMatchList(matches *match_list, char *match_name)
{
  m_name *new_match = malloc(sizeof(m_name));
  new_match->match_name = malloc((strlen(match_name) + 1) * (sizeof(char)));
  strcpy(new_match->match_name, match_name);
  if (match_list->last != 0)
  {
    match_list->last->next = new_match;
    match_list->last = new_match;
  }
  else
  {
    match_list->head = new_match;
    match_list->last = new_match;
  }

  new_match->previous = match_list->last;
  new_match->next = 0;
}

void insertMatch(match_list **matchHash, team_list **teamHash, char *match_name, char *team1_name, char *team2_name, int team1_score, int team2_score)
{
  int ind = hash(match_name, 1000);
  match *new_match = malloc(sizeof(match));
  new_match->match_name = malloc((strlen(match_name) + 1) * (sizeof(char)));
  new_match->team2_name = malloc((strlen(team2_name) + 1) * (sizeof(char)));
  new_match->team1_name = malloc((strlen(team1_name) + 1) * (sizeof(char)));
  strcpy(new_match->match_name, match_name);
  strcpy(new_match->team1_name, team1_name);
  strcpy(new_match->team2_name, team2_name);
  new_match->team1_score = team1_score;
  new_match->team2_score = team2_score;
  new_match->previous = matchHash[ind]->last;
  new_match->next = 0;
  if (matchHash[ind]->last != 0)
  {
    matchHash[ind]->last->next = new_match;
    matchHash[ind]->last = new_match;
  }
  else
  {
    matchHash[ind]->head = new_match;
    matchHash[ind]->last = new_match;
  }

  if (team1_score > team2_score)
  {
    add_win(teamHash, team1_name);
  }
  else
  {
    if (team1_score < team2_score)
    {
      add_win(teamHash, team2_name);
    }
    else
    {
      return;
    }

  }

}

void add_match(match_list **matchHash, team_list **teamHash, matches *lista_jogos, int NL)
{
  char *match_name = malloc(1024 * (sizeof(char)));
  char *team1_name = malloc(1024 * (sizeof(char)));
  char *team2_name = malloc(1024 * (sizeof(char)));
  int team1_score;
  int team2_score;
  for (int match_name_index = 0; match_name_index < 10; match_name_index++)
  {
    match_name[match_name_index] = new_sym_var(sizeof(char) * 8);
  }

  match_name[10 - 1] = '\0';
  for (int team1_name_index = 0; team1_name_index < 10; team1_name_index++)
  {
    team1_name[team1_name_index] = new_sym_var(sizeof(char) * 8);
  }

  team1_name[10 - 1] = '\0';
  for (int team2_name_index = 0; team2_name_index < 10; team2_name_index++)
  {
    team2_name[team2_name_index] = new_sym_var(sizeof(char) * 8);
  }

  team2_name[10 - 1] = '\0';
  team1_score = new_sym_var(sizeof(int) * 8);
  team2_score = new_sym_var(sizeof(int) * 8);
  if (match_exists(matchHash, match_name))
  {
    printf("%d Jogo existente.\n", NL);
    free(match_name);
    free(team1_name);
    free(team2_name);
    return;
  }
  else
  {
    if ((!team_exists(teamHash, team1_name)) || (!team_exists(teamHash, team2_name)))
    {
      printf("%d Equipa inexistente.\n", NL);
      free(match_name);
      free(team1_name);
      free(team2_name);
      return;
    }
    else
    {
      insertMatch(matchHash, teamHash, match_name, team1_name, team2_name, team1_score, team2_score);
      insertMatchList(lista_jogos, match_name);
    }

  }

  free(match_name);
  free(team1_name);
  free(team2_name);
}

void team_lookup(team_list **teamHash, int NL)
{
  char *team_name = malloc(1024 * (sizeof(char)));
  int ind;
  team *head;
  for (int team_name_index = 0; team_name_index < 10; team_name_index++)
  {
    team_name[team_name_index] = new_sym_var(sizeof(char) * 8);
  }

  team_name[10 - 1] = '\0';
  ind = hash(team_name, 1000);
  head = teamHash[ind]->head;
  if (!team_exists(teamHash, team_name))
  {
    printf("%d Equipa inexistente.\n", NL);
    free(team_name);
    return;
  }
  else
  {
    if (strcmp(head->team_name, team_name) == 0)
    {
      printf("%d %s %d\n", NL, team_name, head->wins);
      free(team_name);
      return;
    }
    else
    {
      
    }

    while (head->next)
    {
      if (strcmp(head->team_name, team_name) == 0)
      {
        printf("%d %s %d\n", NL, team_name, head->wins);
        free(team_name);
        return;
      }
      else
      {
        
      }

      head = head->next;
    }

  }

}

void match_lookup_aux(match_list **matchHash, int NL, char *match_name)
{
  int ind = hash(match_name, 1000);
  match *head = matchHash[ind]->head;
  if (head->next != 0)
  {
    for (; head->next != 0; head = head->next)
    {
      if (strcmp(head->match_name, match_name) == 0)
      {
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  printf("%d %s %s %s %d %d\n", NL, match_name, head->team1_name, head->team2_name, head->team1_score, head->team2_score);
}

void match_lookup(match_list **matchHash, int NL)
{
  char *match_name = malloc(1024 * (sizeof(char)));
  for (int match_name_index = 0; match_name_index < 10; match_name_index++)
  {
    match_name[match_name_index] = new_sym_var(sizeof(char) * 8);
  }

  match_name[10 - 1] = '\0';
  if (!match_exists(matchHash, match_name))
  {
    printf("%d Jogo inexistente.\n", NL);
    free(match_name);
    return;
  }
  else
  {
    match_lookup_aux(matchHash, NL, match_name);
    free(match_name);
    return;
  }

}

void remove_match_list(matches *lista_jogos, char *match_name)
{
  m_name *head = lista_jogos->head;
  if (head->next != 0)
  {
    for (; head->next != 0; head = head->next)
    {
      if (strcmp(head->match_name, match_name) == 0)
      {
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  if (head->previous != 0)
  {
    head->previous = head->next;
  }
  else
  {
    lista_jogos->head = head->next;
  }

  if (head->next != 0)
  {
    head->next->previous = head->previous;
  }
  else
  {
    lista_jogos->last = head->previous;
  }

  free(head);
}

void remove_match(team_list **teamHash, match_list **matchHash, char *match_name)
{
  int ind = hash(match_name, 1000);
  match *head = matchHash[ind]->head;
  if (head->next != 0)
  {
    for (; head->next != 0; head = head->next)
    {
      if (strcmp(head->match_name, match_name) == 0)
      {
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  if (head->team1_score > head->team2_score)
  {
    remove_win(teamHash, head->team1_name);
  }
  else
  {
    if (head->team1_score < head->team2_score)
    {
      remove_win(teamHash, head->team2_name);
    }
    else
    {
      
    }

  }

  if (head->previous != 0)
  {
    head->previous = head->next;
  }
  else
  {
    matchHash[ind]->head = head->next;
  }

  if (head->next != 0)
  {
    head->next->previous = head->previous;
  }
  else
  {
    matchHash[ind]->last = head->previous;
  }

  free(head);
}

void delete_match(team_list **teamHash, match_list **matchHash, matches *lista_jogos, int NL)
{
  char *match_name = malloc(1024 * (sizeof(char)));
  for (int match_name_index = 0; match_name_index < 10; match_name_index++)
  {
    match_name[match_name_index] = new_sym_var(sizeof(char) * 8);
  }

  match_name[10 - 1] = '\0';
  if (!match_exists(matchHash, match_name))
  {
    printf("%d Jogo inexistente.\n", NL);
    free(match_name);
    return;
  }
  else
  {
    
  }

  remove_match(teamHash, matchHash, match_name);
  remove_match_list(lista_jogos, match_name);
  free(match_name);
}

void altera_score(team_list **teamHash, match_list **matchHash, char *match_name, int new_1, int new_2)
{
  int ind = hash(match_name, 1000);
  match *head = matchHash[ind]->head;
  int old_1;
  int old_2;
  if (head->next != 0)
  {
    for (; head->next != 0; head = head->next)
    {
      if (strcmp(head->match_name, match_name) == 0)
      {
        break;
      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  old_1 = head->team1_score;
  old_2 = head->team2_score;
  if ((old_1 > old_2) && (new_1 == new_2))
  {
    remove_win(teamHash, head->team1_name);
  }
  else
  {
    if ((old_1 > old_2) && (new_1 < new_2))
    {
      remove_win(teamHash, head->team1_name);
      add_win(teamHash, head->team2_name);
    }
    else
    {
      if ((old_1 == old_2) && (new_1 > new_2))
      {
        add_win(teamHash, head->team1_name);
      }
      else
      {
        if ((old_1 == old_2) && (new_1 < new_2))
        {
          add_win(teamHash, head->team2_name);
        }
        else
        {
          if ((old_1 < old_2) && (new_1 == new_2))
          {
            remove_win(teamHash, head->team2_name);
          }
          else
          {
            if ((old_1 < old_2) && (new_1 > new_2))
            {
              remove_win(teamHash, head->team2_name);
              add_win(teamHash, head->team1_name);
            }
            else
            {
              
            }

          }

        }

      }

    }

  }

  head->team1_score = new_1;
  head->team2_score = new_2;
}

void change_score(team_list **teamHash, match_list **matchHash, int NL)
{
  char *match_name = malloc(1024 * (sizeof(char)));
  int team1_new_score;
  int team2_new_score;
  for (int match_name_index = 0; match_name_index < 10; match_name_index++)
  {
    match_name[match_name_index] = new_sym_var(sizeof(char) * 8);
  }

  match_name[10 - 1] = '\0';
  team1_new_score = new_sym_var(sizeof(int) * 8);
  team2_new_score = new_sym_var(sizeof(int) * 8);
  if (!match_exists(matchHash, match_name))
  {
    printf("%d Jogo inexistente.\n", NL);
    free(match_name);
    return;
  }
  else
  {
    altera_score(teamHash, matchHash, match_name, team1_new_score, team2_new_score);
    free(match_name);
    return;
  }

}

void print_games(matches *lista_jogos, match_list **matchHash, int NL)
{
  m_name *head;
  if (lista_jogos->head == 0)
  {
    return;
  }
  else
  {
    head = lista_jogos->head;
    for (; head != 0; head = head->next)
    {
      match_lookup_aux(matchHash, NL, head->match_name);
    }

  }

}

int lookup_team_wins(team_list **teamHash, char *team_name)
{
  int ind = hash(team_name, 1000);
  team *head = teamHash[ind]->head;
  if (strcmp(head->team_name, team_name) == 0)
  {
    return head->wins;
  }
  else
  {
    while (head->next)
    {
      if (strcmp(head->team_name, team_name) == 0)
      {
        return head->wins;
      }
      else
      {
        
      }

      head = head->next;
    }

  }

  return 0;
}

int sorted(team_list *lista_equipas)
{
  team *t_head = lista_equipas->head;
  if (t_head->next == 0)
  {
    return 1;
  }
  else
  {
    
  }

  while (t_head->next)
  {
    if (strcmp(t_head->team_name, t_head->next->team_name) > 0)
    {
      return 0;
    }
    else
    {
      
    }

    t_head = t_head->next;
  }

  return 1;
}

void print_teams(team_list *lista_equipas, team_list **teamHash, int NL)
{
  int i;
  int list_len = 0;
  int max_wins = 0;
  char *temp = malloc(1024 * (sizeof(char)));
  team *head;
  team *t_head = lista_equipas->head;
  team_list *lista_eq = malloc(sizeof(team_list));
  initTeamList(lista_eq);
  for (i = 0; i < 1000; i++)
  {
    if (teamHash[i]->head != 0)
    {
      head = teamHash[i]->head;
      while (head)
      {
        head->wins = lookup_team_wins(teamHash, head->team_name);
        if (head->wins > max_wins)
        {
          max_wins = head->wins;
        }
        else
        {
          
        }

        if (head->next != 0)
        {
          head = head->next;
        }
        else
        {
          break;
        }

      }

    }
    else
    {
      
    }

  }

  for (i = 0; i < 1000; i++)
  {
    if (teamHash[i]->head != 0)
    {
      head = teamHash[i]->head;
      while (head)
      {
        if (head->wins == max_wins)
        {
          insertTeamList(lista_eq, head->team_name);
          list_len += 1;
        }
        else
        {
          
        }

        if (head->next != 0)
        {
          head = head->next;
        }
        else
        {
          break;
        }

      }

    }
    else
    {
      
    }

  }

  if (lista_eq->head == 0)
  {
    free(temp);
    destroy_team_list(lista_eq);
    return;
  }
  else
  {
    
  }

  if (lista_eq->head->next == 0)
  {
    printf("%d Melhores %d\n%d * %s\n", NL, max_wins, NL, lista_eq->head->team_name);
    free(temp);
    destroy_team_list(lista_eq);
    return;
  }
  else
  {
    
  }

  if (lista_eq->head)
  {
    while (!sorted(lista_eq))
    {
      t_head = lista_eq->head;
      while (t_head)
      {
        if (t_head->next != 0)
        {
          if (strcmp(t_head->team_name, t_head->next->team_name) > 0)
          {
            strcpy(temp, t_head->team_name);
            free(t_head->team_name);
            t_head->team_name = malloc((strlen(t_head->next->team_name) + 1) * (sizeof(char)));
            strcpy(t_head->team_name, t_head->next->team_name);
            free(t_head->next->team_name);
            t_head->next->team_name = malloc((strlen(temp) + 1) * (sizeof(char)));
            strcpy(t_head->next->team_name, temp);
          }
          else
          {
            
          }

          t_head = t_head->next;
        }
        else
        {
          break;
        }

      }

    }

  }
  else
  {
    
  }

  t_head = lista_eq->head;
  printf("%d Melhores %d\n", NL, max_wins);
  while (t_head)
  {
    printf("%d * %s\n", NL, t_head->team_name);
    if (t_head->next != 0)
    {
      t_head = t_head->next;
    }
    else
    {
      break;
    }

  }

  destroy_team_list(lista_eq);
  free(temp);
}

void end(team_list *lista_equipas, matches *lista_jogos, team_list **teamHash, match_list **matchHash)
{
  int i;
  destroy_team_list(lista_equipas);
  destroy_match_list2(lista_jogos);
  for (i = 0; i < 1000; i++)
  {
    destroy_team_list(teamHash[i]);
    destroy_match_list(matchHash[i]);
  }

}

int main()
{
  char c;
  int NL = 1;
  team_list *teamHash[1000];
  match_list *matchHash[1000];
  matches *lista_jogos = make_match_list();
  team_list *lista_equipas = malloc(sizeof(team_list));
  initTeamList(lista_equipas);
  initTeamHash(teamHash);
  initMatchHash(matchHash);
  while ((c = getchar()) != 'x')
  {
    switch (c)
    {
      case 'a':
        add_match(matchHash, teamHash, lista_jogos, NL);
        NL++;
        break;

      case 'A':
        add_team(teamHash, lista_equipas, NL);
        NL++;
        break;

      case 'p':
        match_lookup(matchHash, NL);
        NL++;
        break;

      case 'P':
        team_lookup(teamHash, NL);
        NL++;
        break;

      case 'r':
        delete_match(teamHash, matchHash, lista_jogos, NL);
        NL++;
        break;

      case 's':
        change_score(teamHash, matchHash, NL);
        NL++;
        break;

      case 'l':
        print_games(lista_jogos, matchHash, NL);
        NL++;
        break;

      case 'g':
        print_teams(lista_equipas, teamHash, NL);
        NL++;
        break;

    }

  }

  end(lista_equipas, lista_jogos, teamHash, matchHash);
  return 0;
}

