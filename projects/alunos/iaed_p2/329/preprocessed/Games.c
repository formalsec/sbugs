#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "Games.h"


void Init_Games(GS *gs)
{
  int i;
  int M;
  gs->HTsize = 1000;
  M = gs->HTsize;
  gs->number_games = 0;
  gs->headsgames = malloc(M * (sizeof(struct nodeG)));
  for (i = 0; i < M; i++)
    gs->headsgames[i] = 0;

  gs->list = malloc(sizeof(struct list));
  gs->list->head = 0;
  gs->list->last = 0;
}

pGNode add_lastListG(plist list, pGame game)
{
  pGNode nnode = malloc(sizeof(struct GNode));
  nnode->next = 0;
  nnode->prev = list->last;
  nnode->g = game;
  if (list->last)
  {
    list->last->next = nnode;
  }
  else
  {
    
  }

  list->last = nnode;
  if (!list->head)
  {
    list->head = nnode;
  }
  else
  {
    
  }

  return nnode;
}

void STinsertG(GS *gs, pGame game)
{
  int i;
  pNode new = malloc(sizeof(struct nodeG));
  new->gms = add_lastListG(gs->list, game);
  i = hash(game->name, gs->HTsize);
  new->next = gs->headsgames[i];
  gs->headsgames[i] = new;
}

pNode searchHTG(pNode list, char *name)
{
  pNode head;
  for (head = list; head; head = head->next)
    if (strcmp(head->gms->g->name, name) == 0)
  {
    return head;
  }
  else
  {
    continue;
  }


  return 0;
}

pNode STsearchG(char *name, GS *gs)
{
  int i = hash(name, gs->HTsize);
  return searchHTG(gs->headsgames[i], name);
}

void change_wins(pGNode gms, int scoret1, int scoret2)
{
  if (gms->g->scoreteam1 > gms->g->scoreteam2)
  {
    if (scoret1 == scoret2)
    {
      gms->g->team1->wins -= 1;
    }
    else
    {
      if (scoret1 < scoret2)
      {
        gms->g->team1->wins -= 1;
        gms->g->team2->wins += 1;
      }
      else
      {
        
      }

    }

  }
  else
  {
    if (gms->g->scoreteam1 < gms->g->scoreteam2)
    {
      if (scoret1 > scoret2)
      {
        gms->g->team1->wins += 1;
        gms->g->team2->wins -= 1;
      }
      else
      {
        if (scoret1 == scoret2)
        {
          gms->g->team2->wins -= 1;
        }
        else
        {
          
        }

      }

    }
    else
    {
      if (scoret1 > scoret2)
      {
        gms->g->team1->wins += 1;
      }
      else
      {
        if (scoret1 < scoret2)
        {
          gms->g->team2->wins += 1;
        }
        else
        {
          
        }

      }

    }

  }

  gms->g->scoreteam1 = scoret1;
  gms->g->scoreteam2 = scoret2;
}

pNode remove_gameaux(pNode head, pGNode game)
{
  pNode t;
  pNode prev;
  for (t = head, prev = 0; t != 0; prev = t, t = t->next)
  {
    if (t->gms == game)
    {
      if (t == head)
      {
        head = t->next;
      }
      else
      {
        prev->next = t->next;
      }

      free(t->gms->g);
      free(t->gms);
      free(t);
      break;
    }
    else
    {
      
    }

  }

  return head;
}

pNode remove_gamefinal(pNode head, pGNode game)
{
  pNode t;
  pNode prev;
  for (t = head, prev = 0; t != 0; prev = t, t = t->next)
  {
    if (!t->gms)
    {
      return head;
    }
    else
    {
      
    }

    if (t->gms == game)
    {
      if (t == head)
      {
        head = t->next;
      }
      else
      {
        prev->next = t->next;
      }

      free(t->gms->g->name);
      free(t->gms->g);
      free(t->gms);
      free(t);
      break;
    }
    else
    {
      
    }

  }

  return head;
}

void Stop_Games(GS *gs)
{
  int i;
  pGNode nodelist;
  while (gs->list->head)
  {
    nodelist = gs->list->head->next;
    i = hash(gs->list->head->g->name, gs->HTsize);
    gs->headsgames[i] = remove_gamefinal(gs->headsgames[i], gs->list->head);
    gs->list->head = nodelist;
  }

  free(gs->headsgames);
  free(gs->list);
}

