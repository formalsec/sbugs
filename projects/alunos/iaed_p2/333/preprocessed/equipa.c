#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "equipa.h"


hash_table_equipa *cria_hash_table_equipa()
{
  hash_table_equipa *rv = malloc(sizeof(hash_table_equipa));
  rv->capacidade_equipa = 1997;
  rv->tb = calloc(rv->capacidade_equipa, sizeof(hash_node_equipa));
  return rv;
}

int hash(char *v, int M)
{
  int h = 0;
  int a = 127;
  for (; (*v) != '\0'; v++)
  {
    h = ((a * h) + (*v)) % M;
  }

  return h;
}

int verificaExiste(hash_table_equipa *t, char *word)
{
  size_t h = hash(word, t->capacidade_equipa);
  hash_node_equipa *n;
  for (n = t->tb[h]; n != 0; n = n->next)
  {
    if (strcmp(n->equipa1, word) == 0)
    {
      return 0;
    }
    else
    {
      
    }

  }

  return 1;
}

char *aloca_memoria(const char *s)
{
  size_t len = strlen(s) + 1;
  void *new = malloc(len);
  if (new == 0)
  {
    return 0;
  }
  else
  {
    return (char *) memcpy(new, s, len);
  }

}

hash_node_equipa *constroiNo_equipa(char *nome_equipa, hash_node_equipa *inicio)
{
  hash_node_equipa *nn = malloc(sizeof(hash_node_equipa));
  nn->equipa1 = aloca_memoria(nome_equipa);
  nn->vitorias = 0;
  nn->next = inicio;
  inicio = nn;
  return inicio;
}

void adiciona_equipa(hash_table_equipa *HashEquipa, int *Nr_linha)
{
  int n;
  char buffer[1024];
  for (int buffer_index = 0; buffer_index < 10; buffer_index++)
  {
    buffer[buffer_index] = new_sym_var(sizeof(char) * 8);
  }

  buffer[10 - 1] = '\0';
  n = hash(buffer, HashEquipa->capacidade_equipa);
  if (verificaExiste(HashEquipa, buffer) == 0)
  {
    printf("%d Equipa existente.\n", *Nr_linha);
    *Nr_linha += 1;
    return;
  }
  else
  {
    
  }

  HashEquipa->tb[n] = constroiNo_equipa(buffer, HashEquipa->tb[n]);
  *Nr_linha += 1;
}

void procura_equipa(hash_table_equipa *eq, int *Nr_linha)
{
  char equipa[1024];
  size_t h;
  hash_node_equipa *equipa_aux;
  for (int equipa_index = 0; equipa_index < 10; equipa_index++)
  {
    equipa[equipa_index] = new_sym_var(sizeof(char) * 8);
  }

  equipa[10 - 1] = '\0';
  h = hash(equipa, eq->capacidade_equipa);
  for (equipa_aux = eq->tb[h]; equipa_aux; equipa_aux = equipa_aux->next)
  {
    if (strcmp(equipa, equipa_aux->equipa1) == 0)
    {
      printf("%d %s %ld\n", *Nr_linha, equipa, equipa_aux->vitorias);
      *Nr_linha += 1;
      return;
    }
    else
    {
      
    }

  }

  printf("%d Equipa inexistente.\n", *Nr_linha);
  *Nr_linha += 1;
}

int compara_palavras(const void *a, const void *b)
{
  const char **ia = (const char **) a;
  const char **ib = (const char **) b;
  return strcmp(*ia, *ib);
}

void printa_melhores(char **vetor, size_t comp, int *Nr_linha, int maior)
{
  size_t i;
  if (comp != 0)
  {
    printf("%d Melhores %d\n", *Nr_linha, maior);
  }
  else
  {
    
  }

  for (i = 0; i < comp; i++)
  {
    printf("%d * %s\n", *Nr_linha, vetor[i]);
  }

}

void maisGanhos(hash_table_equipa *eq, int *Nr_linha)
{
  size_t i;
  size_t maior_aux = 0;
  size_t maior = 0;
  size_t cont = 0;
  int cont_aux = 0;
  char *vetor[1024];
  hash_node_equipa *equipa_aux;
  for (i = 0; i < eq->capacidade_equipa; i++)
  {
    for (equipa_aux = eq->tb[i]; equipa_aux; equipa_aux = equipa_aux->next)
    {
      if (equipa_aux->vitorias > maior_aux)
      {
        maior_aux = equipa_aux->vitorias;
      }
      else
      {
        
      }

      cont_aux++;
    }

  }

  if (cont_aux == 0)
  {
    *Nr_linha += 1;
    return;
  }
  else
  {
    
  }

  maior = maior_aux;
  for (i = 0; i < eq->capacidade_equipa; i++)
  {
    for (equipa_aux = eq->tb[i]; equipa_aux; equipa_aux = equipa_aux->next)
    {
      if (equipa_aux->vitorias == maior)
      {
        vetor[cont] = equipa_aux->equipa1;
        cont++;
      }
      else
      {
        
      }

    }

  }

  qsort(vetor, cont, sizeof(char *), compara_palavras);
  printa_melhores(vetor, cont, Nr_linha, maior);
  *Nr_linha += 1;
}

void free_hash_table(hash_table_equipa *t)
{
  hash_node_equipa *a;
  size_t i;
  for (i = 0; i < t->capacidade_equipa; i++)
  {
    while (t->tb[i])
    {
      a = t->tb[i]->next;
      free(t->tb[i]->equipa1);
      free(t->tb[i]);
      t->tb[i] = a;
    }

  }

  free(t->tb);
  free(t);
}

