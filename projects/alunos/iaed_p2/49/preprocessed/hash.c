/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "hash.h"


hashM *initM(int size)
{
  hashM *hashtable = malloc(sizeof(hashM));
  int index = 0;
  hashtable->size = size;
  hashtable->numberMatches = 0;
  hashtable->array = (link *) malloc((sizeof(link)) * size);
  for (; index < hashtable->size; index++)
    hashtable->array[index] = 0;

  return hashtable;
}

int hashvalM(hashM *hashtable, char *name)
{
  int hashval = 0;
  int prime = 31;
  for (; (*name) != '\0'; name++)
    hashval = ((*name) + (prime * hashval)) % hashtable->size;

  return hashval;
}

void insertM(hashM *hashtable, link match)
{
  int hashval = hashvalM(hashtable, match->name);
  while (hashtable->array[hashval] != 0)
    hashval = (hashval + 1) % hashtable->size;

  hashtable->array[hashval] = match;
  hashtable->numberMatches++;
  if (hashtable->numberMatches > (hashtable->size / 2))
  {
    expandM(hashtable);
  }
  else
  {
    
  }

}

void expandM(hashM *hashtable)
{
  int index;
  int newHashval;
  link *auxT;
  int oldSize = hashtable->size;
  int newSize = next_sizeM(hashtable->size);
  link *newArray = malloc((sizeof(link)) * newSize);
  hashtable->size = newSize;
  for (index = 0; index < newSize; index++)
    newArray[index] = 0;

  for (index = 0; index < oldSize; index++)
  {
    if (hashtable->array[index] != 0)
    {
      newHashval = hashvalM(hashtable, hashtable->array[index]->name);
      while (newArray[newHashval] != 0)
        newHashval = (newHashval + 1) % newSize;

      newArray[newHashval] = hashtable->array[index];
      hashtable->array[index] = 0;
    }
    else
    {
      
    }

  }

  auxT = hashtable->array;
  hashtable->array = newArray;
  free(auxT);
  newArray = 0;
}

link searchM(hashM *hashtable, char *name)
{
  int hashval = hashvalM(hashtable, name);
  while (hashtable->array[hashval] != 0)
  {
    if (strcmp(name, hashtable->array[hashval]->name) == 0)
    {
      return hashtable->array[hashval];
    }
    else
    {
      hashval = (hashval + 1) % hashtable->size;
    }

  }

  return 0;
}

void eraseM(hashM *hashtable)
{
  int index = 0;
  for (; index < hashtable->size; index++)
  {
    if (hashtable->array[index] != 0)
    {
      free(hashtable->array[index]->name);
      free(hashtable->array[index]->team1);
      free(hashtable->array[index]->team2);
      free(hashtable->array[index]);
      hashtable->array[index] = 0;
    }
    else
    {
      
    }

  }

  free(hashtable->array);
  free(hashtable);
}

int next_sizeM(int size)
{
  int counter = 1;
  size *= 2;
  while (counter != size)
  {
    if ((size % counter) == 0)
    {
      ++size;
    }
    else
    {
      
    }

    ++counter;
  }

  return size;
}

