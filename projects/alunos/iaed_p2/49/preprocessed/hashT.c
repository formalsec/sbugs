#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "hashT.h"


hash *initT(int size)
{
  hash *hashtable = malloc(sizeof(hash));
  int index = 0;
  hashtable->size = size;
  hashtable->numberTeams = 0;
  hashtable->array = (char **) malloc((sizeof(char *)) * hashtable->size);
  for (; index < hashtable->size; index++)
    hashtable->array[index] = 0;

  return hashtable;
}

int hashvalT(hash *hashtable, char *name)
{
  int hashval = 0;
  int prime = 31;
  for (; (*name) != '\0'; name++)
    hashval = ((*name) + (prime * hashval)) % hashtable->size;

  return hashval;
}

void insertT(hash *hashtable, char *name)
{
  int hashval = hashvalT(hashtable, name);
  while (hashtable->array[hashval] != 0)
    hashval = (hashval + 1) % hashtable->size;

  hashtable->array[hashval] = name;
  hashtable->numberTeams++;
  if (hashtable->numberTeams > (hashtable->size / 2))
  {
    expandT(hashtable);
  }
  else
  {
    
  }

}

void expandT(hash *hashtable)
{
  int index;
  int newHashval;
  char **auxT;
  int oldSize = hashtable->size;
  int newSize = next_size(hashtable->size);
  char **newArray = malloc((sizeof(char *)) * newSize);
  hashtable->size = newSize;
  for (index = 0; index < newSize; index++)
    newArray[index] = 0;

  for (index = 0; index < oldSize; index++)
  {
    if (hashtable->array[index] != 0)
    {
      newHashval = hashvalT(hashtable, hashtable->array[index]);
      while (newArray[newHashval] != 0)
        newHashval = (newHashval + 1) % newSize;

      newArray[newHashval] = hashtable->array[index];
      hashtable->array[index] = 0;
    }
    else
    {
      
    }

  }

  auxT = hashtable->array;
  hashtable->array = newArray;
  free(auxT);
  newArray = 0;
}

char *searchT(hash *hashtable, char *name)
{
  int hashval = hashvalT(hashtable, name);
  while (hashtable->array[hashval] != 0)
  {
    if (strcmp(name, hashtable->array[hashval]) == 0)
    {
      return hashtable->array[hashval];
    }
    else
    {
      hashval = (hashval + 1) % hashtable->size;
    }

  }

  return 0;
}

void eraseT(hash *hashtable)
{
  int index = 0;
  for (; index < hashtable->size; index++)
  {
    if (hashtable->array[index] != 0)
    {
      free(hashtable->array[index]);
      hashtable->array[index] = 0;
    }
    else
    {
      
    }

  }

  free(hashtable->array);
  free(hashtable);
}

int next_size(int size)
{
  int counter = 1;
  size *= 2;
  while (counter != size)
  {
    if ((size % counter) == 0)
    {
      ++size;
    }
    else
    {
      
    }

    ++counter;
  }

  return size;
}

