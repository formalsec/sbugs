#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "estruturasAlgoritmos.h"


lista *novaLista(int m)
{
  lista *newQ;
  newQ = (lista *) malloc(sizeof(lista));
  newQ->vetor = (item *) malloc((sizeof(item)) * m);
  memset((void *) newQ->vetor, 0, (sizeof(item)) * m);
  newQ->m = m;
  newQ->n = 0;
  return newQ;
}

lista *dupTamanhoLista(lista *q)
{
  if (q == 0)
  {
    return 0;
  }
  else
  {
    
  }

  q->m = 2 * q->m;
  q->vetor = realloc(q->vetor, (sizeof(item)) * q->m);
  return q;
}

lista *insereFinalLista(lista *q, item item)
{
  if (q == 0)
  {
    q = novaLista(5);
  }
  else
  {
    
  }

  if (q->n < q->m)
  {
    q->vetor[q->n++] = item;
    return q;
  }
  else
  {
    q = dupTamanhoLista(q);
    return insereFinalLista(q, item);
  }

}

void libLista(lista *q)
{
  free(q->vetor);
  free(q);
}

void destroiLista(lista *q)
{
  int i;
  if (q == 0)
  {
    return;
  }
  else
  {
    
  }

  for (i = 0; i < q->n; i++)
  {
    libItem(q->vetor[i]);
    free(q->vetor[i]);
  }

  libLista(q);
}

lista *removeItemLista(lista *q, item Item)
{
  int i;
  if (q == 0)
  {
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < q->n; i++)
    if (!strcmp(q->vetor[i]->nome, Item->nome))
  {
    q->vetor[i]->scr[1] = -1;
  }
  else
  {
    
  }


  return q;
}

item procuraLista(lista *q, char *chave)
{
  int i;
  if (q == 0)
  {
    return 0;
  }
  else
  {
    
  }

  for (i = 0; i < q->n; i++)
  {
    if ((!strcmp(q->vetor[i]->nome, chave)) && (q->vetor[i]->scr[1] >= 0))
    {
      return q->vetor[i];
    }
    else
    {
      
    }

  }

  return 0;
}

tabela *novaTabela(int m)
{
  tabela *new = (tabela *) malloc(sizeof(tabela));
  new->m = m;
  new->n = 0;
  new->itens = (lista **) malloc((sizeof(lista *)) * m);
  memset((void *) new->itens, 0, (sizeof(lista *)) * m);
  return new;
}

void insereTabela(tabela *st, item Item)
{
  int i = hash(Item->nome, st->m);
  st->itens[i] = insereFinalLista(st->itens[i], Item);
}

void removeTabela(tabela *st, item Item)
{
  int i = hash(Item->nome, st->m);
  st->itens[i] = removeItemLista(st->itens[i], Item);
}

item procuraTabela(tabela *st, Chave v)
{
  int i = hash(v, st->m);
  return procuraLista(st->itens[i], v);
}

void destroiTabela(tabela *st)
{
  int i;
  for (i = 0; i < st->m; i++)
  {
    destroiLista(st->itens[i]);
  }

  free(st->itens);
  free(st);
}

void insertionSort(lista *v, int l, int r)
{
  int i;
  int j;
  item Item;
  for (i = l + 1; i < r; i++)
  {
    Item = v->vetor[i];
    j = i - 1;
    while ((j >= l) && (strcmp(Item->nome, v->vetor[j]->nome) < 0))
    {
      v->vetor[j + 1] = v->vetor[j];
      j--;
    }

    v->vetor[j + 1] = Item;
  }

}

