#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>


typedef int ll;
typedef unsigned long ull;
ll i;
ll i1;
ll i2;
ll insig;
void Out(ll x[], ll s)
{
  for (i = 0; i < s; i++)
  {
    printf("%d ", x[i]);
  }

  printf("\n");
}

int line;
int min(int a, int b)
{
  if (a < b)
  {
    return a;
  }
  else
  {
    return b;
  }

}

int max(int a, int b)
{
  if (a < b)
  {
    return b;
  }
  else
  {
    return a;
  }

}

void swap(int *a, int *b)
{
  int *c = a;
  a = b;
  b = c;
}

struct string
{
  char *s;
  ll si;
};
struct string inp()
{
  struct string ans;
  char c;
  bool now;
  ans.s = (char *) malloc(sizeof(char));
  ans.si = 0;
  now = false;
  while (1 > 0)
  {
    c = new_sym_var(sizeof(char) * 8);
    if (now && ((c == '\n') || (c == ':')))
    {
      break;
    }
    else
    {
      
    }

    if ((c == '\n') || (c == ':'))
    {
      continue;
    }
    else
    {
      
    }

    if ((!now) && (c == ' '))
    {
      continue;
    }
    else
    {
      
    }

    now = true;
    ans.si++;
    ans.s = realloc(ans.s, ans.si * (sizeof(char)));
    ans.s[ans.si - 1] = c;
  }

  return ans;
}

void print(struct string s)
{
  for (i1 = 0; i1 < s.si; i1++)
  {
    printf("%c", s.s[i1]);
  }

}

bool eq(struct string s, struct string t)
{
  int i2 = 0;
  if (s.si != t.si)
  {
    return false;
  }
  else
  {
    
  }

  for (i2 = 0; i2 < s.si; i2++)
  {
    if (s.s[i2] != t.s[i2])
    {
      return false;
    }
    else
    {
      
    }

  }

  return true;
}

struct pair
{
  int a;
  struct string s;
};
ll cmp(struct pair p1, struct pair p2)
{
  int i3 = 0;
  if (p1.a > p2.a)
  {
    return 0;
  }
  else
  {
    
  }

  if (p1.a < p2.a)
  {
    return 1;
  }
  else
  {
    
  }

  if (p1.a == 1000000L)
  {
    return -1;
  }
  else
  {
    
  }

  for (i3 = 0; i3 < min(p1.s.si, p2.s.si); i3++)
  {
    if (p1.s.s[i3] < p2.s.s[i3])
    {
      return 1;
    }
    else
    {
      if (p1.s.s[i3] > p2.s.s[i3])
      {
        return 0;
      }
      else
      {
        
      }

    }

  }

  if (p1.s.si > p2.s.si)
  {
    return 0;
  }
  else
  {
    if (p1.s.si < p2.s.si)
    {
      return 1;
    }
    else
    {
      
    }

  }

  return -1;
}

struct pair inp3()
{
  struct pair ans;
  ans.a = new_sym_var(sizeof(int) * 8);
  ans.s = inp();
  return ans;
}

void print3(struct pair val)
{
  printf("%d ", val.a);
  print(val.s);
}

struct node3
{
  struct pair val;
  ll h;
  struct node3 *par;
  struct node3 *lson;
  struct node3 *rson;
  struct node3 *prv;
  struct node3 *nxt;
};
struct AVL3
{
  ll N;
  struct node3 *root;
  struct node3 *beg;
  struct node3 *en;
};
struct AVL3 init3()
{
  struct AVL3 s;
  struct pair p;
  struct string str;
  p.a = 1000000L;
  str.s = (char *) malloc(sizeof(char));
  str.s[0] = 'a';
  str.si = 1;
  p.s = str;
  s.en = (struct node3 *) malloc(sizeof(struct node3));
  s.en->lson = 0;
  s.en->rson = 0;
  s.en->par = 0;
  s.en->h = 0;
  s.en->val = p;
  s.en->val.s = str;
  s.en->prv = 0;
  s.en->nxt = 0;
  s.root = s.en;
  s.beg = s.en;
  s.N = 0L;
  return s;
}

struct node3 *begin3(struct AVL3 *s)
{
  return s->beg;
}

struct node3 *end3(struct AVL3 *s)
{
  return s->en;
}

void display3(struct AVL3 *s)
{
  struct node3 *X = begin3(s);
  while (X != end3(s))
  {
    printf("%d ", X->val.a);
    print(X->val.s);
    printf("\n");
    X = X->nxt;
  }

  printf("\n");
}

struct node3 *find3(struct AVL3 *s, struct pair val)
{
  struct node3 *cur = s->root;
  while (1 > 0)
  {
    if (cmp(cur->val, val) == (-1))
    {
      return cur;
    }
    else
    {
      if ((cmp(cur->val, val) == 0) && (cur->lson != 0))
      {
        cur = cur->lson;
      }
      else
      {
        if ((cmp(cur->val, val) == 1) && (cur->rson != 0))
        {
          cur = cur->rson;
        }
        else
        {
          return s->en;
        }

      }

    }

  }

}

struct node3 *lower_bound3(struct AVL3 *s, struct pair val)
{
  struct node3 *cur = s->root;
  struct node3 *ans = s->en;
  while (1 > 0)
  {
    if (cmp(cur->val, val) == (-1))
    {
      return cur;
    }
    else
    {
      
    }

    if ((cmp(cur->val, val) == 0) && (cmp(cur->val, ans->val) == 1))
    {
      ans = cur;
    }
    else
    {
      
    }

    if ((cmp(cur->val, val) == 0) && (cur->lson != 0))
    {
      cur = cur->lson;
    }
    else
    {
      if ((cmp(cur->val, val) == 1) && (cur->rson != 0))
      {
        cur = cur->rson;
      }
      else
      {
        break;
      }

    }

  }

  return ans;
}

struct node3 *upper_bound3(struct AVL3 *s, struct pair val)
{
  struct node3 *cur = s->root;
  struct node3 *ans = s->en;
  while (1 > 0)
  {
    if ((cmp(cur->val, val) == 0) && (cmp(cur->val, ans->val) == 1))
    {
      ans = cur;
    }
    else
    {
      
    }

    if ((cmp(cur->val, val) == 0) && (cur->lson != 0))
    {
      cur = cur->lson;
    }
    else
    {
      if ((cmp(cur->val, val) != 0) && (cur->rson != 0))
      {
        cur = cur->rson;
      }
      else
      {
        return ans;
      }

    }

  }

}

void Balance3(struct AVL3 *s, struct node3 *X)
{
  ll h1;
  ll h2;
  struct node3 *cur;
  bool balanced;
  struct node3 *A;
  struct node3 *B;
  struct node3 *C;
  struct node3 *D;
  struct node3 *E;
  balanced = true;
  cur = X;
  while (1 > 0)
  {
    h1 = 0, h2 = 0;
    if (cur->lson != 0)
    {
      h1 = cur->lson->h + 1;
    }
    else
    {
      
    }

    if (cur->rson != 0)
    {
      h2 = cur->rson->h + 1;
    }
    else
    {
      
    }

    if (abs(h1 - h2) > 1)
    {
      balanced = false;
      break;
    }
    else
    {
      
    }

    if (cur == s->root)
    {
      break;
    }
    else
    {
      
    }

    cur = cur->par;
  }

  if (balanced)
  {
    return;
  }
  else
  {
    
  }

  h1 = 0;
  h2 = 0;
  if (cur->lson != 0)
  {
    h1 = cur->lson->h + 1;
  }
  else
  {
    
  }

  if (cur->rson != 0)
  {
    h2 = cur->rson->h + 1;
  }
  else
  {
    
  }

  if (h2 > h1)
  {
    ll hl = 0;
    ll hr = 0;
    if (cur->rson->lson != 0)
    {
      hl = cur->rson->lson->h + 1;
    }
    else
    {
      
    }

    if (cur->rson->rson != 0)
    {
      hr = cur->rson->rson->h + 1;
    }
    else
    {
      
    }

    if (hr > hl)
    {
      cur->h -= 2;
      A = cur->rson;
      if (cur->par == 0)
      {
        s->root = A;
      }
      else
      {
        
      }

      A->par = cur->par;
      cur->par = A;
      cur->rson = A->lson;
      if (A->lson != 0)
      {
        A->lson->par = cur;
      }
      else
      {
        
      }

      A->lson = cur;
      if (A->par != 0)
      {
        if (A->par->rson == cur)
        {
          A->par->rson = A;
        }
        else
        {
          
        }

        if (A->par->lson == cur)
        {
          A->par->lson = A;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      cur = A;
      while (cur != s->root)
      {
        cur = cur->par;
        cur->h--;
      }

    }
    else
    {
      A = cur;
      B = A->rson;
      C = B->lson;
      D = C->lson;
      E = C->rson;
      if (s->root == A)
      {
        s->root = C;
      }
      else
      {
        
      }

      C->par = A->par;
      if (C->par != 0)
      {
        if (C->par->rson == A)
        {
          C->par->rson = C;
        }
        else
        {
          
        }

        if (C->par->lson == A)
        {
          C->par->lson = C;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      A->par = C;
      C->lson = A;
      A->rson = D;
      if (D != 0)
      {
        D->par = A;
      }
      else
      {
        
      }

      B->lson = E;
      if (E != 0)
      {
        E->par = B;
      }
      else
      {
        
      }

      B->par = C;
      C->rson = B;
      B->h = 0;
      if (B->rson != 0)
      {
        B->h = B->rson->h + 1;
      }
      else
      {
        
      }

      A->h = 0;
      if (A->lson != 0)
      {
        A->h = A->lson->h + 1;
      }
      else
      {
        
      }

      C->h++;
      cur = C;
      while (cur != s->root)
      {
        cur = cur->par;
        cur->h--;
      }

    }

  }
  else
  {
    ll hl = 0;
    ll hr = 0;
    if (cur->lson->lson != 0)
    {
      hl = cur->lson->lson->h + 1;
    }
    else
    {
      
    }

    if (cur->lson->rson != 0)
    {
      hr = cur->lson->rson->h + 1;
    }
    else
    {
      
    }

    if (hl > hr)
    {
      cur->h -= 2;
      A = cur->lson;
      if (cur->par == 0)
      {
        s->root = A;
      }
      else
      {
        
      }

      A->par = cur->par;
      cur->par = A;
      cur->lson = A->rson;
      if (A->rson != 0)
      {
        A->rson->par = cur;
      }
      else
      {
        
      }

      A->rson = cur;
      if (A->par != 0)
      {
        if (A->par->rson == cur)
        {
          A->par->rson = A;
        }
        else
        {
          
        }

        if (A->par->lson == cur)
        {
          A->par->lson = A;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      cur = A;
      while (cur != s->root)
      {
        cur = cur->par;
        cur->h--;
      }

    }
    else
    {
      A = cur;
      B = A->lson;
      C = B->rson;
      D = C->rson;
      E = C->lson;
      if (s->root == A)
      {
        s->root = C;
      }
      else
      {
        
      }

      C->par = A->par;
      A->par = C;
      A->lson = D;
      B->rson = E;
      B->par = C;
      C->rson = A;
      C->lson = B;
      if (D != 0)
      {
        D->par = A;
      }
      else
      {
        
      }

      if (E != 0)
      {
        E->par = B;
      }
      else
      {
        
      }

      B->h = 0;
      if (B->lson != 0)
      {
        B->h = B->lson->h + 1;
      }
      else
      {
        
      }

      A->h = 0;
      if (A->rson != 0)
      {
        A->h = A->rson->h + 1;
      }
      else
      {
        
      }

      C->h++;
      if (C->par != 0)
      {
        if (C->par->rson == cur)
        {
          C->par->rson = C;
        }
        else
        {
          
        }

        if (C->par->lson == cur)
        {
          C->par->lson = C;
        }
        else
        {
          
        }

      }
      else
      {
        
      }

      cur = C;
      while (cur != s->root)
      {
        cur = cur->par;
        cur->h--;
      }

    }

  }

  return;
}

void insert3(struct AVL3 *s, struct pair val)
{
  struct node3 *next;
  struct node3 *X;
  struct node3 *cur;
  next = lower_bound3(s, val);
  X = (struct node3 *) malloc(sizeof(struct node3));
  X->val = val;
  X->h = 0;
  X->par = 0;
  X->lson = 0;
  X->rson = 0;
  cur = s->root;
  s->N++;
  while ((cur->lson != 0) && (cur->rson != 0))
  {
    cur->h++;
    if (cmp(cur->val, X->val) != 1)
    {
      cur = cur->lson;
    }
    else
    {
      cur = cur->rson;
    }

  }

  cur->h++;
  if ((cur->lson == 0) && (cur->rson == 0))
  {
    if (cmp(cur->val, X->val) != 1)
    {
      cur->lson = X;
      X->par = cur;
    }
    else
    {
      cur->rson = X;
      X->par = cur;
    }

  }
  else
  {
    if (cur->lson == 0)
    {
      if (cmp(cur->val, X->val) != 1)
      {
        cur->lson = X;
        X->par = cur;
      }
      else
      {
        cur = cur->rson;
        cur->h++;
        if (cmp(X->val, cur->val) != 1)
        {
          cur->rson = X;
          X->par = cur;
        }
        else
        {
          cur->lson = X;
          X->par = cur;
        }

      }

    }
    else
    {
      if (cur->rson == 0)
      {
        if (cmp(cur->val, X->val) != 0)
        {
          cur->rson = X;
          X->par = cur;
        }
        else
        {
          cur = cur->lson;
          cur->h++;
          if (cmp(X->val, cur->val) != 1)
          {
            cur->rson = X;
            X->par = cur;
          }
          else
          {
            cur->lson = X;
            X->par = cur;
          }

        }

      }
      else
      {
        
      }

    }

  }

  if (cmp(X->val, s->beg->val) == 1)
  {
    s->beg = X;
  }
  else
  {
    
  }

  Balance3(s, X);
  X->nxt = next;
  X->prv = X->nxt->prv;
  X->nxt->prv = X;
  if (X->prv != 0)
  {
    X->prv->nxt = X;
  }
  else
  {
    
  }

}

void erase3(struct AVL3 *s, struct node3 *X)
{
  struct node3 *p;
  struct node3 *cur;
  struct pair aux;
  if (X->val.a == 1000000L)
  {
    return;
  }
  else
  {
    
  }

  if ((X->lson == 0) && (X->rson == 0))
  {
    cur = X;
    p = cur->par;
    cur->h = -1;
    cur = p;
    while (1 > 0)
    {
      ll h1 = 0;
      ll h2 = 0;
      if (cur->lson != 0)
      {
        h1 = cur->lson->h + 1;
      }
      else
      {
        
      }

      if (cur->rson != 0)
      {
        h2 = cur->rson->h + 1;
      }
      else
      {
        
      }

      cur->h = max(h1, h2);
      if (cur == s->root)
      {
        break;
      }
      else
      {
        
      }

      cur = cur->par;
    }

    cur = X;
    if (cur->par->rson == cur)
    {
      cur->par->rson = 0;
    }
    else
    {
      
    }

    if (cur->par->lson == cur)
    {
      cur->par->lson = 0;
    }
    else
    {
      
    }

    X->nxt->prv = X->prv;
    if (X->prv != 0)
    {
      X->prv->nxt = X->nxt;
    }
    else
    {
      
    }

    if (X == s->beg)
    {
      s->beg = s->beg->nxt;
    }
    else
    {
      
    }

    free(cur);
    s->N--;
    Balance3(s, p);
    return;
  }
  else
  {
    
  }

  if (X->rson == 0)
  {
    cur = X;
    p = cur->lson;
    cur->h = -1;
    cur = p;
    while (1 > 0)
    {
      ll h1 = 0;
      ll h2 = 0;
      if (cur->lson != 0)
      {
        h1 = cur->lson->h + 1;
      }
      else
      {
        
      }

      if (cur->rson != 0)
      {
        h2 = cur->rson->h + 1;
      }
      else
      {
        
      }

      cur->h = max(h1, h2);
      if (cur == s->root)
      {
        break;
      }
      else
      {
        
      }

      cur = cur->par;
    }

    cur = X;
    if (X == s->root)
    {
      p->par = 0;
      s->root = p;
      return;
    }
    else
    {
      
    }

    if (cur->par->rson == cur)
    {
      cur->par->rson = p;
    }
    else
    {
      
    }

    if (cur->par->lson == cur)
    {
      cur->par->lson = p;
    }
    else
    {
      
    }

    p->par = cur->par;
    X->nxt->prv = X->prv;
    if (X->prv != 0)
    {
      X->prv->nxt = X->nxt;
    }
    else
    {
      
    }

    if (X == s->beg)
    {
      s->beg = s->beg->nxt;
    }
    else
    {
      
    }

    free(cur);
    s->N--;
    Balance3(s, p);
    return;
  }
  else
  {
    
  }

  if (X->lson == 0)
  {
    cur = X;
    p = cur->rson;
    cur->h = -1;
    cur = p;
    while (1 > 0)
    {
      ll h1 = 0;
      ll h2 = 0;
      if (cur->lson != 0)
      {
        h1 = cur->lson->h + 1;
      }
      else
      {
        
      }

      if (cur->rson != 0)
      {
        h2 = cur->rson->h + 1;
      }
      else
      {
        
      }

      cur->h = max(h1, h2);
      if (cur == s->root)
      {
        break;
      }
      else
      {
        
      }

      cur = cur->par;
    }

    cur = X;
    if (X == s->root)
    {
      p->par = 0;
      s->root = p;
      return;
    }
    else
    {
      
    }

    if (cur->par->rson == cur)
    {
      cur->par->rson = p;
    }
    else
    {
      
    }

    if (cur->par->lson == cur)
    {
      cur->par->lson = p;
    }
    else
    {
      
    }

    p->par = cur->par;
    X->nxt->prv = X->prv;
    if (X->prv != 0)
    {
      X->prv->nxt = X->nxt;
    }
    else
    {
      
    }

    if (X == s->beg)
    {
      s->beg = s->beg->nxt;
    }
    else
    {
      
    }

    free(cur);
    s->N--;
    Balance3(s, p);
    return;
  }
  else
  {
    
  }

  p = X->lson;
  while (p->rson != 0)
  {
    p = p->rson;
  }

  aux = X->val;
  X->val = p->val;
  p->val = aux;
  erase3(s, p);
}

struct string unid;
struct string inp6()
{
  struct string ans;
  ans = inp();
  return ans;
}

void print6(struct string val)
{
  print(val);
}

struct node6
{
  struct string val;
  struct string t1;
  struct string t2;
  int s1;
  int s2;
  struct string k;
  bool visited;
  struct node6 *nxt;
  struct node6 *prv;
};
struct node6 inp7()
{
  struct node6 ans;
  ans.val = inp();
  return ans;
}

void print7(struct node6 val)
{
  print(val.val);
}

struct vector7
{
  struct node6 *a;
  ll size;
};
void disp7(struct vector7 v)
{
  int i4;
  for (i4 = 0; i4 < v.size; i4++)
  {
    print7(*(v.a + i4));
    printf(" ");
  }

  printf("\n");
}

struct vector7 init7(int N)
{
  int i5;
  struct vector7 v;
  v.a = (struct node6 *) malloc(N * (sizeof(struct node6)));
  v.size = N;
  for (i5 = 0; i5 < N; i5++)
  {
    *(v.a + i5) = inp7();
  }

  return v;
}

void push_back7(struct vector7 *v, struct node6 val)
{
  (*v).size++;
  (*v).a = (struct node6 *) realloc((*v).a, (*v).size * (sizeof(struct node6)));
  (*v).a[(*v).size - 1] = val;
}

void pop_back7(struct vector7 *v)
{
  (*v).size--;
  (*v).a = (struct node6 *) realloc((*v).a, (*v).size * (sizeof(struct node6)));
}

struct unordered_map6
{
  ll M;
  ll N;
  struct vector7 a;
  struct node6 *be;
  struct node6 *en;
};
struct unordered_map6 init6(ll m)
{
  int i6;
  struct unordered_map6 H;
  struct node6 X;
  unid.si = 10L;
  unid.s = (char *) malloc(10 * (sizeof(char)));
  unid.s = "impossible";
  H.a = init7(0);
  H.M = m;
  X = *((struct node6 *) malloc(sizeof(struct node6)));
  for (i6 = 0; i6 < H.M; i6++)
  {
    push_back7(&H.a, X);
  }

  H.be = (struct node6 *) malloc(sizeof(struct node6));
  H.en = (struct node6 *) malloc(sizeof(struct node6));
  H.be->prv = 0;
  H.be->nxt = H.en;
  H.en->prv = H.be;
  H.en->nxt = 0;
  H.N = 0;
  return H;
}

struct node6 *begin6(struct unordered_map6 *H)
{
  return H->be;
}

struct node6 *end6(struct unordered_map6 *H)
{
  return H->en;
}

ll hash6(struct unordered_map6 *H, struct string k)
{
  ll i7;
  ll ans = 0L;
  ll val = 1L;
  for (i7 = 0; i7 < k.si; i7++)
  {
    ll cur_val = (ll) k.s[i7];
    ans += cur_val * val;
    ans = ans % H->M;
    val *= 10L;
    val = val % H->M;
  }

  return ans;
}

void insert6(struct unordered_map6 *H, struct string k, struct string val, struct string t1, struct string t2, int s1, int s2)
{
  struct node6 *X;
  ll ind;
  X = (struct node6 *) malloc(sizeof(struct node6));
  X->visited = true;
  X->k = k;
  X->val = val;
  X->t1 = t1;
  X->t2 = t2;
  X->s1 = s1;
  X->s2 = s2;
  ind = hash6(H, k);
  while (H->a.a[ind].visited)
  {
    if (eq(H->a.a[ind].k, k))
    {
      H->a.a[ind] = *X;
      return;
    }
    else
    {
      
    }

    ind = (ind + 1) % H->M;
  }

  H->a.a[ind] = *X;
  H->N++;
  H->a.a[ind].nxt = end6(H);
  H->a.a[ind].prv = H->en->prv;
  H->a.a[ind].prv->nxt = &H->a.a[ind];
  H->en->prv = &H->a.a[ind];
  if (H->N == 1)
  {
    H->be = &H->a.a[ind];
    return;
  }
  else
  {
    
  }

}

struct node6 *find6(struct unordered_map6 *H, struct string k)
{
  ll ind = hash6(H, k);
  while (H->a.a[ind].visited)
  {
    if (eq(H->a.a[ind].k, k))
    {
      return &H->a.a[ind];
    }
    else
    {
      
    }

    ind = (ind + 1) % H->M;
  }

  return end6(H);
}

void erase6(struct unordered_map6 *H, struct node6 *X)
{
  H->N--;
  X->k = unid;
  X->nxt->prv = X->prv;
  if (X->prv != 0)
  {
    X->prv->nxt = X->nxt;
  }
  else
  {
    
  }

  if (H->be == X)
  {
    H->be = X->nxt;
  }
  else
  {
    
  }

}

struct string unid;
struct string inp8()
{
  struct string ans;
  ans = inp();
  return ans;
}

void print8(struct string val)
{
  print(val);
}

struct node8
{
  struct string val;
  int pts;
  struct string k;
  bool visited;
  struct node8 *nxt;
  struct node8 *prv;
};
struct node8 inp9()
{
  struct node8 ans;
  ans.val = inp();
  ans.pts = 0;
  return ans;
}

void print9(struct node8 val)
{
  print(val.val);
}

struct vector9
{
  struct node8 *a;
  ll size;
};
void disp9(struct vector9 v)
{
  int i8;
  for (i8 = 0; i8 < v.size; i8++)
  {
    print9(*(v.a + i8));
    printf(" ");
  }

  printf("\n");
}

struct vector9 init9(int N)
{
  int i9;
  struct vector9 v;
  v.a = (struct node8 *) malloc(N * (sizeof(struct node8)));
  v.size = N;
  for (i9 = 0; i9 < N; i9++)
  {
    *(v.a + i9) = inp9();
  }

  return v;
}

void push_back9(struct vector9 *v, struct node8 val)
{
  (*v).size++;
  (*v).a = (struct node8 *) realloc((*v).a, (*v).size * (sizeof(struct node8)));
  (*v).a[(*v).size - 1] = val;
}

void pop_back9(struct vector9 *v)
{
  (*v).size--;
  (*v).a = (struct node8 *) realloc((*v).a, (*v).size * (sizeof(struct node8)));
}

struct unordered_map8
{
  ll M;
  ll N;
  struct vector9 a;
  struct node8 *be;
  struct node8 *en;
};
struct unordered_map8 init8(ll m)
{
  int i10;
  struct unordered_map8 H;
  struct node8 X;
  unid.si = 10L;
  unid.s = (char *) malloc(10 * (sizeof(char)));
  unid.s = "impossible";
  H.a = init9(0);
  H.M = m;
  X = *((struct node8 *) malloc(sizeof(struct node8)));
  for (i10 = 0; i10 < H.M; i10++)
  {
    push_back9(&H.a, X);
  }

  H.be = (struct node8 *) malloc(sizeof(struct node8));
  H.en = (struct node8 *) malloc(sizeof(struct node8));
  H.be->prv = 0;
  H.be->nxt = H.en;
  H.en->prv = H.be;
  H.en->nxt = 0;
  H.N = 0;
  return H;
}

struct node8 *begin8(struct unordered_map8 *H)
{
  return H->be;
}

struct node8 *end8(struct unordered_map8 *H)
{
  return H->en;
}

ll hash8(struct unordered_map8 *H, struct string k)
{
  int i11;
  ll ans = 0L;
  ll val = 1L;
  for (i11 = 0; i11 < k.si; i11++)
  {
    ll cur_val = (ll) k.s[i11];
    ans += cur_val * val;
    ans = ans % H->M;
    val *= 10L;
    val = val % H->M;
  }

  return ans;
}

void insert8(struct unordered_map8 *H, struct string k, struct string val)
{
  ll ind;
  struct node8 *X = (struct node8 *) malloc(sizeof(struct node8));
  X->visited = true;
  X->k = k;
  X->val = val;
  X->pts = 0L;
  ind = hash8(H, k);
  while (H->a.a[ind].visited)
  {
    if (eq(H->a.a[ind].k, k))
    {
      H->a.a[ind] = *X;
      return;
    }
    else
    {
      
    }

    ind = (ind + 1) % H->M;
  }

  H->a.a[ind] = *X;
  H->N++;
  H->a.a[ind].nxt = end8(H);
  H->a.a[ind].prv = H->en->prv;
  H->a.a[ind].prv->nxt = &H->a.a[ind];
  H->en->prv = &H->a.a[ind];
  if (H->N == 1)
  {
    H->be = &H->a.a[ind];
    return;
  }
  else
  {
    
  }

}

struct node8 *find8(struct unordered_map8 *H, struct string k)
{
  ll ind = hash8(H, k);
  while (H->a.a[ind].visited)
  {
    if (eq(H->a.a[ind].k, k))
    {
      return &H->a.a[ind];
    }
    else
    {
      
    }

    ind = (ind + 1) % H->M;
  }

  return end8(H);
}

void erase8(struct unordered_map8 *H, struct node8 *X)
{
  H->N--;
  X->k = unid;
  X->nxt->prv = X->prv;
  if (X->prv != 0)
  {
    X->prv->nxt = X->nxt;
  }
  else
  {
    
  }

  if (H->be == X)
  {
    H->be = X->nxt;
  }
  else
  {
    
  }

}

int main()
{
  struct unordered_map6 mg = init6(9973L);
  struct unordered_map8 mt = init8(9973L);
  struct pair p;
  struct node3 *Z;
  struct AVL3 s = init3();
  char c;
  line = 0;
  while (1 > 0)
  {
    line++;
    c = new_sym_var(sizeof(char) * 8);
    if (c == 'a')
    {
      struct string name;
      struct string t1;
      struct string t2;
      struct node6 *X;
      struct node8 *Y;
      int s1;
      int s2;
      char insig;
      name = inp();
      t1 = inp();
      t2 = inp();
      s1 = new_sym_var(sizeof(int) * 8);
      insig = new_sym_var(sizeof(char) * 8);
      s2 = new_sym_var(sizeof(int) * 8);
      insig = new_sym_var(sizeof(char) * 8);
      X = find6(&mg, name);
      if (X != end6(&mg))
      {
        printf("%d Jogo existente.\n", line);
        continue;
      }
      else
      {
        
      }

      Y = find8(&mt, t1);
      if (Y == end8(&mt))
      {
        printf("%d Equipa inexistente.\n", line);
        continue;
      }
      else
      {
        
      }

      Y = find8(&mt, t2);
      if (Y == end8(&mt))
      {
        printf("%d Equipa inexistente.\n", line);
        continue;
      }
      else
      {
        
      }

      insert6(&mg, name, name, t1, t2, s1, s2);
      Y = find8(&mt, t1);
      p.a = Y->pts;
      p.s = t1;
      Z = find3(&s, p);
      erase3(&s, Z);
      Y = find8(&mt, t2);
      p.a = Y->pts;
      p.s = t2;
      Z = find3(&s, p);
      erase3(&s, Z);
      if (s1 > s2)
      {
        Y = find8(&mt, t1);
        Y->pts++;
      }
      else
      {
        if (s2 > s1)
        {
          Y = find8(&mt, t2);
          Y->pts++;
        }
        else
        {
          
        }

      }

      Y = find8(&mt, t1);
      p.a = Y->pts;
      p.s = t1;
      insert3(&s, p);
      Y = find8(&mt, t2);
      p.a = Y->pts;
      p.s = t2;
      insert3(&s, p);
    }
    else
    {
      if (c == 'A')
      {
        struct string name = inp();
        struct node8 *X;
        X = find8(&mt, name);
        if (X != end8(&mt))
        {
          printf("%d Equipa existente.\n", line);
          continue;
        }
        else
        {
          insert8(&mt, name, name);
        }

        p.a = 0;
        p.s = name;
        insert3(&s, p);
      }
      else
      {
        if (c == 'l')
        {
          char insig;
          struct node6 *cur = begin6(&mg);
          for (i = 0; i < mg.N; i++)
          {
            printf("%d ", line);
            print(cur->val);
            printf(" ");
            print(cur->t1);
            printf(" ");
            print(cur->t2);
            printf(" ");
            printf("%d %d\n", cur->s1, cur->s2);
            cur = cur->nxt;
          }

          insig = new_sym_var(sizeof(char) * 8);
        }
        else
        {
          if (c == 'p')
          {
            struct string name;
            struct node6 *X;
            name = inp();
            X = find6(&mg, name);
            if (X == end6(&mg))
            {
              printf("%d Jogo inexistente.\n", line);
              continue;
            }
            else
            {
              
            }

            printf("%d ", line);
            print(name);
            printf(" ");
            print(X->t1);
            printf(" ");
            print(X->t2);
            printf(" ");
            printf("%d %d\n", X->s1, X->s2);
          }
          else
          {
            if (c == 'P')
            {
              struct string name = inp();
              struct node8 *X = find8(&mt, name);
              if (X == end8(&mt))
              {
                printf("%d Equipa inexistente.\n", line);
              }
              else
              {
                printf("%d ", line);
                print(name);
                printf(" %d\n", X->pts);
              }

            }
            else
            {
              if (c == 'r')
              {
                struct node8 *Y;
                struct string name = inp();
                struct node6 *X = find6(&mg, name);
                if (X == end6(&mg))
                {
                  printf("%d Jogo inexistente.\n", line);
                  continue;
                }
                else
                {
                  
                }

                if (X->s1 > X->s2)
                {
                  Y = find8(&mt, X->t1);
                  p.a = Y->pts;
                  p.s = X->t1;
                  Z = find3(&s, p);
                  erase3(&s, Z);
                  Y->pts--;
                  p.a--;
                  insert3(&s, p);
                }
                else
                {
                  if (X->s2 > X->s1)
                  {
                    Y = find8(&mt, X->t2);
                    p.a = Y->pts;
                    p.s = X->t2;
                    Z = find3(&s, p);
                    erase3(&s, Z);
                    Y->pts--;
                    p.a--;
                    insert3(&s, p);
                  }
                  else
                  {
                    
                  }

                }

                erase6(&mg, X);
              }
              else
              {
                if (c == 's')
                {
                  struct string name = inp();
                  int s1;
                  int s2;
                  char insig;
                  struct node6 *X;
                  struct node8 *Y;
                  s1 = new_sym_var(sizeof(int) * 8);
                  insig = new_sym_var(sizeof(char) * 8);
                  s2 = new_sym_var(sizeof(int) * 8);
                  insig = new_sym_var(sizeof(char) * 8);
                  X = find6(&mg, name);
                  if (X == end6(&mg))
                  {
                    printf("%d Jogo inexistente.\n", line);
                    continue;
                  }
                  else
                  {
                    
                  }

                  Y = find8(&mt, X->t1);
                  p.a = Y->pts;
                  p.s = X->t1;
                  Z = find3(&s, p);
                  erase3(&s, Z);
                  Y = find8(&mt, X->t2);
                  p.a = Y->pts;
                  p.s = X->t2;
                  Z = find3(&s, p);
                  erase3(&s, Z);
                  if (X->s1 > X->s2)
                  {
                    Y = find8(&mt, X->t1);
                    Y->pts--;
                  }
                  else
                  {
                    if (X->s2 > X->s1)
                    {
                      Y = find8(&mt, X->t2);
                      Y->pts--;
                    }
                    else
                    {
                      
                    }

                  }

                  X->s1 = s1;
                  X->s2 = s2;
                  if (s1 > s2)
                  {
                    Y = find8(&mt, X->t1);
                    Y->pts++;
                  }
                  else
                  {
                    if (s2 > s1)
                    {
                      Y = find8(&mt, X->t2);
                      Y->pts++;
                    }
                    else
                    {
                      
                    }

                  }

                  Y = find8(&mt, X->t1);
                  p.a = Y->pts;
                  p.s = X->t1;
                  insert3(&s, p);
                  Y = find8(&mt, X->t2);
                  p.a = Y->pts;
                  p.s = X->t2;
                  insert3(&s, p);
                }
                else
                {
                  if (c == 'g')
                  {
                    char insig;
                    int maxvalue;
                    insig = new_sym_var(sizeof(char) * 8);
                    if (s.N == 0)
                    {
                      continue;
                    }
                    else
                    {
                      
                    }

                    Z = end3(&s);
                    Z = Z->prv;
                    maxvalue = Z->val.a;
                    while (Z->val.a == maxvalue)
                    {
                      if (Z == begin3(&s))
                      {
                        break;
                      }
                      else
                      {
                        
                      }

                      if (Z->prv->val.a == maxvalue)
                      {
                        Z = Z->prv;
                      }
                      else
                      {
                        break;
                      }

                    }

                    printf("%d Melhores %d\n", line, maxvalue);
                    while (Z != end3(&s))
                    {
                      printf("%d * ", line);
                      print(Z->val.s);
                      printf("\n");
                      Z = Z->nxt;
                    }

                  }
                  else
                  {
                    if (c == 'x')
                    {
                      break;
                    }
                    else
                    {
                      
                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return 0;
}

