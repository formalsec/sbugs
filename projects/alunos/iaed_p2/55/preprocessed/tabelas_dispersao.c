/*File generated by PreProcessor.py*/


#include "constantes.h"
#include "tabelas_dispersao.h"
#include "comandos.h"
#include "listas.h"


int hash(char *v, int M)
{
  int h = 0;
  int a = 127;
  for (; (*v) != '\0'; v++)
    h = ((a * h) + (*v)) % M;

  return h;
}

int eh_vazia_tabela_equipa(const tabela_equipa *tabela, int M)
{
  int i = 0;
  for (i = 0; i < M; i++)
  {
    if (tabela->cabecas_eq[i] != 0)
    {
      return 0;
    }
    else
    {
      
    }

  }

  return 1;
}

int eh_vazia_tabela_jogo(const tabela_jogo *tabela, int MJ)
{
  int i = 0;
  for (i = 0; i < MJ; i++)
  {
    if (tabela->cabecas_jg[i] != 0)
    {
      return 0;
    }
    else
    {
      
    }

  }

  return 1;
}

tabela_equipa *cria_tabela_equipa(int M)
{
  int i = 0;
  tabela_equipa *novaTabela = (tabela_equipa *) malloc(sizeof(tabela_equipa));
  lista_equipa **cabecas = (lista_equipa **) malloc((sizeof(lista_equipa *)) * M);
  for (i = 0; i < M; i++)
  {
    cabecas[i] = 0;
  }

  novaTabela->cabecas_eq = &cabecas[0];
  return novaTabela;
}

tabela_jogo *cria_tabela_jogo(int MJ)
{
  int i = 0;
  tabela_jogo *novaTabela = (tabela_jogo *) malloc(sizeof(tabela_jogo));
  lista **cabecas = (lista **) malloc((sizeof(lista *)) * MJ);
  for (i = 0; i < MJ; i++)
  {
    cabecas[i] = 0;
  }

  novaTabela->cabecas_jg = &cabecas[0];
  return novaTabela;
}

void liberta_tabela_equipa(tabela_equipa *tab_libertar, int M)
{
  int i = 0;
  for (i = 0; i < M; i++)
  {
    if (tab_libertar->cabecas_eq[i] != 0)
    {
      liberta_lista_equipa(tab_libertar->cabecas_eq[i]);
    }
    else
    {
      
    }

  }

  free(tab_libertar->cabecas_eq);
  free(tab_libertar);
  return;
}

void liberta_tabela_jogo(tabela_jogo *tab_libertar, int MJ)
{
  int i = 0;
  for (i = 0; i < MJ; i++)
  {
    if (tab_libertar->cabecas_jg[i] != 0)
    {
      liberta_lista_jogo(tab_libertar->cabecas_jg[i]);
    }
    else
    {
      
    }

  }

  free(tab_libertar->cabecas_jg);
  free(tab_libertar);
  return;
}

lista_equipa *insere_ou_cria_lista_equipa(tabela_equipa *tabela, char *equipa, int M)
{
  int indice = hash(equipa, M);
  if (tabela->cabecas_eq[indice] != 0)
  {
    return tabela->cabecas_eq[indice];
  }
  else
  {
    tabela->cabecas_eq[indice] = cria_lista_equipa();
    return tabela->cabecas_eq[indice];
  }

  puts("insere_lista_equipa: Erro\n");
}

lista_equipa *pesquisa_lista_equipa(tabela_equipa *tabela, char *equipa, int M)
{
  int indice = hash(equipa, M);
  return tabela->cabecas_eq[indice];
}

lista *insere_ou_cria_lista_jogo(tabela_jogo *tabela, char *jogo, int MJ)
{
  int indice = hash(jogo, MJ);
  if (tabela->cabecas_jg[indice] != 0)
  {
    return tabela->cabecas_jg[indice];
  }
  else
  {
    tabela->cabecas_jg[indice] = cria_lista();
    return tabela->cabecas_jg[indice];
  }

  puts("insere_lista_equipa: Erro\n");
}

lista *pesquisa_lista_jogo(tabela_jogo *tabela, char *jogo, int MJ)
{
  int indice = hash(jogo, MJ);
  return tabela->cabecas_jg[indice];
}

int retorna_contador_max_vitorias_tabela(const tabela_equipa *tabela, int M, int max_vitorias)
{
  int i;
  int contador_vitorias = 0;
  lista_equipa *lista;
  if (!eh_vazia_tabela_equipa(tabela, M))
  {
    for (i = 0; i < M; i++)
    {
      if (tabela->cabecas_eq[i] != 0)
      {
        lista = tabela->cabecas_eq[i];
        if (!eh_vazia_equipa(lista))
        {
          contador_vitorias += Retorna_contador_max_vitorias(lista, max_vitorias);
        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  return contador_vitorias;
}

int retorna_max_vitorias_tabela(const tabela_equipa *tabela, int M)
{
  int i;
  int maximo = 0;
  int maximo_vitorias = 0;
  lista_equipa *lista;
  if (!eh_vazia_tabela_equipa(tabela, M))
  {
    for (i = 0; i < M; i++)
    {
      if (tabela->cabecas_eq[i] != 0)
      {
        lista = tabela->cabecas_eq[i];
        if (!eh_vazia_equipa(lista))
        {
          maximo = Retorna_max_vitorias(lista);
          if (maximo > maximo_vitorias)
          {
            maximo_vitorias = maximo;
          }
          else
          {
            
          }

        }
        else
        {
          
        }

      }
      else
      {
        
      }

    }

  }
  else
  {
    
  }

  return maximo_vitorias;
}

