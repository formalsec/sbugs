/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "teams.h"


TeamHT team_ht_init(int size)
{
  TeamHT team_ht;
  int i;
  team_ht.size = size;
  team_ht.teams_num = 0;
  team_ht.header = (TeamLink *) malloc(size * (sizeof(TeamLink)));
  for (i = 0; i < size; i++)
  {
    team_ht.header[i] = 0;
  }

  return team_ht;
}

int name_hash(int size, char *c)
{
  int h;
  int a = 31415;
  int b = 27183;
  for (h = 0; (*c) != '\0'; c++, a = (a * b) % (size - 1))
  {
    h = ((a * h) + (*c)) % size;
  }

  return h;
}

TeamLink team_ht_search(TeamHT team_ht, char *team)
{
  TeamLink t;
  int team_hash = name_hash(team_ht.size, team);
  for (t = team_ht.header[team_hash]; t != 0; t = t->next)
  {
    if (!strcmp(t->team, team))
    {
      return t;
    }
    else
    {
      
    }

  }

  return 0;
}

void team_ht_search_print(TeamHT team_ht, char *team, unsigned long int NL)
{
  TeamLink res = team_ht_search(team_ht, team);
  if (res == 0)
  {
    printf("%ld Equipa inexistente.\n", NL);
    return;
  }
  else
  {
    printf("%ld %s %d\n", NL, res->team, res->games_won);
  }

}

void team_ht_insert(TeamHT *team_ht_ptr, char *team, unsigned long int NL)
{
  if (team_ht_search(*team_ht_ptr, team) != 0)
  {
    printf("%ld Equipa existente.\n", NL);
    return;
  }
  else
  {
    int team_hash = name_hash(team_ht_ptr->size, team);
    TeamLink t = (TeamLink) malloc(sizeof(struct TeamNode));
    t->team = (char *) malloc((strlen(team) + 1) * (sizeof(char)));
    strcpy(t->team, team);
    t->games_won = 0;
    t->next = team_ht_ptr->header[team_hash];
    team_ht_ptr->header[team_hash] = t;
    team_ht_ptr->teams_num++;
  }

}

static int team_comp_name(const void *team1, const void *team2)
{
  char *name1;
  char *name2;
  name1 = (*((TeamLink *) team1))->team;
  name2 = (*((TeamLink *) team2))->team;
  return strcmp(name1, name2);
}

void team_ht_print_best(TeamHT team_ht, unsigned long int NL)
{
  int i;
  int j = 0;
  TeamLink t;
  int best_score = 0;
  int best_teams_num = 0;
  TeamLink *best_teams;
  if (team_ht.teams_num == 0)
  {
    return;
  }
  else
  {
    for (i = 0; i < team_ht.size; i++)
    {
      for (t = team_ht.header[i]; t != 0; t = t->next)
      {
        if (t->games_won == best_score)
        {
          best_teams_num++;
        }
        else
        {
          if (t->games_won > best_score)
          {
            best_score = t->games_won;
            best_teams_num = 1;
          }
          else
          {
            
          }

        }

      }

    }

    best_teams = (TeamLink *) malloc(best_teams_num * (sizeof(TeamLink)));
    for (i = 0; i < team_ht.size; i++)
    {
      for (t = team_ht.header[i]; t != 0; t = t->next)
      {
        if (t->games_won == best_score)
        {
          best_teams[j++] = t;
        }
        else
        {
          
        }

      }

    }

    qsort(best_teams, best_teams_num, sizeof(TeamLink), team_comp_name);
    printf("%ld Melhores %d\n", NL, best_score);
    for (i = 0; i < best_teams_num; i++)
    {
      printf("%ld * %s\n", NL, best_teams[i]->team);
    }

    free(best_teams);
  }

}

void team_ht_free(TeamHT team_ht)
{
  int i;
  TeamLink head;
  TeamLink next;
  for (i = 0; i < team_ht.size; i++)
  {
    head = team_ht.header[i];
    while (head != 0)
    {
      next = head->next;
      free(head->team);
      free(head);
      head = next;
    }

  }

  free(team_ht.header);
}

