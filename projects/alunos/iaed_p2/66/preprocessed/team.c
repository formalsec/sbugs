#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include "team.h"


Team_ptr NewTeam(char *name)
{
  Team_ptr new_team = (Team_ptr) malloc(sizeof(struct Team));
  new_team->name = StringDup(name);
  new_team->wins = 0;
  return new_team;
}

void PrintTeam(Team_ptr team)
{
  printf("%s %d\n", team->name, team->wins);
}

void FreeTeam(Team_ptr team)
{
  free(team->name);
  free(team);
}

TeamHash_ptr TeamHashInit(int max)
{
  int i;
  TeamHash_ptr team_hash = (TeamHash_ptr) malloc(sizeof(struct TeamHash));
  team_hash->N = 0;
  team_hash->M = max;
  team_hash->hash_table = (Team_ptr *) malloc(team_hash->M * (sizeof(Team_ptr)));
  for (i = 0; i < team_hash->M; i++)
    team_hash->hash_table[i] = 0;

  return team_hash;
}

TeamHash_ptr TeamHashInsert(TeamHash_ptr *team_hash, Team_ptr team)
{
  int i = HashU(team->name, (*team_hash)->M);
  while ((*team_hash)->hash_table[i] != 0)
    i = (i + 1) % (*team_hash)->M;

  (*team_hash)->hash_table[i] = team;
  (*team_hash)->N++;
  if ((*team_hash)->N >= ((*team_hash)->M / 2))
  {
    TeamHash_ptr new_hash = TeamHashExpand(*team_hash);
    return new_hash;
  }
  else
  {
    
  }

  return *team_hash;
}

TeamHash_ptr TeamHashExpand(TeamHash_ptr team_hash)
{
  int i;
  Team_ptr *aux = team_hash->hash_table;
  TeamHash_ptr new_hash = TeamHashInit(team_hash->M * 2);
  for (i = 0; i < team_hash->M; i++)
    if (team_hash->hash_table[i] != 0)
  {
    TeamHashInsert(&new_hash, team_hash->hash_table[i]);
  }
  else
  {
    
  }


  free(aux);
  free(team_hash);
  return new_hash;
}

Team_ptr TeamHashSearch(TeamHash_ptr team_hash, char *name)
{
  int i = HashU(name, team_hash->M);
  while (team_hash->hash_table[i] != 0)
    if (strcmp(name, team_hash->hash_table[i]->name) == 0)
  {
    return team_hash->hash_table[i];
  }
  else
  {
    i = (i + 1) % team_hash->M;
  }


  return 0;
}

void ArrayInsert(Team_ptr best_teams[], Team_ptr team, int *N)
{
  best_teams[(*N)++] = team;
}

void mergesort(Team_ptr arr[], int left, int right, TeamHash_ptr team_hash)
{
  int m = (right + left) / 2;
  if (right <= left)
  {
    return;
  }
  else
  {
    
  }

  mergesort(arr, left, m, team_hash);
  mergesort(arr, m + 1, right, team_hash);
  merge(arr, left, m, right, team_hash);
}

void merge(Team_ptr arr[], int left, int m, int right, TeamHash_ptr team_hash)
{
  Team_ptr *aux = (Team_ptr *) malloc((sizeof(Team_ptr)) * team_hash->M);
  int i;
  int j;
  int k;
  for (i = m + 1; i > left; i--)
    aux[i - 1] = arr[i - 1];

  for (j = m; j < right; j++)
    aux[(right + m) - j] = arr[j + 1];

  for (k = left; k <= right; k++)
  {
    if (strcmp(aux[j]->name, aux[i]->name) < 0)
    {
      arr[k] = aux[j--];
    }
    else
    {
      arr[k] = aux[i++];
    }

  }

  free(aux);
}

void DeleteTeamHash(TeamHash_ptr team_hash)
{
  int i;
  for (i = 0; i < team_hash->M; i++)
    if (team_hash->hash_table[i] != 0)
  {
    FreeTeam(team_hash->hash_table[i]);
  }
  else
  {
    
  }


  free(team_hash->hash_table);
  free(team_hash);
}

