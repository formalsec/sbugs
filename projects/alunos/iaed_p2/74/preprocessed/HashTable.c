/*File generated by PreProcessor.py*/


#include "HashTable.h"


static games *g;
static pTeam *t;
int unsigned hash(char *name, int tamanho)
{
  int unsigned hash_value = 0;
  long lenght = strlen(name);
  int i;
  for (i = 0; i < lenght; i++)
  {
    hash_value = (hash_value * 251) + name[i];
  }

  return hash_value % tamanho;
}

void Ginit()
{
  int i;
  g = (games *) malloc((sizeof(games)) * 2000);
  for (i = 0; i < 2000; i++)
    g[i] = 0;

}

void Ginsert(char *name, char *t1, char *t2, int s1, int s2)
{
  int key = hash(name, 2000);
  games newNode = malloc(sizeof(struct node));
  newNode->game_name = stringdup(name);
  newNode->team1 = stringdup(t1);
  newNode->team2 = stringdup(t2);
  newNode->score1 = s1;
  newNode->score2 = s2;
  newNode->next = 0;
  if (g[key] == 0)
  {
    g[key] = newNode;
  }
  else
  {
    games temp = g[key];
    while (temp->next)
    {
      temp = temp->next;
    }

    temp->next = newNode;
  }

}

games Gsearch(char *name)
{
  int key = hash(name, 2000);
  games temp = g[key];
  while (temp)
  {
    if (strcmp(temp->game_name, name) == 0)
    {
      return temp;
    }
    else
    {
      
    }

    temp = temp->next;
  }

  return 0;
}

void Gdelete(char *name)
{
  int key = hash(name, 2000);
  games temp = g[key];
  games dealloc;
  games ant = g[key];
  if (strcmp(temp->game_name, name) == 0)
  {
    g[key] = temp->next;
    free(temp->game_name);
    free(temp->team1);
    free(temp->team2);
    free(temp);
  }
  else
  {
    temp = temp->next;
    while (temp)
    {
      if (strcmp(temp->game_name, name) == 0)
      {
        dealloc = temp;
        temp = temp->next;
        ant->next = temp;
        free(dealloc->game_name);
        free(dealloc->team1);
        free(dealloc->team2);
        free(dealloc);
        return;
      }
      else
      {
        
      }

      ant = temp;
      temp = temp->next;
    }

  }

}

void Gfree_hash()
{
  int i;
  games temp;
  games ant;
  for (i = 0; i < 2000; i++)
  {
    temp = g[i];
    while (temp != 0)
    {
      free(temp->game_name);
      free(temp->team1);
      free(temp->team2);
      ant = temp;
      temp = temp->next;
      free(ant);
    }

  }

  free(g);
}

void Tinit()
{
  int i;
  t = (pTeam *) malloc(25000 * (sizeof(pTeam)));
  for (i = 0; i < 25000; i++)
    t[i] = 0;

}

pTeam Thash(int i)
{
  return t[i];
}

void Tinsert(char *name)
{
  int i = hash(name, 25000);
  pTeam temp;
  while (t[i] != 0)
    i = (i + 1) % 25000;

  temp = (pTeam) malloc(sizeof(struct team));
  temp->team_name = stringdup(name);
  temp->wins = 0;
  t[i] = temp;
}

pTeam Tsearch(char *id)
{
  int i = hash(id, 25000);
  while (t[i] != 0)
  {
    if (strcmp(t[i]->team_name, id) == 0)
    {
      return t[i];
    }
    else
    {
      i = (i + 1) % 25000;
    }

  }

  return 0;
}

int max_wins()
{
  int i;
  int wins;
  int max_wins = 0;
  for (i = 0; i < 25000; i++)
  {
    if (t[i] != 0)
    {
      wins = t[i]->wins;
      if (wins > max_wins)
      {
        max_wins = wins;
      }
      else
      {
        
      }

    }
    else
    {
      
    }

  }

  return max_wins;
}

void Tfree_hash()
{
  int i;
  for (i = 0; i < 25000; i++)
  {
    if (t[i] != 0)
    {
      free(t[i]->team_name);
      free(t[i]);
    }
    else
    {
      
    }

  }

  free(t);
}

