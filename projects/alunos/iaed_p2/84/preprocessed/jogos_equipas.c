#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "jogos_equipas.h"


char *str_duplicate(char str[])
{
  int i;
  int len = strlen(str);
  char *copia;
  copia = (char *) malloc((sizeof(char)) * (len + 1));
  for (i = 0; i < len; ++i)
  {
    copia[i] = str[i];
  }

  copia[i] = '\0';
  return copia;
}

long hash_func(char *nome, int size)
{
  long h;
  long a = 31415;
  int b = 27183;
  for (h = 0; (*nome) != '\0'; nome++, a = (a * b) % (size - 1))
    h = ((a * h) + (*nome)) % size;

  return h;
}

pEquipa cria_equipa(char str[1024])
{
  pEquipa nova_equipa;
  nova_equipa = (pEquipa) malloc(sizeof(equipa));
  nova_equipa->nome = str_duplicate(str);
  nova_equipa->vit = 0;
  return nova_equipa;
}

pEquipa *cria_tabela_equi()
{
  long i;
  pEquipa *tabela;
  tabela = (pEquipa *) malloc((sizeof(pEquipa)) * tabEq_size);
  for (i = 0; i < tabEq_size; ++i)
    tabela[i] = 0;

  return tabela;
}

void expandEq()
{
  long j;
  long i = tabEq_size;
  pEquipa *tabAux;
  tabEq_size = tabEq_size * 2;
  tabAux = tabela_Equi;
  tabela_Equi = cria_tabela_equi();
  for (j = 0; j < i; ++j)
    if (tabAux[j] != 0)
  {
    insert_Eq(tabAux[j]);
  }
  else
  {
    
  }


  free(tabAux);
}

void insert_Eq(pEquipa eq)
{
  long i;
  for (i = hash_func(eq->nome, tabEq_size); tabela_Equi[i] != 0; i = (i + 1) % tabEq_size)
    ;

  tabela_Equi[i] = eq;
  if ((tabEq_ocup++) >= (tabEq_size / 2))
  {
    expandEq();
  }
  else
  {
    
  }

}

long search_Eq(char *nome)
{
  long i;
  for (i = hash_func(nome, tabEq_size); tabela_Equi[i] != 0; i = (i + 1) % tabEq_size)
  {
    if (strcmp(tabela_Equi[i]->nome, nome) == 0)
    {
      return i;
    }
    else
    {
      
    }

  }

  return -1;
}

void merge(pEquipa *vetor, int e, int d, int m)
{
  int i;
  int j;
  int k;
  pEquipa *aux;
  aux = (pEquipa *) malloc((sizeof(pEquipa)) * tabEq_ocup);
  for (i = m + 1; i > e; --i)
    aux[i - 1] = vetor[i - 1];

  for (j = m; j < d; ++j)
    aux[(d + m) - j] = vetor[j + 1];

  for (k = e; k <= d; ++k)
    if ((strcmp(aux[j]->nome, aux[i]->nome) < 0) || (i > m))
  {
    vetor[k] = aux[j];
    --j;
  }
  else
  {
    vetor[k] = aux[i];
    ++i;
  }


  free(aux);
}

void mergesort(pEquipa *vetor, int e, int d)
{
  int m = (e + d) / 2;
  if (d <= e)
  {
    return;
  }
  else
  {
    
  }

  mergesort(vetor, e, m);
  mergesort(vetor, m + 1, d);
  merge(vetor, e, d, m);
}

void freeTabEq()
{
  long i;
  for (i = 0; i < tabEq_size; ++i)
    if (tabela_Equi[i] != 0)
  {
    free(tabela_Equi[i]->nome);
    free(tabela_Equi[i]);
  }
  else
  {
    
  }


  free(tabela_Equi);
}

int vencedor(int sc1, int sc2)
{
  if (sc1 > sc2)
  {
    return 1;
  }
  else
  {
    
  }

  if (sc1 < sc2)
  {
    return 2;
  }
  else
  {
    
  }

  return -1;
}

void atualiza_vencedores(int ant_venc, int novo_venc, pEquipa e1, pEquipa e2)
{
  if ((ant_venc == 1) && (novo_venc == 2))
  {
    e1->vit--;
    e2->vit++;
  }
  else
  {
    if ((ant_venc == 2) && (novo_venc == 1))
    {
      e1->vit++;
      e2->vit--;
    }
    else
    {
      if ((ant_venc == 1) && (novo_venc == (-1)))
      {
        e1->vit--;
      }
      else
      {
        if ((ant_venc == 2) && (novo_venc == (-1)))
        {
          e2->vit--;
        }
        else
        {
          if ((ant_venc == (-1)) && (novo_venc == 1))
          {
            e1->vit++;
          }
          else
          {
            if ((ant_venc == (-1)) && (novo_venc == 2))
            {
              e2->vit++;
            }
            else
            {
              
            }

          }

        }

      }

    }

  }

}

pJogo cria_jogo(char nome[1024], pEquipa e1, pEquipa e2, int sc1, int sc2)
{
  pJogo novo_jogo;
  novo_jogo = (pJogo) malloc(sizeof(jogo));
  novo_jogo->nome = str_duplicate(nome);
  novo_jogo->e1 = e1;
  novo_jogo->e2 = e2;
  novo_jogo->sc1 = sc1;
  novo_jogo->sc2 = sc2;
  novo_jogo->next = 0;
  atualiza_vencedores(-1, vencedor(sc1, sc2), e1, e2);
  if (head == 0)
  {
    head = novo_jogo;
    tail = novo_jogo;
    novo_jogo->previous = 0;
  }
  else
  {
    tail->next = novo_jogo;
    novo_jogo->previous = tail;
    tail = novo_jogo;
  }

  return novo_jogo;
}

pJogo *cria_tabela_jogo()
{
  long i;
  pJogo *tabela;
  tabela = (pJogo *) malloc((sizeof(pJogo)) * tabJo_size);
  for (i = 0; i < tabJo_size; ++i)
    tabela[i] = 0;

  return tabela;
}

void expandJo()
{
  long j;
  long i = tabJo_size;
  pJogo *tabAux;
  tabAux = tabela_Jo;
  tabJo_size = tabJo_size * 2;
  tabela_Jo = cria_tabela_jogo();
  for (j = 0; j < i; ++j)
  {
    if (tabAux[j] != 0)
    {
      insert_Jo(tabAux[j]);
    }
    else
    {
      
    }

  }

  free(tabAux);
}

void insert_Jo(pJogo jogo)
{
  long i;
  for (i = hash_func(jogo->nome, tabJo_size); tabela_Jo[i] != 0; i = (i + 1) % tabJo_size)
    ;

  tabela_Jo[i] = jogo;
  if ((tabJo_ocup++) > (tabJo_size / 2))
  {
    expandJo();
  }
  else
  {
    
  }

}

long search_Jo(char *nome)
{
  long i;
  for (i = hash_func(nome, tabJo_size); tabela_Jo[i] != 0; i = (i + 1) % tabJo_size)
    if (strcmp(tabela_Jo[i]->nome, nome) == 0)
  {
    return i;
  }
  else
  {
    
  }


  return -1;
}

int remove_Jo(char *nome)
{
  long i;
  long j;
  pJogo jo;
  if ((i = search_Jo(nome)) == (-1))
  {
    return -1;
  }
  else
  {
    
  }

  jo = tabela_Jo[i];
  if (jo == head)
  {
    head = head->next;
    if (jo == tail)
    {
      tail = 0;
    }
    else
    {
      
    }

  }
  else
  {
    if (jo == tail)
    {
      tail = jo->previous;
      tail->next = 0;
    }
    else
    {
      jo->previous->next = jo->next;
      jo->next->previous = jo->previous;
    }

  }

  atualiza_vencedores(vencedor(jo->sc1, jo->sc2), -1, jo->e1, jo->e2);
  free(jo->nome);
  free(jo);
  tabela_Jo[i] = 0;
  tabJo_ocup--;
  for (j = (i + 1) % tabJo_size; tabela_Jo[j] != 0; j = (j + 1) % tabJo_size, tabJo_ocup--)
  {
    jo = tabela_Jo[j];
    tabela_Jo[j] = 0;
    insert_Jo(jo);
  }

  return 0;
}

void freeTabJo()
{
  long i;
  for (i = 0; i < tabJo_size; ++i)
  {
    if (tabela_Jo[i] != 0)
    {
      free(tabela_Jo[i]->nome);
      free(tabela_Jo[i]);
    }
    else
    {
      
    }

  }

  free(tabela_Jo);
}

