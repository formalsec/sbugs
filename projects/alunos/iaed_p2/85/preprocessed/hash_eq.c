#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "aux.h"
#include "hash_eq.h"


hash_eq init_hash_eq(int m)
{
  int i;
  hash_eq hash;
  hash = malloc(sizeof(struct hash_eq));
  hash->M = m;
  hash->heads = malloc(hash->M * (sizeof(struct node_eq)));
  for (i = 0; i < hash->M; i++)
  {
    hash->heads[i] = 0;
  }

  return hash;
}

link_eq insert_eq(link_eq head, pEquipa eq)
{
  link_eq old_head = head;
  head = malloc(sizeof(struct node_eq));
  head->next = old_head;
  head->eq = eq;
  return head;
}

void STinsert_eq(hash_eq hash, pEquipa eq)
{
  int i = hash_chave(hash->M, eq->n_eq);
  hash->heads[i] = insert_eq(hash->heads[i], eq);
}

pEquipa search_eq(link_eq head, char *n_eq)
{
  link_eq temp = head;
  while (temp)
  {
    if (strcmp(temp->eq->n_eq, n_eq) == 0)
    {
      return temp->eq;
    }
    else
    {
      
    }

    temp = temp->next;
  }

  return 0;
}

pEquipa STsearch_eq(hash_eq hash, char *n_eq)
{
  int i = hash_chave(hash->M, n_eq);
  pEquipa eq = 0;
  if (!hash->heads[i])
  {
    return 0;
  }
  else
  {
    
  }

  eq = search_eq(hash->heads[i], n_eq);
  if (!eq)
  {
    return 0;
  }
  else
  {
    
  }

  return eq;
}

void corrige_wins(hash_eq hash_eq, pJogo j, char *old_vencedora)
{
  if (((!j->vencedora) && (!old_vencedora)) || ((j->vencedora && old_vencedora) && (strcmp(j->vencedora, old_vencedora) == 0)))
  {
    return;
  }
  else
  {
    if ((!j->vencedora) && old_vencedora)
    {
      STsearch_eq(hash_eq, old_vencedora)->wins--;
      return;
    }
    else
    {
      if (j->vencedora && (!old_vencedora))
      {
        STsearch_eq(hash_eq, j->vencedora)->wins++;
        return;
      }
      else
      {
        STsearch_eq(hash_eq, old_vencedora)->wins--;
        STsearch_eq(hash_eq, j->vencedora)->wins++;
        return;
      }

    }

  }

}

void calcula_max(hash_eq hash, int *max, int *num_eq)
{
  int i;
  link_eq temp = 0;
  for (i = 0; i < hash->M; i++)
  {
    temp = hash->heads[i];
    while (temp)
    {
      if (temp->eq->wins == (*max))
      {
        (*num_eq)++;
      }
      else
      {
        
      }

      if (temp->eq->wins > (*max))
      {
        *num_eq = 1;
        *max = temp->eq->wins;
      }
      else
      {
        
      }

      temp = temp->next;
    }

  }

}

int comparestr(const void *pa, const void *pb)
{
  char **v1;
  char **v2;
  v1 = (char **) pa;
  v2 = (char **) pb;
  return strcmp(*v1, *v2);
}

void imprime_vencedoras(hash_eq hash, int max, int num_eq, int NL)
{
  int i;
  int j = 0;
  char **equipas;
  link_eq temp = 0;
  equipas = (char **) malloc((sizeof(char *)) * num_eq);
  for (i = 0; (i < hash->M) && (j != num_eq); i++)
  {
    temp = hash->heads[i];
    while (temp)
    {
      if (temp->eq->wins == max)
      {
        equipas[j++] = strdup(temp->eq->n_eq);
      }
      else
      {
        
      }

      temp = temp->next;
    }

  }

  qsort(equipas, num_eq, sizeof(char *), comparestr);
  printf("%d Melhores %d\n", NL, max);
  for (i = 0; i < num_eq; i++)
  {
    printf("%d * %s\n", NL, equipas[i]);
    free(equipas[i]);
  }

  free(equipas);
}

void free_link_eq(link_eq node)
{
  free_eq(node->eq);
  free(node);
}

void freeHash_eq(hash_eq hash)
{
  int i;
  link_eq temp;
  for (i = 0; i < hash->M; i++)
  {
    temp = hash->heads[i];
    while (hash->heads[i])
    {
      temp = hash->heads[i];
      hash->heads[i] = hash->heads[i]->next;
      free_link_eq(temp);
    }

    free(hash->heads[i]);
  }

  free(hash->heads);
  free(hash);
}

