#include "/home/fmarques/sbugs/projects/alunos/lib/stubs.h"
/*File generated by PreProcessor.py*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "geral.h"
#include "structs.h"


pJogo cria_jogo(char *buffer, char *team1, char *team2, int s1, int s2, table_eq tab_eq)
{
  pJogo match;
  match = (pJogo) malloc(sizeof(struct game));
  match->nome = malloc((sizeof(char)) * (strlen(buffer) + 1));
  strcpy(match->nome, buffer);
  match->equipa1 = malloc((sizeof(char)) * (strlen(team1) + 1));
  strcpy(match->equipa1, team1);
  match->equipa2 = malloc((sizeof(char)) * (strlen(team2) + 1));
  strcpy(match->equipa2, team2);
  match->score1 = s1;
  match->score2 = s2;
  if (s1 > s2)
  {
    match->winner = malloc((sizeof(char)) * (strlen(team1) + 1));
    strcpy(match->winner, team1);
    SearchEquipa(match->winner, tab_eq)->vitorias++;
  }
  else
  {
    if (s2 > s1)
    {
      match->winner = malloc((sizeof(char)) * (strlen(team2) + 1));
      strcpy(match->winner, team2);
      SearchEquipa(match->winner, tab_eq)->vitorias++;
    }
    else
    {
      match->winner = 0;
    }

  }

  return match;
}

void add_last(listagem l, pJogo match)
{
  match->next = 0;
  match->previous = l->tail;
  if (l->tail != 0)
  {
    l->tail->next = match;
  }
  else
  {
    
  }

  l->tail = match;
  if (l->head == 0)
  {
    l->head = match;
  }
  else
  {
    
  }

}

Node_jogos InsertBeginJogo(Node_jogos head, pJogo match)
{
  Node_jogos old_head = head;
  head = (Node_jogos) malloc(sizeof(struct node_jogo));
  head->next = old_head;
  head->match = match;
  return head;
}

void InsertJogo(pJogo match, table_jogos table)
{
  int i = hash_jogos(match->nome, table);
  table->heads[i] = InsertBeginJogo(table->heads[i], match);
}

void delete_jogo_lst(listagem lst, pJogo match)
{
  if ((match->previous == 0) && (match->next == 0))
  {
    lst->head = 0;
    lst->tail = 0;
  }
  else
  {
    if ((match->previous != 0) && (match->next == 0))
    {
      lst->tail = match->previous;
      match->previous->next = 0;
    }
    else
    {
      if ((match->previous == 0) && (match->next != 0))
      {
        match->next->previous = 0;
        lst->head = match->next;
      }
      else
      {
        match->previous->next = match->next;
        match->next->previous = match->previous;
      }

    }

  }

}

Node_jogos delete_jogo_hash(char nome[], Node_jogos node_j)
{
  Node_jogos temp = node_j;
  Node_jogos prev = 0;
  while (temp != 0)
  {
    if (strcmp(temp->match->nome, nome) == 0)
    {
      if (temp == node_j)
      {
        node_j = temp->next;
      }
      else
      {
        prev->next = temp->next;
      }

      liberta_no_j(temp);
      break;
    }
    else
    {
      
    }

    prev = temp;
    temp = temp->next;
  }

  return node_j;
}

void DeleteJogoHash(char nome[], table_jogos tab_j)
{
  int i = hash_jogos(nome, tab_j);
  tab_j->heads[i] = delete_jogo_hash(nome, tab_j->heads[i]);
}

void Change_Score(pJogo match, int score1, int score2)
{
  match->score1 = score1;
  match->score2 = score2;
  free(match->winner);
  if (score1 > score2)
  {
    match->winner = malloc((sizeof(char)) * (strlen(match->equipa1) + 1));
    strcpy(match->winner, match->equipa1);
  }
  else
  {
    if (score2 > score1)
    {
      match->winner = malloc((sizeof(char)) * (strlen(match->equipa2) + 1));
      strcpy(match->winner, match->equipa2);
    }
    else
    {
      match->winner = 0;
    }

  }

}

void Change_Wins(pJogo match, table_eq tab_eq, char *old_winner)
{
  if ((match->winner == 0) && (old_winner == 0))
  {
    return;
  }
  else
  {
    
  }

  if (((match->winner != 0) && (old_winner != 0)) && (strcmp(match->winner, old_winner) == 0))
  {
    return;
  }
  else
  {
    if ((match->winner == 0) && (old_winner != 0))
    {
      SearchEquipa(old_winner, tab_eq)->vitorias--;
      return;
    }
    else
    {
      if ((match->winner != 0) && (old_winner == 0))
      {
        SearchEquipa(match->winner, tab_eq)->vitorias++;
        return;
      }
      else
      {
        SearchEquipa(old_winner, tab_eq)->vitorias--;
        SearchEquipa(match->winner, tab_eq)->vitorias++;
        return;
      }

    }

  }

}

Equipas cria_equipa(char *nome)
{
  Equipas equipa;
  equipa = (Equipas) malloc(sizeof(struct eq));
  equipa->nome = (char *) malloc((sizeof(char)) * (strlen(nome) + 1));
  strcpy(equipa->nome, nome);
  equipa->vitorias = 0;
  return equipa;
}

Node_eq insertBeginEquipa(Node_eq head, Equipas equipa)
{
  Node_eq old_head = head;
  head = (Node_eq) malloc(sizeof(struct node_eq));
  head->next = old_head;
  head->equipa = equipa;
  return head;
}

void InsertEquipa(Equipas equipa, table_eq table)
{
  int i = hash_eq(equipa->nome, table);
  table->heads[i] = insertBeginEquipa(table->heads[i], equipa);
}

