import os

from pycparser import  parse_file
from pycparser.c_ast import *
from CProcessor.config import compiler_extensions
from sympy import li 

class C_FileGenerator:
	def __init__(self, inputfile, outputfile,
				 include=None, save_ast=False):

		self.inputfile = inputfile
		self.outputfile = outputfile
		
		self.include = include
		self.save_ast = save_ast
		self.fakelib = f'{os.path.abspath(os.path.dirname(__file__))}/Fake_libc/fake_libc_include'

		tmpname = self.outputfile.split('/')[-1]
		self.tmpfile = f'tmp_{tmpname}'


		#Write input ast for debug
		if self.save_ast:

			cpp_args=['-E', f'-I{self.fakelib}']
			if self.include:
				cpp_args.append(f'-I{self.include}')

			ast = parse_file(self.inputfile, use_cpp=True, cpp_path='gcc', cpp_args=cpp_args)
			file = open('ast.txt', "w")
			file.write(str(ast))


	
	def _remove_files(self, *files):
		for f in files:
			if os.path.exists(f):
				os.remove(f)


	#Store 'includes' of inputfile
	#Create tmp file annotated to separate code from includes
	def _preprocess_file(self, inputfile, tmpfile, add_stdlib=False):
		stdlib = False
		includes = []
		guards = []
		defguard = None
		file = []
		with open(inputfile, 'r') as inp:
			for line in inp:
				if line.startswith('#include'):
					includes.append(line)
					
					if 'stdlib' in line:
						stdlib = True #Check if already contains <stdlib>				
				else:
					file.append(line)
				
			
				if line.startswith('#ifndef'):
					guards.append(line)
					defguard = line.split()[1]
				
				elif defguard:
					if line.startswith('#define') and defguard in line:
						guards.append(line)

		#Mark end of includes
		tmpfile = open(tmpfile, "w")
		tmpfile.writelines(compiler_extensions)
		tmpfile.writelines(includes)
		tmpfile.write('void ___start();\n')
		tmpfile.writelines(file)
		tmpfile.flush()

		#Add <stdlib> for malloc warning
		if not stdlib and add_stdlib:
			includes.append(f'#include <stdlib.h>\n')

		return includes, guards


	#Removes typedefs from fake_libc
	#Prepends the correct includes
	#Add our macros for symbolic tests
	def	_postprocess_file(self, inputfile, includes, generator=None, guards=[], stubs=[]):
		if generator is None:
			generator= os.path.basename(__file__)

		start = False
		file = []

		with open(inputfile, 'r') as inp:
			for line in inp:
				if start:
					file.append(line)

				if line.startswith('void ___start();'):
					start = True
					file.append(f'/*File generated by {generator}*/\n\n')
					file += guards
					file.append('\n')
					file += includes
					file.append('\n')
					file += stubs
					file.append('\n')

		if len(guards) > 0:
			file.append('#endif')

		return file



	def gen(self):
		pass