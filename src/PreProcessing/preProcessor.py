#!/usr/bin/env python3

import traceback
import argparse
import sys, os

# This is not required if you've installed pycparser into
# your site-packages/ with setup.py
sys.path.extend(['.', '..'])

from pycparser import parse_file, c_generator
from visitors import *


def get_cmd_args():
	parser = argparse.ArgumentParser(description='Generate Symbolic Tests')

	parser.add_argument('-o', metavar='name', type=str, required=False, default='out.c',
						help='Output name')
	
	parser.add_argument('targetFile', metavar='file', type=str,
						help='The name of the target C file')
	
	parser.add_argument('--fakelib', metavar='path', type=str,
						help='Path to pycparser fake libc')

	parser.add_argument('-ast', action='store_true',
						help='Save input ast for debug')

	
	return parser.parse_args()


class PreProcessor():

	def __init__(self, inputfile, outputfile, fakelib=None, save_ast=False):
		
		self.inputfile = inputfile
		self.outputfile = outputfile
		self.save_ast = save_ast
		self.fakelib = '../Fake_libc'
		self.tmpfile = f'tmp_{self.outputfile}'

		if fakelib is not None:
			self.fakelib = fakelib


		#Write input ast for debug
		if self.save_ast:
			ast = parse_file(self.inputfile, use_cpp=True,
			cpp_path='gcc',
			cpp_args=['-E', f'-I{self.fakelib}/fake_libc_include'])
			file = open('ast.txt', "w")
			file.write(str(ast))

	

	def _remove_files(self, *files):
		for f in files:
			if os.path.exists(f):
	  			os.remove(f)


	#Store 'includes' of inputfile
	#Create tmp file annotated to separate code from includes
	def _preprocess_file(self, inputfile, tmpfile):
		includes = []
		file = []
		with open(inputfile, 'r') as inp:
			for line in inp:
				if line.startswith('#include'):
					includes.append(line)
				else:
					file.append(line)


		#Mark end of includes
		tmpfile = open(tmpfile, "w")
		tmpfile.writelines(includes)
		tmpfile.write('void __start();\n')
		tmpfile.writelines(file)
		tmpfile.flush()

		return includes

	#Removes typedefs from fake_libc
	#Prepends the correct includes
	def	_postprocess_file(self, inputfile, includes):
		start = False
		file = []
		with open(inputfile, 'r') as inp:
			for line in inp:
				if start:
					file.append(line)

				if line.startswith('void __start();'):
					start = True
					file.append(f'/*File generated by {os.path.basename(__file__)}*/\n\n')
					file += includes
					file.append('\n')

		return file


	def gen(self):
		
		try:
			#PreProcess inputfile
			includes = self._preprocess_file(self.inputfile, self.tmpfile)

			#Parse new file
			ast = parse_file(self.tmpfile, use_cpp=True,
				cpp_path='gcc',
				cpp_args=['-E', f'-I{self.fakelib}/fake_libc_include'])

			#Visit the ast
			visitor = PreProcessVisitor()
			generated_ast = visitor.visit(ast) 

			generator = c_generator.CGenerator()
			generated_string = generator.visit(generated_ast)

			#Write ast to temporary file
			tmpfile = open(self.tmpfile, "w")
			tmpfile.write(generated_string)
			tmpfile.flush()

			#PostPreProcess temporary file
			final_code = self._postprocess_file(self.tmpfile, includes)

			self._remove_files(self.tmpfile)

			#Write final output file
			outfile = open(self.outputfile, "w")
			outfile.writelines(final_code)
			

		except Exception as e:
			self._remove_files(self.tmpfile)
			print(traceback.format_exc())


if __name__ == "__main__":

	#Command line arguments
	args = get_cmd_args()
	inputfile = args.targetFile
	outfile = args.o
	fakelib = args.fakelib
	save_ast = args.ast

	preprocessor = PreProcessor(inputfile, outfile,
				 fakelib=fakelib, save_ast=save_ast)
	
	preprocessor.gen()
