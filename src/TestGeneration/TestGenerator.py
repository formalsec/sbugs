import sys, os

from pycparser import parse_file, c_generator
from pycparser.c_ast import *

from TestGeneration.visitors.InputGen import InputGenVisitor
from TestGeneration.visitors.StructGen import StructGenVisitor
from TestGeneration.utils import defineMacro, defineInclude, mainFunction, returnValue, createFunction 
from TestGeneration.utils import InitialVisitor, FUEL_MACRO, ARRAY_SIZE_MACRO, POINTER_SIZE_MACRO

class TestGenerator():
	def __init__(self, inputfile, outputfile, fuel=5, arraysize=10, pointersize=5,\
				 fakelib=None, save_ast=False):
		
		self.inputfile = inputfile
		self.outputfile = outputfile
		
		self.fuel = fuel
		self.arraysize = arraysize
		self.pointersize = pointersize
		
		self.save_ast = save_ast
		self.fakelib = 'Fake_libc'

		tmpname = self.outputfile.split('/')[-1]
		self.tmpfile = f'tmp_{tmpname}'


		if fakelib is not None:
			self.fakelib = fakelib

		#Write input ast for debug
		if self.save_ast:
			ast = parse_file(self.inputfile, use_cpp=True,
			cpp_path='gcc',
			cpp_args=['-E', f'-I{self.fakelib}/fake_libc_include'])
			file = open('ast.txt', "w")
			file.write(str(ast))


	
	def _remove_files(self, *files):
		for f in files:
			if os.path.exists(f):
	  			os.remove(f)


	#Store 'includes' of inputfile
	#Create tmp file annotated to separate code from includes
	def _preprocess_file(self, inputfile, tmpfile):
		stdlib = False
		includes = []
		file = []
		with open(inputfile, 'r') as inp:
			for line in inp:
				if line.startswith('#include'):
					includes.append(line)
					
					if 'stdlib' in line:
						stdlib = True #Check if already contains <stdlib>
				else:
					file.append(line)


		#Mark end of includes
		tmpfile = open(tmpfile, "w")
		tmpfile.writelines(includes)
		tmpfile.write('void __start();\n')
		tmpfile.writelines(file)
		tmpfile.flush()

		#Add <stdlib> for malloc warning
		if not stdlib:
			includes.append(defineInclude('stdlib.h'))

		return includes


	#Removes typedefs from fake_libc
	#Prepends the correct includes
	#Add our macros ofr symbolic tests
	def	_postprocess_file(self, inputfile, includes):
		start = False
		file = []
		with open(inputfile, 'r') as inp:
			for line in inp:
				if start:
					file.append(line)

				if line.startswith('void __start();'):
					start = True
					file.append(f'/*File generated by {os.path.basename(__file__)}*/\n\n')
	
					file += includes
					
					#Add Macros for size (array size and fuel)
					file.append(defineMacro(FUEL_MACRO, self.fuel))
					file.append(defineMacro(ARRAY_SIZE_MACRO, self.arraysize))
					file.append(defineMacro(POINTER_SIZE_MACRO, self.pointersize))
					
					file.append('\n')

		return file



	#Create a single test
	def create_test(self, fname, args, structs, aliases):

		testname = f'test_{fname}'
		
		if fname == 'main':
			return ('main', None) #Ignore 'main' function

		fblock = []     #Test code to be generated
		call_args = []  #Arguments to call the function		

		#Function has no arguments
		if args is None:
			args = []
		
		#Visit arguments 
		for arg in args:

			vis = InputGenVisitor(structs,aliases)   
			vis.visit(arg)
			code = vis.code

			if code is None:
				return (fname, None)
			
			call_args.append(vis.argname)
			fblock += code

	   
		#Add the function call to the Ast
		fblock.append(FuncCall(ID(fname), ExprList(call_args)))
		fblock.append(returnValue(None)) #Return (void)

		#Create a block containg the test code
		block = Compound(fblock)

		#Create the actual test function
		decl = createFunction(name=testname,\
			args=None,\
			returnType='void')

		#Place the block inside a function definition
		func_def_ast = FuncDef(decl, None, block, None)

		return (testname, func_def_ast) #Return (key,value) tuple


	#Create tests for all functions
	#Returns a dictionary -> {fname : ast}
	def create_tests(self, f_decls, structs, aliases):
		return {k: v for k, v in map(lambda x :\
				self.create_test(x, f_decls[x],structs, aliases), f_decls)\
				if v is not None} 


	def place_testcode(self, ast, code, mainblock):
		index = 0
		for stmt in ast.ext:
			if isinstance(stmt, FuncDef):
				if stmt.decl.name == 'main':
					stmt.body = mainFunction(mainblock)
					ast.ext = ast.ext[:index] + code + ast.ext[index:]
					return
			index += 1

		#File does not contain a main function
		ast.ext += code
		decl = createFunction(name='main',\
				args=None,returnType='int')
		main = FuncDef(decl, None, mainFunction(mainblock), None)
		ast.ext.append(main)
		return



	def gen(self):


		#PreProcess inputfile
		includes = self._preprocess_file(self.inputfile, self.tmpfile)

		#Parse new file
		ast = parse_file(self.tmpfile, use_cpp=True,
			cpp_path='gcc',
			cpp_args=['-E', f'-I{self.fakelib}/fake_libc_include'])            

		#Initial visitor to get all relevant elements
		vis = InitialVisitor()
		vis.visit(ast)

		fun_decls = vis.fun_dict
		structs = vis.structs
		aliases = vis.aliases 

		#Final list of strings to be written to file
		codeList = []

		#Generate functions responsible for creating symbolic structs
		struct_generator = StructGenVisitor(structs, aliases)
		codeList +=  struct_generator.symbolic_structs()

		#Create actual test functions
		testsDict = self.create_tests(fun_decls, structs, aliases) 
		codeList += testsDict.values()

		self.place_testcode(ast, codeList, testsDict.keys())
			

		#Generate string from ast
		generator = c_generator.CGenerator()
		generated_string = generator.visit(ast)

		#Write ast to temporary file
		tmpfile = open(self.tmpfile, "w")
		tmpfile.write(generated_string)
		tmpfile.flush()

		#PostPreProcess temporary file
		final_code = self._postprocess_file(self.tmpfile, includes)
		self._remove_files(self.tmpfile)

		#Write final output file
		outfile = open(self.outputfile, "w")
		outfile.writelines(final_code)
