#!/usr/bin/env python3

from __future__ import print_function
import argparse
import sys, os
import re

from shutil import copyfile

# This is not required if you've installed pycparser into
# your site-packages/ with setup.py
sys.path.extend(['.', '..'])

from pycparser import c_parser, parse_file, c_generator
from pycparser.c_ast import *

from typeGenerators import InputGenVisitor
from structGenerator import StructGen
from utils import defineMacro, mainFunction, returnValue, createFunction, InitialVisitor
import utils



class testGenerator():
    def __init__(self, inputfile, outputfile, fuel=5, arraysize=10, pointersize=5):
        self.inputfile = inputfile
        self.outputfile = outputfile
        self.fuel = fuel
        self.arraysize = arraysize
        self.pointersize = pointersize

        #Parse File
        self.ast = parse_file(self.inputfile, use_cpp=True,
            cpp_path='gcc',
            cpp_args=['-E', '-Iloglib/fake_libc_include'])


    #Create a single test
    def create_test(self, fname, args, structs, aliases):

        testname = f'test_{fname}'
        
        if fname == 'main':
            return ('main', None) #Ignore 'main' function

        
        fblock = []     #Test code to be generated
        call_args = []  #Arguments to call the function
        

        #Function has no arguments
        if args is None:
            args = []
        
        #Visit arguments 
        for arg in args:

            vis = InputGenVisitor(structs,aliases)   
            vis.visit(arg)
            
            call_args.append(vis.argname) 
            fblock += vis.code

       
        #Add the function call to the Ast
        fblock.append(FuncCall(ID(fname), ExprList(call_args)))
        fblock.append(returnValue(None)) #Return (void)

        #Create a block containg the test code
        block = Compound(fblock)

        #Create the actual test function
        decl = createFunction(name=testname,\
            args=None,\
            returnType='void')

        #Place the block inside a function definition
        func_def_ast = FuncDef(decl, None, block, None)

        #Generate the final string with the test
        gen = c_generator.CGenerator()
        str_ast = gen.visit(func_def_ast)

        return (testname, str_ast) #Return (key,value) tuple


    #Create tests for all functions
    #Returns a dictionary -> {fname : ast}
    def create_tests(self, f_decls, structs, aliases):
        return {k: v for k, v in map(lambda x :self.create_test(x, f_decls[x],\
                 structs, aliases), f_decls) if v is not None} 



    def gen(self):            

        #Initial visitor to get all relevant elements
        vis = InitialVisitor()
        vis.visit(self.ast)

        fun_decls = vis.fun_dict
        structs = vis.structs
        aliases = vis.aliases  

        #Final list of strings to be written to file
        codeList = []

        #Add Macros for size (array size and fuel)
        codeList.append(defineMacro(utils.FUEL_MACRO, self.fuel))
        codeList.append(defineMacro(utils.ARRAY_SIZE_MACRO, self.arraysize))
        codeList.append(defineMacro(utils.POINTER_SIZE_MACRO, self.pointersize)+'\n')

        #Generate functions responsible for creating symbolic structs
        struct_generator = StructGen(structs, aliases)
        codeList +=  struct_generator.symbolic_structs()

        #Create actual test functions
        testsDict = self.create_tests(fun_decls, structs, aliases) 
        codeList += testsDict.values()

        #Main function to call tests
        codeList.append(mainFunction(testsDict.keys()))

        #Write to file
        file = open(self.outputfile, "w")
        file.write(f'/*File generated by {os.path.basename(__file__)}*/\n\n')
        for c in codeList:
            file.write(f'{c}\n')





def get_cmd_args():
    parser = argparse.ArgumentParser(description='Generate Symbolic Tests')

    parser.add_argument('-o', metavar='name', type=str, required=False, default='out.c',
                        help='Output name')

    parser.add_argument('--fuel', metavar='value', type=int, required=False, default=5,
                        help='Define \'Fuel\' value (default:5)')

    parser.add_argument('--arraySize', metavar='value', type=int, required=False, default=10,
                        help='Define array size (default:10)')

    parser.add_argument('--pointerSize', metavar='value', type=int, required=False, default=5,
                        help='Define array size allocated for pointers (*) (default:5)')

    parser.add_argument('targetFile', metavar='file', type=str,
                        help='The name of the target C file')

    return parser.parse_args()



if __name__ == "__main__":

    
    #Command line arguments
    args = get_cmd_args()
    
    inputfile = args.targetFile
    outputfile = args.o
    fuel = args.fuel
    arraysize = args.arraySize
    pointersize = args.pointerSize

    

    testGenerator = testGenerator(inputfile, outputfile,\
                     fuel, arraysize, pointersize)

    testGenerator.gen()